var imgInput = "imgs_equipamentos/" + document.getElementById('inputValor').value;
var modelo =  "Modelo " + document.getElementById('inputModelo').value + ", ";


var I4 = (t, e) => () => (e || t((e = {
   exports: {}
}).exports, e), e.exports);
var sve = I4((gi, vi) => {
   (function () {
      const e = document.createElement("link").relList;
      if (e && e.supports && e.supports("modulepreload")) return;
      for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
      new MutationObserver(i => {
         for (const s of i)
            if (s.type === "childList")
               for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
      }).observe(document, {
         childList: !0,
         subtree: !0
      });

      function n(i) {
         const s = {};
         return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
      }

      function r(i) {
         if (i.ep) return;
         i.ep = !0;
         const s = n(i);
         fetch(i.href, s)
      }
   })();
   var Em = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

   function qd(t) {
      return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
   }
   var rL = {
         exports: {}
      },
      cv = {},
      iL = {
         exports: {}
      },
      Ht = {};
   /**
    * @license React
    * react.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   var ep = Symbol.for("react.element"),
      L4 = Symbol.for("react.portal"),
      D4 = Symbol.for("react.fragment"),
      F4 = Symbol.for("react.strict_mode"),
      O4 = Symbol.for("react.profiler"),
      N4 = Symbol.for("react.provider"),
      U4 = Symbol.for("react.context"),
      k4 = Symbol.for("react.forward_ref"),
      H4 = Symbol.for("react.suspense"),
      G4 = Symbol.for("react.memo"),
      z4 = Symbol.for("react.lazy"),
      PC = Symbol.iterator;

   function V4(t) {
      return t === null || typeof t != "object" ? null : (t = PC && t[PC] || t["@@iterator"], typeof t == "function" ? t : null)
   }
   var sL = {
         isMounted: function () {
            return !1
         },
         enqueueForceUpdate: function () {},
         enqueueReplaceState: function () {},
         enqueueSetState: function () {}
      },
      oL = Object.assign,
      aL = {};

   function Mf(t, e, n) {
      this.props = t, this.context = e, this.refs = aL, this.updater = n || sL
   }
   Mf.prototype.isReactComponent = {};
   Mf.prototype.setState = function (t, e) {
      if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, t, e, "setState")
   };
   Mf.prototype.forceUpdate = function (t) {
      this.updater.enqueueForceUpdate(this, t, "forceUpdate")
   };

   function lL() {}
   lL.prototype = Mf.prototype;

   function kS(t, e, n) {
      this.props = t, this.context = e, this.refs = aL, this.updater = n || sL
   }
   var HS = kS.prototype = new lL;
   HS.constructor = kS;
   oL(HS, Mf.prototype);
   HS.isPureReactComponent = !0;
   var BC = Array.isArray,
      uL = Object.prototype.hasOwnProperty,
      GS = {
         current: null
      },
      cL = {
         key: !0,
         ref: !0,
         __self: !0,
         __source: !0
      };

   function fL(t, e, n) {
      var r, i = {},
         s = null,
         o = null;
      if (e != null)
         for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) uL.call(e, r) && !cL.hasOwnProperty(r) && (i[r] = e[r]);
      var a = arguments.length - 2;
      if (a === 1) i.children = n;
      else if (1 < a) {
         for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
         i.children = l
      }
      if (t && t.defaultProps)
         for (r in a = t.defaultProps, a) i[r] === void 0 && (i[r] = a[r]);
      return {
         $$typeof: ep,
         type: t,
         key: s,
         ref: o,
         props: i,
         _owner: GS.current
      }
   }

   function W4(t, e) {
      return {
         $$typeof: ep,
         type: t.type,
         key: e,
         ref: t.ref,
         props: t.props,
         _owner: t._owner
      }
   }

   function zS(t) {
      return typeof t == "object" && t !== null && t.$$typeof === ep
   }

   function j4(t) {
      var e = {
         "=": "=0",
         ":": "=2"
      };
      return "$" + t.replace(/[=:]/g, function (n) {
         return e[n]
      })
   }
   var IC = /\/+/g;

   function Px(t, e) {
      return typeof t == "object" && t !== null && t.key != null ? j4("" + t.key) : e.toString(36)
   }

   function Wg(t, e, n, r, i) {
      var s = typeof t;
      (s === "undefined" || s === "boolean") && (t = null);
      var o = !1;
      if (t === null) o = !0;
      else switch (s) {
         case "string":
         case "number":
            o = !0;
            break;
         case "object":
            switch (t.$$typeof) {
               case ep:
               case L4:
                  o = !0
            }
      }
      if (o) return o = t, i = i(o), t = r === "" ? "." + Px(o, 0) : r, BC(i) ? (n = "", t != null && (n = t.replace(IC, "$&/") + "/"), Wg(i, e, n, "", function (u) {
         return u
      })) : i != null && (zS(i) && (i = W4(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(IC, "$&/") + "/") + t)), e.push(i)), 1;
      if (o = 0, r = r === "" ? "." : r + ":", BC(t))
         for (var a = 0; a < t.length; a++) {
            s = t[a];
            var l = r + Px(s, a);
            o += Wg(s, e, n, l, i)
         } else if (l = V4(t), typeof l == "function")
            for (t = l.call(t), a = 0; !(s = t.next()).done;) s = s.value, l = r + Px(s, a++), o += Wg(s, e, n, l, i);
         else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
      return o
   }

   function wm(t, e, n) {
      if (t == null) return t;
      var r = [],
         i = 0;
      return Wg(t, r, "", "", function (s) {
         return e.call(n, s, i++)
      }), r
   }

   function $4(t) {
      if (t._status === -1) {
         var e = t._result;
         e = e(), e.then(function (n) {
            (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n)
         }, function (n) {
            (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n)
         }), t._status === -1 && (t._status = 0, t._result = e)
      }
      if (t._status === 1) return t._result.default;
      throw t._result
   }
   var Vr = {
         current: null
      },
      jg = {
         transition: null
      },
      X4 = {
         ReactCurrentDispatcher: Vr,
         ReactCurrentBatchConfig: jg,
         ReactCurrentOwner: GS
      };
   Ht.Children = {
      map: wm,
      forEach: function (t, e, n) {
         wm(t, function () {
            e.apply(this, arguments)
         }, n)
      },
      count: function (t) {
         var e = 0;
         return wm(t, function () {
            e++
         }), e
      },
      toArray: function (t) {
         return wm(t, function (e) {
            return e
         }) || []
      },
      only: function (t) {
         if (!zS(t)) throw Error("React.Children.only expected to receive a single React element child.");
         return t
      }
   };
   Ht.Component = Mf;
   Ht.Fragment = D4;
   Ht.Profiler = O4;
   Ht.PureComponent = kS;
   Ht.StrictMode = F4;
   Ht.Suspense = H4;
   Ht.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = X4;
   Ht.cloneElement = function (t, e, n) {
      if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
      var r = oL({}, t.props),
         i = t.key,
         s = t.ref,
         o = t._owner;
      if (e != null) {
         if (e.ref !== void 0 && (s = e.ref, o = GS.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps;
         for (l in e) uL.call(e, l) && !cL.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
      }
      var l = arguments.length - 2;
      if (l === 1) r.children = n;
      else if (1 < l) {
         a = Array(l);
         for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
         r.children = a
      }
      return {
         $$typeof: ep,
         type: t.type,
         key: i,
         ref: s,
         props: r,
         _owner: o
      }
   };
   Ht.createContext = function (t) {
      return t = {
         $$typeof: U4,
         _currentValue: t,
         _currentValue2: t,
         _threadCount: 0,
         Provider: null,
         Consumer: null,
         _defaultValue: null,
         _globalName: null
      }, t.Provider = {
         $$typeof: N4,
         _context: t
      }, t.Consumer = t
   };
   Ht.createElement = fL;
   Ht.createFactory = function (t) {
      var e = fL.bind(null, t);
      return e.type = t, e
   };
   Ht.createRef = function () {
      return {
         current: null
      }
   };
   Ht.forwardRef = function (t) {
      return {
         $$typeof: k4,
         render: t
      }
   };
   Ht.isValidElement = zS;
   Ht.lazy = function (t) {
      return {
         $$typeof: z4,
         _payload: {
            _status: -1,
            _result: t
         },
         _init: $4
      }
   };
   Ht.memo = function (t, e) {
      return {
         $$typeof: G4,
         type: t,
         compare: e === void 0 ? null : e
      }
   };
   Ht.startTransition = function (t) {
      var e = jg.transition;
      jg.transition = {};
      try {
         t()
      } finally {
         jg.transition = e
      }
   };
   Ht.unstable_act = function () {
      throw Error("act(...) is not supported in production builds of React.")
   };
   Ht.useCallback = function (t, e) {
      return Vr.current.useCallback(t, e)
   };
   Ht.useContext = function (t) {
      return Vr.current.useContext(t)
   };
   Ht.useDebugValue = function () {};
   Ht.useDeferredValue = function (t) {
      return Vr.current.useDeferredValue(t)
   };
   Ht.useEffect = function (t, e) {
      return Vr.current.useEffect(t, e)
   };
   Ht.useId = function () {
      return Vr.current.useId()
   };
   Ht.useImperativeHandle = function (t, e, n) {
      return Vr.current.useImperativeHandle(t, e, n)
   };
   Ht.useInsertionEffect = function (t, e) {
      return Vr.current.useInsertionEffect(t, e)
   };
   Ht.useLayoutEffect = function (t, e) {
      return Vr.current.useLayoutEffect(t, e)
   };
   Ht.useMemo = function (t, e) {
      return Vr.current.useMemo(t, e)
   };
   Ht.useReducer = function (t, e, n) {
      return Vr.current.useReducer(t, e, n)
   };
   Ht.useRef = function (t) {
      return Vr.current.useRef(t)
   };
   Ht.useState = function (t) {
      return Vr.current.useState(t)
   };
   Ht.useSyncExternalStore = function (t, e, n) {
      return Vr.current.useSyncExternalStore(t, e, n)
   };
   Ht.useTransition = function () {
      return Vr.current.useTransition()
   };
   Ht.version = "18.2.0";
   iL.exports = Ht;
   var $ = iL.exports;
   const z = qd($);
   /**
    * @license React
    * react-jsx-runtime.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   var J4 = $,
      K4 = Symbol.for("react.element"),
      Y4 = Symbol.for("react.fragment"),
      Q4 = Object.prototype.hasOwnProperty,
      Z4 = J4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
      q4 = {
         key: !0,
         ref: !0,
         __self: !0,
         __source: !0
      };

   function hL(t, e, n) {
      var r, i = {},
         s = null,
         o = null;
      n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
      for (r in e) Q4.call(e, r) && !q4.hasOwnProperty(r) && (i[r] = e[r]);
      if (t && t.defaultProps)
         for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]);
      return {
         $$typeof: K4,
         type: t,
         key: s,
         ref: o,
         props: i,
         _owner: Z4.current
      }
   }
   cv.Fragment = Y4;
   cv.jsx = hL;
   cv.jsxs = hL;
   rL.exports = cv;
   var ot = rL.exports,
      E1 = {},
      dL = {
         exports: {}
      },
      wi = {},
      pL = {
         exports: {}
      },
      mL = {};
   /**
    * @license React
    * scheduler.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   (function (t) {
      function e(G, ne) {
         var Y = G.length;
         G.push(ne);
         e: for (; 0 < Y;) {
            var X = Y - 1 >>> 1,
               Q = G[X];
            if (0 < i(Q, ne)) G[X] = ne, G[Y] = Q, Y = X;
            else break e
         }
      }

      function n(G) {
         return G.length === 0 ? null : G[0]
      }

      function r(G) {
         if (G.length === 0) return null;
         var ne = G[0],
            Y = G.pop();
         if (Y !== ne) {
            G[0] = Y;
            e: for (var X = 0, Q = G.length, _e = Q >>> 1; X < _e;) {
               var Me = 2 * (X + 1) - 1,
                  we = G[Me],
                  Ee = Me + 1,
                  Ue = G[Ee];
               if (0 > i(we, Y)) Ee < Q && 0 > i(Ue, we) ? (G[X] = Ue, G[Ee] = Y, X = Ee) : (G[X] = we, G[Me] = Y, X = Me);
               else if (Ee < Q && 0 > i(Ue, Y)) G[X] = Ue, G[Ee] = Y, X = Ee;
               else break e
            }
         }
         return ne
      }

      function i(G, ne) {
         var Y = G.sortIndex - ne.sortIndex;
         return Y !== 0 ? Y : G.id - ne.id
      }
      if (typeof performance == "object" && typeof performance.now == "function") {
         var s = performance;
         t.unstable_now = function () {
            return s.now()
         }
      } else {
         var o = Date,
            a = o.now();
         t.unstable_now = function () {
            return o.now() - a
         }
      }
      var l = [],
         u = [],
         h = 1,
         d = null,
         p = 3,
         m = !1,
         v = !1,
         _ = !1,
         x = typeof setTimeout == "function" ? setTimeout : null,
         g = typeof clearTimeout == "function" ? clearTimeout : null,
         S = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

      function A(G) {
         for (var ne = n(u); ne !== null;) {
            if (ne.callback === null) r(u);
            else if (ne.startTime <= G) r(u), ne.sortIndex = ne.expirationTime, e(l, ne);
            else break;
            ne = n(u)
         }
      }

      function E(G) {
         if (_ = !1, A(G), !v)
            if (n(l) !== null) v = !0, se(C);
            else {
               var ne = n(u);
               ne !== null && oe(E, ne.startTime - G)
            }
      }

      function C(G, ne) {
         v = !1, _ && (_ = !1, g(D), D = -1), m = !0;
         var Y = p;
         try {
            for (A(ne), d = n(l); d !== null && (!(d.expirationTime > ne) || G && !N());) {
               var X = d.callback;
               if (typeof X == "function") {
                  d.callback = null, p = d.priorityLevel;
                  var Q = X(d.expirationTime <= ne);
                  ne = t.unstable_now(), typeof Q == "function" ? d.callback = Q : d === n(l) && r(l), A(ne)
               } else r(l);
               d = n(l)
            }
            if (d !== null) var _e = !0;
            else {
               var Me = n(u);
               Me !== null && oe(E, Me.startTime - ne), _e = !1
            }
            return _e
         } finally {
            d = null, p = Y, m = !1
         }
      }
      var R = !1,
         B = null,
         D = -1,
         T = 5,
         I = -1;

      function N() {
         return !(t.unstable_now() - I < T)
      }

      function q() {
         if (B !== null) {
            var G = t.unstable_now();
            I = G;
            var ne = !0;
            try {
               ne = B(!0, G)
            } finally {
               ne ? K() : (R = !1, B = null)
            }
         } else R = !1
      }
      var K;
      if (typeof S == "function") K = function () {
         S(q)
      };
      else if (typeof MessageChannel < "u") {
         var Z = new MessageChannel,
            te = Z.port2;
         Z.port1.onmessage = q, K = function () {
            te.postMessage(null)
         }
      } else K = function () {
         x(q, 0)
      };

      function se(G) {
         B = G, R || (R = !0, K())
      }

      function oe(G, ne) {
         D = x(function () {
            G(t.unstable_now())
         }, ne)
      }
      t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (G) {
         G.callback = null
      }, t.unstable_continueExecution = function () {
         v || m || (v = !0, se(C))
      }, t.unstable_forceFrameRate = function (G) {
         0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < G ? Math.floor(1e3 / G) : 5
      }, t.unstable_getCurrentPriorityLevel = function () {
         return p
      }, t.unstable_getFirstCallbackNode = function () {
         return n(l)
      }, t.unstable_next = function (G) {
         switch (p) {
            case 1:
            case 2:
            case 3:
               var ne = 3;
               break;
            default:
               ne = p
         }
         var Y = p;
         p = ne;
         try {
            return G()
         } finally {
            p = Y
         }
      }, t.unstable_pauseExecution = function () {}, t.unstable_requestPaint = function () {}, t.unstable_runWithPriority = function (G, ne) {
         switch (G) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
               break;
            default:
               G = 3
         }
         var Y = p;
         p = G;
         try {
            return ne()
         } finally {
            p = Y
         }
      }, t.unstable_scheduleCallback = function (G, ne, Y) {
         var X = t.unstable_now();
         switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? X + Y : X) : Y = X, G) {
            case 1:
               var Q = -1;
               break;
            case 2:
               Q = 250;
               break;
            case 5:
               Q = 1073741823;
               break;
            case 4:
               Q = 1e4;
               break;
            default:
               Q = 5e3
         }
         return Q = Y + Q, G = {
            id: h++,
            callback: ne,
            priorityLevel: G,
            startTime: Y,
            expirationTime: Q,
            sortIndex: -1
         }, Y > X ? (G.sortIndex = Y, e(u, G), n(l) === null && G === n(u) && (_ ? (g(D), D = -1) : _ = !0, oe(E, Y - X))) : (G.sortIndex = Q, e(l, G), v || m || (v = !0, se(C))), G
      }, t.unstable_shouldYield = N, t.unstable_wrapCallback = function (G) {
         var ne = p;
         return function () {
            var Y = p;
            p = ne;
            try {
               return G.apply(this, arguments)
            } finally {
               p = Y
            }
         }
      }
   })(mL);
   pL.exports = mL;
   var eH = pL.exports;
   /**
    * @license React
    * react-dom.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   var gL = $,
      _i = eH;

   function Re(t) {
      for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
      return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
   }
   var vL = new Set,
      yd = {};

   function eu(t, e) {
      nf(t, e), nf(t + "Capture", e)
   }

   function nf(t, e) {
      for (yd[t] = e, t = 0; t < e.length; t++) vL.add(e[t])
   }
   var Bo = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
      w1 = Object.prototype.hasOwnProperty,
      tH = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
      LC = {},
      DC = {};

   function nH(t) {
      return w1.call(DC, t) ? !0 : w1.call(LC, t) ? !1 : tH.test(t) ? DC[t] = !0 : (LC[t] = !0, !1)
   }

   function rH(t, e, n, r) {
      if (n !== null && n.type === 0) return !1;
      switch (typeof e) {
         case "function":
         case "symbol":
            return !0;
         case "boolean":
            return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
         default:
            return !1
      }
   }

   function iH(t, e, n, r) {
      if (e === null || typeof e > "u" || rH(t, e, n, r)) return !0;
      if (r) return !1;
      if (n !== null) switch (n.type) {
         case 3:
            return !e;
         case 4:
            return e === !1;
         case 5:
            return isNaN(e);
         case 6:
            return isNaN(e) || 1 > e
      }
      return !1
   }

   function Wr(t, e, n, r, i, s, o) {
      this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o
   }
   var mr = {};
   "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) {
      mr[t] = new Wr(t, 0, !1, t, null, !1, !1)
   });
   [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"]
   ].forEach(function (t) {
      var e = t[0];
      mr[e] = new Wr(e, 1, !1, t[1], null, !1, !1)
   });
   ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
      mr[t] = new Wr(t, 2, !1, t.toLowerCase(), null, !1, !1)
   });
   ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) {
      mr[t] = new Wr(t, 2, !1, t, null, !1, !1)
   });
   "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) {
      mr[t] = new Wr(t, 3, !1, t.toLowerCase(), null, !1, !1)
   });
   ["checked", "multiple", "muted", "selected"].forEach(function (t) {
      mr[t] = new Wr(t, 3, !0, t, null, !1, !1)
   });
   ["capture", "download"].forEach(function (t) {
      mr[t] = new Wr(t, 4, !1, t, null, !1, !1)
   });
   ["cols", "rows", "size", "span"].forEach(function (t) {
      mr[t] = new Wr(t, 6, !1, t, null, !1, !1)
   });
   ["rowSpan", "start"].forEach(function (t) {
      mr[t] = new Wr(t, 5, !1, t.toLowerCase(), null, !1, !1)
   });
   var VS = /[\-:]([a-z])/g;

   function WS(t) {
      return t[1].toUpperCase()
   }
   "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) {
      var e = t.replace(VS, WS);
      mr[e] = new Wr(e, 1, !1, t, null, !1, !1)
   });
   "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) {
      var e = t.replace(VS, WS);
      mr[e] = new Wr(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
   });
   ["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
      var e = t.replace(VS, WS);
      mr[e] = new Wr(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
   });
   ["tabIndex", "crossOrigin"].forEach(function (t) {
      mr[t] = new Wr(t, 1, !1, t.toLowerCase(), null, !1, !1)
   });
   mr.xlinkHref = new Wr("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
   ["src", "href", "action", "formAction"].forEach(function (t) {
      mr[t] = new Wr(t, 1, !1, t.toLowerCase(), null, !0, !0)
   });

   function jS(t, e, n, r) {
      var i = mr.hasOwnProperty(e) ? mr[e] : null;
      (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (iH(e, n, i, r) && (n = null), r || i === null ? nH(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
   }
   var No = gL.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
      bm = Symbol.for("react.element"),
      Ec = Symbol.for("react.portal"),
      wc = Symbol.for("react.fragment"),
      $S = Symbol.for("react.strict_mode"),
      b1 = Symbol.for("react.profiler"),
      yL = Symbol.for("react.provider"),
      xL = Symbol.for("react.context"),
      XS = Symbol.for("react.forward_ref"),
      C1 = Symbol.for("react.suspense"),
      T1 = Symbol.for("react.suspense_list"),
      JS = Symbol.for("react.memo"),
      oa = Symbol.for("react.lazy"),
      _L = Symbol.for("react.offscreen"),
      FC = Symbol.iterator;

   function lh(t) {
      return t === null || typeof t != "object" ? null : (t = FC && t[FC] || t["@@iterator"], typeof t == "function" ? t : null)
   }
   var Bn = Object.assign,
      Bx;

   function Gh(t) {
      if (Bx === void 0) try {
         throw Error()
      } catch (n) {
         var e = n.stack.trim().match(/\n( *(at )?)/);
         Bx = e && e[1] || ""
      }
      return `
` + Bx + t
   }
   var Ix = !1;

   function Lx(t, e) {
      if (!t || Ix) return "";
      Ix = !0;
      var n = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
         if (e)
            if (e = function () {
                  throw Error()
               }, Object.defineProperty(e.prototype, "props", {
                  set: function () {
                     throw Error()
                  }
               }), typeof Reflect == "object" && Reflect.construct) {
               try {
                  Reflect.construct(e, [])
               } catch (u) {
                  var r = u
               }
               Reflect.construct(t, [], e)
            } else {
               try {
                  e.call()
               } catch (u) {
                  r = u
               }
               t.call(e.prototype)
            }
         else {
            try {
               throw Error()
            } catch (u) {
               r = u
            }
            t()
         }
      } catch (u) {
         if (u && r && typeof u.stack == "string") {
            for (var i = u.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];) a--;
            for (; 1 <= o && 0 <= a; o--, a--)
               if (i[o] !== s[a]) {
                  if (o !== 1 || a !== 1)
                     do
                        if (o--, a--, 0 > a || i[o] !== s[a]) {
                           var l = `
` + i[o].replace(" at new ", " at ");
                           return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l
                        } while (1 <= o && 0 <= a);
                  break
               }
         }
      } finally {
         Ix = !1, Error.prepareStackTrace = n
      }
      return (t = t ? t.displayName || t.name : "") ? Gh(t) : ""
   }

   function sH(t) {
      switch (t.tag) {
         case 5:
            return Gh(t.type);
         case 16:
            return Gh("Lazy");
         case 13:
            return Gh("Suspense");
         case 19:
            return Gh("SuspenseList");
         case 0:
         case 2:
         case 15:
            return t = Lx(t.type, !1), t;
         case 11:
            return t = Lx(t.type.render, !1), t;
         case 1:
            return t = Lx(t.type, !0), t;
         default:
            return ""
      }
   }

   function R1(t) {
      if (t == null) return null;
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t;
      switch (t) {
         case wc:
            return "Fragment";
         case Ec:
            return "Portal";
         case b1:
            return "Profiler";
         case $S:
            return "StrictMode";
         case C1:
            return "Suspense";
         case T1:
            return "SuspenseList"
      }
      if (typeof t == "object") switch (t.$$typeof) {
         case xL:
            return (t.displayName || "Context") + ".Consumer";
         case yL:
            return (t._context.displayName || "Context") + ".Provider";
         case XS:
            var e = t.render;
            return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
         case JS:
            return e = t.displayName || null, e !== null ? e : R1(t.type) || "Memo";
         case oa:
            e = t._payload, t = t._init;
            try {
               return R1(t(e))
            } catch {}
      }
      return null
   }

   function oH(t) {
      var e = t.type;
      switch (t.tag) {
         case 24:
            return "Cache";
         case 9:
            return (e.displayName || "Context") + ".Consumer";
         case 10:
            return (e._context.displayName || "Context") + ".Provider";
         case 18:
            return "DehydratedFragment";
         case 11:
            return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
         case 7:
            return "Fragment";
         case 5:
            return e;
         case 4:
            return "Portal";
         case 3:
            return "Root";
         case 6:
            return "Text";
         case 16:
            return R1(e);
         case 8:
            return e === $S ? "StrictMode" : "Mode";
         case 22:
            return "Offscreen";
         case 12:
            return "Profiler";
         case 21:
            return "Scope";
         case 13:
            return "Suspense";
         case 19:
            return "SuspenseList";
         case 25:
            return "TracingMarker";
         case 1:
         case 0:
         case 17:
         case 2:
         case 14:
         case 15:
            if (typeof e == "function") return e.displayName || e.name || null;
            if (typeof e == "string") return e
      }
      return null
   }

   function Ia(t) {
      switch (typeof t) {
         case "boolean":
         case "number":
         case "string":
         case "undefined":
            return t;
         case "object":
            return t;
         default:
            return ""
      }
   }

   function AL(t) {
      var e = t.type;
      return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
   }

   function aH(t) {
      var e = AL(t) ? "checked" : "value",
         n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
         r = "" + t[e];
      if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
         var i = n.get,
            s = n.set;
         return Object.defineProperty(t, e, {
            configurable: !0,
            get: function () {
               return i.call(this)
            },
            set: function (o) {
               r = "" + o, s.call(this, o)
            }
         }), Object.defineProperty(t, e, {
            enumerable: n.enumerable
         }), {
            getValue: function () {
               return r
            },
            setValue: function (o) {
               r = "" + o
            },
            stopTracking: function () {
               t._valueTracker = null, delete t[e]
            }
         }
      }
   }

   function Cm(t) {
      t._valueTracker || (t._valueTracker = aH(t))
   }

   function SL(t) {
      if (!t) return !1;
      var e = t._valueTracker;
      if (!e) return !0;
      var n = e.getValue(),
         r = "";
      return t && (r = AL(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1
   }

   function p0(t) {
      if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
      try {
         return t.activeElement || t.body
      } catch {
         return t.body
      }
   }

   function P1(t, e) {
      var n = e.checked;
      return Bn({}, e, {
         defaultChecked: void 0,
         defaultValue: void 0,
         value: void 0,
         checked: n ?? t._wrapperState.initialChecked
      })
   }

   function OC(t, e) {
      var n = e.defaultValue == null ? "" : e.defaultValue,
         r = e.checked != null ? e.checked : e.defaultChecked;
      n = Ia(e.value != null ? e.value : n), t._wrapperState = {
         initialChecked: r,
         initialValue: n,
         controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
      }
   }

   function ML(t, e) {
      e = e.checked, e != null && jS(t, "checked", e, !1)
   }

   function B1(t, e) {
      ML(t, e);
      var n = Ia(e.value),
         r = e.type;
      if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
      else if (r === "submit" || r === "reset") {
         t.removeAttribute("value");
         return
      }
      e.hasOwnProperty("value") ? I1(t, e.type, n) : e.hasOwnProperty("defaultValue") && I1(t, e.type, Ia(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
   }

   function NC(t, e, n) {
      if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
         var r = e.type;
         if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return;
         e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e
      }
      n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n)
   }

   function I1(t, e, n) {
      (e !== "number" || p0(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
   }
   var zh = Array.isArray;

   function Wc(t, e, n, r) {
      if (t = t.options, e) {
         e = {};
         for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
         for (n = 0; n < t.length; n++) i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0)
      } else {
         for (n = "" + Ia(n), e = null, i = 0; i < t.length; i++) {
            if (t[i].value === n) {
               t[i].selected = !0, r && (t[i].defaultSelected = !0);
               return
            }
            e !== null || t[i].disabled || (e = t[i])
         }
         e !== null && (e.selected = !0)
      }
   }

   function L1(t, e) {
      if (e.dangerouslySetInnerHTML != null) throw Error(Re(91));
      return Bn({}, e, {
         value: void 0,
         defaultValue: void 0,
         children: "" + t._wrapperState.initialValue
      })
   }

   function UC(t, e) {
      var n = e.value;
      if (n == null) {
         if (n = e.children, e = e.defaultValue, n != null) {
            if (e != null) throw Error(Re(92));
            if (zh(n)) {
               if (1 < n.length) throw Error(Re(93));
               n = n[0]
            }
            e = n
         }
         e == null && (e = ""), n = e
      }
      t._wrapperState = {
         initialValue: Ia(n)
      }
   }

   function EL(t, e) {
      var n = Ia(e.value),
         r = Ia(e.defaultValue);
      n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r)
   }

   function kC(t) {
      var e = t.textContent;
      e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
   }

   function wL(t) {
      switch (t) {
         case "svg":
            return "http://www.w3.org/2000/svg";
         case "math":
            return "http://www.w3.org/1998/Math/MathML";
         default:
            return "http://www.w3.org/1999/xhtml"
      }
   }

   function D1(t, e) {
      return t == null || t === "http://www.w3.org/1999/xhtml" ? wL(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
   }
   var Tm, bL = function (t) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, r, i) {
         MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, r, i)
         })
      } : t
   }(function (t, e) {
      if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
      else {
         for (Tm = Tm || document.createElement("div"), Tm.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Tm.firstChild; t.firstChild;) t.removeChild(t.firstChild);
         for (; e.firstChild;) t.appendChild(e.firstChild)
      }
   });

   function xd(t, e) {
      if (e) {
         var n = t.firstChild;
         if (n && n === t.lastChild && n.nodeType === 3) {
            n.nodeValue = e;
            return
         }
      }
      t.textContent = e
   }
   var Qh = {
         animationIterationCount: !0,
         aspectRatio: !0,
         borderImageOutset: !0,
         borderImageSlice: !0,
         borderImageWidth: !0,
         boxFlex: !0,
         boxFlexGroup: !0,
         boxOrdinalGroup: !0,
         columnCount: !0,
         columns: !0,
         flex: !0,
         flexGrow: !0,
         flexPositive: !0,
         flexShrink: !0,
         flexNegative: !0,
         flexOrder: !0,
         gridArea: !0,
         gridRow: !0,
         gridRowEnd: !0,
         gridRowSpan: !0,
         gridRowStart: !0,
         gridColumn: !0,
         gridColumnEnd: !0,
         gridColumnSpan: !0,
         gridColumnStart: !0,
         fontWeight: !0,
         lineClamp: !0,
         lineHeight: !0,
         opacity: !0,
         order: !0,
         orphans: !0,
         tabSize: !0,
         widows: !0,
         zIndex: !0,
         zoom: !0,
         fillOpacity: !0,
         floodOpacity: !0,
         stopOpacity: !0,
         strokeDasharray: !0,
         strokeDashoffset: !0,
         strokeMiterlimit: !0,
         strokeOpacity: !0,
         strokeWidth: !0
      },
      lH = ["Webkit", "ms", "Moz", "O"];
   Object.keys(Qh).forEach(function (t) {
      lH.forEach(function (e) {
         e = e + t.charAt(0).toUpperCase() + t.substring(1), Qh[e] = Qh[t]
      })
   });

   function CL(t, e, n) {
      return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || Qh.hasOwnProperty(t) && Qh[t] ? ("" + e).trim() : e + "px"
   }

   function TL(t, e) {
      t = t.style;
      for (var n in e)
         if (e.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0,
               i = CL(n, e[n], r);
            n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i
         }
   }
   var uH = Bn({
      menuitem: !0
   }, {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
   });

   function F1(t, e) {
      if (e) {
         if (uH[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Re(137, t));
         if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null) throw Error(Re(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Re(61))
         }
         if (e.style != null && typeof e.style != "object") throw Error(Re(62))
      }
   }

   function O1(t, e) {
      if (t.indexOf("-") === -1) return typeof e.is == "string";
      switch (t) {
         case "annotation-xml":
         case "color-profile":
         case "font-face":
         case "font-face-src":
         case "font-face-uri":
         case "font-face-format":
         case "font-face-name":
         case "missing-glyph":
            return !1;
         default:
            return !0
      }
   }
   var N1 = null;

   function KS(t) {
      return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t
   }
   var U1 = null,
      jc = null,
      $c = null;

   function HC(t) {
      if (t = rp(t)) {
         if (typeof U1 != "function") throw Error(Re(280));
         var e = t.stateNode;
         e && (e = mv(e), U1(t.stateNode, t.type, e))
      }
   }

   function RL(t) {
      jc ? $c ? $c.push(t) : $c = [t] : jc = t
   }

   function PL() {
      if (jc) {
         var t = jc,
            e = $c;
         if ($c = jc = null, HC(t), e)
            for (t = 0; t < e.length; t++) HC(e[t])
      }
   }

   function BL(t, e) {
      return t(e)
   }

   function IL() {}
   var Dx = !1;

   function LL(t, e, n) {
      if (Dx) return t(e, n);
      Dx = !0;
      try {
         return BL(t, e, n)
      } finally {
         Dx = !1, (jc !== null || $c !== null) && (IL(), PL())
      }
   }

   function _d(t, e) {
      var n = t.stateNode;
      if (n === null) return null;
      var r = mv(n);
      if (r === null) return null;
      n = r[e];
      e: switch (e) {
         case "onClick":
         case "onClickCapture":
         case "onDoubleClick":
         case "onDoubleClickCapture":
         case "onMouseDown":
         case "onMouseDownCapture":
         case "onMouseMove":
         case "onMouseMoveCapture":
         case "onMouseUp":
         case "onMouseUpCapture":
         case "onMouseEnter":
            (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
            break e;
         default:
            t = !1
      }
      if (t) return null;
      if (n && typeof n != "function") throw Error(Re(231, e, typeof n));
      return n
   }
   var k1 = !1;
   if (Bo) try {
      var uh = {};
      Object.defineProperty(uh, "passive", {
         get: function () {
            k1 = !0
         }
      }), window.addEventListener("test", uh, uh), window.removeEventListener("test", uh, uh)
   } catch {
      k1 = !1
   }

   function cH(t, e, n, r, i, s, o, a, l) {
      var u = Array.prototype.slice.call(arguments, 3);
      try {
         e.apply(n, u)
      } catch (h) {
         this.onError(h)
      }
   }
   var Zh = !1,
      m0 = null,
      g0 = !1,
      H1 = null,
      fH = {
         onError: function (t) {
            Zh = !0, m0 = t
         }
      };

   function hH(t, e, n, r, i, s, o, a, l) {
      Zh = !1, m0 = null, cH.apply(fH, arguments)
   }

   function dH(t, e, n, r, i, s, o, a, l) {
      if (hH.apply(this, arguments), Zh) {
         if (Zh) {
            var u = m0;
            Zh = !1, m0 = null
         } else throw Error(Re(198));
         g0 || (g0 = !0, H1 = u)
      }
   }

   function tu(t) {
      var e = t,
         n = t;
      if (t.alternate)
         for (; e.return;) e = e.return;
      else {
         t = e;
         do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t)
      }
      return e.tag === 3 ? n : null
   }

   function DL(t) {
      if (t.tag === 13) {
         var e = t.memoizedState;
         if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated
      }
      return null
   }

   function GC(t) {
      if (tu(t) !== t) throw Error(Re(188))
   }

   function pH(t) {
      var e = t.alternate;
      if (!e) {
         if (e = tu(t), e === null) throw Error(Re(188));
         return e !== t ? null : t
      }
      for (var n = t, r = e;;) {
         var i = n.return;
         if (i === null) break;
         var s = i.alternate;
         if (s === null) {
            if (r = i.return, r !== null) {
               n = r;
               continue
            }
            break
         }
         if (i.child === s.child) {
            for (s = i.child; s;) {
               if (s === n) return GC(i), t;
               if (s === r) return GC(i), e;
               s = s.sibling
            }
            throw Error(Re(188))
         }
         if (n.return !== r.return) n = i, r = s;
         else {
            for (var o = !1, a = i.child; a;) {
               if (a === n) {
                  o = !0, n = i, r = s;
                  break
               }
               if (a === r) {
                  o = !0, r = i, n = s;
                  break
               }
               a = a.sibling
            }
            if (!o) {
               for (a = s.child; a;) {
                  if (a === n) {
                     o = !0, n = s, r = i;
                     break
                  }
                  if (a === r) {
                     o = !0, r = s, n = i;
                     break
                  }
                  a = a.sibling
               }
               if (!o) throw Error(Re(189))
            }
         }
         if (n.alternate !== r) throw Error(Re(190))
      }
      if (n.tag !== 3) throw Error(Re(188));
      return n.stateNode.current === n ? t : e
   }

   function FL(t) {
      return t = pH(t), t !== null ? OL(t) : null
   }

   function OL(t) {
      if (t.tag === 5 || t.tag === 6) return t;
      for (t = t.child; t !== null;) {
         var e = OL(t);
         if (e !== null) return e;
         t = t.sibling
      }
      return null
   }
   var NL = _i.unstable_scheduleCallback,
      zC = _i.unstable_cancelCallback,
      mH = _i.unstable_shouldYield,
      gH = _i.unstable_requestPaint,
      Gn = _i.unstable_now,
      vH = _i.unstable_getCurrentPriorityLevel,
      YS = _i.unstable_ImmediatePriority,
      UL = _i.unstable_UserBlockingPriority,
      v0 = _i.unstable_NormalPriority,
      yH = _i.unstable_LowPriority,
      kL = _i.unstable_IdlePriority,
      fv = null,
      Hs = null;

   function xH(t) {
      if (Hs && typeof Hs.onCommitFiberRoot == "function") try {
         Hs.onCommitFiberRoot(fv, t, void 0, (t.current.flags & 128) === 128)
      } catch {}
   }
   var ms = Math.clz32 ? Math.clz32 : SH,
      _H = Math.log,
      AH = Math.LN2;

   function SH(t) {
      return t >>>= 0, t === 0 ? 32 : 31 - (_H(t) / AH | 0) | 0
   }
   var Rm = 64,
      Pm = 4194304;

   function Vh(t) {
      switch (t & -t) {
         case 1:
            return 1;
         case 2:
            return 2;
         case 4:
            return 4;
         case 8:
            return 8;
         case 16:
            return 16;
         case 32:
            return 32;
         case 64:
         case 128:
         case 256:
         case 512:
         case 1024:
         case 2048:
         case 4096:
         case 8192:
         case 16384:
         case 32768:
         case 65536:
         case 131072:
         case 262144:
         case 524288:
         case 1048576:
         case 2097152:
            return t & 4194240;
         case 4194304:
         case 8388608:
         case 16777216:
         case 33554432:
         case 67108864:
            return t & 130023424;
         case 134217728:
            return 134217728;
         case 268435456:
            return 268435456;
         case 536870912:
            return 536870912;
         case 1073741824:
            return 1073741824;
         default:
            return t
      }
   }

   function y0(t, e) {
      var n = t.pendingLanes;
      if (n === 0) return 0;
      var r = 0,
         i = t.suspendedLanes,
         s = t.pingedLanes,
         o = n & 268435455;
      if (o !== 0) {
         var a = o & ~i;
         a !== 0 ? r = Vh(a) : (s &= o, s !== 0 && (r = Vh(s)))
      } else o = n & ~i, o !== 0 ? r = Vh(o) : s !== 0 && (r = Vh(s));
      if (r === 0) return 0;
      if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e;
      if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0)
         for (t = t.entanglements, e &= r; 0 < e;) n = 31 - ms(e), i = 1 << n, r |= t[n], e &= ~i;
      return r
   }

   function MH(t, e) {
      switch (t) {
         case 1:
         case 2:
         case 4:
            return e + 250;
         case 8:
         case 16:
         case 32:
         case 64:
         case 128:
         case 256:
         case 512:
         case 1024:
         case 2048:
         case 4096:
         case 8192:
         case 16384:
         case 32768:
         case 65536:
         case 131072:
         case 262144:
         case 524288:
         case 1048576:
         case 2097152:
            return e + 5e3;
         case 4194304:
         case 8388608:
         case 16777216:
         case 33554432:
         case 67108864:
            return -1;
         case 134217728:
         case 268435456:
         case 536870912:
         case 1073741824:
            return -1;
         default:
            return -1
      }
   }

   function EH(t, e) {
      for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) {
         var o = 31 - ms(s),
            a = 1 << o,
            l = i[o];
         l === -1 ? (!(a & n) || a & r) && (i[o] = MH(a, e)) : l <= e && (t.expiredLanes |= a), s &= ~a
      }
   }

   function G1(t) {
      return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
   }

   function HL() {
      var t = Rm;
      return Rm <<= 1, !(Rm & 4194240) && (Rm = 64), t
   }

   function Fx(t) {
      for (var e = [], n = 0; 31 > n; n++) e.push(t);
      return e
   }

   function tp(t, e, n) {
      t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - ms(e), t[e] = n
   }

   function wH(t, e) {
      var n = t.pendingLanes & ~e;
      t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
      var r = t.eventTimes;
      for (t = t.expirationTimes; 0 < n;) {
         var i = 31 - ms(n),
            s = 1 << i;
         e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s
      }
   }

   function QS(t, e) {
      var n = t.entangledLanes |= e;
      for (t = t.entanglements; n;) {
         var r = 31 - ms(n),
            i = 1 << r;
         i & e | t[r] & e && (t[r] |= e), n &= ~i
      }
   }
   var rn = 0;

   function GL(t) {
      return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
   }
   var zL, ZS, VL, WL, jL, z1 = !1,
      Bm = [],
      ya = null,
      xa = null,
      _a = null,
      Ad = new Map,
      Sd = new Map,
      ha = [],
      bH = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

   function VC(t, e) {
      switch (t) {
         case "focusin":
         case "focusout":
            ya = null;
            break;
         case "dragenter":
         case "dragleave":
            xa = null;
            break;
         case "mouseover":
         case "mouseout":
            _a = null;
            break;
         case "pointerover":
         case "pointerout":
            Ad.delete(e.pointerId);
            break;
         case "gotpointercapture":
         case "lostpointercapture":
            Sd.delete(e.pointerId)
      }
   }

   function ch(t, e, n, r, i, s) {
      return t === null || t.nativeEvent !== s ? (t = {
         blockedOn: e,
         domEventName: n,
         eventSystemFlags: r,
         nativeEvent: s,
         targetContainers: [i]
      }, e !== null && (e = rp(e), e !== null && ZS(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t)
   }

   function CH(t, e, n, r, i) {
      switch (e) {
         case "focusin":
            return ya = ch(ya, t, e, n, r, i), !0;
         case "dragenter":
            return xa = ch(xa, t, e, n, r, i), !0;
         case "mouseover":
            return _a = ch(_a, t, e, n, r, i), !0;
         case "pointerover":
            var s = i.pointerId;
            return Ad.set(s, ch(Ad.get(s) || null, t, e, n, r, i)), !0;
         case "gotpointercapture":
            return s = i.pointerId, Sd.set(s, ch(Sd.get(s) || null, t, e, n, r, i)), !0
      }
      return !1
   }

   function $L(t) {
      var e = Tl(t.target);
      if (e !== null) {
         var n = tu(e);
         if (n !== null) {
            if (e = n.tag, e === 13) {
               if (e = DL(n), e !== null) {
                  t.blockedOn = e, jL(t.priority, function () {
                     VL(n)
                  });
                  return
               }
            } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
               t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
               return
            }
         }
      }
      t.blockedOn = null
   }

   function $g(t) {
      if (t.blockedOn !== null) return !1;
      for (var e = t.targetContainers; 0 < e.length;) {
         var n = V1(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
         if (n === null) {
            n = t.nativeEvent;
            var r = new n.constructor(n.type, n);
            N1 = r, n.target.dispatchEvent(r), N1 = null
         } else return e = rp(n), e !== null && ZS(e), t.blockedOn = n, !1;
         e.shift()
      }
      return !0
   }

   function WC(t, e, n) {
      $g(t) && n.delete(e)
   }

   function TH() {
      z1 = !1, ya !== null && $g(ya) && (ya = null), xa !== null && $g(xa) && (xa = null), _a !== null && $g(_a) && (_a = null), Ad.forEach(WC), Sd.forEach(WC)
   }

   function fh(t, e) {
      t.blockedOn === e && (t.blockedOn = null, z1 || (z1 = !0, _i.unstable_scheduleCallback(_i.unstable_NormalPriority, TH)))
   }

   function Md(t) {
      function e(i) {
         return fh(i, t)
      }
      if (0 < Bm.length) {
         fh(Bm[0], t);
         for (var n = 1; n < Bm.length; n++) {
            var r = Bm[n];
            r.blockedOn === t && (r.blockedOn = null)
         }
      }
      for (ya !== null && fh(ya, t), xa !== null && fh(xa, t), _a !== null && fh(_a, t), Ad.forEach(e), Sd.forEach(e), n = 0; n < ha.length; n++) r = ha[n], r.blockedOn === t && (r.blockedOn = null);
      for (; 0 < ha.length && (n = ha[0], n.blockedOn === null);) $L(n), n.blockedOn === null && ha.shift()
   }
   var Xc = No.ReactCurrentBatchConfig,
      x0 = !0;

   function RH(t, e, n, r) {
      var i = rn,
         s = Xc.transition;
      Xc.transition = null;
      try {
         rn = 1, qS(t, e, n, r)
      } finally {
         rn = i, Xc.transition = s
      }
   }

   function PH(t, e, n, r) {
      var i = rn,
         s = Xc.transition;
      Xc.transition = null;
      try {
         rn = 4, qS(t, e, n, r)
      } finally {
         rn = i, Xc.transition = s
      }
   }

   function qS(t, e, n, r) {
      if (x0) {
         var i = V1(t, e, n, r);
         if (i === null) jx(t, e, r, _0, n), VC(t, r);
         else if (CH(i, t, e, n, r)) r.stopPropagation();
         else if (VC(t, r), e & 4 && -1 < bH.indexOf(t)) {
            for (; i !== null;) {
               var s = rp(i);
               if (s !== null && zL(s), s = V1(t, e, n, r), s === null && jx(t, e, r, _0, n), s === i) break;
               i = s
            }
            i !== null && r.stopPropagation()
         } else jx(t, e, r, null, n)
      }
   }
   var _0 = null;

   function V1(t, e, n, r) {
      if (_0 = null, t = KS(r), t = Tl(t), t !== null)
         if (e = tu(t), e === null) t = null;
         else if (n = e.tag, n === 13) {
         if (t = DL(e), t !== null) return t;
         t = null
      } else if (n === 3) {
         if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
         t = null
      } else e !== t && (t = null);
      return _0 = t, null
   }

   function XL(t) {
      switch (t) {
         case "cancel":
         case "click":
         case "close":
         case "contextmenu":
         case "copy":
         case "cut":
         case "auxclick":
         case "dblclick":
         case "dragend":
         case "dragstart":
         case "drop":
         case "focusin":
         case "focusout":
         case "input":
         case "invalid":
         case "keydown":
         case "keypress":
         case "keyup":
         case "mousedown":
         case "mouseup":
         case "paste":
         case "pause":
         case "play":
         case "pointercancel":
         case "pointerdown":
         case "pointerup":
         case "ratechange":
         case "reset":
         case "resize":
         case "seeked":
         case "submit":
         case "touchcancel":
         case "touchend":
         case "touchstart":
         case "volumechange":
         case "change":
         case "selectionchange":
         case "textInput":
         case "compositionstart":
         case "compositionend":
         case "compositionupdate":
         case "beforeblur":
         case "afterblur":
         case "beforeinput":
         case "blur":
         case "fullscreenchange":
         case "focus":
         case "hashchange":
         case "popstate":
         case "select":
         case "selectstart":
            return 1;
         case "drag":
         case "dragenter":
         case "dragexit":
         case "dragleave":
         case "dragover":
         case "mousemove":
         case "mouseout":
         case "mouseover":
         case "pointermove":
         case "pointerout":
         case "pointerover":
         case "scroll":
         case "toggle":
         case "touchmove":
         case "wheel":
         case "mouseenter":
         case "mouseleave":
         case "pointerenter":
         case "pointerleave":
            return 4;
         case "message":
            switch (vH()) {
               case YS:
                  return 1;
               case UL:
                  return 4;
               case v0:
               case yH:
                  return 16;
               case kL:
                  return 536870912;
               default:
                  return 16
            }
         default:
            return 16
      }
   }
   var ma = null,
      eM = null,
      Xg = null;

   function JL() {
      if (Xg) return Xg;
      var t, e = eM,
         n = e.length,
         r, i = "value" in ma ? ma.value : ma.textContent,
         s = i.length;
      for (t = 0; t < n && e[t] === i[t]; t++);
      var o = n - t;
      for (r = 1; r <= o && e[n - r] === i[s - r]; r++);
      return Xg = i.slice(t, 1 < r ? 1 - r : void 0)
   }

   function Jg(t) {
      var e = t.keyCode;
      return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0
   }

   function Im() {
      return !0
   }

   function jC() {
      return !1
   }

   function bi(t) {
      function e(n, r, i, s, o) {
         this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null;
         for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]);
         return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Im : jC, this.isPropagationStopped = jC, this
      }
      return Bn(e.prototype, {
         preventDefault: function () {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Im)
         },
         stopPropagation: function () {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Im)
         },
         persist: function () {},
         isPersistent: Im
      }), e
   }
   var Ef = {
         eventPhase: 0,
         bubbles: 0,
         cancelable: 0,
         timeStamp: function (t) {
            return t.timeStamp || Date.now()
         },
         defaultPrevented: 0,
         isTrusted: 0
      },
      tM = bi(Ef),
      np = Bn({}, Ef, {
         view: 0,
         detail: 0
      }),
      BH = bi(np),
      Ox, Nx, hh, hv = Bn({}, np, {
         screenX: 0,
         screenY: 0,
         clientX: 0,
         clientY: 0,
         pageX: 0,
         pageY: 0,
         ctrlKey: 0,
         shiftKey: 0,
         altKey: 0,
         metaKey: 0,
         getModifierState: nM,
         button: 0,
         buttons: 0,
         relatedTarget: function (t) {
            return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
         },
         movementX: function (t) {
            return "movementX" in t ? t.movementX : (t !== hh && (hh && t.type === "mousemove" ? (Ox = t.screenX - hh.screenX, Nx = t.screenY - hh.screenY) : Nx = Ox = 0, hh = t), Ox)
         },
         movementY: function (t) {
            return "movementY" in t ? t.movementY : Nx
         }
      }),
      $C = bi(hv),
      IH = Bn({}, hv, {
         dataTransfer: 0
      }),
      LH = bi(IH),
      DH = Bn({}, np, {
         relatedTarget: 0
      }),
      Ux = bi(DH),
      FH = Bn({}, Ef, {
         animationName: 0,
         elapsedTime: 0,
         pseudoElement: 0
      }),
      OH = bi(FH),
      NH = Bn({}, Ef, {
         clipboardData: function (t) {
            return "clipboardData" in t ? t.clipboardData : window.clipboardData
         }
      }),
      UH = bi(NH),
      kH = Bn({}, Ef, {
         data: 0
      }),
      XC = bi(kH),
      HH = {
         Esc: "Escape",
         Spacebar: " ",
         Left: "ArrowLeft",
         Up: "ArrowUp",
         Right: "ArrowRight",
         Down: "ArrowDown",
         Del: "Delete",
         Win: "OS",
         Menu: "ContextMenu",
         Apps: "ContextMenu",
         Scroll: "ScrollLock",
         MozPrintableKey: "Unidentified"
      },
      GH = {
         8: "Backspace",
         9: "Tab",
         12: "Clear",
         13: "Enter",
         16: "Shift",
         17: "Control",
         18: "Alt",
         19: "Pause",
         20: "CapsLock",
         27: "Escape",
         32: " ",
         33: "PageUp",
         34: "PageDown",
         35: "End",
         36: "Home",
         37: "ArrowLeft",
         38: "ArrowUp",
         39: "ArrowRight",
         40: "ArrowDown",
         45: "Insert",
         46: "Delete",
         112: "F1",
         113: "F2",
         114: "F3",
         115: "F4",
         116: "F5",
         117: "F6",
         118: "F7",
         119: "F8",
         120: "F9",
         121: "F10",
         122: "F11",
         123: "F12",
         144: "NumLock",
         145: "ScrollLock",
         224: "Meta"
      },
      zH = {
         Alt: "altKey",
         Control: "ctrlKey",
         Meta: "metaKey",
         Shift: "shiftKey"
      };

   function VH(t) {
      var e = this.nativeEvent;
      return e.getModifierState ? e.getModifierState(t) : (t = zH[t]) ? !!e[t] : !1
   }

   function nM() {
      return VH
   }
   var WH = Bn({}, np, {
         key: function (t) {
            if (t.key) {
               var e = HH[t.key] || t.key;
               if (e !== "Unidentified") return e
            }
            return t.type === "keypress" ? (t = Jg(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? GH[t.keyCode] || "Unidentified" : ""
         },
         code: 0,
         location: 0,
         ctrlKey: 0,
         shiftKey: 0,
         altKey: 0,
         metaKey: 0,
         repeat: 0,
         locale: 0,
         getModifierState: nM,
         charCode: function (t) {
            return t.type === "keypress" ? Jg(t) : 0
         },
         keyCode: function (t) {
            return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
         },
         which: function (t) {
            return t.type === "keypress" ? Jg(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
         }
      }),
      jH = bi(WH),
      $H = Bn({}, hv, {
         pointerId: 0,
         width: 0,
         height: 0,
         pressure: 0,
         tangentialPressure: 0,
         tiltX: 0,
         tiltY: 0,
         twist: 0,
         pointerType: 0,
         isPrimary: 0
      }),
      JC = bi($H),
      XH = Bn({}, np, {
         touches: 0,
         targetTouches: 0,
         changedTouches: 0,
         altKey: 0,
         metaKey: 0,
         ctrlKey: 0,
         shiftKey: 0,
         getModifierState: nM
      }),
      JH = bi(XH),
      KH = Bn({}, Ef, {
         propertyName: 0,
         elapsedTime: 0,
         pseudoElement: 0
      }),
      YH = bi(KH),
      QH = Bn({}, hv, {
         deltaX: function (t) {
            return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
         },
         deltaY: function (t) {
            return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
         },
         deltaZ: 0,
         deltaMode: 0
      }),
      ZH = bi(QH),
      qH = [9, 13, 27, 32],
      rM = Bo && "CompositionEvent" in window,
      qh = null;
   Bo && "documentMode" in document && (qh = document.documentMode);
   var eG = Bo && "TextEvent" in window && !qh,
      KL = Bo && (!rM || qh && 8 < qh && 11 >= qh),
      KC = String.fromCharCode(32),
      YC = !1;

   function YL(t, e) {
      switch (t) {
         case "keyup":
            return qH.indexOf(e.keyCode) !== -1;
         case "keydown":
            return e.keyCode !== 229;
         case "keypress":
         case "mousedown":
         case "focusout":
            return !0;
         default:
            return !1
      }
   }

   function QL(t) {
      return t = t.detail, typeof t == "object" && "data" in t ? t.data : null
   }
   var bc = !1;

   function tG(t, e) {
      switch (t) {
         case "compositionend":
            return QL(e);
         case "keypress":
            return e.which !== 32 ? null : (YC = !0, KC);
         case "textInput":
            return t = e.data, t === KC && YC ? null : t;
         default:
            return null
      }
   }

   function nG(t, e) {
      if (bc) return t === "compositionend" || !rM && YL(t, e) ? (t = JL(), Xg = eM = ma = null, bc = !1, t) : null;
      switch (t) {
         case "paste":
            return null;
         case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
               if (e.char && 1 < e.char.length) return e.char;
               if (e.which) return String.fromCharCode(e.which)
            }
            return null;
         case "compositionend":
            return KL && e.locale !== "ko" ? null : e.data;
         default:
            return null
      }
   }
   var rG = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
   };

   function QC(t) {
      var e = t && t.nodeName && t.nodeName.toLowerCase();
      return e === "input" ? !!rG[t.type] : e === "textarea"
   }

   function ZL(t, e, n, r) {
      RL(r), e = A0(e, "onChange"), 0 < e.length && (n = new tM("onChange", "change", null, n, r), t.push({
         event: n,
         listeners: e
      }))
   }
   var ed = null,
      Ed = null;

   function iG(t) {
      uD(t, 0)
   }

   function dv(t) {
      var e = Rc(t);
      if (SL(e)) return t
   }

   function sG(t, e) {
      if (t === "change") return e
   }
   var qL = !1;
   if (Bo) {
      var kx;
      if (Bo) {
         var Hx = "oninput" in document;
         if (!Hx) {
            var ZC = document.createElement("div");
            ZC.setAttribute("oninput", "return;"), Hx = typeof ZC.oninput == "function"
         }
         kx = Hx
      } else kx = !1;
      qL = kx && (!document.documentMode || 9 < document.documentMode)
   }

   function qC() {
      ed && (ed.detachEvent("onpropertychange", eD), Ed = ed = null)
   }

   function eD(t) {
      if (t.propertyName === "value" && dv(Ed)) {
         var e = [];
         ZL(e, Ed, t, KS(t)), LL(iG, e)
      }
   }

   function oG(t, e, n) {
      t === "focusin" ? (qC(), ed = e, Ed = n, ed.attachEvent("onpropertychange", eD)) : t === "focusout" && qC()
   }

   function aG(t) {
      if (t === "selectionchange" || t === "keyup" || t === "keydown") return dv(Ed)
   }

   function lG(t, e) {
      if (t === "click") return dv(e)
   }

   function uG(t, e) {
      if (t === "input" || t === "change") return dv(e)
   }

   function cG(t, e) {
      return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
   }
   var vs = typeof Object.is == "function" ? Object.is : cG;

   function wd(t, e) {
      if (vs(t, e)) return !0;
      if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
      var n = Object.keys(t),
         r = Object.keys(e);
      if (n.length !== r.length) return !1;
      for (r = 0; r < n.length; r++) {
         var i = n[r];
         if (!w1.call(e, i) || !vs(t[i], e[i])) return !1
      }
      return !0
   }

   function eT(t) {
      for (; t && t.firstChild;) t = t.firstChild;
      return t
   }

   function tT(t, e) {
      var n = eT(t);
      t = 0;
      for (var r; n;) {
         if (n.nodeType === 3) {
            if (r = t + n.textContent.length, t <= e && r >= e) return {
               node: n,
               offset: e - t
            };
            t = r
         }
         e: {
            for (; n;) {
               if (n.nextSibling) {
                  n = n.nextSibling;
                  break e
               }
               n = n.parentNode
            }
            n = void 0
         }
         n = eT(n)
      }
   }

   function tD(t, e) {
      return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? tD(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
   }

   function nD() {
      for (var t = window, e = p0(); e instanceof t.HTMLIFrameElement;) {
         try {
            var n = typeof e.contentWindow.location.href == "string"
         } catch {
            n = !1
         }
         if (n) t = e.contentWindow;
         else break;
         e = p0(t.document)
      }
      return e
   }

   function iM(t) {
      var e = t && t.nodeName && t.nodeName.toLowerCase();
      return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
   }

   function fG(t) {
      var e = nD(),
         n = t.focusedElem,
         r = t.selectionRange;
      if (e !== n && n && n.ownerDocument && tD(n.ownerDocument.documentElement, n)) {
         if (r !== null && iM(n)) {
            if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
            else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
               t = t.getSelection();
               var i = n.textContent.length,
                  s = Math.min(r.start, i);
               r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = tT(n, s);
               var o = tT(n, r);
               i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e)))
            }
         }
         for (e = [], t = n; t = t.parentNode;) t.nodeType === 1 && e.push({
            element: t,
            left: t.scrollLeft,
            top: t.scrollTop
         });
         for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++) t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top
      }
   }
   var hG = Bo && "documentMode" in document && 11 >= document.documentMode,
      Cc = null,
      W1 = null,
      td = null,
      j1 = !1;

   function nT(t, e, n) {
      var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
      j1 || Cc == null || Cc !== p0(r) || (r = Cc, "selectionStart" in r && iM(r) ? r = {
         start: r.selectionStart,
         end: r.selectionEnd
      } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
         anchorNode: r.anchorNode,
         anchorOffset: r.anchorOffset,
         focusNode: r.focusNode,
         focusOffset: r.focusOffset
      }), td && wd(td, r) || (td = r, r = A0(W1, "onSelect"), 0 < r.length && (e = new tM("onSelect", "select", null, e, n), t.push({
         event: e,
         listeners: r
      }), e.target = Cc)))
   }

   function Lm(t, e) {
      var n = {};
      return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n
   }
   var Tc = {
         animationend: Lm("Animation", "AnimationEnd"),
         animationiteration: Lm("Animation", "AnimationIteration"),
         animationstart: Lm("Animation", "AnimationStart"),
         transitionend: Lm("Transition", "TransitionEnd")
      },
      Gx = {},
      rD = {};
   Bo && (rD = document.createElement("div").style, "AnimationEvent" in window || (delete Tc.animationend.animation, delete Tc.animationiteration.animation, delete Tc.animationstart.animation), "TransitionEvent" in window || delete Tc.transitionend.transition);

   function pv(t) {
      if (Gx[t]) return Gx[t];
      if (!Tc[t]) return t;
      var e = Tc[t],
         n;
      for (n in e)
         if (e.hasOwnProperty(n) && n in rD) return Gx[t] = e[n];
      return t
   }
   var iD = pv("animationend"),
      sD = pv("animationiteration"),
      oD = pv("animationstart"),
      aD = pv("transitionend"),
      lD = new Map,
      rT = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

   function Va(t, e) {
      lD.set(t, e), eu(e, [t])
   }
   for (var zx = 0; zx < rT.length; zx++) {
      var Vx = rT[zx],
         dG = Vx.toLowerCase(),
         pG = Vx[0].toUpperCase() + Vx.slice(1);
      Va(dG, "on" + pG)
   }
   Va(iD, "onAnimationEnd");
   Va(sD, "onAnimationIteration");
   Va(oD, "onAnimationStart");
   Va("dblclick", "onDoubleClick");
   Va("focusin", "onFocus");
   Va("focusout", "onBlur");
   Va(aD, "onTransitionEnd");
   nf("onMouseEnter", ["mouseout", "mouseover"]);
   nf("onMouseLeave", ["mouseout", "mouseover"]);
   nf("onPointerEnter", ["pointerout", "pointerover"]);
   nf("onPointerLeave", ["pointerout", "pointerover"]);
   eu("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
   eu("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
   eu("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
   eu("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
   eu("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
   eu("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
   var Wh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
      mG = new Set("cancel close invalid load scroll toggle".split(" ").concat(Wh));

   function iT(t, e, n) {
      var r = t.type || "unknown-event";
      t.currentTarget = n, dH(r, e, void 0, t), t.currentTarget = null
   }

   function uD(t, e) {
      e = (e & 4) !== 0;
      for (var n = 0; n < t.length; n++) {
         var r = t[n],
            i = r.event;
         r = r.listeners;
         e: {
            var s = void 0;
            if (e)
               for (var o = r.length - 1; 0 <= o; o--) {
                  var a = r[o],
                     l = a.instance,
                     u = a.currentTarget;
                  if (a = a.listener, l !== s && i.isPropagationStopped()) break e;
                  iT(i, a, u), s = l
               } else
                  for (o = 0; o < r.length; o++) {
                     if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e;
                     iT(i, a, u), s = l
                  }
         }
      }
      if (g0) throw t = H1, g0 = !1, H1 = null, t
   }

   function hn(t, e) {
      var n = e[Y1];
      n === void 0 && (n = e[Y1] = new Set);
      var r = t + "__bubble";
      n.has(r) || (cD(e, t, 2, !1), n.add(r))
   }

   function Wx(t, e, n) {
      var r = 0;
      e && (r |= 4), cD(n, t, r, e)
   }
   var Dm = "_reactListening" + Math.random().toString(36).slice(2);

   function bd(t) {
      if (!t[Dm]) {
         t[Dm] = !0, vL.forEach(function (n) {
            n !== "selectionchange" && (mG.has(n) || Wx(n, !1, t), Wx(n, !0, t))
         });
         var e = t.nodeType === 9 ? t : t.ownerDocument;
         e === null || e[Dm] || (e[Dm] = !0, Wx("selectionchange", !1, e))
      }
   }

   function cD(t, e, n, r) {
      switch (XL(e)) {
         case 1:
            var i = RH;
            break;
         case 4:
            i = PH;
            break;
         default:
            i = qS
      }
      n = i.bind(null, e, n, t), i = void 0, !k1 || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, {
         capture: !0,
         passive: i
      }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, {
         passive: i
      }) : t.addEventListener(e, n, !1)
   }

   function jx(t, e, n, r, i) {
      var s = r;
      if (!(e & 1) && !(e & 2) && r !== null) e: for (;;) {
         if (r === null) return;
         var o = r.tag;
         if (o === 3 || o === 4) {
            var a = r.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i) break;
            if (o === 4)
               for (o = r.return; o !== null;) {
                  var l = o.tag;
                  if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return;
                  o = o.return
               }
            for (; a !== null;) {
               if (o = Tl(a), o === null) return;
               if (l = o.tag, l === 5 || l === 6) {
                  r = s = o;
                  continue e
               }
               a = a.parentNode
            }
         }
         r = r.return
      }
      LL(function () {
         var u = s,
            h = KS(n),
            d = [];
         e: {
            var p = lD.get(t);
            if (p !== void 0) {
               var m = tM,
                  v = t;
               switch (t) {
                  case "keypress":
                     if (Jg(n) === 0) break e;
                  case "keydown":
                  case "keyup":
                     m = jH;
                     break;
                  case "focusin":
                     v = "focus", m = Ux;
                     break;
                  case "focusout":
                     v = "blur", m = Ux;
                     break;
                  case "beforeblur":
                  case "afterblur":
                     m = Ux;
                     break;
                  case "click":
                     if (n.button === 2) break e;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                     m = $C;
                     break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                     m = LH;
                     break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                     m = JH;
                     break;
                  case iD:
                  case sD:
                  case oD:
                     m = OH;
                     break;
                  case aD:
                     m = YH;
                     break;
                  case "scroll":
                     m = BH;
                     break;
                  case "wheel":
                     m = ZH;
                     break;
                  case "copy":
                  case "cut":
                  case "paste":
                     m = UH;
                     break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                     m = JC
               }
               var _ = (e & 4) !== 0,
                  x = !_ && t === "scroll",
                  g = _ ? p !== null ? p + "Capture" : null : p;
               _ = [];
               for (var S = u, A; S !== null;) {
                  A = S;
                  var E = A.stateNode;
                  if (A.tag === 5 && E !== null && (A = E, g !== null && (E = _d(S, g), E != null && _.push(Cd(S, E, A)))), x) break;
                  S = S.return
               }
               0 < _.length && (p = new m(p, v, null, n, h), d.push({
                  event: p,
                  listeners: _
               }))
            }
         }
         if (!(e & 7)) {
            e: {
               if (p = t === "mouseover" || t === "pointerover", m = t === "mouseout" || t === "pointerout", p && n !== N1 && (v = n.relatedTarget || n.fromElement) && (Tl(v) || v[Io])) break e;
               if ((m || p) && (p = h.window === h ? h : (p = h.ownerDocument) ? p.defaultView || p.parentWindow : window, m ? (v = n.relatedTarget || n.toElement, m = u, v = v ? Tl(v) : null, v !== null && (x = tu(v), v !== x || v.tag !== 5 && v.tag !== 6) && (v = null)) : (m = null, v = u), m !== v)) {
                  if (_ = $C, E = "onMouseLeave", g = "onMouseEnter", S = "mouse", (t === "pointerout" || t === "pointerover") && (_ = JC, E = "onPointerLeave", g = "onPointerEnter", S = "pointer"), x = m == null ? p : Rc(m), A = v == null ? p : Rc(v), p = new _(E, S + "leave", m, n, h), p.target = x, p.relatedTarget = A, E = null, Tl(h) === u && (_ = new _(g, S + "enter", v, n, h), _.target = A, _.relatedTarget = x, E = _), x = E, m && v) t: {
                     for (_ = m, g = v, S = 0, A = _; A; A = Iu(A)) S++;
                     for (A = 0, E = g; E; E = Iu(E)) A++;
                     for (; 0 < S - A;) _ = Iu(_),
                     S--;
                     for (; 0 < A - S;) g = Iu(g),
                     A--;
                     for (; S--;) {
                        if (_ === g || g !== null && _ === g.alternate) break t;
                        _ = Iu(_), g = Iu(g)
                     }
                     _ = null
                  }
                  else _ = null;
                  m !== null && sT(d, p, m, _, !1), v !== null && x !== null && sT(d, x, v, _, !0)
               }
            }
            e: {
               if (p = u ? Rc(u) : window, m = p.nodeName && p.nodeName.toLowerCase(), m === "select" || m === "input" && p.type === "file") var C = sG;
               else if (QC(p))
                  if (qL) C = uG;
                  else {
                     C = aG;
                     var R = oG
                  }
               else(m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (C = lG);
               if (C && (C = C(t, u))) {
                  ZL(d, C, n, h);
                  break e
               }
               R && R(t, p, u),
               t === "focusout" && (R = p._wrapperState) && R.controlled && p.type === "number" && I1(p, "number", p.value)
            }
            switch (R = u ? Rc(u) : window, t) {
               case "focusin":
                  (QC(R) || R.contentEditable === "true") && (Cc = R, W1 = u, td = null);
                  break;
               case "focusout":
                  td = W1 = Cc = null;
                  break;
               case "mousedown":
                  j1 = !0;
                  break;
               case "contextmenu":
               case "mouseup":
               case "dragend":
                  j1 = !1, nT(d, n, h);
                  break;
               case "selectionchange":
                  if (hG) break;
               case "keydown":
               case "keyup":
                  nT(d, n, h)
            }
            var B;
            if (rM) e: {
               switch (t) {
                  case "compositionstart":
                     var D = "onCompositionStart";
                     break e;
                  case "compositionend":
                     D = "onCompositionEnd";
                     break e;
                  case "compositionupdate":
                     D = "onCompositionUpdate";
                     break e
               }
               D = void 0
            }
            else bc ? YL(t, n) && (D = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (D = "onCompositionStart");D && (KL && n.locale !== "ko" && (bc || D !== "onCompositionStart" ? D === "onCompositionEnd" && bc && (B = JL()) : (ma = h, eM = "value" in ma ? ma.value : ma.textContent, bc = !0)), R = A0(u, D), 0 < R.length && (D = new XC(D, t, null, n, h), d.push({
               event: D,
               listeners: R
            }), B ? D.data = B : (B = QL(n), B !== null && (D.data = B)))),
            (B = eG ? tG(t, n) : nG(t, n)) && (u = A0(u, "onBeforeInput"), 0 < u.length && (h = new XC("onBeforeInput", "beforeinput", null, n, h), d.push({
               event: h,
               listeners: u
            }), h.data = B))
         }
         uD(d, e)
      })
   }

   function Cd(t, e, n) {
      return {
         instance: t,
         listener: e,
         currentTarget: n
      }
   }

   function A0(t, e) {
      for (var n = e + "Capture", r = []; t !== null;) {
         var i = t,
            s = i.stateNode;
         i.tag === 5 && s !== null && (i = s, s = _d(t, n), s != null && r.unshift(Cd(t, s, i)), s = _d(t, e), s != null && r.push(Cd(t, s, i))), t = t.return
      }
      return r
   }

   function Iu(t) {
      if (t === null) return null;
      do t = t.return; while (t && t.tag !== 5);
      return t || null
   }

   function sT(t, e, n, r, i) {
      for (var s = e._reactName, o = []; n !== null && n !== r;) {
         var a = n,
            l = a.alternate,
            u = a.stateNode;
         if (l !== null && l === r) break;
         a.tag === 5 && u !== null && (a = u, i ? (l = _d(n, s), l != null && o.unshift(Cd(n, l, a))) : i || (l = _d(n, s), l != null && o.push(Cd(n, l, a)))), n = n.return
      }
      o.length !== 0 && t.push({
         event: e,
         listeners: o
      })
   }
   var gG = /\r\n?/g,
      vG = /\u0000|\uFFFD/g;

   function oT(t) {
      return (typeof t == "string" ? t : "" + t).replace(gG, `
`).replace(vG, "")
   }

   function Fm(t, e, n) {
      if (e = oT(e), oT(t) !== e && n) throw Error(Re(425))
   }

   function S0() {}
   var $1 = null,
      X1 = null;

   function J1(t, e) {
      return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
   }
   var K1 = typeof setTimeout == "function" ? setTimeout : void 0,
      yG = typeof clearTimeout == "function" ? clearTimeout : void 0,
      aT = typeof Promise == "function" ? Promise : void 0,
      xG = typeof queueMicrotask == "function" ? queueMicrotask : typeof aT < "u" ? function (t) {
         return aT.resolve(null).then(t).catch(_G)
      } : K1;

   function _G(t) {
      setTimeout(function () {
         throw t
      })
   }

   function $x(t, e) {
      var n = e,
         r = 0;
      do {
         var i = n.nextSibling;
         if (t.removeChild(n), i && i.nodeType === 8)
            if (n = i.data, n === "/$") {
               if (r === 0) {
                  t.removeChild(i), Md(e);
                  return
               }
               r--
            } else n !== "$" && n !== "$?" && n !== "$!" || r++;
         n = i
      } while (n);
      Md(e)
   }

   function Aa(t) {
      for (; t != null; t = t.nextSibling) {
         var e = t.nodeType;
         if (e === 1 || e === 3) break;
         if (e === 8) {
            if (e = t.data, e === "$" || e === "$!" || e === "$?") break;
            if (e === "/$") return null
         }
      }
      return t
   }

   function lT(t) {
      t = t.previousSibling;
      for (var e = 0; t;) {
         if (t.nodeType === 8) {
            var n = t.data;
            if (n === "$" || n === "$!" || n === "$?") {
               if (e === 0) return t;
               e--
            } else n === "/$" && e++
         }
         t = t.previousSibling
      }
      return null
   }
   var wf = Math.random().toString(36).slice(2),
      Us = "__reactFiber$" + wf,
      Td = "__reactProps$" + wf,
      Io = "__reactContainer$" + wf,
      Y1 = "__reactEvents$" + wf,
      AG = "__reactListeners$" + wf,
      SG = "__reactHandles$" + wf;

   function Tl(t) {
      var e = t[Us];
      if (e) return e;
      for (var n = t.parentNode; n;) {
         if (e = n[Io] || n[Us]) {
            if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
               for (t = lT(t); t !== null;) {
                  if (n = t[Us]) return n;
                  t = lT(t)
               }
            return e
         }
         t = n, n = t.parentNode
      }
      return null
   }

   function rp(t) {
      return t = t[Us] || t[Io], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
   }

   function Rc(t) {
      if (t.tag === 5 || t.tag === 6) return t.stateNode;
      throw Error(Re(33))
   }

   function mv(t) {
      return t[Td] || null
   }
   var Q1 = [],
      Pc = -1;

   function Wa(t) {
      return {
         current: t
      }
   }

   function vn(t) {
      0 > Pc || (t.current = Q1[Pc], Q1[Pc] = null, Pc--)
   }

   function fn(t, e) {
      Pc++, Q1[Pc] = t.current, t.current = e
   }
   var La = {},
      Tr = Wa(La),
      qr = Wa(!1),
      Wl = La;

   function rf(t, e) {
      var n = t.type.contextTypes;
      if (!n) return La;
      var r = t.stateNode;
      if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext;
      var i = {},
         s;
      for (s in n) i[s] = e[s];
      return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i
   }

   function ei(t) {
      return t = t.childContextTypes, t != null
   }

   function M0() {
      vn(qr), vn(Tr)
   }

   function uT(t, e, n) {
      if (Tr.current !== La) throw Error(Re(168));
      fn(Tr, e), fn(qr, n)
   }

   function fD(t, e, n) {
      var r = t.stateNode;
      if (e = e.childContextTypes, typeof r.getChildContext != "function") return n;
      r = r.getChildContext();
      for (var i in r)
         if (!(i in e)) throw Error(Re(108, oH(t) || "Unknown", i));
      return Bn({}, n, r)
   }

   function E0(t) {
      return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || La, Wl = Tr.current, fn(Tr, t), fn(qr, qr.current), !0
   }

   function cT(t, e, n) {
      var r = t.stateNode;
      if (!r) throw Error(Re(169));
      n ? (t = fD(t, e, Wl), r.__reactInternalMemoizedMergedChildContext = t, vn(qr), vn(Tr), fn(Tr, t)) : vn(qr), fn(qr, n)
   }
   var yo = null,
      gv = !1,
      Xx = !1;

   function hD(t) {
      yo === null ? yo = [t] : yo.push(t)
   }

   function MG(t) {
      gv = !0, hD(t)
   }

   function ja() {
      if (!Xx && yo !== null) {
         Xx = !0;
         var t = 0,
            e = rn;
         try {
            var n = yo;
            for (rn = 1; t < n.length; t++) {
               var r = n[t];
               do r = r(!0); while (r !== null)
            }
            yo = null, gv = !1
         } catch (i) {
            throw yo !== null && (yo = yo.slice(t + 1)), NL(YS, ja), i
         } finally {
            rn = e, Xx = !1
         }
      }
      return null
   }
   var Bc = [],
      Ic = 0,
      w0 = null,
      b0 = 0,
      zi = [],
      Vi = 0,
      jl = null,
      _o = 1,
      Ao = "";

   function xl(t, e) {
      Bc[Ic++] = b0, Bc[Ic++] = w0, w0 = t, b0 = e
   }

   function dD(t, e, n) {
      zi[Vi++] = _o, zi[Vi++] = Ao, zi[Vi++] = jl, jl = t;
      var r = _o;
      t = Ao;
      var i = 32 - ms(r) - 1;
      r &= ~(1 << i), n += 1;
      var s = 32 - ms(e) + i;
      if (30 < s) {
         var o = i - i % 5;
         s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, _o = 1 << 32 - ms(e) + i | n << i | r, Ao = s + t
      } else _o = 1 << s | n << i | r, Ao = t
   }

   function sM(t) {
      t.return !== null && (xl(t, 1), dD(t, 1, 0))
   }

   function oM(t) {
      for (; t === w0;) w0 = Bc[--Ic], Bc[Ic] = null, b0 = Bc[--Ic], Bc[Ic] = null;
      for (; t === jl;) jl = zi[--Vi], zi[Vi] = null, Ao = zi[--Vi], zi[Vi] = null, _o = zi[--Vi], zi[Vi] = null
   }
   var yi = null,
      pi = null,
      Mn = !1,
      hs = null;

   function pD(t, e) {
      var n = Xi(5, null, null, 0);
      n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n)
   }

   function fT(t, e) {
      switch (t.tag) {
         case 5:
            var n = t.type;
            return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, yi = t, pi = Aa(e.firstChild), !0) : !1;
         case 6:
            return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, yi = t, pi = null, !0) : !1;
         case 13:
            return e = e.nodeType !== 8 ? null : e, e !== null ? (n = jl !== null ? {
               id: _o,
               overflow: Ao
            } : null, t.memoizedState = {
               dehydrated: e,
               treeContext: n,
               retryLane: 1073741824
            }, n = Xi(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, yi = t, pi = null, !0) : !1;
         default:
            return !1
      }
   }

   function Z1(t) {
      return (t.mode & 1) !== 0 && (t.flags & 128) === 0
   }

   function q1(t) {
      if (Mn) {
         var e = pi;
         if (e) {
            var n = e;
            if (!fT(t, e)) {
               if (Z1(t)) throw Error(Re(418));
               e = Aa(n.nextSibling);
               var r = yi;
               e && fT(t, e) ? pD(r, n) : (t.flags = t.flags & -4097 | 2, Mn = !1, yi = t)
            }
         } else {
            if (Z1(t)) throw Error(Re(418));
            t.flags = t.flags & -4097 | 2, Mn = !1, yi = t
         }
      }
   }

   function hT(t) {
      for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
      yi = t
   }

   function Om(t) {
      if (t !== yi) return !1;
      if (!Mn) return hT(t), Mn = !0, !1;
      var e;
      if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !J1(t.type, t.memoizedProps)), e && (e = pi)) {
         if (Z1(t)) throw mD(), Error(Re(418));
         for (; e;) pD(t, e), e = Aa(e.nextSibling)
      }
      if (hT(t), t.tag === 13) {
         if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(Re(317));
         e: {
            for (t = t.nextSibling, e = 0; t;) {
               if (t.nodeType === 8) {
                  var n = t.data;
                  if (n === "/$") {
                     if (e === 0) {
                        pi = Aa(t.nextSibling);
                        break e
                     }
                     e--
                  } else n !== "$" && n !== "$!" && n !== "$?" || e++
               }
               t = t.nextSibling
            }
            pi = null
         }
      } else pi = yi ? Aa(t.stateNode.nextSibling) : null;
      return !0
   }

   function mD() {
      for (var t = pi; t;) t = Aa(t.nextSibling)
   }

   function sf() {
      pi = yi = null, Mn = !1
   }

   function aM(t) {
      hs === null ? hs = [t] : hs.push(t)
   }
   var EG = No.ReactCurrentBatchConfig;

   function us(t, e) {
      if (t && t.defaultProps) {
         e = Bn({}, e), t = t.defaultProps;
         for (var n in t) e[n] === void 0 && (e[n] = t[n]);
         return e
      }
      return e
   }
   var C0 = Wa(null),
      T0 = null,
      Lc = null,
      lM = null;

   function uM() {
      lM = Lc = T0 = null
   }

   function cM(t) {
      var e = C0.current;
      vn(C0), t._currentValue = e
   }

   function eA(t, e, n) {
      for (; t !== null;) {
         var r = t.alternate;
         if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break;
         t = t.return
      }
   }

   function Jc(t, e) {
      T0 = t, lM = Lc = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (Zr = !0), t.firstContext = null)
   }

   function Ki(t) {
      var e = t._currentValue;
      if (lM !== t)
         if (t = {
               context: t,
               memoizedValue: e,
               next: null
            }, Lc === null) {
            if (T0 === null) throw Error(Re(308));
            Lc = t, T0.dependencies = {
               lanes: 0,
               firstContext: t
            }
         } else Lc = Lc.next = t;
      return e
   }
   var Rl = null;

   function fM(t) {
      Rl === null ? Rl = [t] : Rl.push(t)
   }

   function gD(t, e, n, r) {
      var i = e.interleaved;
      return i === null ? (n.next = n, fM(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Lo(t, r)
   }

   function Lo(t, e) {
      t.lanes |= e;
      var n = t.alternate;
      for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;) t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
      return n.tag === 3 ? n.stateNode : null
   }
   var aa = !1;

   function hM(t) {
      t.updateQueue = {
         baseState: t.memoizedState,
         firstBaseUpdate: null,
         lastBaseUpdate: null,
         shared: {
            pending: null,
            interleaved: null,
            lanes: 0
         },
         effects: null
      }
   }

   function vD(t, e) {
      t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
         baseState: t.baseState,
         firstBaseUpdate: t.firstBaseUpdate,
         lastBaseUpdate: t.lastBaseUpdate,
         shared: t.shared,
         effects: t.effects
      })
   }

   function bo(t, e) {
      return {
         eventTime: t,
         lane: e,
         tag: 0,
         payload: null,
         callback: null,
         next: null
      }
   }

   function Sa(t, e, n) {
      var r = t.updateQueue;
      if (r === null) return null;
      if (r = r.shared, Xt & 2) {
         var i = r.pending;
         return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Lo(t, n)
      }
      return i = r.interleaved, i === null ? (e.next = e, fM(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Lo(t, n)
   }

   function Kg(t, e, n) {
      if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
         var r = e.lanes;
         r &= t.pendingLanes, n |= r, e.lanes = n, QS(t, n)
      }
   }

   function dT(t, e) {
      var n = t.updateQueue,
         r = t.alternate;
      if (r !== null && (r = r.updateQueue, n === r)) {
         var i = null,
            s = null;
         if (n = n.firstBaseUpdate, n !== null) {
            do {
               var o = {
                  eventTime: n.eventTime,
                  lane: n.lane,
                  tag: n.tag,
                  payload: n.payload,
                  callback: n.callback,
                  next: null
               };
               s === null ? i = s = o : s = s.next = o, n = n.next
            } while (n !== null);
            s === null ? i = s = e : s = s.next = e
         } else i = s = e;
         n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: r.shared,
            effects: r.effects
         }, t.updateQueue = n;
         return
      }
      t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e
   }

   function R0(t, e, n, r) {
      var i = t.updateQueue;
      aa = !1;
      var s = i.firstBaseUpdate,
         o = i.lastBaseUpdate,
         a = i.shared.pending;
      if (a !== null) {
         i.shared.pending = null;
         var l = a,
            u = l.next;
         l.next = null, o === null ? s = u : o.next = u, o = l;
         var h = t.alternate;
         h !== null && (h = h.updateQueue, a = h.lastBaseUpdate, a !== o && (a === null ? h.firstBaseUpdate = u : a.next = u, h.lastBaseUpdate = l))
      }
      if (s !== null) {
         var d = i.baseState;
         o = 0, h = u = l = null, a = s;
         do {
            var p = a.lane,
               m = a.eventTime;
            if ((r & p) === p) {
               h !== null && (h = h.next = {
                  eventTime: m,
                  lane: 0,
                  tag: a.tag,
                  payload: a.payload,
                  callback: a.callback,
                  next: null
               });
               e: {
                  var v = t,
                     _ = a;
                  switch (p = e, m = n, _.tag) {
                     case 1:
                        if (v = _.payload, typeof v == "function") {
                           d = v.call(m, d, p);
                           break e
                        }
                        d = v;
                        break e;
                     case 3:
                        v.flags = v.flags & -65537 | 128;
                     case 0:
                        if (v = _.payload, p = typeof v == "function" ? v.call(m, d, p) : v, p == null) break e;
                        d = Bn({}, d, p);
                        break e;
                     case 2:
                        aa = !0
                  }
               }
               a.callback !== null && a.lane !== 0 && (t.flags |= 64, p = i.effects, p === null ? i.effects = [a] : p.push(a))
            } else m = {
               eventTime: m,
               lane: p,
               tag: a.tag,
               payload: a.payload,
               callback: a.callback,
               next: null
            }, h === null ? (u = h = m, l = d) : h = h.next = m, o |= p;
            if (a = a.next, a === null) {
               if (a = i.shared.pending, a === null) break;
               p = a, a = p.next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null
            }
         } while (1);
         if (h === null && (l = d), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = h, e = i.shared.interleaved, e !== null) {
            i = e;
            do o |= i.lane, i = i.next; while (i !== e)
         } else s === null && (i.shared.lanes = 0);
         Xl |= o, t.lanes = o, t.memoizedState = d
      }
   }

   function pT(t, e, n) {
      if (t = e.effects, e.effects = null, t !== null)
         for (e = 0; e < t.length; e++) {
            var r = t[e],
               i = r.callback;
            if (i !== null) {
               if (r.callback = null, r = n, typeof i != "function") throw Error(Re(191, i));
               i.call(r)
            }
         }
   }
   var yD = new gL.Component().refs;

   function tA(t, e, n, r) {
      e = t.memoizedState, n = n(r, e), n = n == null ? e : Bn({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n)
   }
   var vv = {
      isMounted: function (t) {
         return (t = t._reactInternals) ? tu(t) === t : !1
      },
      enqueueSetState: function (t, e, n) {
         t = t._reactInternals;
         var r = Gr(),
            i = Ea(t),
            s = bo(r, i);
         s.payload = e, n != null && (s.callback = n), e = Sa(t, s, i), e !== null && (gs(e, t, i, r), Kg(e, t, i))
      },
      enqueueReplaceState: function (t, e, n) {
         t = t._reactInternals;
         var r = Gr(),
            i = Ea(t),
            s = bo(r, i);
         s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Sa(t, s, i), e !== null && (gs(e, t, i, r), Kg(e, t, i))
      },
      enqueueForceUpdate: function (t, e) {
         t = t._reactInternals;
         var n = Gr(),
            r = Ea(t),
            i = bo(n, r);
         i.tag = 2, e != null && (i.callback = e), e = Sa(t, i, r), e !== null && (gs(e, t, r, n), Kg(e, t, r))
      }
   };

   function mT(t, e, n, r, i, s, o) {
      return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !wd(n, r) || !wd(i, s) : !0
   }

   function xD(t, e, n) {
      var r = !1,
         i = La,
         s = e.contextType;
      return typeof s == "object" && s !== null ? s = Ki(s) : (i = ei(e) ? Wl : Tr.current, r = e.contextTypes, s = (r = r != null) ? rf(t, i) : La), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = vv, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e
   }

   function gT(t, e, n, r) {
      t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && vv.enqueueReplaceState(e, e.state, null)
   }

   function nA(t, e, n, r) {
      var i = t.stateNode;
      i.props = n, i.state = t.memoizedState, i.refs = yD, hM(t);
      var s = e.contextType;
      typeof s == "object" && s !== null ? i.context = Ki(s) : (s = ei(e) ? Wl : Tr.current, i.context = rf(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (tA(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && vv.enqueueReplaceState(i, i.state, null), R0(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308)
   }

   function dh(t, e, n) {
      if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
         if (n._owner) {
            if (n = n._owner, n) {
               if (n.tag !== 1) throw Error(Re(309));
               var r = n.stateNode
            }
            if (!r) throw Error(Re(147, t));
            var i = r,
               s = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) {
               var a = i.refs;
               a === yD && (a = i.refs = {}), o === null ? delete a[s] : a[s] = o
            }, e._stringRef = s, e)
         }
         if (typeof t != "string") throw Error(Re(284));
         if (!n._owner) throw Error(Re(290, t))
      }
      return t
   }

   function Nm(t, e) {
      throw t = Object.prototype.toString.call(e), Error(Re(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
   }

   function vT(t) {
      var e = t._init;
      return e(t._payload)
   }

   function _D(t) {
      function e(g, S) {
         if (t) {
            var A = g.deletions;
            A === null ? (g.deletions = [S], g.flags |= 16) : A.push(S)
         }
      }

      function n(g, S) {
         if (!t) return null;
         for (; S !== null;) e(g, S), S = S.sibling;
         return null
      }

      function r(g, S) {
         for (g = new Map; S !== null;) S.key !== null ? g.set(S.key, S) : g.set(S.index, S), S = S.sibling;
         return g
      }

      function i(g, S) {
         return g = wa(g, S), g.index = 0, g.sibling = null, g
      }

      function s(g, S, A) {
         return g.index = A, t ? (A = g.alternate, A !== null ? (A = A.index, A < S ? (g.flags |= 2, S) : A) : (g.flags |= 2, S)) : (g.flags |= 1048576, S)
      }

      function o(g) {
         return t && g.alternate === null && (g.flags |= 2), g
      }

      function a(g, S, A, E) {
         return S === null || S.tag !== 6 ? (S = e_(A, g.mode, E), S.return = g, S) : (S = i(S, A), S.return = g, S)
      }

      function l(g, S, A, E) {
         var C = A.type;
         return C === wc ? h(g, S, A.props.children, E, A.key) : S !== null && (S.elementType === C || typeof C == "object" && C !== null && C.$$typeof === oa && vT(C) === S.type) ? (E = i(S, A.props), E.ref = dh(g, S, A), E.return = g, E) : (E = t0(A.type, A.key, A.props, null, g.mode, E), E.ref = dh(g, S, A), E.return = g, E)
      }

      function u(g, S, A, E) {
         return S === null || S.tag !== 4 || S.stateNode.containerInfo !== A.containerInfo || S.stateNode.implementation !== A.implementation ? (S = t_(A, g.mode, E), S.return = g, S) : (S = i(S, A.children || []), S.return = g, S)
      }

      function h(g, S, A, E, C) {
         return S === null || S.tag !== 7 ? (S = kl(A, g.mode, E, C), S.return = g, S) : (S = i(S, A), S.return = g, S)
      }

      function d(g, S, A) {
         if (typeof S == "string" && S !== "" || typeof S == "number") return S = e_("" + S, g.mode, A), S.return = g, S;
         if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
               case bm:
                  return A = t0(S.type, S.key, S.props, null, g.mode, A), A.ref = dh(g, null, S), A.return = g, A;
               case Ec:
                  return S = t_(S, g.mode, A), S.return = g, S;
               case oa:
                  var E = S._init;
                  return d(g, E(S._payload), A)
            }
            if (zh(S) || lh(S)) return S = kl(S, g.mode, A, null), S.return = g, S;
            Nm(g, S)
         }
         return null
      }

      function p(g, S, A, E) {
         var C = S !== null ? S.key : null;
         if (typeof A == "string" && A !== "" || typeof A == "number") return C !== null ? null : a(g, S, "" + A, E);
         if (typeof A == "object" && A !== null) {
            switch (A.$$typeof) {
               case bm:
                  return A.key === C ? l(g, S, A, E) : null;
               case Ec:
                  return A.key === C ? u(g, S, A, E) : null;
               case oa:
                  return C = A._init, p(g, S, C(A._payload), E)
            }
            if (zh(A) || lh(A)) return C !== null ? null : h(g, S, A, E, null);
            Nm(g, A)
         }
         return null
      }

      function m(g, S, A, E, C) {
         if (typeof E == "string" && E !== "" || typeof E == "number") return g = g.get(A) || null, a(S, g, "" + E, C);
         if (typeof E == "object" && E !== null) {
            switch (E.$$typeof) {
               case bm:
                  return g = g.get(E.key === null ? A : E.key) || null, l(S, g, E, C);
               case Ec:
                  return g = g.get(E.key === null ? A : E.key) || null, u(S, g, E, C);
               case oa:
                  var R = E._init;
                  return m(g, S, A, R(E._payload), C)
            }
            if (zh(E) || lh(E)) return g = g.get(A) || null, h(S, g, E, C, null);
            Nm(S, E)
         }
         return null
      }

      function v(g, S, A, E) {
         for (var C = null, R = null, B = S, D = S = 0, T = null; B !== null && D < A.length; D++) {
            B.index > D ? (T = B, B = null) : T = B.sibling;
            var I = p(g, B, A[D], E);
            if (I === null) {
               B === null && (B = T);
               break
            }
            t && B && I.alternate === null && e(g, B), S = s(I, S, D), R === null ? C = I : R.sibling = I, R = I, B = T
         }
         if (D === A.length) return n(g, B), Mn && xl(g, D), C;
         if (B === null) {
            for (; D < A.length; D++) B = d(g, A[D], E), B !== null && (S = s(B, S, D), R === null ? C = B : R.sibling = B, R = B);
            return Mn && xl(g, D), C
         }
         for (B = r(g, B); D < A.length; D++) T = m(B, g, D, A[D], E), T !== null && (t && T.alternate !== null && B.delete(T.key === null ? D : T.key), S = s(T, S, D), R === null ? C = T : R.sibling = T, R = T);
         return t && B.forEach(function (N) {
            return e(g, N)
         }), Mn && xl(g, D), C
      }

      function _(g, S, A, E) {
         var C = lh(A);
         if (typeof C != "function") throw Error(Re(150));
         if (A = C.call(A), A == null) throw Error(Re(151));
         for (var R = C = null, B = S, D = S = 0, T = null, I = A.next(); B !== null && !I.done; D++, I = A.next()) {
            B.index > D ? (T = B, B = null) : T = B.sibling;
            var N = p(g, B, I.value, E);
            if (N === null) {
               B === null && (B = T);
               break
            }
            t && B && N.alternate === null && e(g, B), S = s(N, S, D), R === null ? C = N : R.sibling = N, R = N, B = T
         }
         if (I.done) return n(g, B), Mn && xl(g, D), C;
         if (B === null) {
            for (; !I.done; D++, I = A.next()) I = d(g, I.value, E), I !== null && (S = s(I, S, D), R === null ? C = I : R.sibling = I, R = I);
            return Mn && xl(g, D), C
         }
         for (B = r(g, B); !I.done; D++, I = A.next()) I = m(B, g, D, I.value, E), I !== null && (t && I.alternate !== null && B.delete(I.key === null ? D : I.key), S = s(I, S, D), R === null ? C = I : R.sibling = I, R = I);
         return t && B.forEach(function (q) {
            return e(g, q)
         }), Mn && xl(g, D), C
      }

      function x(g, S, A, E) {
         if (typeof A == "object" && A !== null && A.type === wc && A.key === null && (A = A.props.children), typeof A == "object" && A !== null) {
            switch (A.$$typeof) {
               case bm:
                  e: {
                     for (var C = A.key, R = S; R !== null;) {
                        if (R.key === C) {
                           if (C = A.type, C === wc) {
                              if (R.tag === 7) {
                                 n(g, R.sibling), S = i(R, A.props.children), S.return = g, g = S;
                                 break e
                              }
                           } else if (R.elementType === C || typeof C == "object" && C !== null && C.$$typeof === oa && vT(C) === R.type) {
                              n(g, R.sibling), S = i(R, A.props), S.ref = dh(g, R, A), S.return = g, g = S;
                              break e
                           }
                           n(g, R);
                           break
                        } else e(g, R);
                        R = R.sibling
                     }
                     A.type === wc ? (S = kl(A.props.children, g.mode, E, A.key), S.return = g, g = S) : (E = t0(A.type, A.key, A.props, null, g.mode, E), E.ref = dh(g, S, A), E.return = g, g = E)
                  }
                  return o(g);
               case Ec:
                  e: {
                     for (R = A.key; S !== null;) {
                        if (S.key === R)
                           if (S.tag === 4 && S.stateNode.containerInfo === A.containerInfo && S.stateNode.implementation === A.implementation) {
                              n(g, S.sibling), S = i(S, A.children || []), S.return = g, g = S;
                              break e
                           } else {
                              n(g, S);
                              break
                           }
                        else e(g, S);
                        S = S.sibling
                     }
                     S = t_(A, g.mode, E),
                     S.return = g,
                     g = S
                  }
                  return o(g);
               case oa:
                  return R = A._init, x(g, S, R(A._payload), E)
            }
            if (zh(A)) return v(g, S, A, E);
            if (lh(A)) return _(g, S, A, E);
            Nm(g, A)
         }
         return typeof A == "string" && A !== "" || typeof A == "number" ? (A = "" + A, S !== null && S.tag === 6 ? (n(g, S.sibling), S = i(S, A), S.return = g, g = S) : (n(g, S), S = e_(A, g.mode, E), S.return = g, g = S), o(g)) : n(g, S)
      }
      return x
   }
   var of = _D(!0), AD = _D(!1), ip = {}, Gs = Wa(ip), Rd = Wa(ip), Pd = Wa(ip);

   function Pl(t) {
      if (t === ip) throw Error(Re(174));
      return t
   }

   function dM(t, e) {
      switch (fn(Pd, e), fn(Rd, t), fn(Gs, ip), t = e.nodeType, t) {
         case 9:
         case 11:
            e = (e = e.documentElement) ? e.namespaceURI : D1(null, "");
            break;
         default:
            t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = D1(e, t)
      }
      vn(Gs), fn(Gs, e)
   }

   function af() {
      vn(Gs), vn(Rd), vn(Pd)
   }

   function SD(t) {
      Pl(Pd.current);
      var e = Pl(Gs.current),
         n = D1(e, t.type);
      e !== n && (fn(Rd, t), fn(Gs, n))
   }

   function pM(t) {
      Rd.current === t && (vn(Gs), vn(Rd))
   }
   var Cn = Wa(0);

   function P0(t) {
      for (var e = t; e !== null;) {
         if (e.tag === 13) {
            var n = e.memoizedState;
            if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e
         } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128) return e
         } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue
         }
         if (e === t) break;
         for (; e.sibling === null;) {
            if (e.return === null || e.return === t) return null;
            e = e.return
         }
         e.sibling.return = e.return, e = e.sibling
      }
      return null
   }
   var Jx = [];

   function mM() {
      for (var t = 0; t < Jx.length; t++) Jx[t]._workInProgressVersionPrimary = null;
      Jx.length = 0
   }
   var Yg = No.ReactCurrentDispatcher,
      Kx = No.ReactCurrentBatchConfig,
      $l = 0,
      Pn = null,
      Qn = null,
      lr = null,
      B0 = !1,
      nd = !1,
      Bd = 0,
      wG = 0;

   function Ar() {
      throw Error(Re(321))
   }

   function gM(t, e) {
      if (e === null) return !1;
      for (var n = 0; n < e.length && n < t.length; n++)
         if (!vs(t[n], e[n])) return !1;
      return !0
   }

   function vM(t, e, n, r, i, s) {
      if ($l = s, Pn = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Yg.current = t === null || t.memoizedState === null ? RG : PG, t = n(r, i), nd) {
         s = 0;
         do {
            if (nd = !1, Bd = 0, 25 <= s) throw Error(Re(301));
            s += 1, lr = Qn = null, e.updateQueue = null, Yg.current = BG, t = n(r, i)
         } while (nd)
      }
      if (Yg.current = I0, e = Qn !== null && Qn.next !== null, $l = 0, lr = Qn = Pn = null, B0 = !1, e) throw Error(Re(300));
      return t
   }

   function yM() {
      var t = Bd !== 0;
      return Bd = 0, t
   }

   function Fs() {
      var t = {
         memoizedState: null,
         baseState: null,
         baseQueue: null,
         queue: null,
         next: null
      };
      return lr === null ? Pn.memoizedState = lr = t : lr = lr.next = t, lr
   }

   function Yi() {
      if (Qn === null) {
         var t = Pn.alternate;
         t = t !== null ? t.memoizedState : null
      } else t = Qn.next;
      var e = lr === null ? Pn.memoizedState : lr.next;
      if (e !== null) lr = e, Qn = t;
      else {
         if (t === null) throw Error(Re(310));
         Qn = t, t = {
            memoizedState: Qn.memoizedState,
            baseState: Qn.baseState,
            baseQueue: Qn.baseQueue,
            queue: Qn.queue,
            next: null
         }, lr === null ? Pn.memoizedState = lr = t : lr = lr.next = t
      }
      return lr
   }

   function Id(t, e) {
      return typeof e == "function" ? e(t) : e
   }

   function Yx(t) {
      var e = Yi(),
         n = e.queue;
      if (n === null) throw Error(Re(311));
      n.lastRenderedReducer = t;
      var r = Qn,
         i = r.baseQueue,
         s = n.pending;
      if (s !== null) {
         if (i !== null) {
            var o = i.next;
            i.next = s.next, s.next = o
         }
         r.baseQueue = i = s, n.pending = null
      }
      if (i !== null) {
         s = i.next, r = r.baseState;
         var a = o = null,
            l = null,
            u = s;
         do {
            var h = u.lane;
            if (($l & h) === h) l !== null && (l = l.next = {
               lane: 0,
               action: u.action,
               hasEagerState: u.hasEagerState,
               eagerState: u.eagerState,
               next: null
            }), r = u.hasEagerState ? u.eagerState : t(r, u.action);
            else {
               var d = {
                  lane: h,
                  action: u.action,
                  hasEagerState: u.hasEagerState,
                  eagerState: u.eagerState,
                  next: null
               };
               l === null ? (a = l = d, o = r) : l = l.next = d, Pn.lanes |= h, Xl |= h
            }
            u = u.next
         } while (u !== null && u !== s);
         l === null ? o = r : l.next = a, vs(r, e.memoizedState) || (Zr = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = l, n.lastRenderedState = r
      }
      if (t = n.interleaved, t !== null) {
         i = t;
         do s = i.lane, Pn.lanes |= s, Xl |= s, i = i.next; while (i !== t)
      } else i === null && (n.lanes = 0);
      return [e.memoizedState, n.dispatch]
   }

   function Qx(t) {
      var e = Yi(),
         n = e.queue;
      if (n === null) throw Error(Re(311));
      n.lastRenderedReducer = t;
      var r = n.dispatch,
         i = n.pending,
         s = e.memoizedState;
      if (i !== null) {
         n.pending = null;
         var o = i = i.next;
         do s = t(s, o.action), o = o.next; while (o !== i);
         vs(s, e.memoizedState) || (Zr = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s
      }
      return [s, r]
   }

   function MD() {}

   function ED(t, e) {
      var n = Pn,
         r = Yi(),
         i = e(),
         s = !vs(r.memoizedState, i);
      if (s && (r.memoizedState = i, Zr = !0), r = r.queue, xM(CD.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || lr !== null && lr.memoizedState.tag & 1) {
         if (n.flags |= 2048, Ld(9, bD.bind(null, n, r, i, e), void 0, null), ur === null) throw Error(Re(349));
         $l & 30 || wD(n, e, i)
      }
      return i
   }

   function wD(t, e, n) {
      t.flags |= 16384, t = {
         getSnapshot: e,
         value: n
      }, e = Pn.updateQueue, e === null ? (e = {
         lastEffect: null,
         stores: null
      }, Pn.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t))
   }

   function bD(t, e, n, r) {
      e.value = n, e.getSnapshot = r, TD(e) && RD(t)
   }

   function CD(t, e, n) {
      return n(function () {
         TD(e) && RD(t)
      })
   }

   function TD(t) {
      var e = t.getSnapshot;
      t = t.value;
      try {
         var n = e();
         return !vs(t, n)
      } catch {
         return !0
      }
   }

   function RD(t) {
      var e = Lo(t, 1);
      e !== null && gs(e, t, 1, -1)
   }

   function yT(t) {
      var e = Fs();
      return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
         pending: null,
         interleaved: null,
         lanes: 0,
         dispatch: null,
         lastRenderedReducer: Id,
         lastRenderedState: t
      }, e.queue = t, t = t.dispatch = TG.bind(null, Pn, t), [e.memoizedState, t]
   }

   function Ld(t, e, n, r) {
      return t = {
         tag: t,
         create: e,
         destroy: n,
         deps: r,
         next: null
      }, e = Pn.updateQueue, e === null ? (e = {
         lastEffect: null,
         stores: null
      }, Pn.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t
   }

   function PD() {
      return Yi().memoizedState
   }

   function Qg(t, e, n, r) {
      var i = Fs();
      Pn.flags |= t, i.memoizedState = Ld(1 | e, n, void 0, r === void 0 ? null : r)
   }

   function yv(t, e, n, r) {
      var i = Yi();
      r = r === void 0 ? null : r;
      var s = void 0;
      if (Qn !== null) {
         var o = Qn.memoizedState;
         if (s = o.destroy, r !== null && gM(r, o.deps)) {
            i.memoizedState = Ld(e, n, s, r);
            return
         }
      }
      Pn.flags |= t, i.memoizedState = Ld(1 | e, n, s, r)
   }

   function xT(t, e) {
      return Qg(8390656, 8, t, e)
   }

   function xM(t, e) {
      return yv(2048, 8, t, e)
   }

   function BD(t, e) {
      return yv(4, 2, t, e)
   }

   function ID(t, e) {
      return yv(4, 4, t, e)
   }

   function LD(t, e) {
      if (typeof e == "function") return t = t(), e(t),
         function () {
            e(null)
         };
      if (e != null) return t = t(), e.current = t,
         function () {
            e.current = null
         }
   }

   function DD(t, e, n) {
      return n = n != null ? n.concat([t]) : null, yv(4, 4, LD.bind(null, e, t), n)
   }

   function _M() {}

   function FD(t, e) {
      var n = Yi();
      e = e === void 0 ? null : e;
      var r = n.memoizedState;
      return r !== null && e !== null && gM(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t)
   }

   function OD(t, e) {
      var n = Yi();
      e = e === void 0 ? null : e;
      var r = n.memoizedState;
      return r !== null && e !== null && gM(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t)
   }

   function ND(t, e, n) {
      return $l & 21 ? (vs(n, e) || (n = HL(), Pn.lanes |= n, Xl |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, Zr = !0), t.memoizedState = n)
   }

   function bG(t, e) {
      var n = rn;
      rn = n !== 0 && 4 > n ? n : 4, t(!0);
      var r = Kx.transition;
      Kx.transition = {};
      try {
         t(!1), e()
      } finally {
         rn = n, Kx.transition = r
      }
   }

   function UD() {
      return Yi().memoizedState
   }

   function CG(t, e, n) {
      var r = Ea(t);
      if (n = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
         }, kD(t)) HD(e, n);
      else if (n = gD(t, e, n, r), n !== null) {
         var i = Gr();
         gs(n, t, r, i), GD(n, e, r)
      }
   }

   function TG(t, e, n) {
      var r = Ea(t),
         i = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
         };
      if (kD(t)) HD(e, i);
      else {
         var s = t.alternate;
         if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
            var o = e.lastRenderedState,
               a = s(o, n);
            if (i.hasEagerState = !0, i.eagerState = a, vs(a, o)) {
               var l = e.interleaved;
               l === null ? (i.next = i, fM(e)) : (i.next = l.next, l.next = i), e.interleaved = i;
               return
            }
         } catch {} finally {}
         n = gD(t, e, i, r), n !== null && (i = Gr(), gs(n, t, r, i), GD(n, e, r))
      }
   }

   function kD(t) {
      var e = t.alternate;
      return t === Pn || e !== null && e === Pn
   }

   function HD(t, e) {
      nd = B0 = !0;
      var n = t.pending;
      n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e
   }

   function GD(t, e, n) {
      if (n & 4194240) {
         var r = e.lanes;
         r &= t.pendingLanes, n |= r, e.lanes = n, QS(t, n)
      }
   }
   var I0 = {
         readContext: Ki,
         useCallback: Ar,
         useContext: Ar,
         useEffect: Ar,
         useImperativeHandle: Ar,
         useInsertionEffect: Ar,
         useLayoutEffect: Ar,
         useMemo: Ar,
         useReducer: Ar,
         useRef: Ar,
         useState: Ar,
         useDebugValue: Ar,
         useDeferredValue: Ar,
         useTransition: Ar,
         useMutableSource: Ar,
         useSyncExternalStore: Ar,
         useId: Ar,
         unstable_isNewReconciler: !1
      },
      RG = {
         readContext: Ki,
         useCallback: function (t, e) {
            return Fs().memoizedState = [t, e === void 0 ? null : e], t
         },
         useContext: Ki,
         useEffect: xT,
         useImperativeHandle: function (t, e, n) {
            return n = n != null ? n.concat([t]) : null, Qg(4194308, 4, LD.bind(null, e, t), n)
         },
         useLayoutEffect: function (t, e) {
            return Qg(4194308, 4, t, e)
         },
         useInsertionEffect: function (t, e) {
            return Qg(4, 2, t, e)
         },
         useMemo: function (t, e) {
            var n = Fs();
            return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t
         },
         useReducer: function (t, e, n) {
            var r = Fs();
            return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
               pending: null,
               interleaved: null,
               lanes: 0,
               dispatch: null,
               lastRenderedReducer: t,
               lastRenderedState: e
            }, r.queue = t, t = t.dispatch = CG.bind(null, Pn, t), [r.memoizedState, t]
         },
         useRef: function (t) {
            var e = Fs();
            return t = {
               current: t
            }, e.memoizedState = t
         },
         useState: yT,
         useDebugValue: _M,
         useDeferredValue: function (t) {
            return Fs().memoizedState = t
         },
         useTransition: function () {
            var t = yT(!1),
               e = t[0];
            return t = bG.bind(null, t[1]), Fs().memoizedState = t, [e, t]
         },
         useMutableSource: function () {},
         useSyncExternalStore: function (t, e, n) {
            var r = Pn,
               i = Fs();
            if (Mn) {
               if (n === void 0) throw Error(Re(407));
               n = n()
            } else {
               if (n = e(), ur === null) throw Error(Re(349));
               $l & 30 || wD(r, e, n)
            }
            i.memoizedState = n;
            var s = {
               value: n,
               getSnapshot: e
            };
            return i.queue = s, xT(CD.bind(null, r, s, t), [t]), r.flags |= 2048, Ld(9, bD.bind(null, r, s, n, e), void 0, null), n
         },
         useId: function () {
            var t = Fs(),
               e = ur.identifierPrefix;
            if (Mn) {
               var n = Ao,
                  r = _o;
               n = (r & ~(1 << 32 - ms(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = Bd++, 0 < n && (e += "H" + n.toString(32)), e += ":"
            } else n = wG++, e = ":" + e + "r" + n.toString(32) + ":";
            return t.memoizedState = e
         },
         unstable_isNewReconciler: !1
      },
      PG = {
         readContext: Ki,
         useCallback: FD,
         useContext: Ki,
         useEffect: xM,
         useImperativeHandle: DD,
         useInsertionEffect: BD,
         useLayoutEffect: ID,
         useMemo: OD,
         useReducer: Yx,
         useRef: PD,
         useState: function () {
            return Yx(Id)
         },
         useDebugValue: _M,
         useDeferredValue: function (t) {
            var e = Yi();
            return ND(e, Qn.memoizedState, t)
         },
         useTransition: function () {
            var t = Yx(Id)[0],
               e = Yi().memoizedState;
            return [t, e]
         },
         useMutableSource: MD,
         useSyncExternalStore: ED,
         useId: UD,
         unstable_isNewReconciler: !1
      },
      BG = {
         readContext: Ki,
         useCallback: FD,
         useContext: Ki,
         useEffect: xM,
         useImperativeHandle: DD,
         useInsertionEffect: BD,
         useLayoutEffect: ID,
         useMemo: OD,
         useReducer: Qx,
         useRef: PD,
         useState: function () {
            return Qx(Id)
         },
         useDebugValue: _M,
         useDeferredValue: function (t) {
            var e = Yi();
            return Qn === null ? e.memoizedState = t : ND(e, Qn.memoizedState, t)
         },
         useTransition: function () {
            var t = Qx(Id)[0],
               e = Yi().memoizedState;
            return [t, e]
         },
         useMutableSource: MD,
         useSyncExternalStore: ED,
         useId: UD,
         unstable_isNewReconciler: !1
      };

   function lf(t, e) {
      try {
         var n = "",
            r = e;
         do n += sH(r), r = r.return; while (r);
         var i = n
      } catch (s) {
         i = `
Error generating stack: ` + s.message + `
` + s.stack
      }
      return {
         value: t,
         source: e,
         stack: i,
         digest: null
      }
   }

   function Zx(t, e, n) {
      return {
         value: t,
         source: null,
         stack: n ?? null,
         digest: e ?? null
      }
   }

   function rA(t, e) {
      try {
         console.error(e.value)
      } catch (n) {
         setTimeout(function () {
            throw n
         })
      }
   }
   var IG = typeof WeakMap == "function" ? WeakMap : Map;

   function zD(t, e, n) {
      n = bo(-1, n), n.tag = 3, n.payload = {
         element: null
      };
      var r = e.value;
      return n.callback = function () {
         D0 || (D0 = !0, dA = r), rA(t, e)
      }, n
   }

   function VD(t, e, n) {
      n = bo(-1, n), n.tag = 3;
      var r = t.type.getDerivedStateFromError;
      if (typeof r == "function") {
         var i = e.value;
         n.payload = function () {
            return r(i)
         }, n.callback = function () {
            rA(t, e)
         }
      }
      var s = t.stateNode;
      return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () {
         rA(t, e), typeof r != "function" && (Ma === null ? Ma = new Set([this]) : Ma.add(this));
         var o = e.stack;
         this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
         })
      }), n
   }

   function _T(t, e, n) {
      var r = t.pingCache;
      if (r === null) {
         r = t.pingCache = new IG;
         var i = new Set;
         r.set(e, i)
      } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i));
      i.has(n) || (i.add(n), t = $G.bind(null, t, e, n), e.then(t, t))
   }

   function AT(t) {
      do {
         var e;
         if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t;
         t = t.return
      } while (t !== null);
      return null
   }

   function ST(t, e, n, r, i) {
      return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = bo(-1, 1), e.tag = 2, Sa(n, e, 1))), n.lanes |= 1), t)
   }
   var LG = No.ReactCurrentOwner,
      Zr = !1;

   function Ur(t, e, n, r) {
      e.child = t === null ? AD(e, null, n, r) : of (e, t.child, n, r)
   }

   function MT(t, e, n, r, i) {
      n = n.render;
      var s = e.ref;
      return Jc(e, i), r = vM(t, e, n, r, s, i), n = yM(), t !== null && !Zr ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Do(t, e, i)) : (Mn && n && sM(e), e.flags |= 1, Ur(t, e, r, i), e.child)
   }

   function ET(t, e, n, r, i) {
      if (t === null) {
         var s = n.type;
         return typeof s == "function" && !TM(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, WD(t, e, s, r, i)) : (t = t0(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t)
      }
      if (s = t.child, !(t.lanes & i)) {
         var o = s.memoizedProps;
         if (n = n.compare, n = n !== null ? n : wd, n(o, r) && t.ref === e.ref) return Do(t, e, i)
      }
      return e.flags |= 1, t = wa(s, r), t.ref = e.ref, t.return = e, e.child = t
   }

   function WD(t, e, n, r, i) {
      if (t !== null) {
         var s = t.memoizedProps;
         if (wd(s, r) && t.ref === e.ref)
            if (Zr = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (Zr = !0);
            else return e.lanes = t.lanes, Do(t, e, i)
      }
      return iA(t, e, n, r, i)
   }

   function jD(t, e, n) {
      var r = e.pendingProps,
         i = r.children,
         s = t !== null ? t.memoizedState : null;
      if (r.mode === "hidden")
         if (!(e.mode & 1)) e.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
         }, fn(Fc, di), di |= n;
         else {
            if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
               baseLanes: t,
               cachePool: null,
               transitions: null
            }, e.updateQueue = null, fn(Fc, di), di |= t, null;
            e.memoizedState = {
               baseLanes: 0,
               cachePool: null,
               transitions: null
            }, r = s !== null ? s.baseLanes : n, fn(Fc, di), di |= r
         }
      else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, fn(Fc, di), di |= r;
      return Ur(t, e, i, n), e.child
   }

   function $D(t, e) {
      var n = e.ref;
      (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152)
   }

   function iA(t, e, n, r, i) {
      var s = ei(n) ? Wl : Tr.current;
      return s = rf(e, s), Jc(e, i), n = vM(t, e, n, r, s, i), r = yM(), t !== null && !Zr ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Do(t, e, i)) : (Mn && r && sM(e), e.flags |= 1, Ur(t, e, n, i), e.child)
   }

   function wT(t, e, n, r, i) {
      if (ei(n)) {
         var s = !0;
         E0(e)
      } else s = !1;
      if (Jc(e, i), e.stateNode === null) Zg(t, e), xD(e, n, r), nA(e, n, r, i), r = !0;
      else if (t === null) {
         var o = e.stateNode,
            a = e.memoizedProps;
         o.props = a;
         var l = o.context,
            u = n.contextType;
         typeof u == "object" && u !== null ? u = Ki(u) : (u = ei(n) ? Wl : Tr.current, u = rf(e, u));
         var h = n.getDerivedStateFromProps,
            d = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function";
         d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== u) && gT(e, o, r, u), aa = !1;
         var p = e.memoizedState;
         o.state = p, R0(e, r, o, i), l = e.memoizedState, a !== r || p !== l || qr.current || aa ? (typeof h == "function" && (tA(e, n, h, r), l = e.memoizedState), (a = aa || mT(e, n, a, r, p, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), r = !1)
      } else {
         o = e.stateNode, vD(t, e), a = e.memoizedProps, u = e.type === e.elementType ? a : us(e.type, a), o.props = u, d = e.pendingProps, p = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = Ki(l) : (l = ei(n) ? Wl : Tr.current, l = rf(e, l));
         var m = n.getDerivedStateFromProps;
         (h = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || p !== l) && gT(e, o, r, l), aa = !1, p = e.memoizedState, o.state = p, R0(e, r, o, i);
         var v = e.memoizedState;
         a !== d || p !== v || qr.current || aa ? (typeof m == "function" && (tA(e, n, m, r), v = e.memoizedState), (u = aa || mT(e, n, u, r, p, v, l) || !1) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, v, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, v, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = v), o.props = r, o.state = v, o.context = l, r = u) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024), r = !1)
      }
      return sA(t, e, n, r, s, i)
   }

   function sA(t, e, n, r, i, s) {
      $D(t, e);
      var o = (e.flags & 128) !== 0;
      if (!r && !o) return i && cT(e, n, !1), Do(t, e, s);
      r = e.stateNode, LG.current = e;
      var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
      return e.flags |= 1, t !== null && o ? (e.child = of (e, t.child, null, s), e.child = of (e, null, a, s)) : Ur(t, e, a, s), e.memoizedState = r.state, i && cT(e, n, !0), e.child
   }

   function XD(t) {
      var e = t.stateNode;
      e.pendingContext ? uT(t, e.pendingContext, e.pendingContext !== e.context) : e.context && uT(t, e.context, !1), dM(t, e.containerInfo)
   }

   function bT(t, e, n, r, i) {
      return sf(), aM(i), e.flags |= 256, Ur(t, e, n, r), e.child
   }
   var oA = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0
   };

   function aA(t) {
      return {
         baseLanes: t,
         cachePool: null,
         transitions: null
      }
   }

   function JD(t, e, n) {
      var r = e.pendingProps,
         i = Cn.current,
         s = !1,
         o = (e.flags & 128) !== 0,
         a;
      if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), fn(Cn, i & 1), t === null) return q1(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, o = {
         mode: "hidden",
         children: o
      }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Av(o, r, 0, null), t = kl(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = aA(n), e.memoizedState = oA, t) : AM(e, o));
      if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return DG(t, e, o, r, a, i, n);
      if (s) {
         s = r.fallback, o = e.mode, i = t.child, a = i.sibling;
         var l = {
            mode: "hidden",
            children: r.children
         };
         return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = wa(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = wa(a, s) : (s = kl(s, o, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = t.child.memoizedState, o = o === null ? aA(n) : {
            baseLanes: o.baseLanes | n,
            cachePool: null,
            transitions: o.transitions
         }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = oA, r
      }
      return s = t.child, t = s.sibling, r = wa(s, {
         mode: "visible",
         children: r.children
      }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r
   }

   function AM(t, e) {
      return e = Av({
         mode: "visible",
         children: e
      }, t.mode, 0, null), e.return = t, t.child = e
   }

   function Um(t, e, n, r) {
      return r !== null && aM(r), of (e, t.child, null, n), t = AM(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t
   }

   function DG(t, e, n, r, i, s, o) {
      if (n) return e.flags & 256 ? (e.flags &= -257, r = Zx(Error(Re(422))), Um(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = Av({
         mode: "visible",
         children: r.children
      }, i, 0, null), s = kl(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && of (e, t.child, null, o), e.child.memoizedState = aA(o), e.memoizedState = oA, s);
      if (!(e.mode & 1)) return Um(t, e, o, null);
      if (i.data === "$!") {
         if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst;
         return r = a, s = Error(Re(419)), r = Zx(s, r, void 0), Um(t, e, o, r)
      }
      if (a = (o & t.childLanes) !== 0, Zr || a) {
         if (r = ur, r !== null) {
            switch (o & -o) {
               case 4:
                  i = 2;
                  break;
               case 16:
                  i = 8;
                  break;
               case 64:
               case 128:
               case 256:
               case 512:
               case 1024:
               case 2048:
               case 4096:
               case 8192:
               case 16384:
               case 32768:
               case 65536:
               case 131072:
               case 262144:
               case 524288:
               case 1048576:
               case 2097152:
               case 4194304:
               case 8388608:
               case 16777216:
               case 33554432:
               case 67108864:
                  i = 32;
                  break;
               case 536870912:
                  i = 268435456;
                  break;
               default:
                  i = 0
            }
            i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, Lo(t, i), gs(r, t, i, -1))
         }
         return CM(), r = Zx(Error(Re(421))), Um(t, e, o, r)
      }
      return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = XG.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, pi = Aa(i.nextSibling), yi = e, Mn = !0, hs = null, t !== null && (zi[Vi++] = _o, zi[Vi++] = Ao, zi[Vi++] = jl, _o = t.id, Ao = t.overflow, jl = e), e = AM(e, r.children), e.flags |= 4096, e)
   }

   function CT(t, e, n) {
      t.lanes |= e;
      var r = t.alternate;
      r !== null && (r.lanes |= e), eA(t.return, e, n)
   }

   function qx(t, e, n, r, i) {
      var s = t.memoizedState;
      s === null ? t.memoizedState = {
         isBackwards: e,
         rendering: null,
         renderingStartTime: 0,
         last: r,
         tail: n,
         tailMode: i
      } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i)
   }

   function KD(t, e, n) {
      var r = e.pendingProps,
         i = r.revealOrder,
         s = r.tail;
      if (Ur(t, e, r.children, n), r = Cn.current, r & 2) r = r & 1 | 2, e.flags |= 128;
      else {
         if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) {
            if (t.tag === 13) t.memoizedState !== null && CT(t, n, e);
            else if (t.tag === 19) CT(t, n, e);
            else if (t.child !== null) {
               t.child.return = t, t = t.child;
               continue
            }
            if (t === e) break e;
            for (; t.sibling === null;) {
               if (t.return === null || t.return === e) break e;
               t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
         }
         r &= 1
      }
      if (fn(Cn, r), !(e.mode & 1)) e.memoizedState = null;
      else switch (i) {
         case "forwards":
            for (n = e.child, i = null; n !== null;) t = n.alternate, t !== null && P0(t) === null && (i = n), n = n.sibling;
            n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), qx(e, !1, i, n, s);
            break;
         case "backwards":
            for (n = null, i = e.child, e.child = null; i !== null;) {
               if (t = i.alternate, t !== null && P0(t) === null) {
                  e.child = i;
                  break
               }
               t = i.sibling, i.sibling = n, n = i, i = t
            }
            qx(e, !0, n, null, s);
            break;
         case "together":
            qx(e, !1, null, null, void 0);
            break;
         default:
            e.memoizedState = null
      }
      return e.child
   }

   function Zg(t, e) {
      !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2)
   }

   function Do(t, e, n) {
      if (t !== null && (e.dependencies = t.dependencies), Xl |= e.lanes, !(n & e.childLanes)) return null;
      if (t !== null && e.child !== t.child) throw Error(Re(153));
      if (e.child !== null) {
         for (t = e.child, n = wa(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;) t = t.sibling, n = n.sibling = wa(t, t.pendingProps), n.return = e;
         n.sibling = null
      }
      return e.child
   }

   function FG(t, e, n) {
      switch (e.tag) {
         case 3:
            XD(e), sf();
            break;
         case 5:
            SD(e);
            break;
         case 1:
            ei(e.type) && E0(e);
            break;
         case 4:
            dM(e, e.stateNode.containerInfo);
            break;
         case 10:
            var r = e.type._context,
               i = e.memoizedProps.value;
            fn(C0, r._currentValue), r._currentValue = i;
            break;
         case 13:
            if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (fn(Cn, Cn.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? JD(t, e, n) : (fn(Cn, Cn.current & 1), t = Do(t, e, n), t !== null ? t.sibling : null);
            fn(Cn, Cn.current & 1);
            break;
         case 19:
            if (r = (n & e.childLanes) !== 0, t.flags & 128) {
               if (r) return KD(t, e, n);
               e.flags |= 128
            }
            if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), fn(Cn, Cn.current), r) break;
            return null;
         case 22:
         case 23:
            return e.lanes = 0, jD(t, e, n)
      }
      return Do(t, e, n)
   }
   var YD, lA, QD, ZD;
   YD = function (t, e) {
      for (var n = e.child; n !== null;) {
         if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
         else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n, n = n.child;
            continue
         }
         if (n === e) break;
         for (; n.sibling === null;) {
            if (n.return === null || n.return === e) return;
            n = n.return
         }
         n.sibling.return = n.return, n = n.sibling
      }
   };
   lA = function () {};
   QD = function (t, e, n, r) {
      var i = t.memoizedProps;
      if (i !== r) {
         t = e.stateNode, Pl(Gs.current);
         var s = null;
         switch (n) {
            case "input":
               i = P1(t, i), r = P1(t, r), s = [];
               break;
            case "select":
               i = Bn({}, i, {
                  value: void 0
               }), r = Bn({}, r, {
                  value: void 0
               }), s = [];
               break;
            case "textarea":
               i = L1(t, i), r = L1(t, r), s = [];
               break;
            default:
               typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = S0)
         }
         F1(n, r);
         var o;
         n = null;
         for (u in i)
            if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null)
               if (u === "style") {
                  var a = i[u];
                  for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
               } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (yd.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null));
         for (u in r) {
            var l = r[u];
            if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null))
               if (u === "style")
                  if (a) {
                     for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                     for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o])
                  } else n || (s || (s = []), s.push(u, n)), n = l;
            else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (yd.hasOwnProperty(u) ? (l != null && u === "onScroll" && hn("scroll", t), s || a === l || (s = [])) : (s = s || []).push(u, l))
         }
         n && (s = s || []).push("style", n);
         var u = s;
         (e.updateQueue = u) && (e.flags |= 4)
      }
   };
   ZD = function (t, e, n, r) {
      n !== r && (e.flags |= 4)
   };

   function ph(t, e) {
      if (!Mn) switch (t.tailMode) {
         case "hidden":
            e = t.tail;
            for (var n = null; e !== null;) e.alternate !== null && (n = e), e = e.sibling;
            n === null ? t.tail = null : n.sibling = null;
            break;
         case "collapsed":
            n = t.tail;
            for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
            r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null
      }
   }

   function Sr(t) {
      var e = t.alternate !== null && t.alternate.child === t.child,
         n = 0,
         r = 0;
      if (e)
         for (var i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling;
      else
         for (i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling;
      return t.subtreeFlags |= r, t.childLanes = n, e
   }

   function OG(t, e, n) {
      var r = e.pendingProps;
      switch (oM(e), e.tag) {
         case 2:
         case 16:
         case 15:
         case 0:
         case 11:
         case 7:
         case 8:
         case 12:
         case 9:
         case 14:
            return Sr(e), null;
         case 1:
            return ei(e.type) && M0(), Sr(e), null;
         case 3:
            return r = e.stateNode, af(), vn(qr), vn(Tr), mM(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (Om(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, hs !== null && (gA(hs), hs = null))), lA(t, e), Sr(e), null;
         case 5:
            pM(e);
            var i = Pl(Pd.current);
            if (n = e.type, t !== null && e.stateNode != null) QD(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
            else {
               if (!r) {
                  if (e.stateNode === null) throw Error(Re(166));
                  return Sr(e), null
               }
               if (t = Pl(Gs.current), Om(e)) {
                  r = e.stateNode, n = e.type;
                  var s = e.memoizedProps;
                  switch (r[Us] = e, r[Td] = s, t = (e.mode & 1) !== 0, n) {
                     case "dialog":
                        hn("cancel", r), hn("close", r);
                        break;
                     case "iframe":
                     case "object":
                     case "embed":
                        hn("load", r);
                        break;
                     case "video":
                     case "audio":
                        for (i = 0; i < Wh.length; i++) hn(Wh[i], r);
                        break;
                     case "source":
                        hn("error", r);
                        break;
                     case "img":
                     case "image":
                     case "link":
                        hn("error", r), hn("load", r);
                        break;
                     case "details":
                        hn("toggle", r);
                        break;
                     case "input":
                        OC(r, s), hn("invalid", r);
                        break;
                     case "select":
                        r._wrapperState = {
                           wasMultiple: !!s.multiple
                        }, hn("invalid", r);
                        break;
                     case "textarea":
                        UC(r, s), hn("invalid", r)
                  }
                  F1(n, s), i = null;
                  for (var o in s)
                     if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && Fm(r.textContent, a, t), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Fm(r.textContent, a, t), i = ["children", "" + a]) : yd.hasOwnProperty(o) && a != null && o === "onScroll" && hn("scroll", r)
                     } switch (n) {
                     case "input":
                        Cm(r), NC(r, s, !0);
                        break;
                     case "textarea":
                        Cm(r), kC(r);
                        break;
                     case "select":
                     case "option":
                        break;
                     default:
                        typeof s.onClick == "function" && (r.onclick = S0)
                  }
                  r = i, e.updateQueue = r, r !== null && (e.flags |= 4)
               } else {
                  o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = wL(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, {
                     is: r.is
                  }) : (t = o.createElement(n), n === "select" && (o = t, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n), t[Us] = e, t[Td] = r, YD(t, e, !1, !1), e.stateNode = t;
                  e: {
                     switch (o = O1(n, r), n) {
                        case "dialog":
                           hn("cancel", t), hn("close", t), i = r;
                           break;
                        case "iframe":
                        case "object":
                        case "embed":
                           hn("load", t), i = r;
                           break;
                        case "video":
                        case "audio":
                           for (i = 0; i < Wh.length; i++) hn(Wh[i], t);
                           i = r;
                           break;
                        case "source":
                           hn("error", t), i = r;
                           break;
                        case "img":
                        case "image":
                        case "link":
                           hn("error", t), hn("load", t), i = r;
                           break;
                        case "details":
                           hn("toggle", t), i = r;
                           break;
                        case "input":
                           OC(t, r), i = P1(t, r), hn("invalid", t);
                           break;
                        case "option":
                           i = r;
                           break;
                        case "select":
                           t._wrapperState = {
                              wasMultiple: !!r.multiple
                           }, i = Bn({}, r, {
                              value: void 0
                           }), hn("invalid", t);
                           break;
                        case "textarea":
                           UC(t, r), i = L1(t, r), hn("invalid", t);
                           break;
                        default:
                           i = r
                     }
                     F1(n, i),
                     a = i;
                     for (s in a)
                        if (a.hasOwnProperty(s)) {
                           var l = a[s];
                           s === "style" ? TL(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && bL(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && xd(t, l) : typeof l == "number" && xd(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (yd.hasOwnProperty(s) ? l != null && s === "onScroll" && hn("scroll", t) : l != null && jS(t, s, l, o))
                        } switch (n) {
                        case "input":
                           Cm(t), NC(t, r, !1);
                           break;
                        case "textarea":
                           Cm(t), kC(t);
                           break;
                        case "option":
                           r.value != null && t.setAttribute("value", "" + Ia(r.value));
                           break;
                        case "select":
                           t.multiple = !!r.multiple, s = r.value, s != null ? Wc(t, !!r.multiple, s, !1) : r.defaultValue != null && Wc(t, !!r.multiple, r.defaultValue, !0);
                           break;
                        default:
                           typeof i.onClick == "function" && (t.onclick = S0)
                     }
                     switch (n) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                           r = !!r.autoFocus;
                           break e;
                        case "img":
                           r = !0;
                           break e;
                        default:
                           r = !1
                     }
                  }
                  r && (e.flags |= 4)
               }
               e.ref !== null && (e.flags |= 512, e.flags |= 2097152)
            }
            return Sr(e), null;
         case 6:
            if (t && e.stateNode != null) ZD(t, e, t.memoizedProps, r);
            else {
               if (typeof r != "string" && e.stateNode === null) throw Error(Re(166));
               if (n = Pl(Pd.current), Pl(Gs.current), Om(e)) {
                  if (r = e.stateNode, n = e.memoizedProps, r[Us] = e, (s = r.nodeValue !== n) && (t = yi, t !== null)) switch (t.tag) {
                     case 3:
                        Fm(r.nodeValue, n, (t.mode & 1) !== 0);
                        break;
                     case 5:
                        t.memoizedProps.suppressHydrationWarning !== !0 && Fm(r.nodeValue, n, (t.mode & 1) !== 0)
                  }
                  s && (e.flags |= 4)
               } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Us] = e, e.stateNode = r
            }
            return Sr(e), null;
         case 13:
            if (vn(Cn), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
               if (Mn && pi !== null && e.mode & 1 && !(e.flags & 128)) mD(), sf(), e.flags |= 98560, s = !1;
               else if (s = Om(e), r !== null && r.dehydrated !== null) {
                  if (t === null) {
                     if (!s) throw Error(Re(318));
                     if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Re(317));
                     s[Us] = e
                  } else sf(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
                  Sr(e), s = !1
               } else hs !== null && (gA(hs), hs = null), s = !0;
               if (!s) return e.flags & 65536 ? e : null
            }
            return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || Cn.current & 1 ? qn === 0 && (qn = 3) : CM())), e.updateQueue !== null && (e.flags |= 4), Sr(e), null);
         case 4:
            return af(), lA(t, e), t === null && bd(e.stateNode.containerInfo), Sr(e), null;
         case 10:
            return cM(e.type._context), Sr(e), null;
         case 17:
            return ei(e.type) && M0(), Sr(e), null;
         case 19:
            if (vn(Cn), s = e.memoizedState, s === null) return Sr(e), null;
            if (r = (e.flags & 128) !== 0, o = s.rendering, o === null)
               if (r) ph(s, !1);
               else {
                  if (qn !== 0 || t !== null && t.flags & 128)
                     for (t = e.child; t !== null;) {
                        if (o = P0(t), o !== null) {
                           for (e.flags |= 128, ph(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;) s = n, t = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : {
                              lanes: t.lanes,
                              firstContext: t.firstContext
                           }), n = n.sibling;
                           return fn(Cn, Cn.current & 1 | 2), e.child
                        }
                        t = t.sibling
                     }
                  s.tail !== null && Gn() > uf && (e.flags |= 128, r = !0, ph(s, !1), e.lanes = 4194304)
               }
            else {
               if (!r)
                  if (t = P0(o), t !== null) {
                     if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), ph(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Mn) return Sr(e), null
                  } else 2 * Gn() - s.renderingStartTime > uf && n !== 1073741824 && (e.flags |= 128, r = !0, ph(s, !1), e.lanes = 4194304);
               s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o)
            }
            return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Gn(), e.sibling = null, n = Cn.current, fn(Cn, r ? n & 1 | 2 : n & 1), e) : (Sr(e), null);
         case 22:
         case 23:
            return bM(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? di & 1073741824 && (Sr(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Sr(e), null;
         case 24:
            return null;
         case 25:
            return null
      }
      throw Error(Re(156, e.tag))
   }

   function NG(t, e) {
      switch (oM(e), e.tag) {
         case 1:
            return ei(e.type) && M0(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
         case 3:
            return af(), vn(qr), vn(Tr), mM(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null;
         case 5:
            return pM(e), null;
         case 13:
            if (vn(Cn), t = e.memoizedState, t !== null && t.dehydrated !== null) {
               if (e.alternate === null) throw Error(Re(340));
               sf()
            }
            return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
         case 19:
            return vn(Cn), null;
         case 4:
            return af(), null;
         case 10:
            return cM(e.type._context), null;
         case 22:
         case 23:
            return bM(), null;
         case 24:
            return null;
         default:
            return null
      }
   }
   var km = !1,
      br = !1,
      UG = typeof WeakSet == "function" ? WeakSet : Set,
      Ze = null;

   function Dc(t, e) {
      var n = t.ref;
      if (n !== null)
         if (typeof n == "function") try {
            n(null)
         } catch (r) {
            Dn(t, e, r)
         } else n.current = null
   }

   function uA(t, e, n) {
      try {
         n()
      } catch (r) {
         Dn(t, e, r)
      }
   }
   var TT = !1;

   function kG(t, e) {
      if ($1 = x0, t = nD(), iM(t)) {
         if ("selectionStart" in t) var n = {
            start: t.selectionStart,
            end: t.selectionEnd
         };
         else e: {
            n = (n = t.ownerDocument) && n.defaultView || window;
            var r = n.getSelection && n.getSelection();
            if (r && r.rangeCount !== 0) {
               n = r.anchorNode;
               var i = r.anchorOffset,
                  s = r.focusNode;
               r = r.focusOffset;
               try {
                  n.nodeType, s.nodeType
               } catch {
                  n = null;
                  break e
               }
               var o = 0,
                  a = -1,
                  l = -1,
                  u = 0,
                  h = 0,
                  d = t,
                  p = null;
               t: for (;;) {
                  for (var m; d !== n || i !== 0 && d.nodeType !== 3 || (a = o + i), d !== s || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (m = d.firstChild) !== null;) p = d, d = m;
                  for (;;) {
                     if (d === t) break t;
                     if (p === n && ++u === i && (a = o), p === s && ++h === r && (l = o), (m = d.nextSibling) !== null) break;
                     d = p, p = d.parentNode
                  }
                  d = m
               }
               n = a === -1 || l === -1 ? null : {
                  start: a,
                  end: l
               }
            } else n = null
         }
         n = n || {
            start: 0,
            end: 0
         }
      } else n = null;
      for (X1 = {
            focusedElem: t,
            selectionRange: n
         }, x0 = !1, Ze = e; Ze !== null;)
         if (e = Ze, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, Ze = t;
         else
            for (; Ze !== null;) {
               e = Ze;
               try {
                  var v = e.alternate;
                  if (e.flags & 1024) switch (e.tag) {
                     case 0:
                     case 11:
                     case 15:
                        break;
                     case 1:
                        if (v !== null) {
                           var _ = v.memoizedProps,
                              x = v.memoizedState,
                              g = e.stateNode,
                              S = g.getSnapshotBeforeUpdate(e.elementType === e.type ? _ : us(e.type, _), x);
                           g.__reactInternalSnapshotBeforeUpdate = S
                        }
                        break;
                     case 3:
                        var A = e.stateNode.containerInfo;
                        A.nodeType === 1 ? A.textContent = "" : A.nodeType === 9 && A.documentElement && A.removeChild(A.documentElement);
                        break;
                     case 5:
                     case 6:
                     case 4:
                     case 17:
                        break;
                     default:
                        throw Error(Re(163))
                  }
               } catch (E) {
                  Dn(e, e.return, E)
               }
               if (t = e.sibling, t !== null) {
                  t.return = e.return, Ze = t;
                  break
               }
               Ze = e.return
            }
      return v = TT, TT = !1, v
   }

   function rd(t, e, n) {
      var r = e.updateQueue;
      if (r = r !== null ? r.lastEffect : null, r !== null) {
         var i = r = r.next;
         do {
            if ((i.tag & t) === t) {
               var s = i.destroy;
               i.destroy = void 0, s !== void 0 && uA(e, n, s)
            }
            i = i.next
         } while (i !== r)
      }
   }

   function xv(t, e) {
      if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
         var n = e = e.next;
         do {
            if ((n.tag & t) === t) {
               var r = n.create;
               n.destroy = r()
            }
            n = n.next
         } while (n !== e)
      }
   }

   function cA(t) {
      var e = t.ref;
      if (e !== null) {
         var n = t.stateNode;
         switch (t.tag) {
            case 5:
               t = n;
               break;
            default:
               t = n
         }
         typeof e == "function" ? e(t) : e.current = t
      }
   }

   function qD(t) {
      var e = t.alternate;
      e !== null && (t.alternate = null, qD(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[Us], delete e[Td], delete e[Y1], delete e[AG], delete e[SG])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null
   }

   function e3(t) {
      return t.tag === 5 || t.tag === 3 || t.tag === 4
   }

   function RT(t) {
      e: for (;;) {
         for (; t.sibling === null;) {
            if (t.return === null || e3(t.return)) return null;
            t = t.return
         }
         for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
            if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
            t.child.return = t, t = t.child
         }
         if (!(t.flags & 2)) return t.stateNode
      }
   }

   function fA(t, e, n) {
      var r = t.tag;
      if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = S0));
      else if (r !== 4 && (t = t.child, t !== null))
         for (fA(t, e, n), t = t.sibling; t !== null;) fA(t, e, n), t = t.sibling
   }

   function hA(t, e, n) {
      var r = t.tag;
      if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
      else if (r !== 4 && (t = t.child, t !== null))
         for (hA(t, e, n), t = t.sibling; t !== null;) hA(t, e, n), t = t.sibling
   }
   var fr = null,
      fs = !1;

   function Qo(t, e, n) {
      for (n = n.child; n !== null;) t3(t, e, n), n = n.sibling
   }

   function t3(t, e, n) {
      if (Hs && typeof Hs.onCommitFiberUnmount == "function") try {
         Hs.onCommitFiberUnmount(fv, n)
      } catch {}
      switch (n.tag) {
         case 5:
            br || Dc(n, e);
         case 6:
            var r = fr,
               i = fs;
            fr = null, Qo(t, e, n), fr = r, fs = i, fr !== null && (fs ? (t = fr, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : fr.removeChild(n.stateNode));
            break;
         case 18:
            fr !== null && (fs ? (t = fr, n = n.stateNode, t.nodeType === 8 ? $x(t.parentNode, n) : t.nodeType === 1 && $x(t, n), Md(t)) : $x(fr, n.stateNode));
            break;
         case 4:
            r = fr, i = fs, fr = n.stateNode.containerInfo, fs = !0, Qo(t, e, n), fr = r, fs = i;
            break;
         case 0:
         case 11:
         case 14:
         case 15:
            if (!br && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
               i = r = r.next;
               do {
                  var s = i,
                     o = s.destroy;
                  s = s.tag, o !== void 0 && (s & 2 || s & 4) && uA(n, e, o), i = i.next
               } while (i !== r)
            }
            Qo(t, e, n);
            break;
         case 1:
            if (!br && (Dc(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
               r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
            } catch (a) {
               Dn(n, e, a)
            }
            Qo(t, e, n);
            break;
         case 21:
            Qo(t, e, n);
            break;
         case 22:
            n.mode & 1 ? (br = (r = br) || n.memoizedState !== null, Qo(t, e, n), br = r) : Qo(t, e, n);
            break;
         default:
            Qo(t, e, n)
      }
   }

   function PT(t) {
      var e = t.updateQueue;
      if (e !== null) {
         t.updateQueue = null;
         var n = t.stateNode;
         n === null && (n = t.stateNode = new UG), e.forEach(function (r) {
            var i = JG.bind(null, t, r);
            n.has(r) || (n.add(r), r.then(i, i))
         })
      }
   }

   function ns(t, e) {
      var n = e.deletions;
      if (n !== null)
         for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
               var s = t,
                  o = e,
                  a = o;
               e: for (; a !== null;) {
                  switch (a.tag) {
                     case 5:
                        fr = a.stateNode, fs = !1;
                        break e;
                     case 3:
                        fr = a.stateNode.containerInfo, fs = !0;
                        break e;
                     case 4:
                        fr = a.stateNode.containerInfo, fs = !0;
                        break e
                  }
                  a = a.return
               }
               if (fr === null) throw Error(Re(160));
               t3(s, o, i), fr = null, fs = !1;
               var l = i.alternate;
               l !== null && (l.return = null), i.return = null
            } catch (u) {
               Dn(i, e, u)
            }
         }
      if (e.subtreeFlags & 12854)
         for (e = e.child; e !== null;) n3(e, t), e = e.sibling
   }

   function n3(t, e) {
      var n = t.alternate,
         r = t.flags;
      switch (t.tag) {
         case 0:
         case 11:
         case 14:
         case 15:
            if (ns(e, t), Ds(t), r & 4) {
               try {
                  rd(3, t, t.return), xv(3, t)
               } catch (_) {
                  Dn(t, t.return, _)
               }
               try {
                  rd(5, t, t.return)
               } catch (_) {
                  Dn(t, t.return, _)
               }
            }
            break;
         case 1:
            ns(e, t), Ds(t), r & 512 && n !== null && Dc(n, n.return);
            break;
         case 5:
            if (ns(e, t), Ds(t), r & 512 && n !== null && Dc(n, n.return), t.flags & 32) {
               var i = t.stateNode;
               try {
                  xd(i, "")
               } catch (_) {
                  Dn(t, t.return, _)
               }
            }
            if (r & 4 && (i = t.stateNode, i != null)) {
               var s = t.memoizedProps,
                  o = n !== null ? n.memoizedProps : s,
                  a = t.type,
                  l = t.updateQueue;
               if (t.updateQueue = null, l !== null) try {
                  a === "input" && s.type === "radio" && s.name != null && ML(i, s), O1(a, o);
                  var u = O1(a, s);
                  for (o = 0; o < l.length; o += 2) {
                     var h = l[o],
                        d = l[o + 1];
                     h === "style" ? TL(i, d) : h === "dangerouslySetInnerHTML" ? bL(i, d) : h === "children" ? xd(i, d) : jS(i, h, d, u)
                  }
                  switch (a) {
                     case "input":
                        B1(i, s);
                        break;
                     case "textarea":
                        EL(i, s);
                        break;
                     case "select":
                        var p = i._wrapperState.wasMultiple;
                        i._wrapperState.wasMultiple = !!s.multiple;
                        var m = s.value;
                        m != null ? Wc(i, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? Wc(i, !!s.multiple, s.defaultValue, !0) : Wc(i, !!s.multiple, s.multiple ? [] : "", !1))
                  }
                  i[Td] = s
               } catch (_) {
                  Dn(t, t.return, _)
               }
            }
            break;
         case 6:
            if (ns(e, t), Ds(t), r & 4) {
               if (t.stateNode === null) throw Error(Re(162));
               i = t.stateNode, s = t.memoizedProps;
               try {
                  i.nodeValue = s
               } catch (_) {
                  Dn(t, t.return, _)
               }
            }
            break;
         case 3:
            if (ns(e, t), Ds(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
               Md(e.containerInfo)
            } catch (_) {
               Dn(t, t.return, _)
            }
            break;
         case 4:
            ns(e, t), Ds(t);
            break;
         case 13:
            ns(e, t), Ds(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (EM = Gn())), r & 4 && PT(t);
            break;
         case 22:
            if (h = n !== null && n.memoizedState !== null, t.mode & 1 ? (br = (u = br) || h, ns(e, t), br = u) : ns(e, t), Ds(t), r & 8192) {
               if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !h && t.mode & 1)
                  for (Ze = t, h = t.child; h !== null;) {
                     for (d = Ze = h; Ze !== null;) {
                        switch (p = Ze, m = p.child, p.tag) {
                           case 0:
                           case 11:
                           case 14:
                           case 15:
                              rd(4, p, p.return);
                              break;
                           case 1:
                              Dc(p, p.return);
                              var v = p.stateNode;
                              if (typeof v.componentWillUnmount == "function") {
                                 r = p, n = p.return;
                                 try {
                                    e = r, v.props = e.memoizedProps, v.state = e.memoizedState, v.componentWillUnmount()
                                 } catch (_) {
                                    Dn(r, n, _)
                                 }
                              }
                              break;
                           case 5:
                              Dc(p, p.return);
                              break;
                           case 22:
                              if (p.memoizedState !== null) {
                                 IT(d);
                                 continue
                              }
                        }
                        m !== null ? (m.return = p, Ze = m) : IT(d)
                     }
                     h = h.sibling
                  }
               e: for (h = null, d = t;;) {
                  if (d.tag === 5) {
                     if (h === null) {
                        h = d;
                        try {
                           i = d.stateNode, u ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = CL("display", o))
                        } catch (_) {
                           Dn(t, t.return, _)
                        }
                     }
                  } else if (d.tag === 6) {
                     if (h === null) try {
                        d.stateNode.nodeValue = u ? "" : d.memoizedProps
                     } catch (_) {
                        Dn(t, t.return, _)
                     }
                  } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) {
                     d.child.return = d, d = d.child;
                     continue
                  }
                  if (d === t) break e;
                  for (; d.sibling === null;) {
                     if (d.return === null || d.return === t) break e;
                     h === d && (h = null), d = d.return
                  }
                  h === d && (h = null), d.sibling.return = d.return, d = d.sibling
               }
            }
            break;
         case 19:
            ns(e, t), Ds(t), r & 4 && PT(t);
            break;
         case 21:
            break;
         default:
            ns(e, t), Ds(t)
      }
   }

   function Ds(t) {
      var e = t.flags;
      if (e & 2) {
         try {
            e: {
               for (var n = t.return; n !== null;) {
                  if (e3(n)) {
                     var r = n;
                     break e
                  }
                  n = n.return
               }
               throw Error(Re(160))
            }
            switch (r.tag) {
               case 5:
                  var i = r.stateNode;
                  r.flags & 32 && (xd(i, ""), r.flags &= -33);
                  var s = RT(t);
                  hA(t, s, i);
                  break;
               case 3:
               case 4:
                  var o = r.stateNode.containerInfo,
                     a = RT(t);
                  fA(t, a, o);
                  break;
               default:
                  throw Error(Re(161))
            }
         }
         catch (l) {
            Dn(t, t.return, l)
         }
         t.flags &= -3
      }
      e & 4096 && (t.flags &= -4097)
   }

   function HG(t, e, n) {
      Ze = t, r3(t)
   }

   function r3(t, e, n) {
      for (var r = (t.mode & 1) !== 0; Ze !== null;) {
         var i = Ze,
            s = i.child;
         if (i.tag === 22 && r) {
            var o = i.memoizedState !== null || km;
            if (!o) {
               var a = i.alternate,
                  l = a !== null && a.memoizedState !== null || br;
               a = km;
               var u = br;
               if (km = o, (br = l) && !u)
                  for (Ze = i; Ze !== null;) o = Ze, l = o.child, o.tag === 22 && o.memoizedState !== null ? LT(i) : l !== null ? (l.return = o, Ze = l) : LT(i);
               for (; s !== null;) Ze = s, r3(s), s = s.sibling;
               Ze = i, km = a, br = u
            }
            BT(t)
         } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, Ze = s) : BT(t)
      }
   }

   function BT(t) {
      for (; Ze !== null;) {
         var e = Ze;
         if (e.flags & 8772) {
            var n = e.alternate;
            try {
               if (e.flags & 8772) switch (e.tag) {
                  case 0:
                  case 11:
                  case 15:
                     br || xv(5, e);
                     break;
                  case 1:
                     var r = e.stateNode;
                     if (e.flags & 4 && !br)
                        if (n === null) r.componentDidMount();
                        else {
                           var i = e.elementType === e.type ? n.memoizedProps : us(e.type, n.memoizedProps);
                           r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                        } var s = e.updateQueue;
                     s !== null && pT(e, s, r);
                     break;
                  case 3:
                     var o = e.updateQueue;
                     if (o !== null) {
                        if (n = null, e.child !== null) switch (e.child.tag) {
                           case 5:
                              n = e.child.stateNode;
                              break;
                           case 1:
                              n = e.child.stateNode
                        }
                        pT(e, o, n)
                     }
                     break;
                  case 5:
                     var a = e.stateNode;
                     if (n === null && e.flags & 4) {
                        n = a;
                        var l = e.memoizedProps;
                        switch (e.type) {
                           case "button":
                           case "input":
                           case "select":
                           case "textarea":
                              l.autoFocus && n.focus();
                              break;
                           case "img":
                              l.src && (n.src = l.src)
                        }
                     }
                     break;
                  case 6:
                     break;
                  case 4:
                     break;
                  case 12:
                     break;
                  case 13:
                     if (e.memoizedState === null) {
                        var u = e.alternate;
                        if (u !== null) {
                           var h = u.memoizedState;
                           if (h !== null) {
                              var d = h.dehydrated;
                              d !== null && Md(d)
                           }
                        }
                     }
                     break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                     break;
                  default:
                     throw Error(Re(163))
               }
               br || e.flags & 512 && cA(e)
            } catch (p) {
               Dn(e, e.return, p)
            }
         }
         if (e === t) {
            Ze = null;
            break
         }
         if (n = e.sibling, n !== null) {
            n.return = e.return, Ze = n;
            break
         }
         Ze = e.return
      }
   }

   function IT(t) {
      for (; Ze !== null;) {
         var e = Ze;
         if (e === t) {
            Ze = null;
            break
         }
         var n = e.sibling;
         if (n !== null) {
            n.return = e.return, Ze = n;
            break
         }
         Ze = e.return
      }
   }

   function LT(t) {
      for (; Ze !== null;) {
         var e = Ze;
         try {
            switch (e.tag) {
               case 0:
               case 11:
               case 15:
                  var n = e.return;
                  try {
                     xv(4, e)
                  } catch (l) {
                     Dn(e, n, l)
                  }
                  break;
               case 1:
                  var r = e.stateNode;
                  if (typeof r.componentDidMount == "function") {
                     var i = e.return;
                     try {
                        r.componentDidMount()
                     } catch (l) {
                        Dn(e, i, l)
                     }
                  }
                  var s = e.return;
                  try {
                     cA(e)
                  } catch (l) {
                     Dn(e, s, l)
                  }
                  break;
               case 5:
                  var o = e.return;
                  try {
                     cA(e)
                  } catch (l) {
                     Dn(e, o, l)
                  }
            }
         } catch (l) {
            Dn(e, e.return, l)
         }
         if (e === t) {
            Ze = null;
            break
         }
         var a = e.sibling;
         if (a !== null) {
            a.return = e.return, Ze = a;
            break
         }
         Ze = e.return
      }
   }
   var GG = Math.ceil,
      L0 = No.ReactCurrentDispatcher,
      SM = No.ReactCurrentOwner,
      Ji = No.ReactCurrentBatchConfig,
      Xt = 0,
      ur = null,
      $n = null,
      pr = 0,
      di = 0,
      Fc = Wa(0),
      qn = 0,
      Dd = null,
      Xl = 0,
      _v = 0,
      MM = 0,
      id = null,
      Kr = null,
      EM = 0,
      uf = 1 / 0,
      vo = null,
      D0 = !1,
      dA = null,
      Ma = null,
      Hm = !1,
      ga = null,
      F0 = 0,
      sd = 0,
      pA = null,
      qg = -1,
      e0 = 0;

   function Gr() {
      return Xt & 6 ? Gn() : qg !== -1 ? qg : qg = Gn()
   }

   function Ea(t) {
      return t.mode & 1 ? Xt & 2 && pr !== 0 ? pr & -pr : EG.transition !== null ? (e0 === 0 && (e0 = HL()), e0) : (t = rn, t !== 0 || (t = window.event, t = t === void 0 ? 16 : XL(t.type)), t) : 1
   }

   function gs(t, e, n, r) {
      if (50 < sd) throw sd = 0, pA = null, Error(Re(185));
      tp(t, n, r), (!(Xt & 2) || t !== ur) && (t === ur && (!(Xt & 2) && (_v |= n), qn === 4 && da(t, pr)), ti(t, r), n === 1 && Xt === 0 && !(e.mode & 1) && (uf = Gn() + 500, gv && ja()))
   }

   function ti(t, e) {
      var n = t.callbackNode;
      EH(t, e);
      var r = y0(t, t === ur ? pr : 0);
      if (r === 0) n !== null && zC(n), t.callbackNode = null, t.callbackPriority = 0;
      else if (e = r & -r, t.callbackPriority !== e) {
         if (n != null && zC(n), e === 1) t.tag === 0 ? MG(DT.bind(null, t)) : hD(DT.bind(null, t)), xG(function () {
            !(Xt & 6) && ja()
         }), n = null;
         else {
            switch (GL(r)) {
               case 1:
                  n = YS;
                  break;
               case 4:
                  n = UL;
                  break;
               case 16:
                  n = v0;
                  break;
               case 536870912:
                  n = kL;
                  break;
               default:
                  n = v0
            }
            n = f3(n, i3.bind(null, t))
         }
         t.callbackPriority = e, t.callbackNode = n
      }
   }

   function i3(t, e) {
      if (qg = -1, e0 = 0, Xt & 6) throw Error(Re(327));
      var n = t.callbackNode;
      if (Kc() && t.callbackNode !== n) return null;
      var r = y0(t, t === ur ? pr : 0);
      if (r === 0) return null;
      if (r & 30 || r & t.expiredLanes || e) e = O0(t, r);
      else {
         e = r;
         var i = Xt;
         Xt |= 2;
         var s = o3();
         (ur !== t || pr !== e) && (vo = null, uf = Gn() + 500, Ul(t, e));
         do try {
            WG();
            break
         } catch (a) {
            s3(t, a)
         }
         while (1);
         uM(), L0.current = s, Xt = i, $n !== null ? e = 0 : (ur = null, pr = 0, e = qn)
      }
      if (e !== 0) {
         if (e === 2 && (i = G1(t), i !== 0 && (r = i, e = mA(t, i))), e === 1) throw n = Dd, Ul(t, 0), da(t, r), ti(t, Gn()), n;
         if (e === 6) da(t, r);
         else {
            if (i = t.current.alternate, !(r & 30) && !zG(i) && (e = O0(t, r), e === 2 && (s = G1(t), s !== 0 && (r = s, e = mA(t, s))), e === 1)) throw n = Dd, Ul(t, 0), da(t, r), ti(t, Gn()), n;
            switch (t.finishedWork = i, t.finishedLanes = r, e) {
               case 0:
               case 1:
                  throw Error(Re(345));
               case 2:
                  _l(t, Kr, vo);
                  break;
               case 3:
                  if (da(t, r), (r & 130023424) === r && (e = EM + 500 - Gn(), 10 < e)) {
                     if (y0(t, 0) !== 0) break;
                     if (i = t.suspendedLanes, (i & r) !== r) {
                        Gr(), t.pingedLanes |= t.suspendedLanes & i;
                        break
                     }
                     t.timeoutHandle = K1(_l.bind(null, t, Kr, vo), e);
                     break
                  }
                  _l(t, Kr, vo);
                  break;
               case 4:
                  if (da(t, r), (r & 4194240) === r) break;
                  for (e = t.eventTimes, i = -1; 0 < r;) {
                     var o = 31 - ms(r);
                     s = 1 << o, o = e[o], o > i && (i = o), r &= ~s
                  }
                  if (r = i, r = Gn() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * GG(r / 1960)) - r, 10 < r) {
                     t.timeoutHandle = K1(_l.bind(null, t, Kr, vo), r);
                     break
                  }
                  _l(t, Kr, vo);
                  break;
               case 5:
                  _l(t, Kr, vo);
                  break;
               default:
                  throw Error(Re(329))
            }
         }
      }
      return ti(t, Gn()), t.callbackNode === n ? i3.bind(null, t) : null
   }

   function mA(t, e) {
      var n = id;
      return t.current.memoizedState.isDehydrated && (Ul(t, e).flags |= 256), t = O0(t, e), t !== 2 && (e = Kr, Kr = n, e !== null && gA(e)), t
   }

   function gA(t) {
      Kr === null ? Kr = t : Kr.push.apply(Kr, t)
   }

   function zG(t) {
      for (var e = t;;) {
         if (e.flags & 16384) {
            var n = e.updateQueue;
            if (n !== null && (n = n.stores, n !== null))
               for (var r = 0; r < n.length; r++) {
                  var i = n[r],
                     s = i.getSnapshot;
                  i = i.value;
                  try {
                     if (!vs(s(), i)) return !1
                  } catch {
                     return !1
                  }
               }
         }
         if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n;
         else {
            if (e === t) break;
            for (; e.sibling === null;) {
               if (e.return === null || e.return === t) return !0;
               e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
         }
      }
      return !0
   }

   function da(t, e) {
      for (e &= ~MM, e &= ~_v, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
         var n = 31 - ms(e),
            r = 1 << n;
         t[n] = -1, e &= ~r
      }
   }

   function DT(t) {
      if (Xt & 6) throw Error(Re(327));
      Kc();
      var e = y0(t, 0);
      if (!(e & 1)) return ti(t, Gn()), null;
      var n = O0(t, e);
      if (t.tag !== 0 && n === 2) {
         var r = G1(t);
         r !== 0 && (e = r, n = mA(t, r))
      }
      if (n === 1) throw n = Dd, Ul(t, 0), da(t, e), ti(t, Gn()), n;
      if (n === 6) throw Error(Re(345));
      return t.finishedWork = t.current.alternate, t.finishedLanes = e, _l(t, Kr, vo), ti(t, Gn()), null
   }

   function wM(t, e) {
      var n = Xt;
      Xt |= 1;
      try {
         return t(e)
      } finally {
         Xt = n, Xt === 0 && (uf = Gn() + 500, gv && ja())
      }
   }

   function Jl(t) {
      ga !== null && ga.tag === 0 && !(Xt & 6) && Kc();
      var e = Xt;
      Xt |= 1;
      var n = Ji.transition,
         r = rn;
      try {
         if (Ji.transition = null, rn = 1, t) return t()
      } finally {
         rn = r, Ji.transition = n, Xt = e, !(Xt & 6) && ja()
      }
   }

   function bM() {
      di = Fc.current, vn(Fc)
   }

   function Ul(t, e) {
      t.finishedWork = null, t.finishedLanes = 0;
      var n = t.timeoutHandle;
      if (n !== -1 && (t.timeoutHandle = -1, yG(n)), $n !== null)
         for (n = $n.return; n !== null;) {
            var r = n;
            switch (oM(r), r.tag) {
               case 1:
                  r = r.type.childContextTypes, r != null && M0();
                  break;
               case 3:
                  af(), vn(qr), vn(Tr), mM();
                  break;
               case 5:
                  pM(r);
                  break;
               case 4:
                  af();
                  break;
               case 13:
                  vn(Cn);
                  break;
               case 19:
                  vn(Cn);
                  break;
               case 10:
                  cM(r.type._context);
                  break;
               case 22:
               case 23:
                  bM()
            }
            n = n.return
         }
      if (ur = t, $n = t = wa(t.current, null), pr = di = e, qn = 0, Dd = null, MM = _v = Xl = 0, Kr = id = null, Rl !== null) {
         for (e = 0; e < Rl.length; e++)
            if (n = Rl[e], r = n.interleaved, r !== null) {
               n.interleaved = null;
               var i = r.next,
                  s = n.pending;
               if (s !== null) {
                  var o = s.next;
                  s.next = i, r.next = o
               }
               n.pending = r
            } Rl = null
      }
      return t
   }

   function s3(t, e) {
      do {
         var n = $n;
         try {
            if (uM(), Yg.current = I0, B0) {
               for (var r = Pn.memoizedState; r !== null;) {
                  var i = r.queue;
                  i !== null && (i.pending = null), r = r.next
               }
               B0 = !1
            }
            if ($l = 0, lr = Qn = Pn = null, nd = !1, Bd = 0, SM.current = null, n === null || n.return === null) {
               qn = 1, Dd = e, $n = null;
               break
            }
            e: {
               var s = t,
                  o = n.return,
                  a = n,
                  l = e;
               if (e = pr, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
                  var u = l,
                     h = a,
                     d = h.tag;
                  if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
                     var p = h.alternate;
                     p ? (h.updateQueue = p.updateQueue, h.memoizedState = p.memoizedState, h.lanes = p.lanes) : (h.updateQueue = null, h.memoizedState = null)
                  }
                  var m = AT(o);
                  if (m !== null) {
                     m.flags &= -257, ST(m, o, a, s, e), m.mode & 1 && _T(s, u, e), e = m, l = u;
                     var v = e.updateQueue;
                     if (v === null) {
                        var _ = new Set;
                        _.add(l), e.updateQueue = _
                     } else v.add(l);
                     break e
                  } else {
                     if (!(e & 1)) {
                        _T(s, u, e), CM();
                        break e
                     }
                     l = Error(Re(426))
                  }
               } else if (Mn && a.mode & 1) {
                  var x = AT(o);
                  if (x !== null) {
                     !(x.flags & 65536) && (x.flags |= 256), ST(x, o, a, s, e), aM(lf(l, a));
                     break e
                  }
               }
               s = l = lf(l, a),
               qn !== 4 && (qn = 2),
               id === null ? id = [s] : id.push(s),
               s = o;do {
                  switch (s.tag) {
                     case 3:
                        s.flags |= 65536, e &= -e, s.lanes |= e;
                        var g = zD(s, l, e);
                        dT(s, g);
                        break e;
                     case 1:
                        a = l;
                        var S = s.type,
                           A = s.stateNode;
                        if (!(s.flags & 128) && (typeof S.getDerivedStateFromError == "function" || A !== null && typeof A.componentDidCatch == "function" && (Ma === null || !Ma.has(A)))) {
                           s.flags |= 65536, e &= -e, s.lanes |= e;
                           var E = VD(s, a, e);
                           dT(s, E);
                           break e
                        }
                  }
                  s = s.return
               } while (s !== null)
            }
            l3(n)
         } catch (C) {
            e = C, $n === n && n !== null && ($n = n = n.return);
            continue
         }
         break
      } while (1)
   }

   function o3() {
      var t = L0.current;
      return L0.current = I0, t === null ? I0 : t
   }

   function CM() {
      (qn === 0 || qn === 3 || qn === 2) && (qn = 4), ur === null || !(Xl & 268435455) && !(_v & 268435455) || da(ur, pr)
   }

   function O0(t, e) {
      var n = Xt;
      Xt |= 2;
      var r = o3();
      (ur !== t || pr !== e) && (vo = null, Ul(t, e));
      do try {
         VG();
         break
      } catch (i) {
         s3(t, i)
      }
      while (1);
      if (uM(), Xt = n, L0.current = r, $n !== null) throw Error(Re(261));
      return ur = null, pr = 0, qn
   }

   function VG() {
      for (; $n !== null;) a3($n)
   }

   function WG() {
      for (; $n !== null && !mH();) a3($n)
   }

   function a3(t) {
      var e = c3(t.alternate, t, di);
      t.memoizedProps = t.pendingProps, e === null ? l3(t) : $n = e, SM.current = null
   }

   function l3(t) {
      var e = t;
      do {
         var n = e.alternate;
         if (t = e.return, e.flags & 32768) {
            if (n = NG(n, e), n !== null) {
               n.flags &= 32767, $n = n;
               return
            }
            if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
            else {
               qn = 6, $n = null;
               return
            }
         } else if (n = OG(n, e, di), n !== null) {
            $n = n;
            return
         }
         if (e = e.sibling, e !== null) {
            $n = e;
            return
         }
         $n = e = t
      } while (e !== null);
      qn === 0 && (qn = 5)
   }

   function _l(t, e, n) {
      var r = rn,
         i = Ji.transition;
      try {
         Ji.transition = null, rn = 1, jG(t, e, n, r)
      } finally {
         Ji.transition = i, rn = r
      }
      return null
   }

   function jG(t, e, n, r) {
      do Kc(); while (ga !== null);
      if (Xt & 6) throw Error(Re(327));
      n = t.finishedWork;
      var i = t.finishedLanes;
      if (n === null) return null;
      if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(Re(177));
      t.callbackNode = null, t.callbackPriority = 0;
      var s = n.lanes | n.childLanes;
      if (wH(t, s), t === ur && ($n = ur = null, pr = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Hm || (Hm = !0, f3(v0, function () {
            return Kc(), null
         })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) {
         s = Ji.transition, Ji.transition = null;
         var o = rn;
         rn = 1;
         var a = Xt;
         Xt |= 4, SM.current = null, kG(t, n), n3(n, t), fG(X1), x0 = !!$1, X1 = $1 = null, t.current = n, HG(n), gH(), Xt = a, rn = o, Ji.transition = s
      } else t.current = n;
      if (Hm && (Hm = !1, ga = t, F0 = i), s = t.pendingLanes, s === 0 && (Ma = null), xH(n.stateNode), ti(t, Gn()), e !== null)
         for (r = t.onRecoverableError, n = 0; n < e.length; n++) i = e[n], r(i.value, {
            componentStack: i.stack,
            digest: i.digest
         });
      if (D0) throw D0 = !1, t = dA, dA = null, t;
      return F0 & 1 && t.tag !== 0 && Kc(), s = t.pendingLanes, s & 1 ? t === pA ? sd++ : (sd = 0, pA = t) : sd = 0, ja(), null
   }

   function Kc() {
      if (ga !== null) {
         var t = GL(F0),
            e = Ji.transition,
            n = rn;
         try {
            if (Ji.transition = null, rn = 16 > t ? 16 : t, ga === null) var r = !1;
            else {
               if (t = ga, ga = null, F0 = 0, Xt & 6) throw Error(Re(331));
               var i = Xt;
               for (Xt |= 4, Ze = t.current; Ze !== null;) {
                  var s = Ze,
                     o = s.child;
                  if (Ze.flags & 16) {
                     var a = s.deletions;
                     if (a !== null) {
                        for (var l = 0; l < a.length; l++) {
                           var u = a[l];
                           for (Ze = u; Ze !== null;) {
                              var h = Ze;
                              switch (h.tag) {
                                 case 0:
                                 case 11:
                                 case 15:
                                    rd(8, h, s)
                              }
                              var d = h.child;
                              if (d !== null) d.return = h, Ze = d;
                              else
                                 for (; Ze !== null;) {
                                    h = Ze;
                                    var p = h.sibling,
                                       m = h.return;
                                    if (qD(h), h === u) {
                                       Ze = null;
                                       break
                                    }
                                    if (p !== null) {
                                       p.return = m, Ze = p;
                                       break
                                    }
                                    Ze = m
                                 }
                           }
                        }
                        var v = s.alternate;
                        if (v !== null) {
                           var _ = v.child;
                           if (_ !== null) {
                              v.child = null;
                              do {
                                 var x = _.sibling;
                                 _.sibling = null, _ = x
                              } while (_ !== null)
                           }
                        }
                        Ze = s
                     }
                  }
                  if (s.subtreeFlags & 2064 && o !== null) o.return = s, Ze = o;
                  else e: for (; Ze !== null;) {
                     if (s = Ze, s.flags & 2048) switch (s.tag) {
                        case 0:
                        case 11:
                        case 15:
                           rd(9, s, s.return)
                     }
                     var g = s.sibling;
                     if (g !== null) {
                        g.return = s.return, Ze = g;
                        break e
                     }
                     Ze = s.return
                  }
               }
               var S = t.current;
               for (Ze = S; Ze !== null;) {
                  o = Ze;
                  var A = o.child;
                  if (o.subtreeFlags & 2064 && A !== null) A.return = o, Ze = A;
                  else e: for (o = S; Ze !== null;) {
                     if (a = Ze, a.flags & 2048) try {
                        switch (a.tag) {
                           case 0:
                           case 11:
                           case 15:
                              xv(9, a)
                        }
                     } catch (C) {
                        Dn(a, a.return, C)
                     }
                     if (a === o) {
                        Ze = null;
                        break e
                     }
                     var E = a.sibling;
                     if (E !== null) {
                        E.return = a.return, Ze = E;
                        break e
                     }
                     Ze = a.return
                  }
               }
               if (Xt = i, ja(), Hs && typeof Hs.onPostCommitFiberRoot == "function") try {
                  Hs.onPostCommitFiberRoot(fv, t)
               } catch {}
               r = !0
            }
            return r
         } finally {
            rn = n, Ji.transition = e
         }
      }
      return !1
   }

   function FT(t, e, n) {
      e = lf(n, e), e = zD(t, e, 1), t = Sa(t, e, 1), e = Gr(), t !== null && (tp(t, 1, e), ti(t, e))
   }

   function Dn(t, e, n) {
      if (t.tag === 3) FT(t, t, n);
      else
         for (; e !== null;) {
            if (e.tag === 3) {
               FT(e, t, n);
               break
            } else if (e.tag === 1) {
               var r = e.stateNode;
               if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Ma === null || !Ma.has(r))) {
                  t = lf(n, t), t = VD(e, t, 1), e = Sa(e, t, 1), t = Gr(), e !== null && (tp(e, 1, t), ti(e, t));
                  break
               }
            }
            e = e.return
         }
   }

   function $G(t, e, n) {
      var r = t.pingCache;
      r !== null && r.delete(e), e = Gr(), t.pingedLanes |= t.suspendedLanes & n, ur === t && (pr & n) === n && (qn === 4 || qn === 3 && (pr & 130023424) === pr && 500 > Gn() - EM ? Ul(t, 0) : MM |= n), ti(t, e)
   }

   function u3(t, e) {
      e === 0 && (t.mode & 1 ? (e = Pm, Pm <<= 1, !(Pm & 130023424) && (Pm = 4194304)) : e = 1);
      var n = Gr();
      t = Lo(t, e), t !== null && (tp(t, e, n), ti(t, n))
   }

   function XG(t) {
      var e = t.memoizedState,
         n = 0;
      e !== null && (n = e.retryLane), u3(t, n)
   }

   function JG(t, e) {
      var n = 0;
      switch (t.tag) {
         case 13:
            var r = t.stateNode,
               i = t.memoizedState;
            i !== null && (n = i.retryLane);
            break;
         case 19:
            r = t.stateNode;
            break;
         default:
            throw Error(Re(314))
      }
      r !== null && r.delete(e), u3(t, n)
   }
   var c3;
   c3 = function (t, e, n) {
      if (t !== null)
         if (t.memoizedProps !== e.pendingProps || qr.current) Zr = !0;
         else {
            if (!(t.lanes & n) && !(e.flags & 128)) return Zr = !1, FG(t, e, n);
            Zr = !!(t.flags & 131072)
         }
      else Zr = !1, Mn && e.flags & 1048576 && dD(e, b0, e.index);
      switch (e.lanes = 0, e.tag) {
         case 2:
            var r = e.type;
            Zg(t, e), t = e.pendingProps;
            var i = rf(e, Tr.current);
            Jc(e, n), i = vM(null, e, r, t, i, n);
            var s = yM();
            return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, ei(r) ? (s = !0, E0(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, hM(e), i.updater = vv, e.stateNode = i, i._reactInternals = e, nA(e, r, t, n), e = sA(null, e, r, !0, s, n)) : (e.tag = 0, Mn && s && sM(e), Ur(null, e, i, n), e = e.child), e;
         case 16:
            r = e.elementType;
            e: {
               switch (Zg(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = YG(r), t = us(r, t), i) {
                  case 0:
                     e = iA(null, e, r, t, n);
                     break e;
                  case 1:
                     e = wT(null, e, r, t, n);
                     break e;
                  case 11:
                     e = MT(null, e, r, t, n);
                     break e;
                  case 14:
                     e = ET(null, e, r, us(r.type, t), n);
                     break e
               }
               throw Error(Re(306, r, ""))
            }
            return e;
         case 0:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : us(r, i), iA(t, e, r, i, n);
         case 1:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : us(r, i), wT(t, e, r, i, n);
         case 3:
            e: {
               if (XD(e), t === null) throw Error(Re(387));r = e.pendingProps,
               s = e.memoizedState,
               i = s.element,
               vD(t, e),
               R0(e, r, null, n);
               var o = e.memoizedState;
               if (r = o.element, s.isDehydrated)
                  if (s = {
                        element: r,
                        isDehydrated: !1,
                        cache: o.cache,
                        pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                        transitions: o.transitions
                     }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
                     i = lf(Error(Re(423)), e), e = bT(t, e, r, n, i);
                     break e
                  } else if (r !== i) {
                  i = lf(Error(Re(424)), e), e = bT(t, e, r, n, i);
                  break e
               } else
                  for (pi = Aa(e.stateNode.containerInfo.firstChild), yi = e, Mn = !0, hs = null, n = AD(e, null, r, n), e.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
               else {
                  if (sf(), r === i) {
                     e = Do(t, e, n);
                     break e
                  }
                  Ur(t, e, r, n)
               }
               e = e.child
            }
            return e;
         case 5:
            return SD(e), t === null && q1(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, J1(r, i) ? o = null : s !== null && J1(r, s) && (e.flags |= 32), $D(t, e), Ur(t, e, o, n), e.child;
         case 6:
            return t === null && q1(e), null;
         case 13:
            return JD(t, e, n);
         case 4:
            return dM(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = of (e, null, r, n) : Ur(t, e, r, n), e.child;
         case 11:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : us(r, i), MT(t, e, r, i, n);
         case 7:
            return Ur(t, e, e.pendingProps, n), e.child;
         case 8:
            return Ur(t, e, e.pendingProps.children, n), e.child;
         case 12:
            return Ur(t, e, e.pendingProps.children, n), e.child;
         case 10:
            e: {
               if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, fn(C0, r._currentValue), r._currentValue = o, s !== null)
                  if (vs(s.value, o)) {
                     if (s.children === i.children && !qr.current) {
                        e = Do(t, e, n);
                        break e
                     }
                  } else
                     for (s = e.child, s !== null && (s.return = e); s !== null;) {
                        var a = s.dependencies;
                        if (a !== null) {
                           o = s.child;
                           for (var l = a.firstContext; l !== null;) {
                              if (l.context === r) {
                                 if (s.tag === 1) {
                                    l = bo(-1, n & -n), l.tag = 2;
                                    var u = s.updateQueue;
                                    if (u !== null) {
                                       u = u.shared;
                                       var h = u.pending;
                                       h === null ? l.next = l : (l.next = h.next, h.next = l), u.pending = l
                                    }
                                 }
                                 s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), eA(s.return, n, e), a.lanes |= n;
                                 break
                              }
                              l = l.next
                           }
                        } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                           if (o = s.return, o === null) throw Error(Re(341));
                           o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), eA(o, n, e), o = s.sibling
                        } else o = s.child;
                        if (o !== null) o.return = s;
                        else
                           for (o = s; o !== null;) {
                              if (o === e) {
                                 o = null;
                                 break
                              }
                              if (s = o.sibling, s !== null) {
                                 s.return = o.return, o = s;
                                 break
                              }
                              o = o.return
                           }
                        s = o
                     }
               Ur(t, e, i.children, n),
               e = e.child
            }
            return e;
         case 9:
            return i = e.type, r = e.pendingProps.children, Jc(e, n), i = Ki(i), r = r(i), e.flags |= 1, Ur(t, e, r, n), e.child;
         case 14:
            return r = e.type, i = us(r, e.pendingProps), i = us(r.type, i), ET(t, e, r, i, n);
         case 15:
            return WD(t, e, e.type, e.pendingProps, n);
         case 17:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : us(r, i), Zg(t, e), e.tag = 1, ei(r) ? (t = !0, E0(e)) : t = !1, Jc(e, n), xD(e, r, i), nA(e, r, i, n), sA(null, e, r, !0, t, n);
         case 19:
            return KD(t, e, n);
         case 22:
            return jD(t, e, n)
      }
      throw Error(Re(156, e.tag))
   };

   function f3(t, e) {
      return NL(t, e)
   }

   function KG(t, e, n, r) {
      this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
   }

   function Xi(t, e, n, r) {
      return new KG(t, e, n, r)
   }

   function TM(t) {
      return t = t.prototype, !(!t || !t.isReactComponent)
   }

   function YG(t) {
      if (typeof t == "function") return TM(t) ? 1 : 0;
      if (t != null) {
         if (t = t.$$typeof, t === XS) return 11;
         if (t === JS) return 14
      }
      return 2
   }

   function wa(t, e) {
      var n = t.alternate;
      return n === null ? (n = Xi(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
         lanes: e.lanes,
         firstContext: e.firstContext
      }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n
   }

   function t0(t, e, n, r, i, s) {
      var o = 2;
      if (r = t, typeof t == "function") TM(t) && (o = 1);
      else if (typeof t == "string") o = 5;
      else e: switch (t) {
         case wc:
            return kl(n.children, i, s, e);
         case $S:
            o = 8, i |= 8;
            break;
         case b1:
            return t = Xi(12, n, e, i | 2), t.elementType = b1, t.lanes = s, t;
         case C1:
            return t = Xi(13, n, e, i), t.elementType = C1, t.lanes = s, t;
         case T1:
            return t = Xi(19, n, e, i), t.elementType = T1, t.lanes = s, t;
         case _L:
            return Av(n, i, s, e);
         default:
            if (typeof t == "object" && t !== null) switch (t.$$typeof) {
               case yL:
                  o = 10;
                  break e;
               case xL:
                  o = 9;
                  break e;
               case XS:
                  o = 11;
                  break e;
               case JS:
                  o = 14;
                  break e;
               case oa:
                  o = 16, r = null;
                  break e
            }
            throw Error(Re(130, t == null ? t : typeof t, ""))
      }
      return e = Xi(o, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e
   }

   function kl(t, e, n, r) {
      return t = Xi(7, t, r, e), t.lanes = n, t
   }

   function Av(t, e, n, r) {
      return t = Xi(22, t, r, e), t.elementType = _L, t.lanes = n, t.stateNode = {
         isHidden: !1
      }, t
   }

   function e_(t, e, n) {
      return t = Xi(6, t, null, e), t.lanes = n, t
   }

   function t_(t, e, n) {
      return e = Xi(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
         containerInfo: t.containerInfo,
         pendingChildren: null,
         implementation: t.implementation
      }, e
   }

   function QG(t, e, n, r, i) {
      this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Fx(0), this.expirationTimes = Fx(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Fx(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
   }

   function RM(t, e, n, r, i, s, o, a, l) {
      return t = new QG(t, e, n, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Xi(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = {
         element: r,
         isDehydrated: n,
         cache: null,
         transitions: null,
         pendingSuspenseBoundaries: null
      }, hM(s), t
   }

   function ZG(t, e, n) {
      var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
         $$typeof: Ec,
         key: r == null ? null : "" + r,
         children: t,
         containerInfo: e,
         implementation: n
      }
   }

   function h3(t) {
      if (!t) return La;
      t = t._reactInternals;
      e: {
         if (tu(t) !== t || t.tag !== 1) throw Error(Re(170));
         var e = t;do {
            switch (e.tag) {
               case 3:
                  e = e.stateNode.context;
                  break e;
               case 1:
                  if (ei(e.type)) {
                     e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                     break e
                  }
            }
            e = e.return
         } while (e !== null);
         throw Error(Re(171))
      }
      if (t.tag === 1) {
         var n = t.type;
         if (ei(n)) return fD(t, n, e)
      }
      return e
   }

   function d3(t, e, n, r, i, s, o, a, l) {
      return t = RM(n, r, !0, t, i, s, o, a, l), t.context = h3(null), n = t.current, r = Gr(), i = Ea(n), s = bo(r, i), s.callback = e ?? null, Sa(n, s, i), t.current.lanes = i, tp(t, i, r), ti(t, r), t
   }

   function Sv(t, e, n, r) {
      var i = e.current,
         s = Gr(),
         o = Ea(i);
      return n = h3(n), e.context === null ? e.context = n : e.pendingContext = n, e = bo(s, o), e.payload = {
         element: t
      }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Sa(i, e, o), t !== null && (gs(t, i, o, s), Kg(t, i, o)), o
   }

   function N0(t) {
      if (t = t.current, !t.child) return null;
      switch (t.child.tag) {
         case 5:
            return t.child.stateNode;
         default:
            return t.child.stateNode
      }
   }

   function OT(t, e) {
      if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
         var n = t.retryLane;
         t.retryLane = n !== 0 && n < e ? n : e
      }
   }

   function PM(t, e) {
      OT(t, e), (t = t.alternate) && OT(t, e)
   }

   function qG() {
      return null
   }
   var p3 = typeof reportError == "function" ? reportError : function (t) {
      console.error(t)
   };

   function BM(t) {
      this._internalRoot = t
   }
   Mv.prototype.render = BM.prototype.render = function (t) {
      var e = this._internalRoot;
      if (e === null) throw Error(Re(409));
      Sv(t, e, null, null)
   };
   Mv.prototype.unmount = BM.prototype.unmount = function () {
      var t = this._internalRoot;
      if (t !== null) {
         this._internalRoot = null;
         var e = t.containerInfo;
         Jl(function () {
            Sv(null, t, null, null)
         }), e[Io] = null
      }
   };

   function Mv(t) {
      this._internalRoot = t
   }
   Mv.prototype.unstable_scheduleHydration = function (t) {
      if (t) {
         var e = WL();
         t = {
            blockedOn: null,
            target: t,
            priority: e
         };
         for (var n = 0; n < ha.length && e !== 0 && e < ha[n].priority; n++);
         ha.splice(n, 0, t), n === 0 && $L(t)
      }
   };

   function IM(t) {
      return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
   }

   function Ev(t) {
      return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
   }

   function NT() {}

   function ez(t, e, n, r, i) {
      if (i) {
         if (typeof r == "function") {
            var s = r;
            r = function () {
               var u = N0(o);
               s.call(u)
            }
         }
         var o = d3(e, r, t, 0, null, !1, !1, "", NT);
         return t._reactRootContainer = o, t[Io] = o.current, bd(t.nodeType === 8 ? t.parentNode : t), Jl(), o
      }
      for (; i = t.lastChild;) t.removeChild(i);
      if (typeof r == "function") {
         var a = r;
         r = function () {
            var u = N0(l);
            a.call(u)
         }
      }
      var l = RM(t, 0, !1, null, null, !1, !1, "", NT);
      return t._reactRootContainer = l, t[Io] = l.current, bd(t.nodeType === 8 ? t.parentNode : t), Jl(function () {
         Sv(e, l, n, r)
      }), l
   }

   function wv(t, e, n, r, i) {
      var s = n._reactRootContainer;
      if (s) {
         var o = s;
         if (typeof i == "function") {
            var a = i;
            i = function () {
               var l = N0(o);
               a.call(l)
            }
         }
         Sv(e, o, t, i)
      } else o = ez(n, e, t, i, r);
      return N0(o)
   }
   zL = function (t) {
      switch (t.tag) {
         case 3:
            var e = t.stateNode;
            if (e.current.memoizedState.isDehydrated) {
               var n = Vh(e.pendingLanes);
               n !== 0 && (QS(e, n | 1), ti(e, Gn()), !(Xt & 6) && (uf = Gn() + 500, ja()))
            }
            break;
         case 13:
            Jl(function () {
               var r = Lo(t, 1);
               if (r !== null) {
                  var i = Gr();
                  gs(r, t, 1, i)
               }
            }), PM(t, 1)
      }
   };
   ZS = function (t) {
      if (t.tag === 13) {
         var e = Lo(t, 134217728);
         if (e !== null) {
            var n = Gr();
            gs(e, t, 134217728, n)
         }
         PM(t, 134217728)
      }
   };
   VL = function (t) {
      if (t.tag === 13) {
         var e = Ea(t),
            n = Lo(t, e);
         if (n !== null) {
            var r = Gr();
            gs(n, t, e, r)
         }
         PM(t, e)
      }
   };
   WL = function () {
      return rn
   };
   jL = function (t, e) {
      var n = rn;
      try {
         return rn = t, e()
      } finally {
         rn = n
      }
   };
   U1 = function (t, e, n) {
      switch (e) {
         case "input":
            if (B1(t, n), e = n.name, n.type === "radio" && e != null) {
               for (n = t; n.parentNode;) n = n.parentNode;
               for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
                  var r = n[e];
                  if (r !== t && r.form === t.form) {
                     var i = mv(r);
                     if (!i) throw Error(Re(90));
                     SL(r), B1(r, i)
                  }
               }
            }
            break;
         case "textarea":
            EL(t, n);
            break;
         case "select":
            e = n.value, e != null && Wc(t, !!n.multiple, e, !1)
      }
   };
   BL = wM;
   IL = Jl;
   var tz = {
         usingClientEntryPoint: !1,
         Events: [rp, Rc, mv, RL, PL, wM]
      },
      mh = {
         findFiberByHostInstance: Tl,
         bundleType: 0,
         version: "18.2.0",
         rendererPackageName: "react-dom"
      },
      nz = {
         bundleType: mh.bundleType,
         version: mh.version,
         rendererPackageName: mh.rendererPackageName,
         rendererConfig: mh.rendererConfig,
         overrideHookState: null,
         overrideHookStateDeletePath: null,
         overrideHookStateRenamePath: null,
         overrideProps: null,
         overridePropsDeletePath: null,
         overridePropsRenamePath: null,
         setErrorHandler: null,
         setSuspenseHandler: null,
         scheduleUpdate: null,
         currentDispatcherRef: No.ReactCurrentDispatcher,
         findHostInstanceByFiber: function (t) {
            return t = FL(t), t === null ? null : t.stateNode
         },
         findFiberByHostInstance: mh.findFiberByHostInstance || qG,
         findHostInstancesForRefresh: null,
         scheduleRefresh: null,
         scheduleRoot: null,
         setRefreshHandler: null,
         getCurrentFiber: null,
         reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
      };
   if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var Gm = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!Gm.isDisabled && Gm.supportsFiber) try {
         fv = Gm.inject(nz), Hs = Gm
      } catch {}
   }
   wi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tz;
   wi.createPortal = function (t, e) {
      var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!IM(e)) throw Error(Re(200));
      return ZG(t, e, null, n)
   };
   wi.createRoot = function (t, e) {
      if (!IM(t)) throw Error(Re(299));
      var n = !1,
         r = "",
         i = p3;
      return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = RM(t, 1, !1, null, null, n, !1, r, i), t[Io] = e.current, bd(t.nodeType === 8 ? t.parentNode : t), new BM(e)
   };
   wi.findDOMNode = function (t) {
      if (t == null) return null;
      if (t.nodeType === 1) return t;
      var e = t._reactInternals;
      if (e === void 0) throw typeof t.render == "function" ? Error(Re(188)) : (t = Object.keys(t).join(","), Error(Re(268, t)));
      return t = FL(e), t = t === null ? null : t.stateNode, t
   };
   wi.flushSync = function (t) {
      return Jl(t)
   };
   wi.hydrate = function (t, e, n) {
      if (!Ev(e)) throw Error(Re(200));
      return wv(null, t, e, !0, n)
   };
   wi.hydrateRoot = function (t, e, n) {
      if (!IM(t)) throw Error(Re(405));
      var r = n != null && n.hydratedSources || null,
         i = !1,
         s = "",
         o = p3;
      if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = d3(e, null, t, 1, n ?? null, i, !1, s, o), t[Io] = e.current, bd(t), r)
         for (t = 0; t < r.length; t++) n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i);
      return new Mv(e)
   };
   wi.render = function (t, e, n) {
      if (!Ev(e)) throw Error(Re(200));
      return wv(null, t, e, !1, n)
   };
   wi.unmountComponentAtNode = function (t) {
      if (!Ev(t)) throw Error(Re(40));
      return t._reactRootContainer ? (Jl(function () {
         wv(null, null, t, !1, function () {
            t._reactRootContainer = null, t[Io] = null
         })
      }), !0) : !1
   };
   wi.unstable_batchedUpdates = wM;
   wi.unstable_renderSubtreeIntoContainer = function (t, e, n, r) {
      if (!Ev(n)) throw Error(Re(200));
      if (t == null || t._reactInternals === void 0) throw Error(Re(38));
      return wv(t, e, n, !1, r)
   };
   wi.version = "18.2.0-next-9e3b772b8-20220608";

   function m3() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
         __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(m3)
      } catch (t) {
         console.error(t)
      }
   }
   m3(), dL.exports = wi;
   var rz = dL.exports,
      UT = rz;
   E1.createRoot = UT.createRoot, E1.hydrateRoot = UT.hydrateRoot;
   /**
    * @license
    * Copyright 2010-2023 Three.js Authors
    * SPDX-License-Identifier: MIT
    */
   const nu = "155",
      iz = {
         LEFT: 0,
         MIDDLE: 1,
         RIGHT: 2,
         ROTATE: 0,
         DOLLY: 1,
         PAN: 2
      },
      sz = {
         ROTATE: 0,
         PAN: 1,
         DOLLY_PAN: 2,
         DOLLY_ROTATE: 3
      },
      g3 = 0,
      vA = 1,
      v3 = 2,
      oz = 3,
      y3 = 0,
      bv = 1,
      od = 2,
      cs = 3,
      Js = 0,
      zr = 1,
      Wi = 2,
      az = 2,
      Co = 0,
      Hl = 1,
      yA = 2,
      xA = 3,
      _A = 4,
      x3 = 5,
      bl = 100,
      _3 = 101,
      A3 = 102,
      AA = 103,
      SA = 104,
      S3 = 200,
      M3 = 201,
      E3 = 202,
      w3 = 203,
      LM = 204,
      DM = 205,
      b3 = 206,
      C3 = 207,
      T3 = 208,
      R3 = 209,
      P3 = 210,
      B3 = 0,
      I3 = 1,
      L3 = 2,
      U0 = 3,
      D3 = 4,
      F3 = 5,
      O3 = 6,
      N3 = 7,
      sp = 0,
      U3 = 1,
      k3 = 2,
      zs = 0,
      H3 = 1,
      G3 = 2,
      z3 = 3,
      FM = 4,
      V3 = 5,
      Cv = 300,
      Ks = 301,
      Da = 302,
      cf = 303,
      Fd = 304,
      bf = 306,
      Fa = 1e3,
      hr = 1001,
      ff = 1002,
      Fn = 1003,
      Od = 1004,
      lz = 1004,
      Yc = 1005,
      uz = 1005,
      ln = 1006,
      Tv = 1007,
      cz = 1007,
      Ys = 1008,
      fz = 1008,
      Vs = 1009,
      W3 = 1010,
      j3 = 1011,
      Rv = 1012,
      OM = 1013,
      So = 1014,
      dr = 1015,
      Cr = 1016,
      NM = 1017,
      UM = 1018,
      ba = 1020,
      $3 = 1021,
      Hr = 1023,
      X3 = 1024,
      J3 = 1025,
      Ca = 1026,
      Kl = 1027,
      kM = 1028,
      HM = 1029,
      K3 = 1030,
      GM = 1031,
      zM = 1033,
      n0 = 33776,
      r0 = 33777,
      i0 = 33778,
      s0 = 33779,
      MA = 35840,
      EA = 35841,
      wA = 35842,
      bA = 35843,
      Y3 = 36196,
      CA = 37492,
      TA = 37496,
      RA = 37808,
      PA = 37809,
      BA = 37810,
      IA = 37811,
      LA = 37812,
      DA = 37813,
      FA = 37814,
      OA = 37815,
      NA = 37816,
      UA = 37817,
      kA = 37818,
      HA = 37819,
      GA = 37820,
      zA = 37821,
      o0 = 36492,
      Q3 = 36283,
      VA = 36284,
      WA = 36285,
      jA = 36286,
      Z3 = 2200,
      q3 = 2201,
      eF = 2202,
      hf = 2300,
      Yl = 2301,
      a0 = 2302,
      Bl = 2400,
      Il = 2401,
      Nd = 2402,
      Pv = 2500,
      VM = 2501,
      tF = 0,
      WM = 1,
      k0 = 2,
      jM = 3e3,
      Ta = 3001,
      nF = 3200,
      rF = 3201,
      $a = 0,
      iF = 1,
      Ra = "",
      Rt = "srgb",
      ys = "srgb-linear",
      $M = "display-p3",
      hz = 0,
      l0 = 7680,
      dz = 7681,
      pz = 7682,
      mz = 7683,
      gz = 34055,
      vz = 34056,
      yz = 5386,
      xz = 512,
      _z = 513,
      Az = 514,
      Sz = 515,
      Mz = 516,
      Ez = 517,
      wz = 518,
      sF = 519,
      oF = 512,
      aF = 513,
      lF = 514,
      uF = 515,
      cF = 516,
      fF = 517,
      hF = 518,
      dF = 519,
      Ud = 35044,
      bz = 35048,
      Cz = 35040,
      Tz = 35045,
      Rz = 35049,
      Pz = 35041,
      Bz = 35046,
      Iz = 35050,
      Lz = 35042,
      Dz = "100",
      $A = "300 es",
      H0 = 1035,
      ks = 2e3,
      kd = 2001;
   class Uo {
      addEventListener(e, n) {
         this._listeners === void 0 && (this._listeners = {});
         const r = this._listeners;
         r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n)
      }
      hasEventListener(e, n) {
         if (this._listeners === void 0) return !1;
         const r = this._listeners;
         return r[e] !== void 0 && r[e].indexOf(n) !== -1
      }
      removeEventListener(e, n) {
         if (this._listeners === void 0) return;
         const i = this._listeners[e];
         if (i !== void 0) {
            const s = i.indexOf(n);
            s !== -1 && i.splice(s, 1)
         }
      }
      dispatchEvent(e) {
         if (this._listeners === void 0) return;
         const r = this._listeners[e.type];
         if (r !== void 0) {
            e.target = this;
            const i = r.slice(0);
            for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
            e.target = null
         }
      }
   }
   const Mr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
   let kT = 1234567;
   const Gl = Math.PI / 180,
      df = 180 / Math.PI;

   function xi() {
      const t = Math.random() * 4294967295 | 0,
         e = Math.random() * 4294967295 | 0,
         n = Math.random() * 4294967295 | 0,
         r = Math.random() * 4294967295 | 0;
      return (Mr[t & 255] + Mr[t >> 8 & 255] + Mr[t >> 16 & 255] + Mr[t >> 24 & 255] + "-" + Mr[e & 255] + Mr[e >> 8 & 255] + "-" + Mr[e >> 16 & 15 | 64] + Mr[e >> 24 & 255] + "-" + Mr[n & 63 | 128] + Mr[n >> 8 & 255] + "-" + Mr[n >> 16 & 255] + Mr[n >> 24 & 255] + Mr[r & 255] + Mr[r >> 8 & 255] + Mr[r >> 16 & 255] + Mr[r >> 24 & 255]).toLowerCase()
   }

   function On(t, e, n) {
      return Math.max(e, Math.min(n, t))
   }

   function XM(t, e) {
      return (t % e + e) % e
   }

   function Fz(t, e, n, r, i) {
      return r + (t - e) * (i - r) / (n - e)
   }

   function Oz(t, e, n) {
      return t !== e ? (n - t) / (e - t) : 0
   }

   function ad(t, e, n) {
      return (1 - n) * t + n * e
   }

   function Nz(t, e, n, r) {
      return ad(t, e, 1 - Math.exp(-n * r))
   }

   function Uz(t, e = 1) {
      return e - Math.abs(XM(t, e * 2) - e)
   }

   function kz(t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t))
   }

   function Hz(t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (t * 6 - 15) + 10))
   }

   function Gz(t, e) {
      return t + Math.floor(Math.random() * (e - t + 1))
   }

   function zz(t, e) {
      return t + Math.random() * (e - t)
   }

   function Vz(t) {
      return t * (.5 - Math.random())
   }

   function Wz(t) {
      t !== void 0 && (kT = t);
      let e = kT += 1831565813;
      return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
   }

   function jz(t) {
      return t * Gl
   }

   function $z(t) {
      return t * df
   }

   function XA(t) {
      return (t & t - 1) === 0 && t !== 0
   }

   function pF(t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
   }

   function G0(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
   }

   function Xz(t, e, n, r, i) {
      const s = Math.cos,
         o = Math.sin,
         a = s(n / 2),
         l = o(n / 2),
         u = s((e + r) / 2),
         h = o((e + r) / 2),
         d = s((e - r) / 2),
         p = o((e - r) / 2),
         m = s((r - e) / 2),
         v = o((r - e) / 2);
      switch (i) {
         case "XYX":
            t.set(a * h, l * d, l * p, a * u);
            break;
         case "YZY":
            t.set(l * p, a * h, l * d, a * u);
            break;
         case "ZXZ":
            t.set(l * d, l * p, a * h, a * u);
            break;
         case "XZX":
            t.set(a * h, l * v, l * m, a * u);
            break;
         case "YXY":
            t.set(l * m, a * h, l * v, a * u);
            break;
         case "ZYZ":
            t.set(l * v, l * m, a * h, a * u);
            break;
         default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
      }
   }

   function Qr(t, e) {
      switch (e.constructor) {
         case Float32Array:
            return t;
         case Uint32Array:
            return t / 4294967295;
         case Uint16Array:
            return t / 65535;
         case Uint8Array:
            return t / 255;
         case Int32Array:
            return Math.max(t / 2147483647, -1);
         case Int16Array:
            return Math.max(t / 32767, -1);
         case Int8Array:
            return Math.max(t / 127, -1);
         default:
            throw new Error("Invalid component type.")
      }
   }

   function It(t, e) {
      switch (e.constructor) {
         case Float32Array:
            return t;
         case Uint32Array:
            return Math.round(t * 4294967295);
         case Uint16Array:
            return Math.round(t * 65535);
         case Uint8Array:
            return Math.round(t * 255);
         case Int32Array:
            return Math.round(t * 2147483647);
         case Int16Array:
            return Math.round(t * 32767);
         case Int8Array:
            return Math.round(t * 127);
         default:
            throw new Error("Invalid component type.")
      }
   }
   const Qc = {
      DEG2RAD: Gl,
      RAD2DEG: df,
      generateUUID: xi,
      clamp: On,
      euclideanModulo: XM,
      mapLinear: Fz,
      inverseLerp: Oz,
      lerp: ad,
      damp: Nz,
      pingpong: Uz,
      smoothstep: kz,
      smootherstep: Hz,
      randInt: Gz,
      randFloat: zz,
      randFloatSpread: Vz,
      seededRandom: Wz,
      degToRad: jz,
      radToDeg: $z,
      isPowerOfTwo: XA,
      ceilPowerOfTwo: pF,
      floorPowerOfTwo: G0,
      setQuaternionFromProperEuler: Xz,
      normalize: It,
      denormalize: Qr
   };
   class Se {
      constructor(e = 0, n = 0) {
         Se.prototype.isVector2 = !0, this.x = e, this.y = n
      }
      get width() {
         return this.x
      }
      set width(e) {
         this.x = e
      }
      get height() {
         return this.y
      }
      set height(e) {
         this.y = e
      }
      set(e, n) {
         return this.x = e, this.y = n, this
      }
      setScalar(e) {
         return this.x = e, this.y = e, this
      }
      setX(e) {
         return this.x = e, this
      }
      setY(e) {
         return this.y = e, this
      }
      setComponent(e, n) {
         switch (e) {
            case 0:
               this.x = n;
               break;
            case 1:
               this.y = n;
               break;
            default:
               throw new Error("index is out of range: " + e)
         }
         return this
      }
      getComponent(e) {
         switch (e) {
            case 0:
               return this.x;
            case 1:
               return this.y;
            default:
               throw new Error("index is out of range: " + e)
         }
      }
      clone() {
         return new this.constructor(this.x, this.y)
      }
      copy(e) {
         return this.x = e.x, this.y = e.y, this
      }
      add(e) {
         return this.x += e.x, this.y += e.y, this
      }
      addScalar(e) {
         return this.x += e, this.y += e, this
      }
      addVectors(e, n) {
         return this.x = e.x + n.x, this.y = e.y + n.y, this
      }
      addScaledVector(e, n) {
         return this.x += e.x * n, this.y += e.y * n, this
      }
      sub(e) {
         return this.x -= e.x, this.y -= e.y, this
      }
      subScalar(e) {
         return this.x -= e, this.y -= e, this
      }
      subVectors(e, n) {
         return this.x = e.x - n.x, this.y = e.y - n.y, this
      }
      multiply(e) {
         return this.x *= e.x, this.y *= e.y, this
      }
      multiplyScalar(e) {
         return this.x *= e, this.y *= e, this
      }
      divide(e) {
         return this.x /= e.x, this.y /= e.y, this
      }
      divideScalar(e) {
         return this.multiplyScalar(1 / e)
      }
      applyMatrix3(e) {
         const n = this.x,
            r = this.y,
            i = e.elements;
         return this.x = i[0] * n + i[3] * r + i[6], this.y = i[1] * n + i[4] * r + i[7], this
      }
      min(e) {
         return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
      }
      max(e) {
         return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
      }
      clamp(e, n) {
         return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this
      }
      clampScalar(e, n) {
         return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this
      }
      clampLength(e, n) {
         const r = this.length();
         return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
      }
      floor() {
         return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
      }
      ceil() {
         return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
      }
      round() {
         return this.x = Math.round(this.x), this.y = Math.round(this.y), this
      }
      roundToZero() {
         return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
      }
      negate() {
         return this.x = -this.x, this.y = -this.y, this
      }
      dot(e) {
         return this.x * e.x + this.y * e.y
      }
      cross(e) {
         return this.x * e.y - this.y * e.x
      }
      lengthSq() {
         return this.x * this.x + this.y * this.y
      }
      length() {
         return Math.sqrt(this.x * this.x + this.y * this.y)
      }
      manhattanLength() {
         return Math.abs(this.x) + Math.abs(this.y)
      }
      normalize() {
         return this.divideScalar(this.length() || 1)
      }
      angle() {
         return Math.atan2(-this.y, -this.x) + Math.PI
      }
      angleTo(e) {
         const n = Math.sqrt(this.lengthSq() * e.lengthSq());
         if (n === 0) return Math.PI / 2;
         const r = this.dot(e) / n;
         return Math.acos(On(r, -1, 1))
      }
      distanceTo(e) {
         return Math.sqrt(this.distanceToSquared(e))
      }
      distanceToSquared(e) {
         const n = this.x - e.x,
            r = this.y - e.y;
         return n * n + r * r
      }
      manhattanDistanceTo(e) {
         return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
      }
      setLength(e) {
         return this.normalize().multiplyScalar(e)
      }
      lerp(e, n) {
         return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this
      }
      lerpVectors(e, n, r) {
         return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this
      }
      equals(e) {
         return e.x === this.x && e.y === this.y
      }
      fromArray(e, n = 0) {
         return this.x = e[n], this.y = e[n + 1], this
      }
      toArray(e = [], n = 0) {
         return e[n] = this.x, e[n + 1] = this.y, e
      }
      fromBufferAttribute(e, n) {
         return this.x = e.getX(n), this.y = e.getY(n), this
      }
      rotateAround(e, n) {
         const r = Math.cos(n),
            i = Math.sin(n),
            s = this.x - e.x,
            o = this.y - e.y;
         return this.x = s * r - o * i + e.x, this.y = s * i + o * r + e.y, this
      }
      random() {
         return this.x = Math.random(), this.y = Math.random(), this
      }*[Symbol.iterator]() {
         yield this.x, yield this.y
      }
   }
   class Ft {
      constructor(e, n, r, i, s, o, a, l, u) {
         Ft.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, n, r, i, s, o, a, l, u)
      }
      set(e, n, r, i, s, o, a, l, u) {
         const h = this.elements;
         return h[0] = e, h[1] = i, h[2] = a, h[3] = n, h[4] = s, h[5] = l, h[6] = r, h[7] = o, h[8] = u, this
      }
      identity() {
         return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
      }
      copy(e) {
         const n = this.elements,
            r = e.elements;
         return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], this
      }
      extractBasis(e, n, r) {
         return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this
      }
      setFromMatrix4(e) {
         const n = e.elements;
         return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
      }
      multiply(e) {
         return this.multiplyMatrices(this, e)
      }
      premultiply(e) {
         return this.multiplyMatrices(e, this)
      }
      multiplyMatrices(e, n) {
         const r = e.elements,
            i = n.elements,
            s = this.elements,
            o = r[0],
            a = r[3],
            l = r[6],
            u = r[1],
            h = r[4],
            d = r[7],
            p = r[2],
            m = r[5],
            v = r[8],
            _ = i[0],
            x = i[3],
            g = i[6],
            S = i[1],
            A = i[4],
            E = i[7],
            C = i[2],
            R = i[5],
            B = i[8];
         return s[0] = o * _ + a * S + l * C, s[3] = o * x + a * A + l * R, s[6] = o * g + a * E + l * B, s[1] = u * _ + h * S + d * C, s[4] = u * x + h * A + d * R, s[7] = u * g + h * E + d * B, s[2] = p * _ + m * S + v * C, s[5] = p * x + m * A + v * R, s[8] = p * g + m * E + v * B, this
      }
      multiplyScalar(e) {
         const n = this.elements;
         return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this
      }
      determinant() {
         const e = this.elements,
            n = e[0],
            r = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            u = e[7],
            h = e[8];
         return n * o * h - n * a * u - r * s * h + r * a * l + i * s * u - i * o * l
      }
      invert() {
         const e = this.elements,
            n = e[0],
            r = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            u = e[7],
            h = e[8],
            d = h * o - a * u,
            p = a * l - h * s,
            m = u * s - o * l,
            v = n * d + r * p + i * m;
         if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
         const _ = 1 / v;
         return e[0] = d * _, e[1] = (i * u - h * r) * _, e[2] = (a * r - i * o) * _, e[3] = p * _, e[4] = (h * n - i * l) * _, e[5] = (i * s - a * n) * _, e[6] = m * _, e[7] = (r * l - u * n) * _, e[8] = (o * n - r * s) * _, this
      }
      transpose() {
         let e;
         const n = this.elements;
         return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this
      }
      getNormalMatrix(e) {
         return this.setFromMatrix4(e).invert().transpose()
      }
      transposeIntoArray(e) {
         const n = this.elements;
         return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this
      }
      setUvTransform(e, n, r, i, s, o, a) {
         const l = Math.cos(s),
            u = Math.sin(s);
         return this.set(r * l, r * u, -r * (l * o + u * a) + o + e, -i * u, i * l, -i * (-u * o + l * a) + a + n, 0, 0, 1), this
      }
      scale(e, n) {
         return this.premultiply(n_.makeScale(e, n)), this
      }
      rotate(e) {
         return this.premultiply(n_.makeRotation(-e)), this
      }
      translate(e, n) {
         return this.premultiply(n_.makeTranslation(e, n)), this
      }
      makeTranslation(e, n) {
         return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, n, 0, 0, 1), this
      }
      makeRotation(e) {
         const n = Math.cos(e),
            r = Math.sin(e);
         return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this
      }
      makeScale(e, n) {
         return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this
      }
      equals(e) {
         const n = this.elements,
            r = e.elements;
         for (let i = 0; i < 9; i++)
            if (n[i] !== r[i]) return !1;
         return !0
      }
      fromArray(e, n = 0) {
         for (let r = 0; r < 9; r++) this.elements[r] = e[r + n];
         return this
      }
      toArray(e = [], n = 0) {
         const r = this.elements;
         return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e
      }
      clone() {
         return new this.constructor().fromArray(this.elements)
      }
   }
   const n_ = new Ft;

   function mF(t) {
      for (let e = t.length - 1; e >= 0; --e)
         if (t[e] >= 65535) return !0;
      return !1
   }
   const Jz = {
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
   };

   function Oc(t, e) {
      return new Jz[t](e)
   }

   function Hd(t) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", t)
   }
   const HT = {};

   function ld(t) {
      t in HT || (HT[t] = !0, console.warn(t))
   }

   function Zc(t) {
      return t < .04045 ? t * .0773993808 : Math.pow(t * .9478672986 + .0521327014, 2.4)
   }

   function r_(t) {
      return t < .0031308 ? t * 12.92 : 1.055 * Math.pow(t, .41666) - .055
   }
   const Kz = new Ft().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]),
      Yz = new Ft().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]);

   function Qz(t) {
      return t.convertSRGBToLinear().applyMatrix3(Yz)
   }

   function Zz(t) {
      return t.applyMatrix3(Kz).convertLinearToSRGB()
   }
   const qz = {
         [ys]: t => t,
         [Rt]: t => t.convertSRGBToLinear(),
         [$M]: Qz
      },
      e5 = {
         [ys]: t => t,
         [Rt]: t => t.convertLinearToSRGB(),
         [$M]: Zz
      },
      ki = {
         enabled: !0,
         get legacyMode() {
            return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled
         },
         set legacyMode(t) {
            console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !t
         },
         get workingColorSpace() {
            return ys
         },
         set workingColorSpace(t) {
            console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
         },
         convert: function (t, e, n) {
            if (this.enabled === !1 || e === n || !e || !n) return t;
            const r = qz[e],
               i = e5[n];
            if (r === void 0 || i === void 0) throw new Error(`Unsupported color space conversion, "${e}" to "${n}".`);
            return i(r(t))
         },
         fromWorkingColorSpace: function (t, e) {
            return this.convert(t, this.workingColorSpace, e)
         },
         toWorkingColorSpace: function (t, e) {
            return this.convert(t, e, this.workingColorSpace)
         }
      };
   let Lu;
   class JM {
      static getDataURL(e) {
         if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
         let n;
         if (e instanceof HTMLCanvasElement) n = e;
         else {
            Lu === void 0 && (Lu = Hd("canvas")), Lu.width = e.width, Lu.height = e.height;
            const r = Lu.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), n = Lu
         }
         return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", .6)) : n.toDataURL("image/png")
      }
      static sRGBToLinear(e) {
         if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const n = Hd("canvas");
            n.width = e.width, n.height = e.height;
            const r = n.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const i = r.getImageData(0, 0, e.width, e.height),
               s = i.data;
            for (let o = 0; o < s.length; o++) s[o] = Zc(s[o] / 255) * 255;
            return r.putImageData(i, 0, 0), n
         } else if (e.data) {
            const n = e.data.slice(0);
            for (let r = 0; r < n.length; r++) n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[r] = Math.floor(Zc(n[r] / 255) * 255) : n[r] = Zc(n[r]);
            return {
               data: n,
               width: e.width,
               height: e.height
            }
         } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
      }
   }
   let t5 = 0;
   class Ll {
      constructor(e = null) {
         this.isSource = !0, Object.defineProperty(this, "id", {
            value: t5++
         }), this.uuid = xi(), this.data = e, this.version = 0
      }
      set needsUpdate(e) {
         e === !0 && this.version++
      }
      toJSON(e) {
         const n = e === void 0 || typeof e == "string";
         if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
         const r = {
               uuid: this.uuid,
               url: ""
            },
            i = this.data;
         if (i !== null) {
            let s;
            if (Array.isArray(i)) {
               s = [];
               for (let o = 0, a = i.length; o < a; o++) i[o].isDataTexture ? s.push(i_(i[o].image)) : s.push(i_(i[o]))
            } else s = i_(i);
            r.url = s
         }
         return n || (e.images[this.uuid] = r), r
      }
   }

   function i_(t) {
      return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? JM.getDataURL(t) : t.data ? {
         data: Array.from(t.data),
         width: t.width,
         height: t.height,
         type: t.data.constructor.name
      } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
   }
   let n5 = 0;
   class yn extends Uo {
      constructor(e = yn.DEFAULT_IMAGE, n = yn.DEFAULT_MAPPING, r = hr, i = hr, s = ln, o = Ys, a = Hr, l = Vs, u = yn.DEFAULT_ANISOTROPY, h = Ra) {
         super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: n5++
         }), this.uuid = xi(), this.name = "", this.source = new Ll(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = r, this.wrapT = i, this.magFilter = s, this.minFilter = o, this.anisotropy = u, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Se(0, 0), this.repeat = new Se(1, 1), this.center = new Se(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ft, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof h == "string" ? this.colorSpace = h : (ld("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = h === Ta ? Rt : Ra), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
      }
      get image() {
         return this.source.data
      }
      set image(e = null) {
         this.source.data = e
      }
      updateMatrix() {
         this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
      }
      clone() {
         return new this.constructor().copy(this)
      }
      copy(e) {
         return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
      }
      toJSON(e) {
         const n = e === void 0 || typeof e == "string";
         if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
         const r = {
            metadata: {
               version: 4.6,
               type: "Texture",
               generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
         };
         return Object.keys(this.userData).length > 0 && (r.userData = this.userData), n || (e.textures[this.uuid] = r), r
      }
      dispose() {
         this.dispatchEvent({
            type: "dispose"
         })
      }
      transformUv(e) {
         if (this.mapping !== Cv) return e;
         if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case Fa:
               e.x = e.x - Math.floor(e.x);
               break;
            case hr:
               e.x = e.x < 0 ? 0 : 1;
               break;
            case ff:
               Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
               break
         }
         if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case Fa:
               e.y = e.y - Math.floor(e.y);
               break;
            case hr:
               e.y = e.y < 0 ? 0 : 1;
               break;
            case ff:
               Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
               break
         }
         return this.flipY && (e.y = 1 - e.y), e
      }
      set needsUpdate(e) {
         e === !0 && (this.version++, this.source.needsUpdate = !0)
      }
      get encoding() {
         return ld("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Rt ? Ta : jM
      }
      set encoding(e) {
         ld("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Ta ? Rt : Ra
      }
   }
   yn.DEFAULT_IMAGE = null;
   yn.DEFAULT_MAPPING = Cv;
   yn.DEFAULT_ANISOTROPY = 1;
   class $t {
      constructor(e = 0, n = 0, r = 0, i = 1) {
         $t.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = r, this.w = i
      }
      get width() {
         return this.z
      }
      set width(e) {
         this.z = e
      }
      get height() {
         return this.w
      }
      set height(e) {
         this.w = e
      }
      set(e, n, r, i) {
         return this.x = e, this.y = n, this.z = r, this.w = i, this
      }
      setScalar(e) {
         return this.x = e, this.y = e, this.z = e, this.w = e, this
      }
      setX(e) {
         return this.x = e, this
      }
      setY(e) {
         return this.y = e, this
      }
      setZ(e) {
         return this.z = e, this
      }
      setW(e) {
         return this.w = e, this
      }
      setComponent(e, n) {
         switch (e) {
            case 0:
               this.x = n;
               break;
            case 1:
               this.y = n;
               break;
            case 2:
               this.z = n;
               break;
            case 3:
               this.w = n;
               break;
            default:
               throw new Error("index is out of range: " + e)
         }
         return this
      }
      getComponent(e) {
         switch (e) {
            case 0:
               return this.x;
            case 1:
               return this.y;
            case 2:
               return this.z;
            case 3:
               return this.w;
            default:
               throw new Error("index is out of range: " + e)
         }
      }
      clone() {
         return new this.constructor(this.x, this.y, this.z, this.w)
      }
      copy(e) {
         return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
      }
      add(e) {
         return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
      }
      addScalar(e) {
         return this.x += e, this.y += e, this.z += e, this.w += e, this
      }
      addVectors(e, n) {
         return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this
      }
      addScaledVector(e, n) {
         return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this
      }
      sub(e) {
         return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
      }
      subScalar(e) {
         return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
      }
      subVectors(e, n) {
         return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this
      }
      multiply(e) {
         return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
      }
      multiplyScalar(e) {
         return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
      }
      applyMatrix4(e) {
         const n = this.x,
            r = this.y,
            i = this.z,
            s = this.w,
            o = e.elements;
         return this.x = o[0] * n + o[4] * r + o[8] * i + o[12] * s, this.y = o[1] * n + o[5] * r + o[9] * i + o[13] * s, this.z = o[2] * n + o[6] * r + o[10] * i + o[14] * s, this.w = o[3] * n + o[7] * r + o[11] * i + o[15] * s, this
      }
      divideScalar(e) {
         return this.multiplyScalar(1 / e)
      }
      setAxisAngleFromQuaternion(e) {
         this.w = 2 * Math.acos(e.w);
         const n = Math.sqrt(1 - e.w * e.w);
         return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this
      }
      setAxisAngleFromRotationMatrix(e) {
         let n, r, i, s;
         const l = e.elements,
            u = l[0],
            h = l[4],
            d = l[8],
            p = l[1],
            m = l[5],
            v = l[9],
            _ = l[2],
            x = l[6],
            g = l[10];
         if (Math.abs(h - p) < .01 && Math.abs(d - _) < .01 && Math.abs(v - x) < .01) {
            if (Math.abs(h + p) < .1 && Math.abs(d + _) < .1 && Math.abs(v + x) < .1 && Math.abs(u + m + g - 3) < .1) return this.set(1, 0, 0, 0), this;
            n = Math.PI;
            const A = (u + 1) / 2,
               E = (m + 1) / 2,
               C = (g + 1) / 2,
               R = (h + p) / 4,
               B = (d + _) / 4,
               D = (v + x) / 4;
            return A > E && A > C ? A < .01 ? (r = 0, i = .707106781, s = .707106781) : (r = Math.sqrt(A), i = R / r, s = B / r) : E > C ? E < .01 ? (r = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(E), r = R / i, s = D / i) : C < .01 ? (r = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(C), r = B / s, i = D / s), this.set(r, i, s, n), this
         }
         let S = Math.sqrt((x - v) * (x - v) + (d - _) * (d - _) + (p - h) * (p - h));
         return Math.abs(S) < .001 && (S = 1), this.x = (x - v) / S, this.y = (d - _) / S, this.z = (p - h) / S, this.w = Math.acos((u + m + g - 1) / 2), this
      }
      min(e) {
         return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
      }
      max(e) {
         return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
      }
      clamp(e, n) {
         return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this
      }
      clampScalar(e, n) {
         return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this
      }
      clampLength(e, n) {
         const r = this.length();
         return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
      }
      floor() {
         return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
      }
      ceil() {
         return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
      }
      round() {
         return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
      }
      roundToZero() {
         return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
      }
      negate() {
         return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
      }
      dot(e) {
         return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
      }
      lengthSq() {
         return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      }
      length() {
         return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
      }
      manhattanLength() {
         return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
      }
      normalize() {
         return this.divideScalar(this.length() || 1)
      }
      setLength(e) {
         return this.normalize().multiplyScalar(e)
      }
      lerp(e, n) {
         return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this
      }
      lerpVectors(e, n, r) {
         return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this.w = e.w + (n.w - e.w) * r, this
      }
      equals(e) {
         return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
      }
      fromArray(e, n = 0) {
         return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this
      }
      toArray(e = [], n = 0) {
         return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e
      }
      fromBufferAttribute(e, n) {
         return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this
      }
      random() {
         return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
      }*[Symbol.iterator]() {
         yield this.x, yield this.y, yield this.z, yield this.w
      }
   }
   class gF extends Uo {
      constructor(e = 1, n = 1, r = {}) {
         super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new $t(0, 0, e, n), this.scissorTest = !1, this.viewport = new $t(0, 0, e, n);
         const i = {
            width: e,
            height: n,
            depth: 1
         };
         r.encoding !== void 0 && (ld("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), r.colorSpace = r.encoding === Ta ? Rt : Ra), this.texture = new yn(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : ln, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0
      }
      setSize(e, n, r = 1) {
         (this.width !== e || this.height !== n || this.depth !== r) && (this.width = e, this.height = n, this.depth = r, this.texture.image.width = e, this.texture.image.height = n, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n)
      }
      clone() {
         return new this.constructor().copy(this)
      }
      copy(e) {
         this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
         const n = Object.assign({}, e.texture.image);
         return this.texture.source = new Ll(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
      }
      dispose() {
         this.dispatchEvent({
            type: "dispose"
         })
      }
   }
   class Ai extends gF {
      constructor(e = 1, n = 1, r = {}) {
         super(e, n, r), this.isWebGLRenderTarget = !0
      }
   }
   class Bv extends yn {
      constructor(e = null, n = 1, r = 1, i = 1) {
         super(null), this.isDataArrayTexture = !0, this.image = {
            data: e,
            width: n,
            height: r,
            depth: i
         }, this.magFilter = Fn, this.minFilter = Fn, this.wrapR = hr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
      }
   }
   class r5 extends Ai {
      constructor(e = 1, n = 1, r = 1) {
         super(e, n), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new Bv(null, e, n, r), this.texture.isRenderTargetTexture = !0
      }
   }
   class KM extends yn {
      constructor(e = null, n = 1, r = 1, i = 1) {
         super(null), this.isData3DTexture = !0, this.image = {
            data: e,
            width: n,
            height: r,
            depth: i
         }, this.magFilter = Fn, this.minFilter = Fn, this.wrapR = hr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
      }
   }
   class i5 extends Ai {
      constructor(e = 1, n = 1, r = 1) {
         super(e, n), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new KM(null, e, n, r), this.texture.isRenderTargetTexture = !0
      }
   }
   class s5 extends Ai {
      constructor(e = 1, n = 1, r = 1, i = {}) {
         super(e, n, i), this.isWebGLMultipleRenderTargets = !0;
         const s = this.texture;
         this.texture = [];
         for (let o = 0; o < r; o++) this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0
      }
      setSize(e, n, r = 1) {
         if (this.width !== e || this.height !== n || this.depth !== r) {
            this.width = e, this.height = n, this.depth = r;
            for (let i = 0, s = this.texture.length; i < s; i++) this.texture[i].image.width = e, this.texture[i].image.height = n, this.texture[i].image.depth = r;
            this.dispose()
         }
         this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n)
      }
      copy(e) {
         this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
         for (let n = 0, r = e.texture.length; n < r; n++) this.texture[n] = e.texture[n].clone(), this.texture[n].isRenderTargetTexture = !0;
         return this
      }
   }
   class tr {
      constructor(e = 0, n = 0, r = 0, i = 1) {
         this.isQuaternion = !0, this._x = e, this._y = n, this._z = r, this._w = i
      }
      static slerpFlat(e, n, r, i, s, o, a) {
         let l = r[i + 0],
            u = r[i + 1],
            h = r[i + 2],
            d = r[i + 3];
         const p = s[o + 0],
            m = s[o + 1],
            v = s[o + 2],
            _ = s[o + 3];
         if (a === 0) {
            e[n + 0] = l, e[n + 1] = u, e[n + 2] = h, e[n + 3] = d;
            return
         }
         if (a === 1) {
            e[n + 0] = p, e[n + 1] = m, e[n + 2] = v, e[n + 3] = _;
            return
         }
         if (d !== _ || l !== p || u !== m || h !== v) {
            let x = 1 - a;
            const g = l * p + u * m + h * v + d * _,
               S = g >= 0 ? 1 : -1,
               A = 1 - g * g;
            if (A > Number.EPSILON) {
               const C = Math.sqrt(A),
                  R = Math.atan2(C, g * S);
               x = Math.sin(x * R) / C, a = Math.sin(a * R) / C
            }
            const E = a * S;
            if (l = l * x + p * E, u = u * x + m * E, h = h * x + v * E, d = d * x + _ * E, x === 1 - a) {
               const C = 1 / Math.sqrt(l * l + u * u + h * h + d * d);
               l *= C, u *= C, h *= C, d *= C
            }
         }
         e[n] = l, e[n + 1] = u, e[n + 2] = h, e[n + 3] = d
      }
      static multiplyQuaternionsFlat(e, n, r, i, s, o) {
         const a = r[i],
            l = r[i + 1],
            u = r[i + 2],
            h = r[i + 3],
            d = s[o],
            p = s[o + 1],
            m = s[o + 2],
            v = s[o + 3];
         return e[n] = a * v + h * d + l * m - u * p, e[n + 1] = l * v + h * p + u * d - a * m, e[n + 2] = u * v + h * m + a * p - l * d, e[n + 3] = h * v - a * d - l * p - u * m, e
      }
      get x() {
         return this._x
      }
      set x(e) {
         this._x = e, this._onChangeCallback()
      }
      get y() {
         return this._y
      }
      set y(e) {
         this._y = e, this._onChangeCallback()
      }
      get z() {
         return this._z
      }
      set z(e) {
         this._z = e, this._onChangeCallback()
      }
      get w() {
         return this._w
      }
      set w(e) {
         this._w = e, this._onChangeCallback()
      }
      set(e, n, r, i) {
         return this._x = e, this._y = n, this._z = r, this._w = i, this._onChangeCallback(), this
      }
      clone() {
         return new this.constructor(this._x, this._y, this._z, this._w)
      }
      copy(e) {
         return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
      }
      setFromEuler(e, n) {
         const r = e._x,
            i = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            u = a(r / 2),
            h = a(i / 2),
            d = a(s / 2),
            p = l(r / 2),
            m = l(i / 2),
            v = l(s / 2);
         switch (o) {
            case "XYZ":
               this._x = p * h * d + u * m * v, this._y = u * m * d - p * h * v, this._z = u * h * v + p * m * d, this._w = u * h * d - p * m * v;
               break;
            case "YXZ":
               this._x = p * h * d + u * m * v, this._y = u * m * d - p * h * v, this._z = u * h * v - p * m * d, this._w = u * h * d + p * m * v;
               break;
            case "ZXY":
               this._x = p * h * d - u * m * v, this._y = u * m * d + p * h * v, this._z = u * h * v + p * m * d, this._w = u * h * d - p * m * v;
               break;
            case "ZYX":
               this._x = p * h * d - u * m * v, this._y = u * m * d + p * h * v, this._z = u * h * v - p * m * d, this._w = u * h * d + p * m * v;
               break;
            case "YZX":
               this._x = p * h * d + u * m * v, this._y = u * m * d + p * h * v, this._z = u * h * v - p * m * d, this._w = u * h * d - p * m * v;
               break;
            case "XZY":
               this._x = p * h * d - u * m * v, this._y = u * m * d - p * h * v, this._z = u * h * v + p * m * d, this._w = u * h * d + p * m * v;
               break;
            default:
               console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
         }
         return n !== !1 && this._onChangeCallback(), this
      }
      setFromAxisAngle(e, n) {
         const r = n / 2,
            i = Math.sin(r);
         return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this
      }
      setFromRotationMatrix(e) {
         const n = e.elements,
            r = n[0],
            i = n[4],
            s = n[8],
            o = n[1],
            a = n[5],
            l = n[9],
            u = n[2],
            h = n[6],
            d = n[10],
            p = r + a + d;
         if (p > 0) {
            const m = .5 / Math.sqrt(p + 1);
            this._w = .25 / m, this._x = (h - l) * m, this._y = (s - u) * m, this._z = (o - i) * m
         } else if (r > a && r > d) {
            const m = 2 * Math.sqrt(1 + r - a - d);
            this._w = (h - l) / m, this._x = .25 * m, this._y = (i + o) / m, this._z = (s + u) / m
         } else if (a > d) {
            const m = 2 * Math.sqrt(1 + a - r - d);
            this._w = (s - u) / m, this._x = (i + o) / m, this._y = .25 * m, this._z = (l + h) / m
         } else {
            const m = 2 * Math.sqrt(1 + d - r - a);
            this._w = (o - i) / m, this._x = (s + u) / m, this._y = (l + h) / m, this._z = .25 * m
         }
         return this._onChangeCallback(), this
      }
      setFromUnitVectors(e, n) {
         let r = e.dot(n) + 1;
         return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = r), this.normalize()
      }
      angleTo(e) {
         return 2 * Math.acos(Math.abs(On(this.dot(e), -1, 1)))
      }
      rotateTowards(e, n) {
         const r = this.angleTo(e);
         if (r === 0) return this;
         const i = Math.min(1, n / r);
         return this.slerp(e, i), this
      }
      identity() {
         return this.set(0, 0, 0, 1)
      }
      invert() {
         return this.conjugate()
      }
      conjugate() {
         return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
      }
      dot(e) {
         return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
      }
      lengthSq() {
         return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
      }
      length() {
         return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
      }
      normalize() {
         let e = this.length();
         return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
      }
      multiply(e) {
         return this.multiplyQuaternions(this, e)
      }
      premultiply(e) {
         return this.multiplyQuaternions(e, this)
      }
      multiplyQuaternions(e, n) {
         const r = e._x,
            i = e._y,
            s = e._z,
            o = e._w,
            a = n._x,
            l = n._y,
            u = n._z,
            h = n._w;
         return this._x = r * h + o * a + i * u - s * l, this._y = i * h + o * l + s * a - r * u, this._z = s * h + o * u + r * l - i * a, this._w = o * h - r * a - i * l - s * u, this._onChangeCallback(), this
      }
      slerp(e, n) {
         if (n === 0) return this;
         if (n === 1) return this.copy(e);
         const r = this._x,
            i = this._y,
            s = this._z,
            o = this._w;
         let a = o * e._w + r * e._x + i * e._y + s * e._z;
         if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = r, this._y = i, this._z = s, this;
         const l = 1 - a * a;
         if (l <= Number.EPSILON) {
            const m = 1 - n;
            return this._w = m * o + n * this._w, this._x = m * r + n * this._x, this._y = m * i + n * this._y, this._z = m * s + n * this._z, this.normalize(), this._onChangeCallback(), this
         }
         const u = Math.sqrt(l),
            h = Math.atan2(u, a),
            d = Math.sin((1 - n) * h) / u,
            p = Math.sin(n * h) / u;
         return this._w = o * d + this._w * p, this._x = r * d + this._x * p, this._y = i * d + this._y * p, this._z = s * d + this._z * p, this._onChangeCallback(), this
      }
      slerpQuaternions(e, n, r) {
         return this.copy(e).slerp(n, r)
      }
      random() {
         const e = Math.random(),
            n = Math.sqrt(1 - e),
            r = Math.sqrt(e),
            i = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
         return this.set(n * Math.cos(i), r * Math.sin(s), r * Math.cos(s), n * Math.sin(i))
      }
      equals(e) {
         return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
      }
      fromArray(e, n = 0) {
         return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this
      }
      toArray(e = [], n = 0) {
         return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e
      }
      fromBufferAttribute(e, n) {
         return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this
      }
      toJSON() {
         return this.toArray()
      }
      _onChange(e) {
         return this._onChangeCallback = e, this
      }
      _onChangeCallback() {}*[Symbol.iterator]() {
         yield this._x, yield this._y, yield this._z, yield this._w
      }
   }
   class U {
      constructor(e = 0, n = 0, r = 0) {
         U.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = r
      }
      set(e, n, r) {
         return r === void 0 && (r = this.z), this.x = e, this.y = n, this.z = r, this
      }
      setScalar(e) {
         return this.x = e, this.y = e, this.z = e, this
      }
      setX(e) {
         return this.x = e, this
      }
      setY(e) {
         return this.y = e, this
      }
      setZ(e) {
         return this.z = e, this
      }
      setComponent(e, n) {
         switch (e) {
            case 0:
               this.x = n;
               break;
            case 1:
               this.y = n;
               break;
            case 2:
               this.z = n;
               break;
            default:
               throw new Error("index is out of range: " + e)
         }
         return this
      }
      getComponent(e) {
         switch (e) {
            case 0:
               return this.x;
            case 1:
               return this.y;
            case 2:
               return this.z;
            default:
               throw new Error("index is out of range: " + e)
         }
      }
      clone() {
         return new this.constructor(this.x, this.y, this.z)
      }
      copy(e) {
         return this.x = e.x, this.y = e.y, this.z = e.z, this
      }
      add(e) {
         return this.x += e.x, this.y += e.y, this.z += e.z, this
      }
      addScalar(e) {
         return this.x += e, this.y += e, this.z += e, this
      }
      addVectors(e, n) {
         return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this
      }
      addScaledVector(e, n) {
         return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this
      }
      sub(e) {
         return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
      }
      subScalar(e) {
         return this.x -= e, this.y -= e, this.z -= e, this
      }
      subVectors(e, n) {
         return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this
      }
      multiply(e) {
         return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
      }
      multiplyScalar(e) {
         return this.x *= e, this.y *= e, this.z *= e, this
      }
      multiplyVectors(e, n) {
         return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this
      }
      applyEuler(e) {
         return this.applyQuaternion(GT.setFromEuler(e))
      }
      applyAxisAngle(e, n) {
         return this.applyQuaternion(GT.setFromAxisAngle(e, n))
      }
      applyMatrix3(e) {
         const n = this.x,
            r = this.y,
            i = this.z,
            s = e.elements;
         return this.x = s[0] * n + s[3] * r + s[6] * i, this.y = s[1] * n + s[4] * r + s[7] * i, this.z = s[2] * n + s[5] * r + s[8] * i, this
      }
      applyNormalMatrix(e) {
         return this.applyMatrix3(e).normalize()
      }
      applyMatrix4(e) {
         const n = this.x,
            r = this.y,
            i = this.z,
            s = e.elements,
            o = 1 / (s[3] * n + s[7] * r + s[11] * i + s[15]);
         return this.x = (s[0] * n + s[4] * r + s[8] * i + s[12]) * o, this.y = (s[1] * n + s[5] * r + s[9] * i + s[13]) * o, this.z = (s[2] * n + s[6] * r + s[10] * i + s[14]) * o, this
      }
      applyQuaternion(e) {
         const n = this.x,
            r = this.y,
            i = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            u = l * n + o * i - a * r,
            h = l * r + a * n - s * i,
            d = l * i + s * r - o * n,
            p = -s * n - o * r - a * i;
         return this.x = u * l + p * -s + h * -a - d * -o, this.y = h * l + p * -o + d * -s - u * -a, this.z = d * l + p * -a + u * -o - h * -s, this
      }
      project(e) {
         return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
      }
      unproject(e) {
         return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
      }
      transformDirection(e) {
         const n = this.x,
            r = this.y,
            i = this.z,
            s = e.elements;
         return this.x = s[0] * n + s[4] * r + s[8] * i, this.y = s[1] * n + s[5] * r + s[9] * i, this.z = s[2] * n + s[6] * r + s[10] * i, this.normalize()
      }
      divide(e) {
         return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
      }
      divideScalar(e) {
         return this.multiplyScalar(1 / e)
      }
      min(e) {
         return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
      }
      max(e) {
         return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
      }
      clamp(e, n) {
         return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this
      }
      clampScalar(e, n) {
         return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this
      }
      clampLength(e, n) {
         const r = this.length();
         return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
      }
      floor() {
         return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
      }
      ceil() {
         return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
      }
      round() {
         return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
      }
      roundToZero() {
         return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
      }
      negate() {
         return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
      }
      dot(e) {
         return this.x * e.x + this.y * e.y + this.z * e.z
      }
      lengthSq() {
         return this.x * this.x + this.y * this.y + this.z * this.z
      }
      length() {
         return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
      }
      manhattanLength() {
         return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
      }
      normalize() {
         return this.divideScalar(this.length() || 1)
      }
      setLength(e) {
         return this.normalize().multiplyScalar(e)
      }
      lerp(e, n) {
         return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this
      }
      lerpVectors(e, n, r) {
         return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this
      }
      cross(e) {
         return this.crossVectors(this, e)
      }
      crossVectors(e, n) {
         const r = e.x,
            i = e.y,
            s = e.z,
            o = n.x,
            a = n.y,
            l = n.z;
         return this.x = i * l - s * a, this.y = s * o - r * l, this.z = r * a - i * o, this
      }
      projectOnVector(e) {
         const n = e.lengthSq();
         if (n === 0) return this.set(0, 0, 0);
         const r = e.dot(this) / n;
         return this.copy(e).multiplyScalar(r)
      }
      projectOnPlane(e) {
         return s_.copy(this).projectOnVector(e), this.sub(s_)
      }
      reflect(e) {
         return this.sub(s_.copy(e).multiplyScalar(2 * this.dot(e)))
      }
      angleTo(e) {
         const n = Math.sqrt(this.lengthSq() * e.lengthSq());
         if (n === 0) return Math.PI / 2;
         const r = this.dot(e) / n;
         return Math.acos(On(r, -1, 1))
      }
      distanceTo(e) {
         return Math.sqrt(this.distanceToSquared(e))
      }
      distanceToSquared(e) {
         const n = this.x - e.x,
            r = this.y - e.y,
            i = this.z - e.z;
         return n * n + r * r + i * i
      }
      manhattanDistanceTo(e) {
         return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
      }
      setFromSpherical(e) {
         return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
      }
      setFromSphericalCoords(e, n, r) {
         const i = Math.sin(n) * e;
         return this.x = i * Math.sin(r), this.y = Math.cos(n) * e, this.z = i * Math.cos(r), this
      }
      setFromCylindrical(e) {
         return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
      }
      setFromCylindricalCoords(e, n, r) {
         return this.x = e * Math.sin(n), this.y = r, this.z = e * Math.cos(n), this
      }
      setFromMatrixPosition(e) {
         const n = e.elements;
         return this.x = n[12], this.y = n[13], this.z = n[14], this
      }
      setFromMatrixScale(e) {
         const n = this.setFromMatrixColumn(e, 0).length(),
            r = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
         return this.x = n, this.y = r, this.z = i, this
      }
      setFromMatrixColumn(e, n) {
         return this.fromArray(e.elements, n * 4)
      }
      setFromMatrix3Column(e, n) {
         return this.fromArray(e.elements, n * 3)
      }
      setFromEuler(e) {
         return this.x = e._x, this.y = e._y, this.z = e._z, this
      }
      setFromColor(e) {
         return this.x = e.r, this.y = e.g, this.z = e.b, this
      }
      equals(e) {
         return e.x === this.x && e.y === this.y && e.z === this.z
      }
      fromArray(e, n = 0) {
         return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this
      }
      toArray(e = [], n = 0) {
         return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e
      }
      fromBufferAttribute(e, n) {
         return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this
      }
      random() {
         return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
      }
      randomDirection() {
         const e = (Math.random() - .5) * 2,
            n = Math.random() * Math.PI * 2,
            r = Math.sqrt(1 - e ** 2);
         return this.x = r * Math.cos(n), this.y = r * Math.sin(n), this.z = e, this
      }*[Symbol.iterator]() {
         yield this.x, yield this.y, yield this.z
      }
   }
   const s_ = new U,
      GT = new tr;
   class qi {
      constructor(e = new U(1 / 0, 1 / 0, 1 / 0), n = new U(-1 / 0, -1 / 0, -1 / 0)) {
         this.isBox3 = !0, this.min = e, this.max = n
      }
      set(e, n) {
         return this.min.copy(e), this.max.copy(n), this
      }
      setFromArray(e) {
         this.makeEmpty();
         for (let n = 0, r = e.length; n < r; n += 3) this.expandByPoint(lo.fromArray(e, n));
         return this
      }
      setFromBufferAttribute(e) {
         this.makeEmpty();
         for (let n = 0, r = e.count; n < r; n++) this.expandByPoint(lo.fromBufferAttribute(e, n));
         return this
      }
      setFromPoints(e) {
         this.makeEmpty();
         for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
         return this
      }
      setFromCenterAndSize(e, n) {
         const r = lo.copy(n).multiplyScalar(.5);
         return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
      }
      setFromObject(e, n = !1) {
         return this.makeEmpty(), this.expandByObject(e, n)
      }
      clone() {
         return new this.constructor().copy(this)
      }
      copy(e) {
         return this.min.copy(e.min), this.max.copy(e.max), this
      }
      makeEmpty() {
         return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
      }
      isEmpty() {
         return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
      }
      getCenter(e) {
         return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
      }
      getSize(e) {
         return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
      }
      expandByPoint(e) {
         return this.min.min(e), this.max.max(e), this
      }
      expandByVector(e) {
         return this.min.sub(e), this.max.add(e), this
      }
      expandByScalar(e) {
         return this.min.addScalar(-e), this.max.addScalar(e), this
      }
      expandByObject(e, n = !1) {
         if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0) e.boundingBox === null && e.computeBoundingBox(), Du.copy(e.boundingBox), Du.applyMatrix4(e.matrixWorld), this.union(Du);
         else {
            const i = e.geometry;
            if (i !== void 0)
               if (n && i.attributes !== void 0 && i.attributes.position !== void 0) {
                  const s = i.attributes.position;
                  for (let o = 0, a = s.count; o < a; o++) lo.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(lo)
               } else i.boundingBox === null && i.computeBoundingBox(), Du.copy(i.boundingBox), Du.applyMatrix4(e.matrixWorld), this.union(Du)
         }
         const r = e.children;
         for (let i = 0, s = r.length; i < s; i++) this.expandByObject(r[i], n);
         return this
      }
      containsPoint(e) {
         return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
      }
      containsBox(e) {
         return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
      }
      getParameter(e, n) {
         return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
      }
      intersectsBox(e) {
         return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
      }
      intersectsSphere(e) {
         return this.clampPoint(e.center, lo), lo.distanceToSquared(e.center) <= e.radius * e.radius
      }
      intersectsPlane(e) {
         let n, r;
         return e.normal.x > 0 ? (n = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, r += e.normal.z * this.min.z), n <= -e.constant && r >= -e.constant
      }
      intersectsTriangle(e) {
         if (this.isEmpty()) return !1;
         this.getCenter(gh), zm.subVectors(this.max, gh), Fu.subVectors(e.a, gh), Ou.subVectors(e.b, gh), Nu.subVectors(e.c, gh), Zo.subVectors(Ou, Fu), qo.subVectors(Nu, Ou), al.subVectors(Fu, Nu);
         let n = [0, -Zo.z, Zo.y, 0, -qo.z, qo.y, 0, -al.z, al.y, Zo.z, 0, -Zo.x, qo.z, 0, -qo.x, al.z, 0, -al.x, -Zo.y, Zo.x, 0, -qo.y, qo.x, 0, -al.y, al.x, 0];
         return !o_(n, Fu, Ou, Nu, zm) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !o_(n, Fu, Ou, Nu, zm)) ? !1 : (Vm.crossVectors(Zo, qo), n = [Vm.x, Vm.y, Vm.z], o_(n, Fu, Ou, Nu, zm))
      }
      clampPoint(e, n) {
         return n.copy(e).clamp(this.min, this.max)
      }
      distanceToPoint(e) {
         return this.clampPoint(e, lo).distanceTo(e)
      }
      getBoundingSphere(e) {
         return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(lo).length() * .5), e
      }
      intersect(e) {
         return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
      }
      union(e) {
         return this.min.min(e.min), this.max.max(e.max), this
      }
      applyMatrix4(e) {
         return this.isEmpty() ? this : (ao[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ao[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ao[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ao[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ao[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ao[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ao[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ao[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ao), this)
      }
      translate(e) {
         return this.min.add(e), this.max.add(e), this
      }
      equals(e) {
         return e.min.equals(this.min) && e.max.equals(this.max)
      }
   }
   const ao = [new U, new U, new U, new U, new U, new U, new U, new U],
      lo = new U,
      Du = new qi,
      Fu = new U,
      Ou = new U,
      Nu = new U,
      Zo = new U,
      qo = new U,
      al = new U,
      gh = new U,
      zm = new U,
      Vm = new U,
      ll = new U;

   function o_(t, e, n, r, i) {
      for (let s = 0, o = t.length - 3; s <= o; s += 3) {
         ll.fromArray(t, s);
         const a = i.x * Math.abs(ll.x) + i.y * Math.abs(ll.y) + i.z * Math.abs(ll.z),
            l = e.dot(ll),
            u = n.dot(ll),
            h = r.dot(ll);
         if (Math.max(-Math.max(l, u, h), Math.min(l, u, h)) > a) return !1
      }
      return !0
   }
   const o5 = new qi,
      vh = new U,
      a_ = new U;
   class Ci {
      constructor(e = new U, n = -1) {
         this.center = e, this.radius = n
      }
      set(e, n) {
         return this.center.copy(e), this.radius = n, this
      }
      setFromPoints(e, n) {
         const r = this.center;
         n !== void 0 ? r.copy(n) : o5.setFromPoints(e).getCenter(r);
         let i = 0;
         for (let s = 0, o = e.length; s < o; s++) i = Math.max(i, r.distanceToSquared(e[s]));
         return this.radius = Math.sqrt(i), this
      }
      copy(e) {
         return this.center.copy(e.center), this.radius = e.radius, this
      }
      isEmpty() {
         return this.radius < 0
      }
      makeEmpty() {
         return this.center.set(0, 0, 0), this.radius = -1, this
      }
      containsPoint(e) {
         return e.distanceToSquared(this.center) <= this.radius * this.radius
      }
      distanceToPoint(e) {
         return e.distanceTo(this.center) - this.radius
      }
      intersectsSphere(e) {
         const n = this.radius + e.radius;
         return e.center.distanceToSquared(this.center) <= n * n
      }
      intersectsBox(e) {
         return e.intersectsSphere(this)
      }
      intersectsPlane(e) {
         return Math.abs(e.distanceToPoint(this.center)) <= this.radius
      }
      clampPoint(e, n) {
         const r = this.center.distanceToSquared(e);
         return n.copy(e), r > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
      }
      getBoundingBox(e) {
         return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
      }
      applyMatrix4(e) {
         return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
      }
      translate(e) {
         return this.center.add(e), this
      }
      expandByPoint(e) {
         if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
         vh.subVectors(e, this.center);
         const n = vh.lengthSq();
         if (n > this.radius * this.radius) {
            const r = Math.sqrt(n),
               i = (r - this.radius) * .5;
            this.center.addScaledVector(vh, i / r), this.radius += i
         }
         return this
      }
      union(e) {
         return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (a_.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(vh.copy(e.center).add(a_)), this.expandByPoint(vh.copy(e.center).sub(a_))), this)
      }
      equals(e) {
         return e.center.equals(this.center) && e.radius === this.radius
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   const uo = new U,
      l_ = new U,
      Wm = new U,
      ea = new U,
      u_ = new U,
      jm = new U,
      c_ = new U;
   class Cf {
      constructor(e = new U, n = new U(0, 0, -1)) {
         this.origin = e, this.direction = n
      }
      set(e, n) {
         return this.origin.copy(e), this.direction.copy(n), this
      }
      copy(e) {
         return this.origin.copy(e.origin), this.direction.copy(e.direction), this
      }
      at(e, n) {
         return n.copy(this.origin).addScaledVector(this.direction, e)
      }
      lookAt(e) {
         return this.direction.copy(e).sub(this.origin).normalize(), this
      }
      recast(e) {
         return this.origin.copy(this.at(e, uo)), this
      }
      closestPointToPoint(e, n) {
         n.subVectors(e, this.origin);
         const r = n.dot(this.direction);
         return r < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, r)
      }
      distanceToPoint(e) {
         return Math.sqrt(this.distanceSqToPoint(e))
      }
      distanceSqToPoint(e) {
         const n = uo.subVectors(e, this.origin).dot(this.direction);
         return n < 0 ? this.origin.distanceToSquared(e) : (uo.copy(this.origin).addScaledVector(this.direction, n), uo.distanceToSquared(e))
      }
      distanceSqToSegment(e, n, r, i) {
         l_.copy(e).add(n).multiplyScalar(.5), Wm.copy(n).sub(e).normalize(), ea.copy(this.origin).sub(l_);
         const s = e.distanceTo(n) * .5,
            o = -this.direction.dot(Wm),
            a = ea.dot(this.direction),
            l = -ea.dot(Wm),
            u = ea.lengthSq(),
            h = Math.abs(1 - o * o);
         let d, p, m, v;
         if (h > 0)
            if (d = o * l - a, p = o * a - l, v = s * h, d >= 0)
               if (p >= -v)
                  if (p <= v) {
                     const _ = 1 / h;
                     d *= _, p *= _, m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + u
                  } else p = s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + u;
         else p = -s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + u;
         else p <= -v ? (d = Math.max(0, -(-o * s + a)), p = d > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -d * d + p * (p + 2 * l) + u) : p <= v ? (d = 0, p = Math.min(Math.max(-s, -l), s), m = p * (p + 2 * l) + u) : (d = Math.max(0, -(o * s + a)), p = d > 0 ? s : Math.min(Math.max(-s, -l), s), m = -d * d + p * (p + 2 * l) + u);
         else p = o > 0 ? -s : s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + u;
         return r && r.copy(this.origin).addScaledVector(this.direction, d), i && i.copy(l_).addScaledVector(Wm, p), m
      }
      intersectSphere(e, n) {
         uo.subVectors(e.center, this.origin);
         const r = uo.dot(this.direction),
            i = uo.dot(uo) - r * r,
            s = e.radius * e.radius;
         if (i > s) return null;
         const o = Math.sqrt(s - i),
            a = r - o,
            l = r + o;
         return l < 0 ? null : a < 0 ? this.at(l, n) : this.at(a, n)
      }
      intersectsSphere(e) {
         return this.distanceSqToPoint(e.center) <= e.radius * e.radius
      }
      distanceToPlane(e) {
         const n = e.normal.dot(this.direction);
         if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
         const r = -(this.origin.dot(e.normal) + e.constant) / n;
         return r >= 0 ? r : null
      }
      intersectPlane(e, n) {
         const r = this.distanceToPlane(e);
         return r === null ? null : this.at(r, n)
      }
      intersectsPlane(e) {
         const n = e.distanceToPoint(this.origin);
         return n === 0 || e.normal.dot(this.direction) * n < 0
      }
      intersectBox(e, n) {
         let r, i, s, o, a, l;
         const u = 1 / this.direction.x,
            h = 1 / this.direction.y,
            d = 1 / this.direction.z,
            p = this.origin;
         return u >= 0 ? (r = (e.min.x - p.x) * u, i = (e.max.x - p.x) * u) : (r = (e.max.x - p.x) * u, i = (e.min.x - p.x) * u), h >= 0 ? (s = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (s = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), r > o || s > i || ((s > r || isNaN(r)) && (r = s), (o < i || isNaN(i)) && (i = o), d >= 0 ? (a = (e.min.z - p.z) * d, l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, l = (e.min.z - p.z) * d), r > l || a > i) || ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(r >= 0 ? r : i, n)
      }
      intersectsBox(e) {
         return this.intersectBox(e, uo) !== null
      }
      intersectTriangle(e, n, r, i, s) {
         u_.subVectors(n, e), jm.subVectors(r, e), c_.crossVectors(u_, jm);
         let o = this.direction.dot(c_),
            a;
         if (o > 0) {
            if (i) return null;
            a = 1
         } else if (o < 0) a = -1, o = -o;
         else return null;
         ea.subVectors(this.origin, e);
         const l = a * this.direction.dot(jm.crossVectors(ea, jm));
         if (l < 0) return null;
         const u = a * this.direction.dot(u_.cross(ea));
         if (u < 0 || l + u > o) return null;
         const h = -a * ea.dot(c_);
         return h < 0 ? null : this.at(h / o, s)
      }
      applyMatrix4(e) {
         return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
      }
      equals(e) {
         return e.origin.equals(this.origin) && e.direction.equals(this.direction)
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   class yt {
      constructor(e, n, r, i, s, o, a, l, u, h, d, p, m, v, _, x) {
         yt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, n, r, i, s, o, a, l, u, h, d, p, m, v, _, x)
      }
      set(e, n, r, i, s, o, a, l, u, h, d, p, m, v, _, x) {
         const g = this.elements;
         return g[0] = e, g[4] = n, g[8] = r, g[12] = i, g[1] = s, g[5] = o, g[9] = a, g[13] = l, g[2] = u, g[6] = h, g[10] = d, g[14] = p, g[3] = m, g[7] = v, g[11] = _, g[15] = x, this
      }
      identity() {
         return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
      }
      clone() {
         return new yt().fromArray(this.elements)
      }
      copy(e) {
         const n = this.elements,
            r = e.elements;
         return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this
      }
      copyPosition(e) {
         const n = this.elements,
            r = e.elements;
         return n[12] = r[12], n[13] = r[13], n[14] = r[14], this
      }
      setFromMatrix3(e) {
         const n = e.elements;
         return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1), this
      }
      extractBasis(e, n, r) {
         return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this
      }
      makeBasis(e, n, r) {
         return this.set(e.x, n.x, r.x, 0, e.y, n.y, r.y, 0, e.z, n.z, r.z, 0, 0, 0, 0, 1), this
      }
      extractRotation(e) {
         const n = this.elements,
            r = e.elements,
            i = 1 / Uu.setFromMatrixColumn(e, 0).length(),
            s = 1 / Uu.setFromMatrixColumn(e, 1).length(),
            o = 1 / Uu.setFromMatrixColumn(e, 2).length();
         return n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = 0, n[4] = r[4] * s, n[5] = r[5] * s, n[6] = r[6] * s, n[7] = 0, n[8] = r[8] * o, n[9] = r[9] * o, n[10] = r[10] * o, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
      }
      makeRotationFromEuler(e) {
         const n = this.elements,
            r = e.x,
            i = e.y,
            s = e.z,
            o = Math.cos(r),
            a = Math.sin(r),
            l = Math.cos(i),
            u = Math.sin(i),
            h = Math.cos(s),
            d = Math.sin(s);
         if (e.order === "XYZ") {
            const p = o * h,
               m = o * d,
               v = a * h,
               _ = a * d;
            n[0] = l * h, n[4] = -l * d, n[8] = u, n[1] = m + v * u, n[5] = p - _ * u, n[9] = -a * l, n[2] = _ - p * u, n[6] = v + m * u, n[10] = o * l
         } else if (e.order === "YXZ") {
            const p = l * h,
               m = l * d,
               v = u * h,
               _ = u * d;
            n[0] = p + _ * a, n[4] = v * a - m, n[8] = o * u, n[1] = o * d, n[5] = o * h, n[9] = -a, n[2] = m * a - v, n[6] = _ + p * a, n[10] = o * l
         } else if (e.order === "ZXY") {
            const p = l * h,
               m = l * d,
               v = u * h,
               _ = u * d;
            n[0] = p - _ * a, n[4] = -o * d, n[8] = v + m * a, n[1] = m + v * a, n[5] = o * h, n[9] = _ - p * a, n[2] = -o * u, n[6] = a, n[10] = o * l
         } else if (e.order === "ZYX") {
            const p = o * h,
               m = o * d,
               v = a * h,
               _ = a * d;
            n[0] = l * h, n[4] = v * u - m, n[8] = p * u + _, n[1] = l * d, n[5] = _ * u + p, n[9] = m * u - v, n[2] = -u, n[6] = a * l, n[10] = o * l
         } else if (e.order === "YZX") {
            const p = o * l,
               m = o * u,
               v = a * l,
               _ = a * u;
            n[0] = l * h, n[4] = _ - p * d, n[8] = v * d + m, n[1] = d, n[5] = o * h, n[9] = -a * h, n[2] = -u * h, n[6] = m * d + v, n[10] = p - _ * d
         } else if (e.order === "XZY") {
            const p = o * l,
               m = o * u,
               v = a * l,
               _ = a * u;
            n[0] = l * h, n[4] = -d, n[8] = u * h, n[1] = p * d + _, n[5] = o * h, n[9] = m * d - v, n[2] = v * d - m, n[6] = a * h, n[10] = _ * d + p
         }
         return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
      }
      makeRotationFromQuaternion(e) {
         return this.compose(a5, e, l5)
      }
      lookAt(e, n, r) {
         const i = this.elements;
         return ci.subVectors(e, n), ci.lengthSq() === 0 && (ci.z = 1), ci.normalize(), ta.crossVectors(r, ci), ta.lengthSq() === 0 && (Math.abs(r.z) === 1 ? ci.x += 1e-4 : ci.z += 1e-4, ci.normalize(), ta.crossVectors(r, ci)), ta.normalize(), $m.crossVectors(ci, ta), i[0] = ta.x, i[4] = $m.x, i[8] = ci.x, i[1] = ta.y, i[5] = $m.y, i[9] = ci.y, i[2] = ta.z, i[6] = $m.z, i[10] = ci.z, this
      }
      multiply(e) {
         return this.multiplyMatrices(this, e)
      }
      premultiply(e) {
         return this.multiplyMatrices(e, this)
      }
      multiplyMatrices(e, n) {
         const r = e.elements,
            i = n.elements,
            s = this.elements,
            o = r[0],
            a = r[4],
            l = r[8],
            u = r[12],
            h = r[1],
            d = r[5],
            p = r[9],
            m = r[13],
            v = r[2],
            _ = r[6],
            x = r[10],
            g = r[14],
            S = r[3],
            A = r[7],
            E = r[11],
            C = r[15],
            R = i[0],
            B = i[4],
            D = i[8],
            T = i[12],
            I = i[1],
            N = i[5],
            q = i[9],
            K = i[13],
            Z = i[2],
            te = i[6],
            se = i[10],
            oe = i[14],
            G = i[3],
            ne = i[7],
            Y = i[11],
            X = i[15];
         return s[0] = o * R + a * I + l * Z + u * G, s[4] = o * B + a * N + l * te + u * ne, s[8] = o * D + a * q + l * se + u * Y, s[12] = o * T + a * K + l * oe + u * X, s[1] = h * R + d * I + p * Z + m * G, s[5] = h * B + d * N + p * te + m * ne, s[9] = h * D + d * q + p * se + m * Y, s[13] = h * T + d * K + p * oe + m * X, s[2] = v * R + _ * I + x * Z + g * G, s[6] = v * B + _ * N + x * te + g * ne, s[10] = v * D + _ * q + x * se + g * Y, s[14] = v * T + _ * K + x * oe + g * X, s[3] = S * R + A * I + E * Z + C * G, s[7] = S * B + A * N + E * te + C * ne, s[11] = S * D + A * q + E * se + C * Y, s[15] = S * T + A * K + E * oe + C * X, this
      }
      multiplyScalar(e) {
         const n = this.elements;
         return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this
      }
      determinant() {
         const e = this.elements,
            n = e[0],
            r = e[4],
            i = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            u = e[13],
            h = e[2],
            d = e[6],
            p = e[10],
            m = e[14],
            v = e[3],
            _ = e[7],
            x = e[11],
            g = e[15];
         return v * (+s * l * d - i * u * d - s * a * p + r * u * p + i * a * m - r * l * m) + _ * (+n * l * m - n * u * p + s * o * p - i * o * m + i * u * h - s * l * h) + x * (+n * u * d - n * a * m - s * o * d + r * o * m + s * a * h - r * u * h) + g * (-i * a * h - n * l * d + n * a * p + i * o * d - r * o * p + r * l * h)
      }
      transpose() {
         const e = this.elements;
         let n;
         return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this
      }
      setPosition(e, n, r) {
         const i = this.elements;
         return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = n, i[14] = r), this
      }
      invert() {
         const e = this.elements,
            n = e[0],
            r = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            u = e[7],
            h = e[8],
            d = e[9],
            p = e[10],
            m = e[11],
            v = e[12],
            _ = e[13],
            x = e[14],
            g = e[15],
            S = d * x * u - _ * p * u + _ * l * m - a * x * m - d * l * g + a * p * g,
            A = v * p * u - h * x * u - v * l * m + o * x * m + h * l * g - o * p * g,
            E = h * _ * u - v * d * u + v * a * m - o * _ * m - h * a * g + o * d * g,
            C = v * d * l - h * _ * l - v * a * p + o * _ * p + h * a * x - o * d * x,
            R = n * S + r * A + i * E + s * C;
         if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
         const B = 1 / R;
         return e[0] = S * B, e[1] = (_ * p * s - d * x * s - _ * i * m + r * x * m + d * i * g - r * p * g) * B, e[2] = (a * x * s - _ * l * s + _ * i * u - r * x * u - a * i * g + r * l * g) * B, e[3] = (d * l * s - a * p * s - d * i * u + r * p * u + a * i * m - r * l * m) * B, e[4] = A * B, e[5] = (h * x * s - v * p * s + v * i * m - n * x * m - h * i * g + n * p * g) * B, e[6] = (v * l * s - o * x * s - v * i * u + n * x * u + o * i * g - n * l * g) * B, e[7] = (o * p * s - h * l * s + h * i * u - n * p * u - o * i * m + n * l * m) * B, e[8] = E * B, e[9] = (v * d * s - h * _ * s - v * r * m + n * _ * m + h * r * g - n * d * g) * B, e[10] = (o * _ * s - v * a * s + v * r * u - n * _ * u - o * r * g + n * a * g) * B, e[11] = (h * a * s - o * d * s - h * r * u + n * d * u + o * r * m - n * a * m) * B, e[12] = C * B, e[13] = (h * _ * i - v * d * i + v * r * p - n * _ * p - h * r * x + n * d * x) * B, e[14] = (v * a * i - o * _ * i - v * r * l + n * _ * l + o * r * x - n * a * x) * B, e[15] = (o * d * i - h * a * i + h * r * l - n * d * l - o * r * p + n * a * p) * B, this
      }
      scale(e) {
         const n = this.elements,
            r = e.x,
            i = e.y,
            s = e.z;
         return n[0] *= r, n[4] *= i, n[8] *= s, n[1] *= r, n[5] *= i, n[9] *= s, n[2] *= r, n[6] *= i, n[10] *= s, n[3] *= r, n[7] *= i, n[11] *= s, this
      }
      getMaxScaleOnAxis() {
         const e = this.elements,
            n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
         return Math.sqrt(Math.max(n, r, i))
      }
      makeTranslation(e, n, r) {
         return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1), this
      }
      makeRotationX(e) {
         const n = Math.cos(e),
            r = Math.sin(e);
         return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this
      }
      makeRotationY(e) {
         const n = Math.cos(e),
            r = Math.sin(e);
         return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this
      }
      makeRotationZ(e) {
         const n = Math.cos(e),
            r = Math.sin(e);
         return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
      }
      makeRotationAxis(e, n) {
         const r = Math.cos(n),
            i = Math.sin(n),
            s = 1 - r,
            o = e.x,
            a = e.y,
            l = e.z,
            u = s * o,
            h = s * a;
         return this.set(u * o + r, u * a - i * l, u * l + i * a, 0, u * a + i * l, h * a + r, h * l - i * o, 0, u * l - i * a, h * l + i * o, s * l * l + r, 0, 0, 0, 0, 1), this
      }
      makeScale(e, n, r) {
         return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this
      }
      makeShear(e, n, r, i, s, o) {
         return this.set(1, r, s, 0, e, 1, o, 0, n, i, 1, 0, 0, 0, 0, 1), this
      }
      compose(e, n, r) {
         const i = this.elements,
            s = n._x,
            o = n._y,
            a = n._z,
            l = n._w,
            u = s + s,
            h = o + o,
            d = a + a,
            p = s * u,
            m = s * h,
            v = s * d,
            _ = o * h,
            x = o * d,
            g = a * d,
            S = l * u,
            A = l * h,
            E = l * d,
            C = r.x,
            R = r.y,
            B = r.z;
         return i[0] = (1 - (_ + g)) * C, i[1] = (m + E) * C, i[2] = (v - A) * C, i[3] = 0, i[4] = (m - E) * R, i[5] = (1 - (p + g)) * R, i[6] = (x + S) * R, i[7] = 0, i[8] = (v + A) * B, i[9] = (x - S) * B, i[10] = (1 - (p + _)) * B, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
      }
      decompose(e, n, r) {
         const i = this.elements;
         let s = Uu.set(i[0], i[1], i[2]).length();
         const o = Uu.set(i[4], i[5], i[6]).length(),
            a = Uu.set(i[8], i[9], i[10]).length();
         this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], rs.copy(this);
         const u = 1 / s,
            h = 1 / o,
            d = 1 / a;
         return rs.elements[0] *= u, rs.elements[1] *= u, rs.elements[2] *= u, rs.elements[4] *= h, rs.elements[5] *= h, rs.elements[6] *= h, rs.elements[8] *= d, rs.elements[9] *= d, rs.elements[10] *= d, n.setFromRotationMatrix(rs), r.x = s, r.y = o, r.z = a, this
      }
      makePerspective(e, n, r, i, s, o, a = ks) {
         const l = this.elements,
            u = 2 * s / (n - e),
            h = 2 * s / (r - i),
            d = (n + e) / (n - e),
            p = (r + i) / (r - i);
         let m, v;
         if (a === ks) m = -(o + s) / (o - s), v = -2 * o * s / (o - s);
         else if (a === kd) m = -o / (o - s), v = -o * s / (o - s);
         else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
         return l[0] = u, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = h, l[9] = p, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = v, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
      }
      makeOrthographic(e, n, r, i, s, o, a = ks) {
         const l = this.elements,
            u = 1 / (n - e),
            h = 1 / (r - i),
            d = 1 / (o - s),
            p = (n + e) * u,
            m = (r + i) * h;
         let v, _;
         if (a === ks) v = (o + s) * d, _ = -2 * d;
         else if (a === kd) v = s * d, _ = -1 * d;
         else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
         return l[0] = 2 * u, l[4] = 0, l[8] = 0, l[12] = -p, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -m, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -v, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
      }
      equals(e) {
         const n = this.elements,
            r = e.elements;
         for (let i = 0; i < 16; i++)
            if (n[i] !== r[i]) return !1;
         return !0
      }
      fromArray(e, n = 0) {
         for (let r = 0; r < 16; r++) this.elements[r] = e[r + n];
         return this
      }
      toArray(e = [], n = 0) {
         const r = this.elements;
         return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e[n + 9] = r[9], e[n + 10] = r[10], e[n + 11] = r[11], e[n + 12] = r[12], e[n + 13] = r[13], e[n + 14] = r[14], e[n + 15] = r[15], e
      }
   }
   const Uu = new U,
      rs = new yt,
      a5 = new U(0, 0, 0),
      l5 = new U(1, 1, 1),
      ta = new U,
      $m = new U,
      ci = new U,
      zT = new yt,
      VT = new tr;
   class Xa {
      constructor(e = 0, n = 0, r = 0, i = Xa.DEFAULT_ORDER) {
         this.isEuler = !0, this._x = e, this._y = n, this._z = r, this._order = i
      }
      get x() {
         return this._x
      }
      set x(e) {
         this._x = e, this._onChangeCallback()
      }
      get y() {
         return this._y
      }
      set y(e) {
         this._y = e, this._onChangeCallback()
      }
      get z() {
         return this._z
      }
      set z(e) {
         this._z = e, this._onChangeCallback()
      }
      get order() {
         return this._order
      }
      set order(e) {
         this._order = e, this._onChangeCallback()
      }
      set(e, n, r, i = this._order) {
         return this._x = e, this._y = n, this._z = r, this._order = i, this._onChangeCallback(), this
      }
      clone() {
         return new this.constructor(this._x, this._y, this._z, this._order)
      }
      copy(e) {
         return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
      }
      setFromRotationMatrix(e, n = this._order, r = !0) {
         const i = e.elements,
            s = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            u = i[5],
            h = i[9],
            d = i[2],
            p = i[6],
            m = i[10];
         switch (n) {
            case "XYZ":
               this._y = Math.asin(On(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, u), this._z = 0);
               break;
            case "YXZ":
               this._x = Math.asin(-On(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-d, s), this._z = 0);
               break;
            case "ZXY":
               this._x = Math.asin(On(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-d, m), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, s));
               break;
            case "ZYX":
               this._y = Math.asin(-On(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(p, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, u));
               break;
            case "YZX":
               this._z = Math.asin(On(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, u), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(a, m));
               break;
            case "XZY":
               this._z = Math.asin(-On(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, u), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, m), this._y = 0);
               break;
            default:
               console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
         }
         return this._order = n, r === !0 && this._onChangeCallback(), this
      }
      setFromQuaternion(e, n, r) {
         return zT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(zT, n, r)
      }
      setFromVector3(e, n = this._order) {
         return this.set(e.x, e.y, e.z, n)
      }
      reorder(e) {
         return VT.setFromEuler(this), this.setFromQuaternion(VT, e)
      }
      equals(e) {
         return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
      }
      fromArray(e) {
         return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
      }
      toArray(e = [], n = 0) {
         return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e
      }
      _onChange(e) {
         return this._onChangeCallback = e, this
      }
      _onChangeCallback() {}*[Symbol.iterator]() {
         yield this._x, yield this._y, yield this._z, yield this._order
      }
   }
   Xa.DEFAULT_ORDER = "XYZ";
   class zl {
      constructor() {
         this.mask = 1
      }
      set(e) {
         this.mask = (1 << e | 0) >>> 0
      }
      enable(e) {
         this.mask |= 1 << e | 0
      }
      enableAll() {
         this.mask = -1
      }
      toggle(e) {
         this.mask ^= 1 << e | 0
      }
      disable(e) {
         this.mask &= ~(1 << e | 0)
      }
      disableAll() {
         this.mask = 0
      }
      test(e) {
         return (this.mask & e.mask) !== 0
      }
      isEnabled(e) {
         return (this.mask & (1 << e | 0)) !== 0
      }
   }
   let u5 = 0;
   const WT = new U,
      ku = new tr,
      co = new yt,
      Xm = new U,
      yh = new U,
      c5 = new U,
      f5 = new tr,
      jT = new U(1, 0, 0),
      $T = new U(0, 1, 0),
      XT = new U(0, 0, 1),
      h5 = {
         type: "added"
      },
      JT = {
         type: "removed"
      };
   class Wt extends Uo {
      constructor() {
         super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: u5++
         }), this.uuid = xi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Wt.DEFAULT_UP.clone();
         const e = new U,
            n = new Xa,
            r = new tr,
            i = new U(1, 1, 1);

         function s() {
            r.setFromEuler(n, !1)
         }

         function o() {
            n.setFromQuaternion(r, void 0, !1)
         }
         n._onChange(s), r._onChange(o), Object.defineProperties(this, {
            position: {
               configurable: !0,
               enumerable: !0,
               value: e
            },
            rotation: {
               configurable: !0,
               enumerable: !0,
               value: n
            },
            quaternion: {
               configurable: !0,
               enumerable: !0,
               value: r
            },
            scale: {
               configurable: !0,
               enumerable: !0,
               value: i
            },
            modelViewMatrix: {
               value: new yt
            },
            normalMatrix: {
               value: new Ft
            }
         }), this.matrix = new yt, this.matrixWorld = new yt, this.matrixAutoUpdate = Wt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Wt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new zl, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(e) {
         this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
      }
      applyQuaternion(e) {
         return this.quaternion.premultiply(e), this
      }
      setRotationFromAxisAngle(e, n) {
         this.quaternion.setFromAxisAngle(e, n)
      }
      setRotationFromEuler(e) {
         this.quaternion.setFromEuler(e, !0)
      }
      setRotationFromMatrix(e) {
         this.quaternion.setFromRotationMatrix(e)
      }
      setRotationFromQuaternion(e) {
         this.quaternion.copy(e)
      }
      rotateOnAxis(e, n) {
         return ku.setFromAxisAngle(e, n), this.quaternion.multiply(ku), this
      }
      rotateOnWorldAxis(e, n) {
         return ku.setFromAxisAngle(e, n), this.quaternion.premultiply(ku), this
      }
      rotateX(e) {
         return this.rotateOnAxis(jT, e)
      }
      rotateY(e) {
         return this.rotateOnAxis($T, e)
      }
      rotateZ(e) {
         return this.rotateOnAxis(XT, e)
      }
      translateOnAxis(e, n) {
         return WT.copy(e).applyQuaternion(this.quaternion), this.position.add(WT.multiplyScalar(n)), this
      }
      translateX(e) {
         return this.translateOnAxis(jT, e)
      }
      translateY(e) {
         return this.translateOnAxis($T, e)
      }
      translateZ(e) {
         return this.translateOnAxis(XT, e)
      }
      localToWorld(e) {
         return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
      }
      worldToLocal(e) {
         return this.updateWorldMatrix(!0, !1), e.applyMatrix4(co.copy(this.matrixWorld).invert())
      }
      lookAt(e, n, r) {
         e.isVector3 ? Xm.copy(e) : Xm.set(e, n, r);
         const i = this.parent;
         this.updateWorldMatrix(!0, !1), yh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? co.lookAt(yh, Xm, this.up) : co.lookAt(Xm, yh, this.up), this.quaternion.setFromRotationMatrix(co), i && (co.extractRotation(i.matrixWorld), ku.setFromRotationMatrix(co), this.quaternion.premultiply(ku.invert()))
      }
      add(e) {
         if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
            return this
         }
         return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(h5)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
      }
      remove(e) {
         if (arguments.length > 1) {
            for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
            return this
         }
         const n = this.children.indexOf(e);
         return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(JT)), this
      }
      removeFromParent() {
         const e = this.parent;
         return e !== null && e.remove(this), this
      }
      clear() {
         for (let e = 0; e < this.children.length; e++) {
            const n = this.children[e];
            n.parent = null, n.dispatchEvent(JT)
         }
         return this.children.length = 0, this
      }
      attach(e) {
         return this.updateWorldMatrix(!0, !1), co.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), co.multiply(e.parent.matrixWorld)), e.applyMatrix4(co), this.add(e), e.updateWorldMatrix(!1, !0), this
      }
      getObjectById(e) {
         return this.getObjectByProperty("id", e)
      }
      getObjectByName(e) {
         return this.getObjectByProperty("name", e)
      }
      getObjectByProperty(e, n) {
         if (this[e] === n) return this;
         for (let r = 0, i = this.children.length; r < i; r++) {
            const o = this.children[r].getObjectByProperty(e, n);
            if (o !== void 0) return o
         }
      }
      getObjectsByProperty(e, n) {
         let r = [];
         this[e] === n && r.push(this);
         for (let i = 0, s = this.children.length; i < s; i++) {
            const o = this.children[i].getObjectsByProperty(e, n);
            o.length > 0 && (r = r.concat(o))
         }
         return r
      }
      getWorldPosition(e) {
         return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
      }
      getWorldQuaternion(e) {
         return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yh, e, c5), e
      }
      getWorldScale(e) {
         return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yh, f5, e), e
      }
      getWorldDirection(e) {
         this.updateWorldMatrix(!0, !1);
         const n = this.matrixWorld.elements;
         return e.set(n[8], n[9], n[10]).normalize()
      }
      raycast() {}
      traverse(e) {
         e(this);
         const n = this.children;
         for (let r = 0, i = n.length; r < i; r++) n[r].traverse(e)
      }
      traverseVisible(e) {
         if (this.visible === !1) return;
         e(this);
         const n = this.children;
         for (let r = 0, i = n.length; r < i; r++) n[r].traverseVisible(e)
      }
      traverseAncestors(e) {
         const n = this.parent;
         n !== null && (e(n), n.traverseAncestors(e))
      }
      updateMatrix() {
         this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
      }
      updateMatrixWorld(e) {
         this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
         const n = this.children;
         for (let r = 0, i = n.length; r < i; r++) {
            const s = n[r];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
         }
      }
      updateWorldMatrix(e, n) {
         const r = this.parent;
         if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), n === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++) {
               const a = i[s];
               a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
         }
      }
      toJSON(e) {
         const n = e === void 0 || typeof e == "string",
            r = {};
         n && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
         }, r.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
         });
         const i = {};
         i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));

         function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
         }
         if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
         else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
               const l = a.shapes;
               if (Array.isArray(l))
                  for (let u = 0, h = l.length; u < h; u++) {
                     const d = l[u];
                     s(e.shapes, d)
                  } else s(e.shapes, l)
            }
         }
         if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
               const a = [];
               for (let l = 0, u = this.material.length; l < u; l++) a.push(s(e.materials, this.material[l]));
               i.material = a
            } else i.material = s(e.materials, this.material);
         if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e).object)
         }
         if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
               const l = this.animations[a];
               i.animations.push(s(e.animations, l))
            }
         }
         if (n) {
            const a = o(e.geometries),
               l = o(e.materials),
               u = o(e.textures),
               h = o(e.images),
               d = o(e.shapes),
               p = o(e.skeletons),
               m = o(e.animations),
               v = o(e.nodes);
            a.length > 0 && (r.geometries = a), l.length > 0 && (r.materials = l), u.length > 0 && (r.textures = u), h.length > 0 && (r.images = h), d.length > 0 && (r.shapes = d), p.length > 0 && (r.skeletons = p), m.length > 0 && (r.animations = m), v.length > 0 && (r.nodes = v)
         }
         return r.object = i, r;

         function o(a) {
            const l = [];
            for (const u in a) {
               const h = a[u];
               delete h.metadata, l.push(h)
            }
            return l
         }
      }
      clone(e) {
         return new this.constructor().copy(this, e)
      }
      copy(e, n = !0) {
         if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
            for (let r = 0; r < e.children.length; r++) {
               const i = e.children[r];
               this.add(i.clone())
            }
         return this
      }
   }
   Wt.DEFAULT_UP = new U(0, 1, 0);
   Wt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
   Wt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
   const is = new U,
      fo = new U,
      f_ = new U,
      ho = new U,
      Hu = new U,
      Gu = new U,
      KT = new U,
      h_ = new U,
      d_ = new U,
      p_ = new U;
   let Jm = !1;
   class Yr {
      constructor(e = new U, n = new U, r = new U) {
         this.a = e, this.b = n, this.c = r
      }
      static getNormal(e, n, r, i) {
         i.subVectors(r, n), is.subVectors(e, n), i.cross(is);
         const s = i.lengthSq();
         return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
      }
      static getBarycoord(e, n, r, i, s) {
         is.subVectors(i, n), fo.subVectors(r, n), f_.subVectors(e, n);
         const o = is.dot(is),
            a = is.dot(fo),
            l = is.dot(f_),
            u = fo.dot(fo),
            h = fo.dot(f_),
            d = o * u - a * a;
         if (d === 0) return s.set(-2, -1, -1);
         const p = 1 / d,
            m = (u * l - a * h) * p,
            v = (o * h - a * l) * p;
         return s.set(1 - m - v, v, m)
      }
      static containsPoint(e, n, r, i) {
         return this.getBarycoord(e, n, r, i, ho), ho.x >= 0 && ho.y >= 0 && ho.x + ho.y <= 1
      }
      static getUV(e, n, r, i, s, o, a, l) {
         return Jm === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Jm = !0), this.getInterpolation(e, n, r, i, s, o, a, l)
      }
      static getInterpolation(e, n, r, i, s, o, a, l) {
         return this.getBarycoord(e, n, r, i, ho), l.setScalar(0), l.addScaledVector(s, ho.x), l.addScaledVector(o, ho.y), l.addScaledVector(a, ho.z), l
      }
      static isFrontFacing(e, n, r, i) {
         return is.subVectors(r, n), fo.subVectors(e, n), is.cross(fo).dot(i) < 0
      }
      set(e, n, r) {
         return this.a.copy(e), this.b.copy(n), this.c.copy(r), this
      }
      setFromPointsAndIndices(e, n, r, i) {
         return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[i]), this
      }
      setFromAttributeAndIndices(e, n, r, i) {
         return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this
      }
      clone() {
         return new this.constructor().copy(this)
      }
      copy(e) {
         return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
      }
      getArea() {
         return is.subVectors(this.c, this.b), fo.subVectors(this.a, this.b), is.cross(fo).length() * .5
      }
      getMidpoint(e) {
         return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
      }
      getNormal(e) {
         return Yr.getNormal(this.a, this.b, this.c, e)
      }
      getPlane(e) {
         return e.setFromCoplanarPoints(this.a, this.b, this.c)
      }
      getBarycoord(e, n) {
         return Yr.getBarycoord(e, this.a, this.b, this.c, n)
      }
      getUV(e, n, r, i, s) {
         return Jm === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Jm = !0), Yr.getInterpolation(e, this.a, this.b, this.c, n, r, i, s)
      }
      getInterpolation(e, n, r, i, s) {
         return Yr.getInterpolation(e, this.a, this.b, this.c, n, r, i, s)
      }
      containsPoint(e) {
         return Yr.containsPoint(e, this.a, this.b, this.c)
      }
      isFrontFacing(e) {
         return Yr.isFrontFacing(this.a, this.b, this.c, e)
      }
      intersectsBox(e) {
         return e.intersectsTriangle(this)
      }
      closestPointToPoint(e, n) {
         const r = this.a,
            i = this.b,
            s = this.c;
         let o, a;
         Hu.subVectors(i, r), Gu.subVectors(s, r), h_.subVectors(e, r);
         const l = Hu.dot(h_),
            u = Gu.dot(h_);
         if (l <= 0 && u <= 0) return n.copy(r);
         d_.subVectors(e, i);
         const h = Hu.dot(d_),
            d = Gu.dot(d_);
         if (h >= 0 && d <= h) return n.copy(i);
         const p = l * d - h * u;
         if (p <= 0 && l >= 0 && h <= 0) return o = l / (l - h), n.copy(r).addScaledVector(Hu, o);
         p_.subVectors(e, s);
         const m = Hu.dot(p_),
            v = Gu.dot(p_);
         if (v >= 0 && m <= v) return n.copy(s);
         const _ = m * u - l * v;
         if (_ <= 0 && u >= 0 && v <= 0) return a = u / (u - v), n.copy(r).addScaledVector(Gu, a);
         const x = h * v - m * d;
         if (x <= 0 && d - h >= 0 && m - v >= 0) return KT.subVectors(s, i), a = (d - h) / (d - h + (m - v)), n.copy(i).addScaledVector(KT, a);
         const g = 1 / (x + _ + p);
         return o = _ * g, a = p * g, n.copy(r).addScaledVector(Hu, o).addScaledVector(Gu, a)
      }
      equals(e) {
         return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
      }
   }
   let d5 = 0,
      Jn = class extends Uo {
         constructor() {
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
               value: d5++
            }), this.uuid = xi(), this.name = "", this.type = "Material", this.blending = Hl, this.side = Js, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = LM, this.blendDst = DM, this.blendEquation = bl, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = U0, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = sF, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = l0, this.stencilZFail = l0, this.stencilZPass = l0, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
         }
         get alphaTest() {
            return this._alphaTest
         }
         set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
         }
         onBuild() {}
         onBeforeRender() {}
         onBeforeCompile() {}
         customProgramCacheKey() {
            return this.onBeforeCompile.toString()
         }
         setValues(e) {
            if (e !== void 0)
               for (const n in e) {
                  const r = e[n];
                  if (r === void 0) {
                     console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
                     continue
                  }
                  const i = this[n];
                  if (i === void 0) {
                     console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
                     continue
                  }
                  i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[n] = r
               }
         }
         toJSON(e) {
            const n = e === void 0 || typeof e == "string";
            n && (e = {
               textures: {},
               images: {}
            });
            const r = {
               metadata: {
                  version: 4.6,
                  type: "Material",
                  generator: "Material.toJSON"
               }
            };
            r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== Hl && (r.blending = this.blending), this.side !== Js && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaHash === !0 && (r.alphaHash = this.alphaHash), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData);

            function i(s) {
               const o = [];
               for (const a in s) {
                  const l = s[a];
                  delete l.metadata, o.push(l)
               }
               return o
            }
            if (n) {
               const s = i(e.textures),
                  o = i(e.images);
               s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o)
            }
            return r
         }
         clone() {
            return new this.constructor().copy(this)
         }
         copy(e) {
            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            const n = e.clippingPlanes;
            let r = null;
            if (n !== null) {
               const i = n.length;
               r = new Array(i);
               for (let s = 0; s !== i; ++s) r[s] = n[s].clone()
            }
            return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
         }
         dispose() {
            this.dispatchEvent({
               type: "dispose"
            })
         }
         set needsUpdate(e) {
            e === !0 && this.version++
         }
      };
   const vF = {
         aliceblue: 15792383,
         antiquewhite: 16444375,
         aqua: 65535,
         aquamarine: 8388564,
         azure: 15794175,
         beige: 16119260,
         bisque: 16770244,
         black: 0,
         blanchedalmond: 16772045,
         blue: 255,
         blueviolet: 9055202,
         brown: 10824234,
         burlywood: 14596231,
         cadetblue: 6266528,
         chartreuse: 8388352,
         chocolate: 13789470,
         coral: 16744272,
         cornflowerblue: 6591981,
         cornsilk: 16775388,
         crimson: 14423100,
         cyan: 65535,
         darkblue: 139,
         darkcyan: 35723,
         darkgoldenrod: 12092939,
         darkgray: 11119017,
         darkgreen: 25600,
         darkgrey: 11119017,
         darkkhaki: 12433259,
         darkmagenta: 9109643,
         darkolivegreen: 5597999,
         darkorange: 16747520,
         darkorchid: 10040012,
         darkred: 9109504,
         darksalmon: 15308410,
         darkseagreen: 9419919,
         darkslateblue: 4734347,
         darkslategray: 3100495,
         darkslategrey: 3100495,
         darkturquoise: 52945,
         darkviolet: 9699539,
         deeppink: 16716947,
         deepskyblue: 49151,
         dimgray: 6908265,
         dimgrey: 6908265,
         dodgerblue: 2003199,
         firebrick: 11674146,
         floralwhite: 16775920,
         forestgreen: 2263842,
         fuchsia: 16711935,
         gainsboro: 14474460,
         ghostwhite: 16316671,
         gold: 16766720,
         goldenrod: 14329120,
         gray: 8421504,
         green: 32768,
         greenyellow: 11403055,
         grey: 8421504,
         honeydew: 15794160,
         hotpink: 16738740,
         indianred: 13458524,
         indigo: 4915330,
         ivory: 16777200,
         khaki: 15787660,
         lavender: 15132410,
         lavenderblush: 16773365,
         lawngreen: 8190976,
         lemonchiffon: 16775885,
         lightblue: 11393254,
         lightcoral: 15761536,
         lightcyan: 14745599,
         lightgoldenrodyellow: 16448210,
         lightgray: 13882323,
         lightgreen: 9498256,
         lightgrey: 13882323,
         lightpink: 16758465,
         lightsalmon: 16752762,
         lightseagreen: 2142890,
         lightskyblue: 8900346,
         lightslategray: 7833753,
         lightslategrey: 7833753,
         lightsteelblue: 11584734,
         lightyellow: 16777184,
         lime: 65280,
         limegreen: 3329330,
         linen: 16445670,
         magenta: 16711935,
         maroon: 8388608,
         mediumaquamarine: 6737322,
         mediumblue: 205,
         mediumorchid: 12211667,
         mediumpurple: 9662683,
         mediumseagreen: 3978097,
         mediumslateblue: 8087790,
         mediumspringgreen: 64154,
         mediumturquoise: 4772300,
         mediumvioletred: 13047173,
         midnightblue: 1644912,
         mintcream: 16121850,
         mistyrose: 16770273,
         moccasin: 16770229,
         navajowhite: 16768685,
         navy: 128,
         oldlace: 16643558,
         olive: 8421376,
         olivedrab: 7048739,
         orange: 16753920,
         orangered: 16729344,
         orchid: 14315734,
         palegoldenrod: 15657130,
         palegreen: 10025880,
         paleturquoise: 11529966,
         palevioletred: 14381203,
         papayawhip: 16773077,
         peachpuff: 16767673,
         peru: 13468991,
         pink: 16761035,
         plum: 14524637,
         powderblue: 11591910,
         purple: 8388736,
         rebeccapurple: 6697881,
         red: 16711680,
         rosybrown: 12357519,
         royalblue: 4286945,
         saddlebrown: 9127187,
         salmon: 16416882,
         sandybrown: 16032864,
         seagreen: 3050327,
         seashell: 16774638,
         sienna: 10506797,
         silver: 12632256,
         skyblue: 8900331,
         slateblue: 6970061,
         slategray: 7372944,
         slategrey: 7372944,
         snow: 16775930,
         springgreen: 65407,
         steelblue: 4620980,
         tan: 13808780,
         teal: 32896,
         thistle: 14204888,
         tomato: 16737095,
         turquoise: 4251856,
         violet: 15631086,
         wheat: 16113331,
         white: 16777215,
         whitesmoke: 16119285,
         yellow: 16776960,
         yellowgreen: 10145074
      },
      ss = {
         h: 0,
         s: 0,
         l: 0
      },
      Km = {
         h: 0,
         s: 0,
         l: 0
      };

   function m_(t, e, n) {
      return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t
   }
   class ke {
      constructor(e, n, r) {
         return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, r)
      }
      set(e, n, r) {
         if (n === void 0 && r === void 0) {
            const i = e;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
         } else this.setRGB(e, n, r);
         return this
      }
      setScalar(e) {
         return this.r = e, this.g = e, this.b = e, this
      }
      setHex(e, n = Rt) {
         return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ki.toWorkingColorSpace(this, n), this
      }
      setRGB(e, n, r, i = ki.workingColorSpace) {
         return this.r = e, this.g = n, this.b = r, ki.toWorkingColorSpace(this, i), this
      }
      setHSL(e, n, r, i = ki.workingColorSpace) {
         if (e = XM(e, 1), n = On(n, 0, 1), r = On(r, 0, 1), n === 0) this.r = this.g = this.b = r;
         else {
            const s = r <= .5 ? r * (1 + n) : r + n - r * n,
               o = 2 * r - s;
            this.r = m_(o, s, e + 1 / 3), this.g = m_(o, s, e), this.b = m_(o, s, e - 1 / 3)
         }
         return ki.toWorkingColorSpace(this, i), this
      }
      setStyle(e, n = Rt) {
         function r(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
         }
         let i;
         if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = i[1],
               a = i[2];
            switch (o) {
               case "rgb":
               case "rgba":
                  if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, n);
                  if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, n);
                  break;
               case "hsl":
               case "hsla":
                  if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, n);
                  break;
               default:
                  console.warn("THREE.Color: Unknown color model " + e)
            }
         } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = i[1],
               o = s.length;
            if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, n);
            if (o === 6) return this.setHex(parseInt(s, 16), n);
            console.warn("THREE.Color: Invalid hex color " + e)
         } else if (e && e.length > 0) return this.setColorName(e, n);
         return this
      }
      setColorName(e, n = Rt) {
         const r = vF[e.toLowerCase()];
         return r !== void 0 ? this.setHex(r, n) : console.warn("THREE.Color: Unknown color " + e), this
      }
      clone() {
         return new this.constructor(this.r, this.g, this.b)
      }
      copy(e) {
         return this.r = e.r, this.g = e.g, this.b = e.b, this
      }
      copySRGBToLinear(e) {
         return this.r = Zc(e.r), this.g = Zc(e.g), this.b = Zc(e.b), this
      }
      copyLinearToSRGB(e) {
         return this.r = r_(e.r), this.g = r_(e.g), this.b = r_(e.b), this
      }
      convertSRGBToLinear() {
         return this.copySRGBToLinear(this), this
      }
      convertLinearToSRGB() {
         return this.copyLinearToSRGB(this), this
      }
      getHex(e = Rt) {
         return ki.fromWorkingColorSpace(Er.copy(this), e), Math.round(On(Er.r * 255, 0, 255)) * 65536 + Math.round(On(Er.g * 255, 0, 255)) * 256 + Math.round(On(Er.b * 255, 0, 255))
      }
      getHexString(e = Rt) {
         return ("000000" + this.getHex(e).toString(16)).slice(-6)
      }
      getHSL(e, n = ki.workingColorSpace) {
         ki.fromWorkingColorSpace(Er.copy(this), n);
         const r = Er.r,
            i = Er.g,
            s = Er.b,
            o = Math.max(r, i, s),
            a = Math.min(r, i, s);
         let l, u;
         const h = (a + o) / 2;
         if (a === o) l = 0, u = 0;
         else {
            const d = o - a;
            switch (u = h <= .5 ? d / (o + a) : d / (2 - o - a), o) {
               case r:
                  l = (i - s) / d + (i < s ? 6 : 0);
                  break;
               case i:
                  l = (s - r) / d + 2;
                  break;
               case s:
                  l = (r - i) / d + 4;
                  break
            }
            l /= 6
         }
         return e.h = l, e.s = u, e.l = h, e
      }
      getRGB(e, n = ki.workingColorSpace) {
         return ki.fromWorkingColorSpace(Er.copy(this), n), e.r = Er.r, e.g = Er.g, e.b = Er.b, e
      }
      getStyle(e = Rt) {
         ki.fromWorkingColorSpace(Er.copy(this), e);
         const n = Er.r,
            r = Er.g,
            i = Er.b;
         return e !== Rt ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(n*255)},${Math.round(r*255)},${Math.round(i*255)})`
      }
      offsetHSL(e, n, r) {
         return this.getHSL(ss), ss.h += e, ss.s += n, ss.l += r, this.setHSL(ss.h, ss.s, ss.l), this
      }
      add(e) {
         return this.r += e.r, this.g += e.g, this.b += e.b, this
      }
      addColors(e, n) {
         return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this
      }
      addScalar(e) {
         return this.r += e, this.g += e, this.b += e, this
      }
      sub(e) {
         return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
      }
      multiply(e) {
         return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
      }
      multiplyScalar(e) {
         return this.r *= e, this.g *= e, this.b *= e, this
      }
      lerp(e, n) {
         return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this
      }
      lerpColors(e, n, r) {
         return this.r = e.r + (n.r - e.r) * r, this.g = e.g + (n.g - e.g) * r, this.b = e.b + (n.b - e.b) * r, this
      }
      lerpHSL(e, n) {
         this.getHSL(ss), e.getHSL(Km);
         const r = ad(ss.h, Km.h, n),
            i = ad(ss.s, Km.s, n),
            s = ad(ss.l, Km.l, n);
         return this.setHSL(r, i, s), this
      }
      setFromVector3(e) {
         return this.r = e.x, this.g = e.y, this.b = e.z, this
      }
      applyMatrix3(e) {
         const n = this.r,
            r = this.g,
            i = this.b,
            s = e.elements;
         return this.r = s[0] * n + s[3] * r + s[6] * i, this.g = s[1] * n + s[4] * r + s[7] * i, this.b = s[2] * n + s[5] * r + s[8] * i, this
      }
      equals(e) {
         return e.r === this.r && e.g === this.g && e.b === this.b
      }
      fromArray(e, n = 0) {
         return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this
      }
      toArray(e = [], n = 0) {
         return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e
      }
      fromBufferAttribute(e, n) {
         return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this
      }
      toJSON() {
         return this.getHex()
      }*[Symbol.iterator]() {
         yield this.r, yield this.g, yield this.b
      }
   }
   const Er = new ke;
   ke.NAMES = vF;
   class mi extends Jn {
      constructor(e) {
         super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ke(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sp, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
      }
   }
   const xo = p5();

   function p5() {
      const t = new ArrayBuffer(4),
         e = new Float32Array(t),
         n = new Uint32Array(t),
         r = new Uint32Array(512),
         i = new Uint32Array(512);
      for (let l = 0; l < 256; ++l) {
         const u = l - 127;
         u < -27 ? (r[l] = 0, r[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : u < -14 ? (r[l] = 1024 >> -u - 14, r[l | 256] = 1024 >> -u - 14 | 32768, i[l] = -u - 1, i[l | 256] = -u - 1) : u <= 15 ? (r[l] = u + 15 << 10, r[l | 256] = u + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : u < 128 ? (r[l] = 31744, r[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (r[l] = 31744, r[l | 256] = 64512, i[l] = 13, i[l | 256] = 13)
      }
      const s = new Uint32Array(2048),
         o = new Uint32Array(64),
         a = new Uint32Array(64);
      for (let l = 1; l < 1024; ++l) {
         let u = l << 13,
            h = 0;
         for (; !(u & 8388608);) u <<= 1, h -= 8388608;
         u &= -8388609, h += 947912704, s[l] = u | h
      }
      for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + (l - 1024 << 13);
      for (let l = 1; l < 31; ++l) o[l] = l << 23;
      o[31] = 1199570944, o[32] = 2147483648;
      for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
      o[63] = 3347054592;
      for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
      return {
         floatView: e,
         uint32View: n,
         baseTable: r,
         shiftTable: i,
         mantissaTable: s,
         exponentTable: o,
         offsetTable: a
      }
   }

   function Jr(t) {
      Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = On(t, -65504, 65504), xo.floatView[0] = t;
      const e = xo.uint32View[0],
         n = e >> 23 & 511;
      return xo.baseTable[n] + ((e & 8388607) >> xo.shiftTable[n])
   }

   function jh(t) {
      const e = t >> 10;
      return xo.uint32View[0] = xo.mantissaTable[xo.offsetTable[e] + (t & 1023)] + xo.exponentTable[e], xo.floatView[0]
   }
   const Dl = {
         toHalfFloat: Jr,
         fromHalfFloat: jh
      },
      Wn = new U,
      Ym = new Se;
   class Zt {
      constructor(e, n, r = !1) {
         if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
         this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = r, this.usage = Ud, this.updateRange = {
            offset: 0,
            count: -1
         }, this.gpuType = dr, this.version = 0
      }
      onUploadCallback() {}
      set needsUpdate(e) {
         e === !0 && this.version++
      }
      setUsage(e) {
         return this.usage = e, this
      }
      copy(e) {
         return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
      }
      copyAt(e, n, r) {
         e *= this.itemSize, r *= n.itemSize;
         for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = n.array[r + i];
         return this
      }
      copyArray(e) {
         return this.array.set(e), this
      }
      applyMatrix3(e) {
         if (this.itemSize === 2)
            for (let n = 0, r = this.count; n < r; n++) Ym.fromBufferAttribute(this, n), Ym.applyMatrix3(e), this.setXY(n, Ym.x, Ym.y);
         else if (this.itemSize === 3)
            for (let n = 0, r = this.count; n < r; n++) Wn.fromBufferAttribute(this, n), Wn.applyMatrix3(e), this.setXYZ(n, Wn.x, Wn.y, Wn.z);
         return this
      }
      applyMatrix4(e) {
         for (let n = 0, r = this.count; n < r; n++) Wn.fromBufferAttribute(this, n), Wn.applyMatrix4(e), this.setXYZ(n, Wn.x, Wn.y, Wn.z);
         return this
      }
      applyNormalMatrix(e) {
         for (let n = 0, r = this.count; n < r; n++) Wn.fromBufferAttribute(this, n), Wn.applyNormalMatrix(e), this.setXYZ(n, Wn.x, Wn.y, Wn.z);
         return this
      }
      transformDirection(e) {
         for (let n = 0, r = this.count; n < r; n++) Wn.fromBufferAttribute(this, n), Wn.transformDirection(e), this.setXYZ(n, Wn.x, Wn.y, Wn.z);
         return this
      }
      set(e, n = 0) {
         return this.array.set(e, n), this
      }
      getComponent(e, n) {
         let r = this.array[e * this.itemSize + n];
         return this.normalized && (r = Qr(r, this.array)), r
      }
      setComponent(e, n, r) {
         return this.normalized && (r = It(r, this.array)), this.array[e * this.itemSize + n] = r, this
      }
      getX(e) {
         let n = this.array[e * this.itemSize];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setX(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize] = n, this
      }
      getY(e) {
         let n = this.array[e * this.itemSize + 1];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setY(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + 1] = n, this
      }
      getZ(e) {
         let n = this.array[e * this.itemSize + 2];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setZ(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + 2] = n, this
      }
      getW(e) {
         let n = this.array[e * this.itemSize + 3];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setW(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + 3] = n, this
      }
      setXY(e, n, r) {
         return e *= this.itemSize, this.normalized && (n = It(n, this.array), r = It(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this
      }
      setXYZ(e, n, r, i) {
         return e *= this.itemSize, this.normalized && (n = It(n, this.array), r = It(r, this.array), i = It(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = i, this
      }
      setXYZW(e, n, r, i, s) {
         return e *= this.itemSize, this.normalized && (n = It(n, this.array), r = It(r, this.array), i = It(i, this.array), s = It(s, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = s, this
      }
      onUpload(e) {
         return this.onUploadCallback = e, this
      }
      clone() {
         return new this.constructor(this.array, this.itemSize).copy(this)
      }
      toJSON() {
         const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
         };
         return this.name !== "" && (e.name = this.name), this.usage !== Ud && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e
      }
   }
   class m5 extends Zt {
      constructor(e, n, r) {
         super(new Int8Array(e), n, r)
      }
   }
   class g5 extends Zt {
      constructor(e, n, r) {
         super(new Uint8Array(e), n, r)
      }
   }
   class v5 extends Zt {
      constructor(e, n, r) {
         super(new Uint8ClampedArray(e), n, r)
      }
   }
   class y5 extends Zt {
      constructor(e, n, r) {
         super(new Int16Array(e), n, r)
      }
   }
   class YM extends Zt {
      constructor(e, n, r) {
         super(new Uint16Array(e), n, r)
      }
   }
   class x5 extends Zt {
      constructor(e, n, r) {
         super(new Int32Array(e), n, r)
      }
   }
   class QM extends Zt {
      constructor(e, n, r) {
         super(new Uint32Array(e), n, r)
      }
   }
   class _5 extends Zt {
      constructor(e, n, r) {
         super(new Uint16Array(e), n, r), this.isFloat16BufferAttribute = !0
      }
      getX(e) {
         let n = jh(this.array[e * this.itemSize]);
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setX(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize] = Jr(n), this
      }
      getY(e) {
         let n = jh(this.array[e * this.itemSize + 1]);
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setY(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + 1] = Jr(n), this
      }
      getZ(e) {
         let n = jh(this.array[e * this.itemSize + 2]);
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setZ(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + 2] = Jr(n), this
      }
      getW(e) {
         let n = jh(this.array[e * this.itemSize + 3]);
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setW(e, n) {
         return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + 3] = Jr(n), this
      }
      setXY(e, n, r) {
         return e *= this.itemSize, this.normalized && (n = It(n, this.array), r = It(r, this.array)), this.array[e + 0] = Jr(n), this.array[e + 1] = Jr(r), this
      }
      setXYZ(e, n, r, i) {
         return e *= this.itemSize, this.normalized && (n = It(n, this.array), r = It(r, this.array), i = It(i, this.array)), this.array[e + 0] = Jr(n), this.array[e + 1] = Jr(r), this.array[e + 2] = Jr(i), this
      }
      setXYZW(e, n, r, i, s) {
         return e *= this.itemSize, this.normalized && (n = It(n, this.array), r = It(r, this.array), i = It(i, this.array), s = It(s, this.array)), this.array[e + 0] = Jr(n), this.array[e + 1] = Jr(r), this.array[e + 2] = Jr(i), this.array[e + 3] = Jr(s), this
      }
   }
   class nt extends Zt {
      constructor(e, n, r) {
         super(new Float32Array(e), n, r)
      }
   }
   class A5 extends Zt {
      constructor(e, n, r) {
         super(new Float64Array(e), n, r)
      }
   }
   let S5 = 0;
   const Oi = new yt,
      g_ = new Wt,
      zu = new U,
      fi = new qi,
      xh = new qi,
      ar = new U;
   class Tt extends Uo {
      constructor() {
         super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: S5++
         }), this.uuid = xi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
         }, this.userData = {}
      }
      getIndex() {
         return this.index
      }
      setIndex(e) {
         return Array.isArray(e) ? this.index = new(mF(e) ? QM : YM)(e, 1) : this.index = e, this
      }
      getAttribute(e) {
         return this.attributes[e]
      }
      setAttribute(e, n) {
         return this.attributes[e] = n, this
      }
      deleteAttribute(e) {
         return delete this.attributes[e], this
      }
      hasAttribute(e) {
         return this.attributes[e] !== void 0
      }
      addGroup(e, n, r = 0) {
         this.groups.push({
            start: e,
            count: n,
            materialIndex: r
         })
      }
      clearGroups() {
         this.groups = []
      }
      setDrawRange(e, n) {
         this.drawRange.start = e, this.drawRange.count = n
      }
      applyMatrix4(e) {
         const n = this.attributes.position;
         n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
         const r = this.attributes.normal;
         if (r !== void 0) {
            const s = new Ft().getNormalMatrix(e);
            r.applyNormalMatrix(s), r.needsUpdate = !0
         }
         const i = this.attributes.tangent;
         return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
      }
      applyQuaternion(e) {
         return Oi.makeRotationFromQuaternion(e), this.applyMatrix4(Oi), this
      }
      rotateX(e) {
         return Oi.makeRotationX(e), this.applyMatrix4(Oi), this
      }
      rotateY(e) {
         return Oi.makeRotationY(e), this.applyMatrix4(Oi), this
      }
      rotateZ(e) {
         return Oi.makeRotationZ(e), this.applyMatrix4(Oi), this
      }
      translate(e, n, r) {
         return Oi.makeTranslation(e, n, r), this.applyMatrix4(Oi), this
      }
      scale(e, n, r) {
         return Oi.makeScale(e, n, r), this.applyMatrix4(Oi), this
      }
      lookAt(e) {
         return g_.lookAt(e), g_.updateMatrix(), this.applyMatrix4(g_.matrix), this
      }
      center() {
         return this.computeBoundingBox(), this.boundingBox.getCenter(zu).negate(), this.translate(zu.x, zu.y, zu.z), this
      }
      setFromPoints(e) {
         const n = [];
         for (let r = 0, i = e.length; r < i; r++) {
            const s = e[r];
            n.push(s.x, s.y, s.z || 0)
         }
         return this.setAttribute("position", new nt(n, 3)), this
      }
      computeBoundingBox() {
         this.boundingBox === null && (this.boundingBox = new qi);
         const e = this.attributes.position,
            n = this.morphAttributes.position;
         if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new U(-1 / 0, -1 / 0, -1 / 0), new U(1 / 0, 1 / 0, 1 / 0));
            return
         }
         if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), n)
               for (let r = 0, i = n.length; r < i; r++) {
                  const s = n[r];
                  fi.setFromBufferAttribute(s), this.morphTargetsRelative ? (ar.addVectors(this.boundingBox.min, fi.min), this.boundingBox.expandByPoint(ar), ar.addVectors(this.boundingBox.max, fi.max), this.boundingBox.expandByPoint(ar)) : (this.boundingBox.expandByPoint(fi.min), this.boundingBox.expandByPoint(fi.max))
               }
         } else this.boundingBox.makeEmpty();
         (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
      }
      computeBoundingSphere() {
         this.boundingSphere === null && (this.boundingSphere = new Ci);
         const e = this.attributes.position,
            n = this.morphAttributes.position;
         if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new U, 1 / 0);
            return
         }
         if (e) {
            const r = this.boundingSphere.center;
            if (fi.setFromBufferAttribute(e), n)
               for (let s = 0, o = n.length; s < o; s++) {
                  const a = n[s];
                  xh.setFromBufferAttribute(a), this.morphTargetsRelative ? (ar.addVectors(fi.min, xh.min), fi.expandByPoint(ar), ar.addVectors(fi.max, xh.max), fi.expandByPoint(ar)) : (fi.expandByPoint(xh.min), fi.expandByPoint(xh.max))
               }
            fi.getCenter(r);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++) ar.fromBufferAttribute(e, s), i = Math.max(i, r.distanceToSquared(ar));
            if (n)
               for (let s = 0, o = n.length; s < o; s++) {
                  const a = n[s],
                     l = this.morphTargetsRelative;
                  for (let u = 0, h = a.count; u < h; u++) ar.fromBufferAttribute(a, u), l && (zu.fromBufferAttribute(e, u), ar.add(zu)), i = Math.max(i, r.distanceToSquared(ar))
               }
            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
         }
      }
      computeTangents() {
         const e = this.index,
            n = this.attributes;
         if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
         }
         const r = e.array,
            i = n.position.array,
            s = n.normal.array,
            o = n.uv.array,
            a = i.length / 3;
         this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Zt(new Float32Array(4 * a), 4));
         const l = this.getAttribute("tangent").array,
            u = [],
            h = [];
         for (let I = 0; I < a; I++) u[I] = new U, h[I] = new U;
         const d = new U,
            p = new U,
            m = new U,
            v = new Se,
            _ = new Se,
            x = new Se,
            g = new U,
            S = new U;

         function A(I, N, q) {
            d.fromArray(i, I * 3), p.fromArray(i, N * 3), m.fromArray(i, q * 3), v.fromArray(o, I * 2), _.fromArray(o, N * 2), x.fromArray(o, q * 2), p.sub(d), m.sub(d), _.sub(v), x.sub(v);
            const K = 1 / (_.x * x.y - x.x * _.y);
            isFinite(K) && (g.copy(p).multiplyScalar(x.y).addScaledVector(m, -_.y).multiplyScalar(K), S.copy(m).multiplyScalar(_.x).addScaledVector(p, -x.x).multiplyScalar(K), u[I].add(g), u[N].add(g), u[q].add(g), h[I].add(S), h[N].add(S), h[q].add(S))
         }
         let E = this.groups;
         E.length === 0 && (E = [{
            start: 0,
            count: r.length
         }]);
         for (let I = 0, N = E.length; I < N; ++I) {
            const q = E[I],
               K = q.start,
               Z = q.count;
            for (let te = K, se = K + Z; te < se; te += 3) A(r[te + 0], r[te + 1], r[te + 2])
         }
         const C = new U,
            R = new U,
            B = new U,
            D = new U;

         function T(I) {
            B.fromArray(s, I * 3), D.copy(B);
            const N = u[I];
            C.copy(N), C.sub(B.multiplyScalar(B.dot(N))).normalize(), R.crossVectors(D, N);
            const K = R.dot(h[I]) < 0 ? -1 : 1;
            l[I * 4] = C.x, l[I * 4 + 1] = C.y, l[I * 4 + 2] = C.z, l[I * 4 + 3] = K
         }
         for (let I = 0, N = E.length; I < N; ++I) {
            const q = E[I],
               K = q.start,
               Z = q.count;
            for (let te = K, se = K + Z; te < se; te += 3) T(r[te + 0]), T(r[te + 1]), T(r[te + 2])
         }
      }
      computeVertexNormals() {
         const e = this.index,
            n = this.getAttribute("position");
         if (n !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0) r = new Zt(new Float32Array(n.count * 3), 3), this.setAttribute("normal", r);
            else
               for (let p = 0, m = r.count; p < m; p++) r.setXYZ(p, 0, 0, 0);
            const i = new U,
               s = new U,
               o = new U,
               a = new U,
               l = new U,
               u = new U,
               h = new U,
               d = new U;
            if (e)
               for (let p = 0, m = e.count; p < m; p += 3) {
                  const v = e.getX(p + 0),
                     _ = e.getX(p + 1),
                     x = e.getX(p + 2);
                  i.fromBufferAttribute(n, v), s.fromBufferAttribute(n, _), o.fromBufferAttribute(n, x), h.subVectors(o, s), d.subVectors(i, s), h.cross(d), a.fromBufferAttribute(r, v), l.fromBufferAttribute(r, _), u.fromBufferAttribute(r, x), a.add(h), l.add(h), u.add(h), r.setXYZ(v, a.x, a.y, a.z), r.setXYZ(_, l.x, l.y, l.z), r.setXYZ(x, u.x, u.y, u.z)
               } else
                  for (let p = 0, m = n.count; p < m; p += 3) i.fromBufferAttribute(n, p + 0), s.fromBufferAttribute(n, p + 1), o.fromBufferAttribute(n, p + 2), h.subVectors(o, s), d.subVectors(i, s), h.cross(d), r.setXYZ(p + 0, h.x, h.y, h.z), r.setXYZ(p + 1, h.x, h.y, h.z), r.setXYZ(p + 2, h.x, h.y, h.z);
            this.normalizeNormals(), r.needsUpdate = !0
         }
      }
      normalizeNormals() {
         const e = this.attributes.normal;
         for (let n = 0, r = e.count; n < r; n++) ar.fromBufferAttribute(e, n), ar.normalize(), e.setXYZ(n, ar.x, ar.y, ar.z)
      }
      toNonIndexed() {
         function e(a, l) {
            const u = a.array,
               h = a.itemSize,
               d = a.normalized,
               p = new u.constructor(l.length * h);
            let m = 0,
               v = 0;
            for (let _ = 0, x = l.length; _ < x; _++) {
               a.isInterleavedBufferAttribute ? m = l[_] * a.data.stride + a.offset : m = l[_] * h;
               for (let g = 0; g < h; g++) p[v++] = u[m++]
            }
            return new Zt(p, h, d)
         }
         if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
         const n = new Tt,
            r = this.index.array,
            i = this.attributes;
         for (const a in i) {
            const l = i[a],
               u = e(l, r);
            n.setAttribute(a, u)
         }
         const s = this.morphAttributes;
         for (const a in s) {
            const l = [],
               u = s[a];
            for (let h = 0, d = u.length; h < d; h++) {
               const p = u[h],
                  m = e(p, r);
               l.push(m)
            }
            n.morphAttributes[a] = l
         }
         n.morphTargetsRelative = this.morphTargetsRelative;
         const o = this.groups;
         for (let a = 0, l = o.length; a < l; a++) {
            const u = o[a];
            n.addGroup(u.start, u.count, u.materialIndex)
         }
         return n
      }
      toJSON() {
         const e = {
            metadata: {
               version: 4.6,
               type: "BufferGeometry",
               generator: "BufferGeometry.toJSON"
            }
         };
         if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const u in l) l[u] !== void 0 && (e[u] = l[u]);
            return e
         }
         e.data = {
            attributes: {}
         };
         const n = this.index;
         n !== null && (e.data.index = {
            type: n.array.constructor.name,
            array: Array.prototype.slice.call(n.array)
         });
         const r = this.attributes;
         for (const l in r) {
            const u = r[l];
            e.data.attributes[l] = u.toJSON(e.data)
         }
         const i = {};
         let s = !1;
         for (const l in this.morphAttributes) {
            const u = this.morphAttributes[l],
               h = [];
            for (let d = 0, p = u.length; d < p; d++) {
               const m = u[d];
               h.push(m.toJSON(e.data))
            }
            h.length > 0 && (i[l] = h, s = !0)
         }
         s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
         const o = this.groups;
         o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
         const a = this.boundingSphere;
         return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
         }), e
      }
      clone() {
         return new this.constructor().copy(this)
      }
      copy(e) {
         this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
         const n = {};
         this.name = e.name;
         const r = e.index;
         r !== null && this.setIndex(r.clone(n));
         const i = e.attributes;
         for (const u in i) {
            const h = i[u];
            this.setAttribute(u, h.clone(n))
         }
         const s = e.morphAttributes;
         for (const u in s) {
            const h = [],
               d = s[u];
            for (let p = 0, m = d.length; p < m; p++) h.push(d[p].clone(n));
            this.morphAttributes[u] = h
         }
         this.morphTargetsRelative = e.morphTargetsRelative;
         const o = e.groups;
         for (let u = 0, h = o.length; u < h; u++) {
            const d = o[u];
            this.addGroup(d.start, d.count, d.materialIndex)
         }
         const a = e.boundingBox;
         a !== null && (this.boundingBox = a.clone());
         const l = e.boundingSphere;
         return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
      }
      dispose() {
         this.dispatchEvent({
            type: "dispose"
         })
      }
   }
   const YT = new yt,
      ul = new Cf,
      Qm = new Ci,
      QT = new U,
      Vu = new U,
      Wu = new U,
      ju = new U,
      v_ = new U,
      Zm = new U,
      qm = new Se,
      eg = new Se,
      tg = new Se,
      ZT = new U,
      qT = new U,
      eR = new U,
      ng = new U,
      rg = new U;
   class Xn extends Wt {
      constructor(e = new Tt, n = new mi) {
         super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets()
      }
      copy(e, n) {
         return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
      }
      updateMorphTargets() {
         const n = this.geometry.morphAttributes,
            r = Object.keys(n);
         if (r.length > 0) {
            const i = n[r[0]];
            if (i !== void 0) {
               this.morphTargetInfluences = [], this.morphTargetDictionary = {};
               for (let s = 0, o = i.length; s < o; s++) {
                  const a = i[s].name || String(s);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
               }
            }
         }
      }
      getVertexPosition(e, n) {
         const r = this.geometry,
            i = r.attributes.position,
            s = r.morphAttributes.position,
            o = r.morphTargetsRelative;
         n.fromBufferAttribute(i, e);
         const a = this.morphTargetInfluences;
         if (s && a) {
            Zm.set(0, 0, 0);
            for (let l = 0, u = s.length; l < u; l++) {
               const h = a[l],
                  d = s[l];
               h !== 0 && (v_.fromBufferAttribute(d, e), o ? Zm.addScaledVector(v_, h) : Zm.addScaledVector(v_.sub(n), h))
            }
            n.add(Zm)
         }
         return n
      }
      raycast(e, n) {
         const r = this.geometry,
            i = this.material,
            s = this.matrixWorld;
         i !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), Qm.copy(r.boundingSphere), Qm.applyMatrix4(s), ul.copy(e.ray).recast(e.near), !(Qm.containsPoint(ul.origin) === !1 && (ul.intersectSphere(Qm, QT) === null || ul.origin.distanceToSquared(QT) > (e.far - e.near) ** 2)) && (YT.copy(s).invert(), ul.copy(e.ray).applyMatrix4(YT), !(r.boundingBox !== null && ul.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, n, ul)))
      }
      _computeIntersections(e, n, r) {
         let i;
         const s = this.geometry,
            o = this.material,
            a = s.index,
            l = s.attributes.position,
            u = s.attributes.uv,
            h = s.attributes.uv1,
            d = s.attributes.normal,
            p = s.groups,
            m = s.drawRange;
         if (a !== null)
            if (Array.isArray(o))
               for (let v = 0, _ = p.length; v < _; v++) {
                  const x = p[v],
                     g = o[x.materialIndex],
                     S = Math.max(x.start, m.start),
                     A = Math.min(a.count, Math.min(x.start + x.count, m.start + m.count));
                  for (let E = S, C = A; E < C; E += 3) {
                     const R = a.getX(E),
                        B = a.getX(E + 1),
                        D = a.getX(E + 2);
                     i = ig(this, g, e, r, u, h, d, R, B, D), i && (i.faceIndex = Math.floor(E / 3), i.face.materialIndex = x.materialIndex, n.push(i))
                  }
               } else {
                  const v = Math.max(0, m.start),
                     _ = Math.min(a.count, m.start + m.count);
                  for (let x = v, g = _; x < g; x += 3) {
                     const S = a.getX(x),
                        A = a.getX(x + 1),
                        E = a.getX(x + 2);
                     i = ig(this, o, e, r, u, h, d, S, A, E), i && (i.faceIndex = Math.floor(x / 3), n.push(i))
                  }
               } else if (l !== void 0)
                  if (Array.isArray(o))
                     for (let v = 0, _ = p.length; v < _; v++) {
                        const x = p[v],
                           g = o[x.materialIndex],
                           S = Math.max(x.start, m.start),
                           A = Math.min(l.count, Math.min(x.start + x.count, m.start + m.count));
                        for (let E = S, C = A; E < C; E += 3) {
                           const R = E,
                              B = E + 1,
                              D = E + 2;
                           i = ig(this, g, e, r, u, h, d, R, B, D), i && (i.faceIndex = Math.floor(E / 3), i.face.materialIndex = x.materialIndex, n.push(i))
                        }
                     } else {
                        const v = Math.max(0, m.start),
                           _ = Math.min(l.count, m.start + m.count);
                        for (let x = v, g = _; x < g; x += 3) {
                           const S = x,
                              A = x + 1,
                              E = x + 2;
                           i = ig(this, o, e, r, u, h, d, S, A, E), i && (i.faceIndex = Math.floor(x / 3), n.push(i))
                        }
                     }
      }
   }

   function M5(t, e, n, r, i, s, o, a) {
      let l;
      if (e.side === zr ? l = r.intersectTriangle(o, s, i, !0, a) : l = r.intersectTriangle(i, s, o, e.side === Js, a), l === null) return null;
      rg.copy(a), rg.applyMatrix4(t.matrixWorld);
      const u = n.ray.origin.distanceTo(rg);
      return u < n.near || u > n.far ? null : {
         distance: u,
         point: rg.clone(),
         object: t
      }
   }

   function ig(t, e, n, r, i, s, o, a, l, u) {
      t.getVertexPosition(a, Vu), t.getVertexPosition(l, Wu), t.getVertexPosition(u, ju);
      const h = M5(t, e, n, r, Vu, Wu, ju, ng);
      if (h) {
         i && (qm.fromBufferAttribute(i, a), eg.fromBufferAttribute(i, l), tg.fromBufferAttribute(i, u), h.uv = Yr.getInterpolation(ng, Vu, Wu, ju, qm, eg, tg, new Se)), s && (qm.fromBufferAttribute(s, a), eg.fromBufferAttribute(s, l), tg.fromBufferAttribute(s, u), h.uv1 = Yr.getInterpolation(ng, Vu, Wu, ju, qm, eg, tg, new Se), h.uv2 = h.uv1), o && (ZT.fromBufferAttribute(o, a), qT.fromBufferAttribute(o, l), eR.fromBufferAttribute(o, u), h.normal = Yr.getInterpolation(ng, Vu, Wu, ju, ZT, qT, eR, new U), h.normal.dot(r.direction) > 0 && h.normal.multiplyScalar(-1));
         const d = {
            a,
            b: l,
            c: u,
            normal: new U,
            materialIndex: 0
         };
         Yr.getNormal(Vu, Wu, ju, d.normal), h.face = d
      }
      return h
   }
   class ru extends Tt {
      constructor(e = 1, n = 1, r = 1, i = 1, s = 1, o = 1) {
         super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: n,
            depth: r,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
         };
         const a = this;
         i = Math.floor(i), s = Math.floor(s), o = Math.floor(o);
         const l = [],
            u = [],
            h = [],
            d = [];
         let p = 0,
            m = 0;
         v("z", "y", "x", -1, -1, r, n, e, o, s, 0), v("z", "y", "x", 1, -1, r, n, -e, o, s, 1), v("x", "z", "y", 1, 1, e, r, n, i, o, 2), v("x", "z", "y", 1, -1, e, r, -n, i, o, 3), v("x", "y", "z", 1, -1, e, n, r, i, s, 4), v("x", "y", "z", -1, -1, e, n, -r, i, s, 5), this.setIndex(l), this.setAttribute("position", new nt(u, 3)), this.setAttribute("normal", new nt(h, 3)), this.setAttribute("uv", new nt(d, 2));

         function v(_, x, g, S, A, E, C, R, B, D, T) {
            const I = E / B,
               N = C / D,
               q = E / 2,
               K = C / 2,
               Z = R / 2,
               te = B + 1,
               se = D + 1;
            let oe = 0,
               G = 0;
            const ne = new U;
            for (let Y = 0; Y < se; Y++) {
               const X = Y * N - K;
               for (let Q = 0; Q < te; Q++) {
                  const _e = Q * I - q;
                  ne[_] = _e * S, ne[x] = X * A, ne[g] = Z, u.push(ne.x, ne.y, ne.z), ne[_] = 0, ne[x] = 0, ne[g] = R > 0 ? 1 : -1, h.push(ne.x, ne.y, ne.z), d.push(Q / B), d.push(1 - Y / D), oe += 1
               }
            }
            for (let Y = 0; Y < D; Y++)
               for (let X = 0; X < B; X++) {
                  const Q = p + X + te * Y,
                     _e = p + X + te * (Y + 1),
                     Me = p + (X + 1) + te * (Y + 1),
                     we = p + (X + 1) + te * Y;
                  l.push(Q, _e, we), l.push(_e, Me, we), G += 6
               }
            a.addGroup(m, G, T), m += G, p += oe
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new ru(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
      }
   }

   function pf(t) {
      const e = {};
      for (const n in t) {
         e[n] = {};
         for (const r in t[n]) {
            const i = t[n][r];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][r] = null) : e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
         }
      }
      return e
   }

   function Or(t) {
      const e = {};
      for (let n = 0; n < t.length; n++) {
         const r = pf(t[n]);
         for (const i in r) e[i] = r[i]
      }
      return e
   }

   function E5(t) {
      const e = [];
      for (let n = 0; n < t.length; n++) e.push(t[n].clone());
      return e
   }

   function yF(t) {
      return t.getRenderTarget() === null ? t.outputColorSpace : ys
   }
   const ZM = {
      clone: pf,
      merge: Or
   };
   var w5 = `void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
      b5 = `void main() {
    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
   class Qi extends Jn {
      constructor(e) {
         super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = w5, this.fragmentShader = b5, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
         }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
         }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = pf(e.uniforms), this.uniformsGroups = E5(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
      }
      toJSON(e) {
         const n = super.toJSON(e);
         n.glslVersion = this.glslVersion, n.uniforms = {};
         for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? n.uniforms[i] = {
               type: "t",
               value: o.toJSON(e).uuid
            } : o && o.isColor ? n.uniforms[i] = {
               type: "c",
               value: o.getHex()
            } : o && o.isVector2 ? n.uniforms[i] = {
               type: "v2",
               value: o.toArray()
            } : o && o.isVector3 ? n.uniforms[i] = {
               type: "v3",
               value: o.toArray()
            } : o && o.isVector4 ? n.uniforms[i] = {
               type: "v4",
               value: o.toArray()
            } : o && o.isMatrix3 ? n.uniforms[i] = {
               type: "m3",
               value: o.toArray()
            } : o && o.isMatrix4 ? n.uniforms[i] = {
               type: "m4",
               value: o.toArray()
            } : n.uniforms[i] = {
               value: o
            }
         }
         Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
         const r = {};
         for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
         return Object.keys(r).length > 0 && (n.extensions = r), n
      }
   }
   class op extends Wt {
      constructor() {
         super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new yt, this.projectionMatrix = new yt, this.projectionMatrixInverse = new yt, this.coordinateSystem = ks
      }
      copy(e, n) {
         return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
      }
      getWorldDirection(e) {
         this.updateWorldMatrix(!0, !1);
         const n = this.matrixWorld.elements;
         return e.set(-n[8], -n[9], -n[10]).normalize()
      }
      updateMatrixWorld(e) {
         super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
      }
      updateWorldMatrix(e, n) {
         super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert()
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   class Zn extends op {
      constructor(e = 50, n = 1, r = .1, i = 2e3) {
         super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
      }
      copy(e, n) {
         return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
      }
      setFocalLength(e) {
         const n = .5 * this.getFilmHeight() / e;
         this.fov = df * 2 * Math.atan(n), this.updateProjectionMatrix()
      }
      getFocalLength() {
         const e = Math.tan(Gl * .5 * this.fov);
         return .5 * this.getFilmHeight() / e
      }
      getEffectiveFOV() {
         return df * 2 * Math.atan(Math.tan(Gl * .5 * this.fov) / this.zoom)
      }
      getFilmWidth() {
         return this.filmGauge * Math.min(this.aspect, 1)
      }
      getFilmHeight() {
         return this.filmGauge / Math.max(this.aspect, 1)
      }
      setViewOffset(e, n, r, i, s, o) {
         this.aspect = e / n, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
         }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
      }
      clearViewOffset() {
         this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
      }
      updateProjectionMatrix() {
         const e = this.near;
         let n = e * Math.tan(Gl * .5 * this.fov) / this.zoom,
            r = 2 * n,
            i = this.aspect * r,
            s = -.5 * i;
         const o = this.view;
         if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
               u = o.fullHeight;
            s += o.offsetX * i / l, n -= o.offsetY * r / u, i *= o.width / l, r *= o.height / u
         }
         const a = this.filmOffset;
         a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, n, n - r, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n
      }
   }
   const $u = -90,
      Xu = 1;
   class xF extends Wt {
      constructor(e, n, r) {
         super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null;
         const i = new Zn($u, Xu, e, n);
         i.layers = this.layers, this.add(i);
         const s = new Zn($u, Xu, e, n);
         s.layers = this.layers, this.add(s);
         const o = new Zn($u, Xu, e, n);
         o.layers = this.layers, this.add(o);
         const a = new Zn($u, Xu, e, n);
         a.layers = this.layers, this.add(a);
         const l = new Zn($u, Xu, e, n);
         l.layers = this.layers, this.add(l);
         const u = new Zn($u, Xu, e, n);
         u.layers = this.layers, this.add(u)
      }
      updateCoordinateSystem() {
         const e = this.coordinateSystem,
            n = this.children.concat(),
            [r, i, s, o, a, l] = n;
         for (const u of n) this.remove(u);
         if (e === ks) r.up.set(0, 1, 0), r.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
         else if (e === kd) r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
         else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
         for (const u of n) this.add(u), u.updateMatrixWorld()
      }
      update(e, n) {
         this.parent === null && this.updateMatrixWorld();
         const r = this.renderTarget;
         this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
         const [i, s, o, a, l, u] = this.children, h = e.getRenderTarget(), d = e.xr.enabled;
         e.xr.enabled = !1;
         const p = r.texture.generateMipmaps;
         r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(n, i), e.setRenderTarget(r, 1), e.render(n, s), e.setRenderTarget(r, 2), e.render(n, o), e.setRenderTarget(r, 3), e.render(n, a), e.setRenderTarget(r, 4), e.render(n, l), r.texture.generateMipmaps = p, e.setRenderTarget(r, 5), e.render(n, u), e.setRenderTarget(h), e.xr.enabled = d, r.texture.needsPMREMUpdate = !0
      }
   }
   class ap extends yn {
      constructor(e, n, r, i, s, o, a, l, u, h) {
         e = e !== void 0 ? e : [], n = n !== void 0 ? n : Ks, super(e, n, r, i, s, o, a, l, u, h), this.isCubeTexture = !0, this.flipY = !1
      }
      get images() {
         return this.image
      }
      set images(e) {
         this.image = e
      }
   }
   class qM extends Ai {
      constructor(e = 1, n = {}) {
         super(e, e, n), this.isWebGLCubeRenderTarget = !0;
         const r = {
               width: e,
               height: e,
               depth: 1
            },
            i = [r, r, r, r, r, r];
         n.encoding !== void 0 && (ld("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === Ta ? Rt : Ra), this.texture = new ap(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : ln
      }
      fromEquirectangularTexture(e, n) {
         this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
         const r = {
               uniforms: {
                  tEquirect: {
                     value: null
                  }
               },
               vertexShader: `

                varying vec3 vWorldDirection;

                vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

                    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

                }

                void main() {

                    vWorldDirection = transformDirection( position, modelMatrix );

                    #include <begin_vertex>
                    #include <project_vertex>

                }
            `,
               fragmentShader: `

                uniform sampler2D tEquirect;

                varying vec3 vWorldDirection;

                #include <common>

                void main() {

                    vec3 direction = normalize( vWorldDirection );

                    vec2 sampleUV = equirectUv( direction );

                    gl_FragColor = texture2D( tEquirect, sampleUV );

                }
            `
            },
            i = new ru(5, 5, 5),
            s = new Qi({
               name: "CubemapFromEquirect",
               uniforms: pf(r.uniforms),
               vertexShader: r.vertexShader,
               fragmentShader: r.fragmentShader,
               side: zr,
               blending: Co
            });
         s.uniforms.tEquirect.value = n;
         const o = new Xn(i, s),
            a = n.minFilter;
         return n.minFilter === Ys && (n.minFilter = ln), new xF(1, 10, this).update(e, o), n.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
      }
      clear(e, n, r, i) {
         const s = e.getRenderTarget();
         for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(n, r, i);
         e.setRenderTarget(s)
      }
   }
   const y_ = new U,
      C5 = new U,
      T5 = new Ft;
   class la {
      constructor(e = new U(1, 0, 0), n = 0) {
         this.isPlane = !0, this.normal = e, this.constant = n
      }
      set(e, n) {
         return this.normal.copy(e), this.constant = n, this
      }
      setComponents(e, n, r, i) {
         return this.normal.set(e, n, r), this.constant = i, this
      }
      setFromNormalAndCoplanarPoint(e, n) {
         return this.normal.copy(e), this.constant = -n.dot(this.normal), this
      }
      setFromCoplanarPoints(e, n, r) {
         const i = y_.subVectors(r, n).cross(C5.subVectors(e, n)).normalize();
         return this.setFromNormalAndCoplanarPoint(i, e), this
      }
      copy(e) {
         return this.normal.copy(e.normal), this.constant = e.constant, this
      }
      normalize() {
         const e = 1 / this.normal.length();
         return this.normal.multiplyScalar(e), this.constant *= e, this
      }
      negate() {
         return this.constant *= -1, this.normal.negate(), this
      }
      distanceToPoint(e) {
         return this.normal.dot(e) + this.constant
      }
      distanceToSphere(e) {
         return this.distanceToPoint(e.center) - e.radius
      }
      projectPoint(e, n) {
         return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
      }
      intersectLine(e, n) {
         const r = e.delta(y_),
            i = this.normal.dot(r);
         if (i === 0) return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
         const s = -(e.start.dot(this.normal) + this.constant) / i;
         return s < 0 || s > 1 ? null : n.copy(e.start).addScaledVector(r, s)
      }
      intersectsLine(e) {
         const n = this.distanceToPoint(e.start),
            r = this.distanceToPoint(e.end);
         return n < 0 && r > 0 || r < 0 && n > 0
      }
      intersectsBox(e) {
         return e.intersectsPlane(this)
      }
      intersectsSphere(e) {
         return e.intersectsPlane(this)
      }
      coplanarPoint(e) {
         return e.copy(this.normal).multiplyScalar(-this.constant)
      }
      applyMatrix4(e, n) {
         const r = n || T5.getNormalMatrix(e),
            i = this.coplanarPoint(y_).applyMatrix4(e),
            s = this.normal.applyMatrix3(r).normalize();
         return this.constant = -i.dot(s), this
      }
      translate(e) {
         return this.constant -= e.dot(this.normal), this
      }
      equals(e) {
         return e.normal.equals(this.normal) && e.constant === this.constant
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   const cl = new Ci,
      sg = new U;
   class Iv {
      constructor(e = new la, n = new la, r = new la, i = new la, s = new la, o = new la) {
         this.planes = [e, n, r, i, s, o]
      }
      set(e, n, r, i, s, o) {
         const a = this.planes;
         return a[0].copy(e), a[1].copy(n), a[2].copy(r), a[3].copy(i), a[4].copy(s), a[5].copy(o), this
      }
      copy(e) {
         const n = this.planes;
         for (let r = 0; r < 6; r++) n[r].copy(e.planes[r]);
         return this
      }
      setFromProjectionMatrix(e, n = ks) {
         const r = this.planes,
            i = e.elements,
            s = i[0],
            o = i[1],
            a = i[2],
            l = i[3],
            u = i[4],
            h = i[5],
            d = i[6],
            p = i[7],
            m = i[8],
            v = i[9],
            _ = i[10],
            x = i[11],
            g = i[12],
            S = i[13],
            A = i[14],
            E = i[15];
         if (r[0].setComponents(l - s, p - u, x - m, E - g).normalize(), r[1].setComponents(l + s, p + u, x + m, E + g).normalize(), r[2].setComponents(l + o, p + h, x + v, E + S).normalize(), r[3].setComponents(l - o, p - h, x - v, E - S).normalize(), r[4].setComponents(l - a, p - d, x - _, E - A).normalize(), n === ks) r[5].setComponents(l + a, p + d, x + _, E + A).normalize();
         else if (n === kd) r[5].setComponents(a, d, _, A).normalize();
         else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
         return this
      }
      intersectsObject(e) {
         if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), cl.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
         else {
            const n = e.geometry;
            n.boundingSphere === null && n.computeBoundingSphere(), cl.copy(n.boundingSphere).applyMatrix4(e.matrixWorld)
         }
         return this.intersectsSphere(cl)
      }
      intersectsSprite(e) {
         return cl.center.set(0, 0, 0), cl.radius = .7071067811865476, cl.applyMatrix4(e.matrixWorld), this.intersectsSphere(cl)
      }
      intersectsSphere(e) {
         const n = this.planes,
            r = e.center,
            i = -e.radius;
         for (let s = 0; s < 6; s++)
            if (n[s].distanceToPoint(r) < i) return !1;
         return !0
      }
      intersectsBox(e) {
         const n = this.planes;
         for (let r = 0; r < 6; r++) {
            const i = n[r];
            if (sg.x = i.normal.x > 0 ? e.max.x : e.min.x, sg.y = i.normal.y > 0 ? e.max.y : e.min.y, sg.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(sg) < 0) return !1
         }
         return !0
      }
      containsPoint(e) {
         const n = this.planes;
         for (let r = 0; r < 6; r++)
            if (n[r].distanceToPoint(e) < 0) return !1;
         return !0
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }

   function _F() {
      let t = null,
         e = !1,
         n = null,
         r = null;

      function i(s, o) {
         n(s, o), r = t.requestAnimationFrame(i)
      }
      return {
         start: function () {
            e !== !0 && n !== null && (r = t.requestAnimationFrame(i), e = !0)
         },
         stop: function () {
            t.cancelAnimationFrame(r), e = !1
         },
         setAnimationLoop: function (s) {
            n = s
         },
         setContext: function (s) {
            t = s
         }
      }
   }

   function R5(t, e) {
      const n = e.isWebGL2,
         r = new WeakMap;

      function i(u, h) {
         const d = u.array,
            p = u.usage,
            m = t.createBuffer();
         t.bindBuffer(h, m), t.bufferData(h, d, p), u.onUploadCallback();
         let v;
         if (d instanceof Float32Array) v = t.FLOAT;
         else if (d instanceof Uint16Array)
            if (u.isFloat16BufferAttribute)
               if (n) v = t.HALF_FLOAT;
               else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
         else v = t.UNSIGNED_SHORT;
         else if (d instanceof Int16Array) v = t.SHORT;
         else if (d instanceof Uint32Array) v = t.UNSIGNED_INT;
         else if (d instanceof Int32Array) v = t.INT;
         else if (d instanceof Int8Array) v = t.BYTE;
         else if (d instanceof Uint8Array) v = t.UNSIGNED_BYTE;
         else if (d instanceof Uint8ClampedArray) v = t.UNSIGNED_BYTE;
         else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
         return {
            buffer: m,
            type: v,
            bytesPerElement: d.BYTES_PER_ELEMENT,
            version: u.version
         }
      }

      function s(u, h, d) {
         const p = h.array,
            m = h.updateRange;
         t.bindBuffer(d, u), m.count === -1 ? t.bufferSubData(d, 0, p) : (n ? t.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : t.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)), m.count = -1), h.onUploadCallback()
      }

      function o(u) {
         return u.isInterleavedBufferAttribute && (u = u.data), r.get(u)
      }

      function a(u) {
         u.isInterleavedBufferAttribute && (u = u.data);
         const h = r.get(u);
         h && (t.deleteBuffer(h.buffer), r.delete(u))
      }

      function l(u, h) {
         if (u.isGLBufferAttribute) {
            const p = r.get(u);
            (!p || p.version < u.version) && r.set(u, {
               buffer: u.buffer,
               type: u.type,
               bytesPerElement: u.elementSize,
               version: u.version
            });
            return
         }
         u.isInterleavedBufferAttribute && (u = u.data);
         const d = r.get(u);
         d === void 0 ? r.set(u, i(u, h)) : d.version < u.version && (s(d.buffer, u, h), d.version = u.version)
      }
      return {
         get: o,
         remove: a,
         update: l
      }
   }
   class lp extends Tt {
      constructor(e = 1, n = 1, r = 1, i = 1) {
         super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: n,
            widthSegments: r,
            heightSegments: i
         };
         const s = e / 2,
            o = n / 2,
            a = Math.floor(r),
            l = Math.floor(i),
            u = a + 1,
            h = l + 1,
            d = e / a,
            p = n / l,
            m = [],
            v = [],
            _ = [],
            x = [];
         for (let g = 0; g < h; g++) {
            const S = g * p - o;
            for (let A = 0; A < u; A++) {
               const E = A * d - s;
               v.push(E, -S, 0), _.push(0, 0, 1), x.push(A / a), x.push(1 - g / l)
            }
         }
         for (let g = 0; g < l; g++)
            for (let S = 0; S < a; S++) {
               const A = S + u * g,
                  E = S + u * (g + 1),
                  C = S + 1 + u * (g + 1),
                  R = S + 1 + u * g;
               m.push(A, E, R), m.push(E, C, R)
            }
         this.setIndex(m), this.setAttribute("position", new nt(v, 3)), this.setAttribute("normal", new nt(_, 3)), this.setAttribute("uv", new nt(x, 2))
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new lp(e.width, e.height, e.widthSegments, e.heightSegments)
      }
   }
   var P5 = `#ifdef USE_ALPHAHASH
    if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
      B5 = `#ifdef USE_ALPHAHASH
    const float ALPHA_HASH_SCALE = 0.05;
    float hash2D( vec2 value ) {
        return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
    }
    float hash3D( vec3 value ) {
        return hash2D( vec2( hash2D( value.xy ), value.z ) );
    }
    float getAlphaHashThreshold( vec3 position ) {
        float maxDeriv = max(
            length( dFdx( position.xyz ) ),
            length( dFdy( position.xyz ) )
        );
        float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
        vec2 pixScales = vec2(
            exp2( floor( log2( pixScale ) ) ),
            exp2( ceil( log2( pixScale ) ) )
        );
        vec2 alpha = vec2(
            hash3D( floor( pixScales.x * position.xyz ) ),
            hash3D( floor( pixScales.y * position.xyz ) )
        );
        float lerpFactor = fract( log2( pixScale ) );
        float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
        float a = min( lerpFactor, 1.0 - lerpFactor );
        vec3 cases = vec3(
            x * x / ( 2.0 * a * ( 1.0 - a ) ),
            ( x - 0.5 * a ) / ( 1.0 - a ),
            1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
        );
        float threshold = ( x < ( 1.0 - a ) )
            ? ( ( x < a ) ? cases.x : cases.y )
            : cases.z;
        return clamp( threshold , 1.0e-6, 1.0 );
    }
#endif`,
      I5 = `#ifdef USE_ALPHAMAP
    diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
      L5 = `#ifdef USE_ALPHAMAP
    uniform sampler2D alphaMap;
#endif`,
      D5 = `#ifdef USE_ALPHATEST
    if ( diffuseColor.a < alphaTest ) discard;
#endif`,
      F5 = `#ifdef USE_ALPHATEST
    uniform float alphaTest;
#endif`,
      O5 = `#ifdef USE_AOMAP
    float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
    reflectedLight.indirectDiffuse *= ambientOcclusion;
    #if defined( USE_ENVMAP ) && defined( STANDARD )
        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
    #endif
#endif`,
      N5 = `#ifdef USE_AOMAP
    uniform sampler2D aoMap;
    uniform float aoMapIntensity;
#endif`,
      U5 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
    vPosition = vec3( position );
#endif`,
      k5 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
    vec3 objectTangent = vec3( tangent.xyz );
#endif`,
      H5 = `float G_BlinnPhong_Implicit( ) {
    return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
    vec3 halfDir = normalize( lightDir + viewDir );
    float dotNH = saturate( dot( normal, halfDir ) );
    float dotVH = saturate( dot( viewDir, halfDir ) );
    vec3 F = F_Schlick( specularColor, 1.0, dotVH );
    float G = G_BlinnPhong_Implicit( );
    float D = D_BlinnPhong( shininess, dotNH );
    return F * ( G * D );
} // validated`,
      G5 = `#ifdef USE_IRIDESCENCE
    const mat3 XYZ_TO_REC709 = mat3(
         3.2404542, -0.9692660,  0.0556434,
        -1.5371385,  1.8760108, -0.2040259,
        -0.4985314,  0.0415560,  1.0572252
    );
    vec3 Fresnel0ToIor( vec3 fresnel0 ) {
        vec3 sqrtF0 = sqrt( fresnel0 );
        return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
    }
    vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
        return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
    }
    float IorToFresnel0( float transmittedIor, float incidentIor ) {
        return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
    }
    vec3 evalSensitivity( float OPD, vec3 shift ) {
        float phase = 2.0 * PI * OPD * 1.0e-9;
        vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
        vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
        vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
        vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
        xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
        xyz /= 1.0685e-7;
        vec3 rgb = XYZ_TO_REC709 * xyz;
        return rgb;
    }
    vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
        vec3 I;
        float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
        float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
        float cosTheta2Sq = 1.0 - sinTheta2Sq;
        if ( cosTheta2Sq < 0.0 ) {
            return vec3( 1.0 );
        }
        float cosTheta2 = sqrt( cosTheta2Sq );
        float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
        float R12 = F_Schlick( R0, 1.0, cosTheta1 );
        float T121 = 1.0 - R12;
        float phi12 = 0.0;
        if ( iridescenceIOR < outsideIOR ) phi12 = PI;
        float phi21 = PI - phi12;
        vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );       vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
        vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
        vec3 phi23 = vec3( 0.0 );
        if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
        if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
        if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
        float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
        vec3 phi = vec3( phi21 ) + phi23;
        vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
        vec3 r123 = sqrt( R123 );
        vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
        vec3 C0 = R12 + Rs;
        I = C0;
        vec3 Cm = Rs - T121;
        for ( int m = 1; m <= 2; ++ m ) {
            Cm *= r123;
            vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
            I += Cm * Sm;
        }
        return max( I, vec3( 0.0 ) );
    }
#endif`,
      z5 = `#ifdef USE_BUMPMAP
    uniform sampler2D bumpMap;
    uniform float bumpScale;
    vec2 dHdxy_fwd() {
        vec2 dSTdx = dFdx( vBumpMapUv );
        vec2 dSTdy = dFdy( vBumpMapUv );
        float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
        float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
        float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
        return vec2( dBx, dBy );
    }
    vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
        vec3 vSigmaX = dFdx( surf_pos.xyz );
        vec3 vSigmaY = dFdy( surf_pos.xyz );
        vec3 vN = surf_norm;
        vec3 R1 = cross( vSigmaY, vN );
        vec3 R2 = cross( vN, vSigmaX );
        float fDet = dot( vSigmaX, R1 ) * faceDirection;
        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
        return normalize( abs( fDet ) * surf_norm - vGrad );
    }
#endif`,
      V5 = `#if NUM_CLIPPING_PLANES > 0
    vec4 plane;
    #pragma unroll_loop_start
    for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
        plane = clippingPlanes[ i ];
        if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
    }
    #pragma unroll_loop_end
    #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
        bool clipped = true;
        #pragma unroll_loop_start
        for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
            plane = clippingPlanes[ i ];
            clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
        }
        #pragma unroll_loop_end
        if ( clipped ) discard;
    #endif
#endif`,
      W5 = `#if NUM_CLIPPING_PLANES > 0
    varying vec3 vClipPosition;
    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
      j5 = `#if NUM_CLIPPING_PLANES > 0
    varying vec3 vClipPosition;
#endif`,
      $5 = `#if NUM_CLIPPING_PLANES > 0
    vClipPosition = - mvPosition.xyz;
#endif`,
      X5 = `#if defined( USE_COLOR_ALPHA )
    diffuseColor *= vColor;
#elif defined( USE_COLOR )
    diffuseColor.rgb *= vColor;
#endif`,
      J5 = `#if defined( USE_COLOR_ALPHA )
    varying vec4 vColor;
#elif defined( USE_COLOR )
    varying vec3 vColor;
#endif`,
      K5 = `#if defined( USE_COLOR_ALPHA )
    varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
    varying vec3 vColor;
#endif`,
      Y5 = `#if defined( USE_COLOR_ALPHA )
    vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
    vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
    vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
    vColor.xyz *= instanceColor.xyz;
#endif`,
      Q5 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
    return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
    float precisionSafeLength( vec3 v ) { return length( v ); }
#else
    float precisionSafeLength( vec3 v ) {
        float maxComponent = max3( abs( v ) );
        return length( v / maxComponent ) * maxComponent;
    }
#endif
struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};
struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};
struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
#ifdef USE_CLEARCOAT
    vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
    varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
    mat3 tmp;
    tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
    tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
    tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
    return tmp;
}
float luminance( const in vec3 rgb ) {
    const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
    return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
    return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
    float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
    float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
    return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
    return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
    float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
    return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
    float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
    return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
      Z5 = `#ifdef ENVMAP_TYPE_CUBE_UV
    #define cubeUV_minMipLevel 4.0
    #define cubeUV_minTileSize 16.0
    float getFace( vec3 direction ) {
        vec3 absDirection = abs( direction );
        float face = - 1.0;
        if ( absDirection.x > absDirection.z ) {
            if ( absDirection.x > absDirection.y )
                face = direction.x > 0.0 ? 0.0 : 3.0;
            else
                face = direction.y > 0.0 ? 1.0 : 4.0;
        } else {
            if ( absDirection.z > absDirection.y )
                face = direction.z > 0.0 ? 2.0 : 5.0;
            else
                face = direction.y > 0.0 ? 1.0 : 4.0;
        }
        return face;
    }
    vec2 getUV( vec3 direction, float face ) {
        vec2 uv;
        if ( face == 0.0 ) {
            uv = vec2( direction.z, direction.y ) / abs( direction.x );
        } else if ( face == 1.0 ) {
            uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
        } else if ( face == 2.0 ) {
            uv = vec2( - direction.x, direction.y ) / abs( direction.z );
        } else if ( face == 3.0 ) {
            uv = vec2( - direction.z, direction.y ) / abs( direction.x );
        } else if ( face == 4.0 ) {
            uv = vec2( - direction.x, direction.z ) / abs( direction.y );
        } else {
            uv = vec2( direction.x, direction.y ) / abs( direction.z );
        }
        return 0.5 * ( uv + 1.0 );
    }
    vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
        float face = getFace( direction );
        float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
        mipInt = max( mipInt, cubeUV_minMipLevel );
        float faceSize = exp2( mipInt );
        highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
        if ( face > 2.0 ) {
            uv.y += faceSize;
            face -= 3.0;
        }
        uv.x += face * faceSize;
        uv.x += filterInt * 3.0 * cubeUV_minTileSize;
        uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
        uv.x *= CUBEUV_TEXEL_WIDTH;
        uv.y *= CUBEUV_TEXEL_HEIGHT;
        #ifdef texture2DGradEXT
            return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
        #else
            return texture2D( envMap, uv ).rgb;
        #endif
    }
    #define cubeUV_r0 1.0
    #define cubeUV_v0 0.339
    #define cubeUV_m0 - 2.0
    #define cubeUV_r1 0.8
    #define cubeUV_v1 0.276
    #define cubeUV_m1 - 1.0
    #define cubeUV_r4 0.4
    #define cubeUV_v4 0.046
    #define cubeUV_m4 2.0
    #define cubeUV_r5 0.305
    #define cubeUV_v5 0.016
    #define cubeUV_m5 3.0
    #define cubeUV_r6 0.21
    #define cubeUV_v6 0.0038
    #define cubeUV_m6 4.0
    float roughnessToMip( float roughness ) {
        float mip = 0.0;
        if ( roughness >= cubeUV_r1 ) {
            mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
        } else if ( roughness >= cubeUV_r4 ) {
            mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
        } else if ( roughness >= cubeUV_r5 ) {
            mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
        } else if ( roughness >= cubeUV_r6 ) {
            mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
        } else {
            mip = - 2.0 * log2( 1.16 * roughness );     }
        return mip;
    }
    vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
        float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
        float mipF = fract( mip );
        float mipInt = floor( mip );
        vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
        if ( mipF == 0.0 ) {
            return vec4( color0, 1.0 );
        } else {
            vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
            return vec4( mix( color0, color1, mipF ), 1.0 );
        }
    }
#endif`,
      q5 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
    mat3 m = mat3( instanceMatrix );
    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
    transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
    transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
    vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
    #ifdef FLIP_SIDED
        transformedTangent = - transformedTangent;
    #endif
#endif`,
      e8 = `#ifdef USE_DISPLACEMENTMAP
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;
#endif`,
      t8 = `#ifdef USE_DISPLACEMENTMAP
    transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
      n8 = `#ifdef USE_EMISSIVEMAP
    vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
    totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
      r8 = `#ifdef USE_EMISSIVEMAP
    uniform sampler2D emissiveMap;
#endif`,
      i8 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      s8 = `vec4 LinearToLinear( in vec4 value ) {
    return value;
}
vec4 LinearTosRGB( in vec4 value ) {
    return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
      o8 = `#ifdef USE_ENVMAP
    #ifdef ENV_WORLDPOS
        vec3 cameraToFrag;
        if ( isOrthographic ) {
            cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
        } else {
            cameraToFrag = normalize( vWorldPosition - cameraPosition );
        }
        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vec3 reflectVec = reflect( cameraToFrag, worldNormal );
        #else
            vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
        #endif
    #else
        vec3 reflectVec = vReflect;
    #endif
    #ifdef ENVMAP_TYPE_CUBE
        vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #else
        vec4 envColor = vec4( 0.0 );
    #endif
    #ifdef ENVMAP_BLENDING_MULTIPLY
        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_MIX )
        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
    #elif defined( ENVMAP_BLENDING_ADD )
        outgoingLight += envColor.xyz * specularStrength * reflectivity;
    #endif
#endif`,
      a8 = `#ifdef USE_ENVMAP
    uniform float envMapIntensity;
    uniform float flipEnvMap;
    #ifdef ENVMAP_TYPE_CUBE
        uniform samplerCube envMap;
    #else
        uniform sampler2D envMap;
    #endif
    
#endif`,
      l8 = `#ifdef USE_ENVMAP
    uniform float reflectivity;
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
        #define ENV_WORLDPOS
    #endif
    #ifdef ENV_WORLDPOS
        varying vec3 vWorldPosition;
        uniform float refractionRatio;
    #else
        varying vec3 vReflect;
    #endif
#endif`,
      u8 = `#ifdef USE_ENVMAP
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
        #define ENV_WORLDPOS
    #endif
    #ifdef ENV_WORLDPOS
        
        varying vec3 vWorldPosition;
    #else
        varying vec3 vReflect;
        uniform float refractionRatio;
    #endif
#endif`,
      c8 = `#ifdef USE_ENVMAP
    #ifdef ENV_WORLDPOS
        vWorldPosition = worldPosition.xyz;
    #else
        vec3 cameraToVertex;
        if ( isOrthographic ) {
            cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
        } else {
            cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
        }
        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
        #ifdef ENVMAP_MODE_REFLECTION
            vReflect = reflect( cameraToVertex, worldNormal );
        #else
            vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
        #endif
    #endif
#endif`,
      f8 = `#ifdef USE_FOG
    vFogDepth = - mvPosition.z;
#endif`,
      h8 = `#ifdef USE_FOG
    varying float vFogDepth;
#endif`,
      d8 = `#ifdef USE_FOG
    #ifdef FOG_EXP2
        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
    #else
        float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
    #endif
    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
      p8 = `#ifdef USE_FOG
    uniform vec3 fogColor;
    varying float vFogDepth;
    #ifdef FOG_EXP2
        uniform float fogDensity;
    #else
        uniform float fogNear;
        uniform float fogFar;
    #endif
#endif`,
      m8 = `#ifdef USE_GRADIENTMAP
    uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
    float dotNL = dot( normal, lightDirection );
    vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
    #ifdef USE_GRADIENTMAP
        return vec3( texture2D( gradientMap, coord ).r );
    #else
        vec2 fw = fwidth( coord ) * 0.5;
        return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
    #endif
}`,
      g8 = `#ifdef USE_LIGHTMAP
    vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
    vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
    reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
      v8 = `#ifdef USE_LIGHTMAP
    uniform sampler2D lightMap;
    uniform float lightMapIntensity;
#endif`,
      y8 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
      x8 = `varying vec3 vViewPosition;
struct LambertMaterial {
    vec3 diffuseColor;
    float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
    vec3 irradiance = dotNL * directLight.color;
    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct               RE_Direct_Lambert
#define RE_IndirectDiffuse      RE_IndirectDiffuse_Lambert`,
      _8 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
    float x = normal.x, y = normal.y, z = normal.z;
    vec3 result = shCoefficients[ 0 ] * 0.886227;
    result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
    result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
    result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
    result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
    result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
    result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
    result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
    result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
    return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
    vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
    return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
    vec3 irradiance = ambientLightColor;
    return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
    #if defined ( LEGACY_LIGHTS )
        if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
            return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
        }
        return 1.0;
    #else
        float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
        if ( cutoffDistance > 0.0 ) {
            distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
        }
        return distanceFalloff;
    #endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
    return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
    struct DirectionalLight {
        vec3 direction;
        vec3 color;
    };
    uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
    void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
        light.color = directionalLight.color;
        light.direction = directionalLight.direction;
        light.visible = true;
    }
#endif
#if NUM_POINT_LIGHTS > 0
    struct PointLight {
        vec3 position;
        vec3 color;
        float distance;
        float decay;
    };
    uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
    void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
        vec3 lVector = pointLight.position - geometry.position;
        light.direction = normalize( lVector );
        float lightDistance = length( lVector );
        light.color = pointLight.color;
        light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
        light.visible = ( light.color != vec3( 0.0 ) );
    }
#endif
#if NUM_SPOT_LIGHTS > 0
    struct SpotLight {
        vec3 position;
        vec3 direction;
        vec3 color;
        float distance;
        float decay;
        float coneCos;
        float penumbraCos;
    };
    uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
    void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
        vec3 lVector = spotLight.position - geometry.position;
        light.direction = normalize( lVector );
        float angleCos = dot( light.direction, spotLight.direction );
        float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
        if ( spotAttenuation > 0.0 ) {
            float lightDistance = length( lVector );
            light.color = spotLight.color * spotAttenuation;
            light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
            light.visible = ( light.color != vec3( 0.0 ) );
        } else {
            light.color = vec3( 0.0 );
            light.visible = false;
        }
    }
#endif
#if NUM_RECT_AREA_LIGHTS > 0
    struct RectAreaLight {
        vec3 color;
        vec3 position;
        vec3 halfWidth;
        vec3 halfHeight;
    };
    uniform sampler2D ltc_1;    uniform sampler2D ltc_2;
    uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
    struct HemisphereLight {
        vec3 direction;
        vec3 skyColor;
        vec3 groundColor;
    };
    uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
    vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
        float dotNL = dot( normal, hemiLight.direction );
        float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
        vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
        return irradiance;
    }
#endif`,
      A8 = `#ifdef USE_ENVMAP
    vec3 getIBLIrradiance( const in vec3 normal ) {
        #ifdef ENVMAP_TYPE_CUBE_UV
            vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
            vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
            return PI * envMapColor.rgb * envMapIntensity;
        #else
            return vec3( 0.0 );
        #endif
    }
    vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
        #ifdef ENVMAP_TYPE_CUBE_UV
            vec3 reflectVec = reflect( - viewDir, normal );
            reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
            reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
            vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
            return envMapColor.rgb * envMapIntensity;
        #else
            return vec3( 0.0 );
        #endif
    }
    #ifdef USE_ANISOTROPY
        vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
            #ifdef ENVMAP_TYPE_CUBE_UV
                vec3 bentNormal = cross( bitangent, viewDir );
                bentNormal = normalize( cross( bentNormal, bitangent ) );
                bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
                return getIBLRadiance( viewDir, bentNormal, roughness );
            #else
                return vec3( 0.0 );
            #endif
        }
    #endif
#endif`,
      S8 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
      M8 = `varying vec3 vViewPosition;
struct ToonMaterial {
    vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
    vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct               RE_Direct_Toon
#define RE_IndirectDiffuse      RE_IndirectDiffuse_Toon`,
      E8 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
      w8 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
    vec3 diffuseColor;
    vec3 specularColor;
    float specularShininess;
    float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
    vec3 irradiance = dotNL * directLight.color;
    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
    reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct               RE_Direct_BlinnPhong
#define RE_IndirectDiffuse      RE_IndirectDiffuse_BlinnPhong`,
      b8 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
    material.ior = ior;
    #ifdef USE_SPECULAR
        float specularIntensityFactor = specularIntensity;
        vec3 specularColorFactor = specularColor;
        #ifdef USE_SPECULAR_COLORMAP
            specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
        #endif
        #ifdef USE_SPECULAR_INTENSITYMAP
            specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
        #endif
        material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
    #else
        float specularIntensityFactor = 1.0;
        vec3 specularColorFactor = vec3( 1.0 );
        material.specularF90 = 1.0;
    #endif
    material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
    material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
    material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
    material.clearcoat = clearcoat;
    material.clearcoatRoughness = clearcoatRoughness;
    material.clearcoatF0 = vec3( 0.04 );
    material.clearcoatF90 = 1.0;
    #ifdef USE_CLEARCOATMAP
        material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
    #endif
    #ifdef USE_CLEARCOAT_ROUGHNESSMAP
        material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
    #endif
    material.clearcoat = saturate( material.clearcoat );    material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
    material.clearcoatRoughness += geometryRoughness;
    material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
    material.iridescence = iridescence;
    material.iridescenceIOR = iridescenceIOR;
    #ifdef USE_IRIDESCENCEMAP
        material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
    #endif
    #ifdef USE_IRIDESCENCE_THICKNESSMAP
        material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
    #else
        material.iridescenceThickness = iridescenceThicknessMaximum;
    #endif
#endif
#ifdef USE_SHEEN
    material.sheenColor = sheenColor;
    #ifdef USE_SHEEN_COLORMAP
        material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
    #endif
    material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
    #ifdef USE_SHEEN_ROUGHNESSMAP
        material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
    #endif
#endif
#ifdef USE_ANISOTROPY
    #ifdef USE_ANISOTROPYMAP
        mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
        vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
        vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
    #else
        vec2 anisotropyV = anisotropyVector;
    #endif
    material.anisotropy = length( anisotropyV );
    anisotropyV /= material.anisotropy;
    material.anisotropy = saturate( material.anisotropy );
    material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
    material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
    material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
      C8 = `struct PhysicalMaterial {
    vec3 diffuseColor;
    float roughness;
    vec3 specularColor;
    float specularF90;
    #ifdef USE_CLEARCOAT
        float clearcoat;
        float clearcoatRoughness;
        vec3 clearcoatF0;
        float clearcoatF90;
    #endif
    #ifdef USE_IRIDESCENCE
        float iridescence;
        float iridescenceIOR;
        float iridescenceThickness;
        vec3 iridescenceFresnel;
        vec3 iridescenceF0;
    #endif
    #ifdef USE_SHEEN
        vec3 sheenColor;
        float sheenRoughness;
    #endif
    #ifdef IOR
        float ior;
    #endif
    #ifdef USE_TRANSMISSION
        float transmission;
        float transmissionAlpha;
        float thickness;
        float attenuationDistance;
        vec3 attenuationColor;
    #endif
    #ifdef USE_ANISOTROPY
        float anisotropy;
        float alphaT;
        vec3 anisotropyT;
        vec3 anisotropyB;
    #endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
    float a2 = pow2( alpha );
    float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
    float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
    return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
    float a2 = pow2( alpha );
    float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
    return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
    float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
        float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
        float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
        float v = 0.5 / ( gv + gl );
        return saturate(v);
    }
    float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
        float a2 = alphaT * alphaB;
        highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
        highp float v2 = dot( v, v );
        float w2 = a2 / v2;
        return RECIPROCAL_PI * a2 * pow2 ( w2 );
    }
#endif
#ifdef USE_CLEARCOAT
    vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
        vec3 f0 = material.clearcoatF0;
        float f90 = material.clearcoatF90;
        float roughness = material.clearcoatRoughness;
        float alpha = pow2( roughness );
        vec3 halfDir = normalize( lightDir + viewDir );
        float dotNL = saturate( dot( normal, lightDir ) );
        float dotNV = saturate( dot( normal, viewDir ) );
        float dotNH = saturate( dot( normal, halfDir ) );
        float dotVH = saturate( dot( viewDir, halfDir ) );
        vec3 F = F_Schlick( f0, f90, dotVH );
        float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
        float D = D_GGX( alpha, dotNH );
        return F * ( V * D );
    }
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
    vec3 f0 = material.specularColor;
    float f90 = material.specularF90;
    float roughness = material.roughness;
    float alpha = pow2( roughness );
    vec3 halfDir = normalize( lightDir + viewDir );
    float dotNL = saturate( dot( normal, lightDir ) );
    float dotNV = saturate( dot( normal, viewDir ) );
    float dotNH = saturate( dot( normal, halfDir ) );
    float dotVH = saturate( dot( viewDir, halfDir ) );
    vec3 F = F_Schlick( f0, f90, dotVH );
    #ifdef USE_IRIDESCENCE
        F = mix( F, material.iridescenceFresnel, material.iridescence );
    #endif
    #ifdef USE_ANISOTROPY
        float dotTL = dot( material.anisotropyT, lightDir );
        float dotTV = dot( material.anisotropyT, viewDir );
        float dotTH = dot( material.anisotropyT, halfDir );
        float dotBL = dot( material.anisotropyB, lightDir );
        float dotBV = dot( material.anisotropyB, viewDir );
        float dotBH = dot( material.anisotropyB, halfDir );
        float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
        float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
    #else
        float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
        float D = D_GGX( alpha, dotNH );
    #endif
    return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
    const float LUT_SIZE = 64.0;
    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
    const float LUT_BIAS = 0.5 / LUT_SIZE;
    float dotNV = saturate( dot( N, V ) );
    vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
    uv = uv * LUT_SCALE + LUT_BIAS;
    return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
    float l = length( f );
    return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
    float x = dot( v1, v2 );
    float y = abs( x );
    float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
    float b = 3.4175940 + ( 4.1616724 + y ) * y;
    float v = a / b;
    float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
    return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
    vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
    vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
    vec3 lightNormal = cross( v1, v2 );
    if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
    vec3 T1, T2;
    T1 = normalize( V - N * dot( V, N ) );
    T2 = - cross( N, T1 );
    mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
    vec3 coords[ 4 ];
    coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
    coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
    coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
    coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
    coords[ 0 ] = normalize( coords[ 0 ] );
    coords[ 1 ] = normalize( coords[ 1 ] );
    coords[ 2 ] = normalize( coords[ 2 ] );
    coords[ 3 ] = normalize( coords[ 3 ] );
    vec3 vectorFormFactor = vec3( 0.0 );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
    float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
    return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
    float alpha = pow2( roughness );
    float invAlpha = 1.0 / alpha;
    float cos2h = dotNH * dotNH;
    float sin2h = max( 1.0 - cos2h, 0.0078125 );
    return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
    return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
    vec3 halfDir = normalize( lightDir + viewDir );
    float dotNL = saturate( dot( normal, lightDir ) );
    float dotNV = saturate( dot( normal, viewDir ) );
    float dotNH = saturate( dot( normal, halfDir ) );
    float D = D_Charlie( sheenRoughness, dotNH );
    float V = V_Neubelt( dotNV, dotNL );
    return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
    float dotNV = saturate( dot( normal, viewDir ) );
    float r2 = roughness * roughness;
    float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
    float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
    float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
    return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
    float dotNV = saturate( dot( normal, viewDir ) );
    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
    vec4 r = roughness * c0 + c1;
    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
    vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
    return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
    vec2 fab = DFGApprox( normal, viewDir, roughness );
    return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
    vec2 fab = DFGApprox( normal, viewDir, roughness );
    #ifdef USE_IRIDESCENCE
        vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
    #else
        vec3 Fr = specularColor;
    #endif
    vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
    float Ess = fab.x + fab.y;
    float Ems = 1.0 - Ess;
    vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;   vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
    singleScatter += FssEss;
    multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
        vec3 normal = geometry.normal;
        vec3 viewDir = geometry.viewDir;
        vec3 position = geometry.position;
        vec3 lightPos = rectAreaLight.position;
        vec3 halfWidth = rectAreaLight.halfWidth;
        vec3 halfHeight = rectAreaLight.halfHeight;
        vec3 lightColor = rectAreaLight.color;
        float roughness = material.roughness;
        vec3 rectCoords[ 4 ];
        rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;        rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
        rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
        rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
        vec2 uv = LTC_Uv( normal, viewDir, roughness );
        vec4 t1 = texture2D( ltc_1, uv );
        vec4 t2 = texture2D( ltc_2, uv );
        mat3 mInv = mat3(
            vec3( t1.x, 0, t1.y ),
            vec3(    0, 1,    0 ),
            vec3( t1.z, 0, t1.w )
        );
        vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
        reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
        reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
    }
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
    vec3 irradiance = dotNL * directLight.color;
    #ifdef USE_CLEARCOAT
        float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
        vec3 ccIrradiance = dotNLcc * directLight.color;
        clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
    #endif
    #ifdef USE_SHEEN
        sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
    #endif
    reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
    #ifdef USE_CLEARCOAT
        clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
    #endif
    #ifdef USE_SHEEN
        sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
    #endif
    vec3 singleScattering = vec3( 0.0 );
    vec3 multiScattering = vec3( 0.0 );
    vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
    #ifdef USE_IRIDESCENCE
        computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
    #else
        computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
    #endif
    vec3 totalScattering = singleScattering + multiScattering;
    vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
    reflectedLight.indirectSpecular += radiance * singleScattering;
    reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct               RE_Direct_Physical
#define RE_Direct_RectArea      RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular     RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
      T8 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
    geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
    float dotNVi = saturate( dot( normal, geometry.viewDir ) );
    if ( material.iridescenceThickness == 0.0 ) {
        material.iridescence = 0.0;
    } else {
        material.iridescence = saturate( material.iridescence );
    }
    if ( material.iridescence > 0.0 ) {
        material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
        material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
    }
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
    PointLight pointLight;
    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLightShadow;
    #endif
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
        pointLight = pointLights[ i ];
        getPointLightInfo( pointLight, geometry, directLight );
        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
        pointLightShadow = pointLightShadows[ i ];
        directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
        #endif
        RE_Direct( directLight, geometry, material, reflectedLight );
    }
    #pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
    SpotLight spotLight;
    vec4 spotColor;
    vec3 spotLightCoord;
    bool inSpotLightMap;
    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLightShadow;
    #endif
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
        spotLight = spotLights[ i ];
        getSpotLightInfo( spotLight, geometry, directLight );
        #if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
        #define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
        #elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
        #define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
        #else
        #define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
        #endif
        #if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
            spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
            inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
            spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
            directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
        #endif
        #undef SPOT_LIGHT_MAP_INDEX
        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
        spotLightShadow = spotLightShadows[ i ];
        directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
        #endif
        RE_Direct( directLight, geometry, material, reflectedLight );
    }
    #pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLightShadow;
    #endif
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
        directionalLight = directionalLights[ i ];
        getDirectionalLightInfo( directionalLight, geometry, directLight );
        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
        directionalLightShadow = directionalLightShadows[ i ];
        directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
        #endif
        RE_Direct( directLight, geometry, material, reflectedLight );
    }
    #pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
    RectAreaLight rectAreaLight;
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
        rectAreaLight = rectAreaLights[ i ];
        RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
    }
    #pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
    vec3 iblIrradiance = vec3( 0.0 );
    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
    irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
    #if ( NUM_HEMI_LIGHTS > 0 )
        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
            irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
        }
        #pragma unroll_loop_end
    #endif
#endif
#if defined( RE_IndirectSpecular )
    vec3 radiance = vec3( 0.0 );
    vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
      R8 = `#if defined( RE_IndirectDiffuse )
    #ifdef USE_LIGHTMAP
        vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
        vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
        irradiance += lightMapIrradiance;
    #endif
    #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
        iblIrradiance += getIBLIrradiance( geometry.normal );
    #endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
    #ifdef USE_ANISOTROPY
        radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
    #else
        radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
    #endif
    #ifdef USE_CLEARCOAT
        clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
    #endif
#endif`,
      P8 = `#if defined( RE_IndirectDiffuse )
    RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
    RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
      B8 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
      I8 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    uniform float logDepthBufFC;
    varying float vFragDepth;
    varying float vIsPerspective;
#endif`,
      L8 = `#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        varying float vFragDepth;
        varying float vIsPerspective;
    #else
        uniform float logDepthBufFC;
    #endif
#endif`,
      D8 = `#ifdef USE_LOGDEPTHBUF
    #ifdef USE_LOGDEPTHBUF_EXT
        vFragDepth = 1.0 + gl_Position.w;
        vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
    #else
        if ( isPerspectiveMatrix( projectionMatrix ) ) {
            gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
            gl_Position.z *= gl_Position.w;
        }
    #endif
#endif`,
      F8 = `#ifdef USE_MAP
    diffuseColor *= texture2D( map, vMapUv );
#endif`,
      O8 = `#ifdef USE_MAP
    uniform sampler2D map;
#endif`,
      N8 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
    #if defined( USE_POINTS_UV )
        vec2 uv = vUv;
    #else
        vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
    #endif
#endif
#ifdef USE_MAP
    diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
    diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
      U8 = `#if defined( USE_POINTS_UV )
    varying vec2 vUv;
#else
    #if defined( USE_MAP ) || defined( USE_ALPHAMAP )
        uniform mat3 uvTransform;
    #endif
#endif
#ifdef USE_MAP
    uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
    uniform sampler2D alphaMap;
#endif`,
      k8 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
    vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
    metalnessFactor *= texelMetalness.b;
#endif`,
      H8 = `#ifdef USE_METALNESSMAP
    uniform sampler2D metalnessMap;
#endif`,
      G8 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
    vColor *= morphTargetBaseInfluence;
    for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
        #if defined( USE_COLOR_ALPHA )
            if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
        #elif defined( USE_COLOR )
            if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
        #endif
    }
#endif`,
      z8 = `#ifdef USE_MORPHNORMALS
    objectNormal *= morphTargetBaseInfluence;
    #ifdef MORPHTARGETS_TEXTURE
        for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
            if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
        }
    #else
        objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
        objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
        objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
        objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
    #endif
#endif`,
      V8 = `#ifdef USE_MORPHTARGETS
    uniform float morphTargetBaseInfluence;
    #ifdef MORPHTARGETS_TEXTURE
        uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
        uniform sampler2DArray morphTargetsTexture;
        uniform ivec2 morphTargetsTextureSize;
        vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
            int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
            int y = texelIndex / morphTargetsTextureSize.x;
            int x = texelIndex - y * morphTargetsTextureSize.x;
            ivec3 morphUV = ivec3( x, y, morphTargetIndex );
            return texelFetch( morphTargetsTexture, morphUV, 0 );
        }
    #else
        #ifndef USE_MORPHNORMALS
            uniform float morphTargetInfluences[ 8 ];
        #else
            uniform float morphTargetInfluences[ 4 ];
        #endif
    #endif
#endif`,
      W8 = `#ifdef USE_MORPHTARGETS
    transformed *= morphTargetBaseInfluence;
    #ifdef MORPHTARGETS_TEXTURE
        for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
            if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
        }
    #else
        transformed += morphTarget0 * morphTargetInfluences[ 0 ];
        transformed += morphTarget1 * morphTargetInfluences[ 1 ];
        transformed += morphTarget2 * morphTargetInfluences[ 2 ];
        transformed += morphTarget3 * morphTargetInfluences[ 3 ];
        #ifndef USE_MORPHNORMALS
            transformed += morphTarget4 * morphTargetInfluences[ 4 ];
            transformed += morphTarget5 * morphTargetInfluences[ 5 ];
            transformed += morphTarget6 * morphTargetInfluences[ 6 ];
            transformed += morphTarget7 * morphTargetInfluences[ 7 ];
        #endif
    #endif
#endif`,
      j8 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
    vec3 fdx = dFdx( vViewPosition );
    vec3 fdy = dFdy( vViewPosition );
    vec3 normal = normalize( cross( fdx, fdy ) );
#else
    vec3 normal = normalize( vNormal );
    #ifdef DOUBLE_SIDED
        normal *= faceDirection;
    #endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
    #ifdef USE_TANGENT
        mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
    #else
        mat3 tbn = getTangentFrame( - vViewPosition, normal,
        #if defined( USE_NORMALMAP )
            vNormalMapUv
        #elif defined( USE_CLEARCOAT_NORMALMAP )
            vClearcoatNormalMapUv
        #else
            vUv
        #endif
        );
    #endif
    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
        tbn[0] *= faceDirection;
        tbn[1] *= faceDirection;
    #endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
    #ifdef USE_TANGENT
        mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
    #else
        mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
    #endif
    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
        tbn2[0] *= faceDirection;
        tbn2[1] *= faceDirection;
    #endif
#endif
vec3 geometryNormal = normal;`,
      $8 = `#ifdef USE_NORMALMAP_OBJECTSPACE
    normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
    #ifdef FLIP_SIDED
        normal = - normal;
    #endif
    #ifdef DOUBLE_SIDED
        normal = normal * faceDirection;
    #endif
    normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
    vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
    mapN.xy *= normalScale;
    normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
      X8 = `#ifndef FLAT_SHADED
    varying vec3 vNormal;
    #ifdef USE_TANGENT
        varying vec3 vTangent;
        varying vec3 vBitangent;
    #endif
#endif`,
      J8 = `#ifndef FLAT_SHADED
    varying vec3 vNormal;
    #ifdef USE_TANGENT
        varying vec3 vTangent;
        varying vec3 vBitangent;
    #endif
#endif`,
      K8 = `#ifndef FLAT_SHADED
    vNormal = normalize( transformedNormal );
    #ifdef USE_TANGENT
        vTangent = normalize( transformedTangent );
        vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
    #endif
#endif`,
      Y8 = `#ifdef USE_NORMALMAP
    uniform sampler2D normalMap;
    uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
    uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
        vec3 q0 = dFdx( eye_pos.xyz );
        vec3 q1 = dFdy( eye_pos.xyz );
        vec2 st0 = dFdx( uv.st );
        vec2 st1 = dFdy( uv.st );
        vec3 N = surf_norm;
        vec3 q1perp = cross( q1, N );
        vec3 q0perp = cross( N, q0 );
        vec3 T = q1perp * st0.x + q0perp * st1.x;
        vec3 B = q1perp * st0.y + q0perp * st1.y;
        float det = max( dot( T, T ), dot( B, B ) );
        float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
        return mat3( T * scale, B * scale, N );
    }
#endif`,
      Q8 = `#ifdef USE_CLEARCOAT
    vec3 clearcoatNormal = geometryNormal;
#endif`,
      Z8 = `#ifdef USE_CLEARCOAT_NORMALMAP
    vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
    clearcoatMapN.xy *= clearcoatNormalScale;
    clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
      q8 = `#ifdef USE_CLEARCOATMAP
    uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
    uniform sampler2D clearcoatNormalMap;
    uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
    uniform sampler2D clearcoatRoughnessMap;
#endif`,
      e9 = `#ifdef USE_IRIDESCENCEMAP
    uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
    uniform sampler2D iridescenceThicknessMap;
#endif`,
      t9 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
      n9 = `vec3 packNormalToRGB( const in vec3 normal ) {
    return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
    return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
    vec4 r = vec4( fract( v * PackFactors ), v );
    r.yzw -= r.xyz * ShiftRight8;   return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
    return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
    return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
    return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
    vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
    return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
    return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
    return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
    return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
    return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
    return ( near * far ) / ( ( far - near ) * depth - far );
}`,
      r9 = `#ifdef PREMULTIPLIED_ALPHA
    gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
      i9 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
    mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
      s9 = `#ifdef DITHERING
    gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
      o9 = `#ifdef DITHERING
    vec3 dithering( vec3 color ) {
        float grid_position = rand( gl_FragCoord.xy );
        vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
        dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
        return color + dither_shift_RGB;
    }
#endif`,
      a9 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
    vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
    roughnessFactor *= texelRoughness.g;
#endif`,
      l9 = `#ifdef USE_ROUGHNESSMAP
    uniform sampler2D roughnessMap;
#endif`,
      u9 = `#if NUM_SPOT_LIGHT_COORDS > 0
    varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
    uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0
        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };
        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
    #endif
    #if NUM_SPOT_LIGHT_SHADOWS > 0
        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };
        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
    #endif
    #if NUM_POINT_LIGHT_SHADOWS > 0
        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };
        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
    #endif
    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
    }
    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
        return unpackRGBATo2Half( texture2D( shadow, uv ) );
    }
    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
        float occlusion = 1.0;
        vec2 distribution = texture2DDistribution( shadow, uv );
        float hard_shadow = step( compare , distribution.x );
        if (hard_shadow != 1.0 ) {
            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance );          softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );          occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
        }
        return occlusion;
    }
    float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
        float shadow = 1.0;
        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;
        bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
        bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
        if ( frustumTest ) {
        #if defined( SHADOWMAP_TYPE_PCF )
            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx0 = - texelSize.x * shadowRadius;
            float dy0 = - texelSize.y * shadowRadius;
            float dx1 = + texelSize.x * shadowRadius;
            float dy1 = + texelSize.y * shadowRadius;
            float dx2 = dx0 / 2.0;
            float dy2 = dy0 / 2.0;
            float dx3 = dx1 / 2.0;
            float dy3 = dy1 / 2.0;
            shadow = (
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
            ) * ( 1.0 / 17.0 );
        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;
            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;
            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );
        #elif defined( SHADOWMAP_TYPE_VSM )
            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
        #else
            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
        #endif
        }
        return shadow;
    }
    vec2 cubeToUV( vec3 v, float texelSizeY ) {
        vec3 absV = abs( v );
        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
        vec2 planar = v.xy;
        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;
        if ( absV.z >= almostOne ) {
            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;
        } else if ( absV.x >= almostOne ) {
            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;
        } else if ( absV.y >= almostOne ) {
            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;
        }
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
    }
    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
        vec3 lightToPosition = shadowCoord.xyz;
        float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );       dp += shadowBias;
        vec3 bd3D = normalize( lightToPosition );
        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
            vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
            return (
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
            ) * ( 1.0 / 9.0 );
        #else
            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
        #endif
    }
#endif`,
      c9 = `#if NUM_SPOT_LIGHT_COORDS > 0
    uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
    varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0
        uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };
        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
    #endif
    #if NUM_SPOT_LIGHT_SHADOWS > 0
        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };
        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
    #endif
    #if NUM_POINT_LIGHT_SHADOWS > 0
        uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };
        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
    #endif
#endif`,
      f9 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
    vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
    vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
    #if NUM_DIR_LIGHT_SHADOWS > 0
        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
            shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
            vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
        }
        #pragma unroll_loop_end
    #endif
    #if NUM_POINT_LIGHT_SHADOWS > 0
        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
            shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
            vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
        }
        #pragma unroll_loop_end
    #endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
        shadowWorldPosition = worldPosition;
        #if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
            shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
        #endif
        vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
    }
    #pragma unroll_loop_end
#endif`,
      h9 = `float getShadowMask() {
    float shadow = 1.0;
    #ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLight;
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
        directionalLight = directionalLightShadows[ i ];
        shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
    }
    #pragma unroll_loop_end
    #endif
    #if NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLight;
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
        spotLight = spotLightShadows[ i ];
        shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
    }
    #pragma unroll_loop_end
    #endif
    #if NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLight;
    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
        pointLight = pointLightShadows[ i ];
        shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
    }
    #pragma unroll_loop_end
    #endif
    #endif
    return shadow;
}`,
      d9 = `#ifdef USE_SKINNING
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
      p9 = `#ifdef USE_SKINNING
    uniform mat4 bindMatrix;
    uniform mat4 bindMatrixInverse;
    uniform highp sampler2D boneTexture;
    uniform int boneTextureSize;
    mat4 getBoneMatrix( const in float i ) {
        float j = i * 4.0;
        float x = mod( j, float( boneTextureSize ) );
        float y = floor( j / float( boneTextureSize ) );
        float dx = 1.0 / float( boneTextureSize );
        float dy = 1.0 / float( boneTextureSize );
        y = dy * ( y + 0.5 );
        vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
        vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
        vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
        vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
        mat4 bone = mat4( v1, v2, v3, v4 );
        return bone;
    }
#endif`,
      m9 = `#ifdef USE_SKINNING
    vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;
    transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
      g9 = `#ifdef USE_SKINNING
    mat4 skinMatrix = mat4( 0.0 );
    skinMatrix += skinWeight.x * boneMatX;
    skinMatrix += skinWeight.y * boneMatY;
    skinMatrix += skinWeight.z * boneMatZ;
    skinMatrix += skinWeight.w * boneMatW;
    skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
    #ifdef USE_TANGENT
        objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
    #endif
#endif`,
      v9 = `float specularStrength;
#ifdef USE_SPECULARMAP
    vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
    specularStrength = texelSpecular.r;
#else
    specularStrength = 1.0;
#endif`,
      y9 = `#ifdef USE_SPECULARMAP
    uniform sampler2D specularMap;
#endif`,
      x9 = `#if defined( TONE_MAPPING )
    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
      _9 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
    return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
    color *= toneMappingExposure;
    return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
    color *= toneMappingExposure;
    color = max( vec3( 0.0 ), color - 0.004 );
    return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
    vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
    vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
    return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
    const mat3 ACESInputMat = mat3(
        vec3( 0.59719, 0.07600, 0.02840 ),      vec3( 0.35458, 0.90834, 0.13383 ),
        vec3( 0.04823, 0.01566, 0.83777 )
    );
    const mat3 ACESOutputMat = mat3(
        vec3(  1.60475, -0.10208, -0.00327 ),       vec3( -0.53108,  1.10813, -0.07276 ),
        vec3( -0.07367, -0.00605,  1.07602 )
    );
    color *= toneMappingExposure / 0.6;
    color = ACESInputMat * color;
    color = RRTAndODTFit( color );
    color = ACESOutputMat * color;
    return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
      A9 = `#ifdef USE_TRANSMISSION
    material.transmission = transmission;
    material.transmissionAlpha = 1.0;
    material.thickness = thickness;
    material.attenuationDistance = attenuationDistance;
    material.attenuationColor = attenuationColor;
    #ifdef USE_TRANSMISSIONMAP
        material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
    #endif
    #ifdef USE_THICKNESSMAP
        material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
    #endif
    vec3 pos = vWorldPosition;
    vec3 v = normalize( cameraPosition - pos );
    vec3 n = inverseTransformDirection( normal, viewMatrix );
    vec4 transmitted = getIBLVolumeRefraction(
        n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
        pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
        material.attenuationColor, material.attenuationDistance );
    material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
    totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
      S9 = `#ifdef USE_TRANSMISSION
    uniform float transmission;
    uniform float thickness;
    uniform float attenuationDistance;
    uniform vec3 attenuationColor;
    #ifdef USE_TRANSMISSIONMAP
        uniform sampler2D transmissionMap;
    #endif
    #ifdef USE_THICKNESSMAP
        uniform sampler2D thicknessMap;
    #endif
    uniform vec2 transmissionSamplerSize;
    uniform sampler2D transmissionSamplerMap;
    uniform mat4 modelMatrix;
    uniform mat4 projectionMatrix;
    varying vec3 vWorldPosition;
    float w0( float a ) {
        return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
    }
    float w1( float a ) {
        return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
    }
    float w2( float a ){
        return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
    }
    float w3( float a ) {
        return ( 1.0 / 6.0 ) * ( a * a * a );
    }
    float g0( float a ) {
        return w0( a ) + w1( a );
    }
    float g1( float a ) {
        return w2( a ) + w3( a );
    }
    float h0( float a ) {
        return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
    }
    float h1( float a ) {
        return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
    }
    vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
        uv = uv * texelSize.zw + 0.5;
        vec2 iuv = floor( uv );
        vec2 fuv = fract( uv );
        float g0x = g0( fuv.x );
        float g1x = g1( fuv.x );
        float h0x = h0( fuv.x );
        float h1x = h1( fuv.x );
        float h0y = h0( fuv.y );
        float h1y = h1( fuv.y );
        vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
        vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
        vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
        vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
        return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
            g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
    }
    vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
        vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
        vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
        vec2 fLodSizeInv = 1.0 / fLodSize;
        vec2 cLodSizeInv = 1.0 / cLodSize;
        vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
        vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
        return mix( fSample, cSample, fract( lod ) );
    }
    vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
        vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
        vec3 modelScale;
        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
        return normalize( refractionVector ) * thickness * modelScale;
    }
    float applyIorToRoughness( const in float roughness, const in float ior ) {
        return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
    }
    vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
        float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
    }
    vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
        if ( isinf( attenuationDistance ) ) {
            return vec3( 1.0 );
        } else {
            vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
            vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );            return transmittance;
        }
    }
    vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
        const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
        const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
        const in vec3 attenuationColor, const in float attenuationDistance ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;
        vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;
        vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
        vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
        vec3 attenuatedColor = transmittance * transmittedLight.rgb;
        vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
        float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
        return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
    }
#endif`,
      M9 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
    varying vec2 vUv;
#endif
#ifdef USE_MAP
    varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
    varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
    varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
    varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
    varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
    varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
    varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
    varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
    varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
    varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
    varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
    varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
    varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
    varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
    varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
    varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
    varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
    varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
    varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
    varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
    uniform mat3 transmissionMapTransform;
    varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
    uniform mat3 thicknessMapTransform;
    varying vec2 vThicknessMapUv;
#endif`,
      E9 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
    varying vec2 vUv;
#endif
#ifdef USE_MAP
    uniform mat3 mapTransform;
    varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
    uniform mat3 alphaMapTransform;
    varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
    uniform mat3 lightMapTransform;
    varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
    uniform mat3 aoMapTransform;
    varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
    uniform mat3 bumpMapTransform;
    varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
    uniform mat3 normalMapTransform;
    varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
    uniform mat3 displacementMapTransform;
    varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
    uniform mat3 emissiveMapTransform;
    varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
    uniform mat3 metalnessMapTransform;
    varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
    uniform mat3 roughnessMapTransform;
    varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
    uniform mat3 anisotropyMapTransform;
    varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
    uniform mat3 clearcoatMapTransform;
    varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
    uniform mat3 clearcoatNormalMapTransform;
    varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
    uniform mat3 clearcoatRoughnessMapTransform;
    varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
    uniform mat3 sheenColorMapTransform;
    varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
    uniform mat3 sheenRoughnessMapTransform;
    varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
    uniform mat3 iridescenceMapTransform;
    varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
    uniform mat3 iridescenceThicknessMapTransform;
    varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
    uniform mat3 specularMapTransform;
    varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
    uniform mat3 specularColorMapTransform;
    varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
    uniform mat3 specularIntensityMapTransform;
    varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
    uniform mat3 transmissionMapTransform;
    varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
    uniform mat3 thicknessMapTransform;
    varying vec2 vThicknessMapUv;
#endif`,
      w9 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
    vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
    vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
    vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
    vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
    vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
    vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
    vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
    vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
    vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
    vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
    vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
    vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
    vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
    vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
    vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
    vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
    vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
    vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
    vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
    vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
    vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
    vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
    vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
    vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
      b9 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
    vec4 worldPosition = vec4( transformed, 1.0 );
    #ifdef USE_INSTANCING
        worldPosition = instanceMatrix * worldPosition;
    #endif
    worldPosition = modelMatrix * worldPosition;
#endif`;
   const C9 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
    vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
      T9 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
    vec4 texColor = texture2D( t2D, vUv );
    texColor.rgb *= backgroundIntensity;
    gl_FragColor = texColor;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`,
      R9 = `varying vec3 vWorldDirection;
#include <common>
void main() {
    vWorldDirection = transformDirection( position, modelMatrix );
    #include <begin_vertex>
    #include <project_vertex>
    gl_Position.z = gl_Position.w;
}`,
      P9 = `#ifdef ENVMAP_TYPE_CUBE
    uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
    uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
    #ifdef ENVMAP_TYPE_CUBE
        vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
    #elif defined( ENVMAP_TYPE_CUBE_UV )
        vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
    #else
        vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
    #endif
    texColor.rgb *= backgroundIntensity;
    gl_FragColor = texColor;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`,
      B9 = `varying vec3 vWorldDirection;
#include <common>
void main() {
    vWorldDirection = transformDirection( position, modelMatrix );
    #include <begin_vertex>
    #include <project_vertex>
    gl_Position.z = gl_Position.w;
}`,
      I9 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
    vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
    gl_FragColor = texColor;
    gl_FragColor.a *= opacity;
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`,
      L9 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
    #include <uv_vertex>
    #include <skinbase_vertex>
    #ifdef USE_DISPLACEMENTMAP
        #include <beginnormal_vertex>
        #include <morphnormal_vertex>
        #include <skinnormal_vertex>
    #endif
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    vHighPrecisionZW = gl_Position.zw;
}`,
      D9 = `#if DEPTH_PACKING == 3200
    uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( 1.0 );
    #if DEPTH_PACKING == 3200
        diffuseColor.a = opacity;
    #endif
    #include <map_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    #include <logdepthbuf_fragment>
    float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
    #if DEPTH_PACKING == 3200
        gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
    #elif DEPTH_PACKING == 3201
        gl_FragColor = packDepthToRGBA( fragCoordZ );
    #endif
}`,
      F9 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <skinbase_vertex>
    #ifdef USE_DISPLACEMENTMAP
        #include <beginnormal_vertex>
        #include <morphnormal_vertex>
        #include <skinnormal_vertex>
    #endif
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <worldpos_vertex>
    #include <clipping_planes_vertex>
    vWorldPosition = worldPosition.xyz;
}`,
      O9 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( 1.0 );
    #include <map_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    float dist = length( vWorldPosition - referencePosition );
    dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
    dist = saturate( dist );
    gl_FragColor = packDepthToRGBA( dist );
}`,
      N9 = `varying vec3 vWorldDirection;
#include <common>
void main() {
    vWorldDirection = transformDirection( position, modelMatrix );
    #include <begin_vertex>
    #include <project_vertex>
}`,
      U9 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
    vec3 direction = normalize( vWorldDirection );
    vec2 sampleUV = equirectUv( direction );
    gl_FragColor = texture2D( tEquirect, sampleUV );
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`,
      k9 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    vLineDistance = scale * lineDistance;
    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <fog_vertex>
}`,
      H9 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    if ( mod( vLineDistance, totalSize ) > dashSize ) {
        discard;
    }
    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vec4( diffuse, opacity );
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    outgoingLight = diffuseColor.rgb;
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
}`,
      G9 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
        #include <beginnormal_vertex>
        #include <morphnormal_vertex>
        #include <skinbase_vertex>
        #include <skinnormal_vertex>
        #include <defaultnormal_vertex>
    #endif
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <fog_vertex>
}`,
      z9 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
    varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( diffuse, opacity );
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    #include <specularmap_fragment>
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    #ifdef USE_LIGHTMAP
        vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
        reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
    #else
        reflectedLight.indirectDiffuse += vec3( 1.0 );
    #endif
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= diffuseColor.rgb;
    vec3 outgoingLight = reflectedLight.indirectDiffuse;
    #include <envmap_fragment>
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}`,
      V9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    vViewPosition = - mvPosition.xyz;
    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>
}`,
      W9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    #include <specularmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <emissivemap_fragment>
    #include <lights_lambert_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>
    #include <aomap_fragment>
    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
    #include <envmap_fragment>
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}`,
      j9 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <fog_vertex>
    vViewPosition = - mvPosition.xyz;
}`,
      $9 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( diffuse, opacity );
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    vec3 viewDir = normalize( vViewPosition );
    vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
    vec3 y = cross( viewDir, x );
    vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
    #ifdef USE_MATCAP
        vec4 matcapColor = texture2D( matcap, uv );
    #else
        vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
    #endif
    vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}`,
      X9 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
    varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
    vViewPosition = - mvPosition.xyz;
#endif
}`,
      J9 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
    varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    #include <logdepthbuf_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
}`,
      K9 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    vViewPosition = - mvPosition.xyz;
    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>
}`,
      Y9 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    #include <specularmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <emissivemap_fragment>
    #include <lights_phong_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>
    #include <aomap_fragment>
    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
    #include <envmap_fragment>
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}`,
      Q9 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
    varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    vViewPosition = - mvPosition.xyz;
    #include <worldpos_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>
#ifdef USE_TRANSMISSION
    vWorldPosition = worldPosition.xyz;
#endif
}`,
      Z9 = `#define STANDARD
#ifdef PHYSICAL
    #define IOR
    #define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
    uniform float ior;
#endif
#ifdef USE_SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;
    #ifdef USE_SPECULAR_COLORMAP
        uniform sampler2D specularColorMap;
    #endif
    #ifdef USE_SPECULAR_INTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif
#endif
#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
    uniform float iridescence;
    uniform float iridescenceIOR;
    uniform float iridescenceThicknessMinimum;
    uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;
    #ifdef USE_SHEEN_COLORMAP
        uniform sampler2D sheenColorMap;
    #endif
    #ifdef USE_SHEEN_ROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif
#ifdef USE_ANISOTROPY
    uniform vec2 anisotropyVector;
    #ifdef USE_ANISOTROPYMAP
        uniform sampler2D anisotropyMap;
    #endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>
    #include <aomap_fragment>
    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
    #include <transmission_fragment>
    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
    #ifdef USE_SHEEN
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
    #endif
    #ifdef USE_CLEARCOAT
        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
    #endif
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}`,
      q9 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    vViewPosition = - mvPosition.xyz;
    #include <worldpos_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>
}`,
      eV = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <emissivemap_fragment>
    #include <lights_toon_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>
    #include <aomap_fragment>
    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}`,
      tV = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
    varying vec2 vUv;
    uniform mat3 uvTransform;
#endif
void main() {
    #ifdef USE_POINTS_UV
        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    #endif
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <project_vertex>
    gl_PointSize = size;
    #ifdef USE_SIZEATTENUATION
        bool isPerspective = isPerspectiveMatrix( projectionMatrix );
        if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
    #endif
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <worldpos_vertex>
    #include <fog_vertex>
}`,
      nV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vec4( diffuse, opacity );
    #include <logdepthbuf_fragment>
    #include <map_particle_fragment>
    #include <color_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    outgoingLight = diffuseColor.rgb;
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
}`,
      rV = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <worldpos_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>
}`,
      iV = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
}`,
      sV = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
    vec2 scale;
    scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
    scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
    #ifndef USE_SIZEATTENUATION
        bool isPerspective = isPerspectiveMatrix( projectionMatrix );
        if ( isPerspective ) scale *= - mvPosition.z;
    #endif
    vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
    mvPosition.xy += rotatedPosition;
    gl_Position = projectionMatrix * mvPosition;
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <fog_vertex>
}`,
      oV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
    #include <clipping_planes_fragment>
    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vec4( diffuse, opacity );
    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <alphahash_fragment>
    outgoingLight = diffuseColor.rgb;
    #include <opaque_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
}`,
      Bt = {
         alphahash_fragment: P5,
         alphahash_pars_fragment: B5,
         alphamap_fragment: I5,
         alphamap_pars_fragment: L5,
         alphatest_fragment: D5,
         alphatest_pars_fragment: F5,
         aomap_fragment: O5,
         aomap_pars_fragment: N5,
         begin_vertex: U5,
         beginnormal_vertex: k5,
         bsdfs: H5,
         iridescence_fragment: G5,
         bumpmap_pars_fragment: z5,
         clipping_planes_fragment: V5,
         clipping_planes_pars_fragment: W5,
         clipping_planes_pars_vertex: j5,
         clipping_planes_vertex: $5,
         color_fragment: X5,
         color_pars_fragment: J5,
         color_pars_vertex: K5,
         color_vertex: Y5,
         common: Q5,
         cube_uv_reflection_fragment: Z5,
         defaultnormal_vertex: q5,
         displacementmap_pars_vertex: e8,
         displacementmap_vertex: t8,
         emissivemap_fragment: n8,
         emissivemap_pars_fragment: r8,
         colorspace_fragment: i8,
         colorspace_pars_fragment: s8,
         envmap_fragment: o8,
         envmap_common_pars_fragment: a8,
         envmap_pars_fragment: l8,
         envmap_pars_vertex: u8,
         envmap_physical_pars_fragment: A8,
         envmap_vertex: c8,
         fog_vertex: f8,
         fog_pars_vertex: h8,
         fog_fragment: d8,
         fog_pars_fragment: p8,
         gradientmap_pars_fragment: m8,
         lightmap_fragment: g8,
         lightmap_pars_fragment: v8,
         lights_lambert_fragment: y8,
         lights_lambert_pars_fragment: x8,
         lights_pars_begin: _8,
         lights_toon_fragment: S8,
         lights_toon_pars_fragment: M8,
         lights_phong_fragment: E8,
         lights_phong_pars_fragment: w8,
         lights_physical_fragment: b8,
         lights_physical_pars_fragment: C8,
         lights_fragment_begin: T8,
         lights_fragment_maps: R8,
         lights_fragment_end: P8,
         logdepthbuf_fragment: B8,
         logdepthbuf_pars_fragment: I8,
         logdepthbuf_pars_vertex: L8,
         logdepthbuf_vertex: D8,
         map_fragment: F8,
         map_pars_fragment: O8,
         map_particle_fragment: N8,
         map_particle_pars_fragment: U8,
         metalnessmap_fragment: k8,
         metalnessmap_pars_fragment: H8,
         morphcolor_vertex: G8,
         morphnormal_vertex: z8,
         morphtarget_pars_vertex: V8,
         morphtarget_vertex: W8,
         normal_fragment_begin: j8,
         normal_fragment_maps: $8,
         normal_pars_fragment: X8,
         normal_pars_vertex: J8,
         normal_vertex: K8,
         normalmap_pars_fragment: Y8,
         clearcoat_normal_fragment_begin: Q8,
         clearcoat_normal_fragment_maps: Z8,
         clearcoat_pars_fragment: q8,
         iridescence_pars_fragment: e9,
         opaque_fragment: t9,
         packing: n9,
         premultiplied_alpha_fragment: r9,
         project_vertex: i9,
         dithering_fragment: s9,
         dithering_pars_fragment: o9,
         roughnessmap_fragment: a9,
         roughnessmap_pars_fragment: l9,
         shadowmap_pars_fragment: u9,
         shadowmap_pars_vertex: c9,
         shadowmap_vertex: f9,
         shadowmask_pars_fragment: h9,
         skinbase_vertex: d9,
         skinning_pars_vertex: p9,
         skinning_vertex: m9,
         skinnormal_vertex: g9,
         specularmap_fragment: v9,
         specularmap_pars_fragment: y9,
         tonemapping_fragment: x9,
         tonemapping_pars_fragment: _9,
         transmission_fragment: A9,
         transmission_pars_fragment: S9,
         uv_pars_fragment: M9,
         uv_pars_vertex: E9,
         uv_vertex: w9,
         worldpos_vertex: b9,
         background_vert: C9,
         background_frag: T9,
         backgroundCube_vert: R9,
         backgroundCube_frag: P9,
         cube_vert: B9,
         cube_frag: I9,
         depth_vert: L9,
         depth_frag: D9,
         distanceRGBA_vert: F9,
         distanceRGBA_frag: O9,
         equirect_vert: N9,
         equirect_frag: U9,
         linedashed_vert: k9,
         linedashed_frag: H9,
         meshbasic_vert: G9,
         meshbasic_frag: z9,
         meshlambert_vert: V9,
         meshlambert_frag: W9,
         meshmatcap_vert: j9,
         meshmatcap_frag: $9,
         meshnormal_vert: X9,
         meshnormal_frag: J9,
         meshphong_vert: K9,
         meshphong_frag: Y9,
         meshphysical_vert: Q9,
         meshphysical_frag: Z9,
         meshtoon_vert: q9,
         meshtoon_frag: eV,
         points_vert: tV,
         points_frag: nV,
         shadow_vert: rV,
         shadow_frag: iV,
         sprite_vert: sV,
         sprite_frag: oV
      },
      Ge = {
         common: {
            diffuse: {
               value: new ke(16777215)
            },
            opacity: {
               value: 1
            },
            map: {
               value: null
            },
            mapTransform: {
               value: new Ft
            },
            alphaMap: {
               value: null
            },
            alphaMapTransform: {
               value: new Ft
            },
            alphaTest: {
               value: 0
            }
         },
         specularmap: {
            specularMap: {
               value: null
            },
            specularMapTransform: {
               value: new Ft
            }
         },
         envmap: {
            envMap: {
               value: null
            },
            flipEnvMap: {
               value: -1
            },
            reflectivity: {
               value: 1
            },
            ior: {
               value: 1.5
            },
            refractionRatio: {
               value: .98
            }
         },
         aomap: {
            aoMap: {
               value: null
            },
            aoMapIntensity: {
               value: 1
            },
            aoMapTransform: {
               value: new Ft
            }
         },
         lightmap: {
            lightMap: {
               value: null
            },
            lightMapIntensity: {
               value: 1
            },
            lightMapTransform: {
               value: new Ft
            }
         },
         bumpmap: {
            bumpMap: {
               value: null
            },
            bumpMapTransform: {
               value: new Ft
            },
            bumpScale: {
               value: 1
            }
         },
         normalmap: {
            normalMap: {
               value: null
            },
            normalMapTransform: {
               value: new Ft
            },
            normalScale: {
               value: new Se(1, 1)
            }
         },
         displacementmap: {
            displacementMap: {
               value: null
            },
            displacementMapTransform: {
               value: new Ft
            },
            displacementScale: {
               value: 1
            },
            displacementBias: {
               value: 0
            }
         },
         emissivemap: {
            emissiveMap: {
               value: null
            },
            emissiveMapTransform: {
               value: new Ft
            }
         },
         metalnessmap: {
            metalnessMap: {
               value: null
            },
            metalnessMapTransform: {
               value: new Ft
            }
         },
         roughnessmap: {
            roughnessMap: {
               value: null
            },
            roughnessMapTransform: {
               value: new Ft
            }
         },
         gradientmap: {
            gradientMap: {
               value: null
            }
         },
         fog: {
            fogDensity: {
               value: 25e-5
            },
            fogNear: {
               value: 1
            },
            fogFar: {
               value: 2e3
            },
            fogColor: {
               value: new ke(16777215)
            }
         },
         lights: {
            ambientLightColor: {
               value: []
            },
            lightProbe: {
               value: []
            },
            directionalLights: {
               value: [],
               properties: {
                  direction: {},
                  color: {}
               }
            },
            directionalLightShadows: {
               value: [],
               properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
               }
            },
            directionalShadowMap: {
               value: []
            },
            directionalShadowMatrix: {
               value: []
            },
            spotLights: {
               value: [],
               properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {}
               }
            },
            spotLightShadows: {
               value: [],
               properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
               }
            },
            spotLightMap: {
               value: []
            },
            spotShadowMap: {
               value: []
            },
            spotLightMatrix: {
               value: []
            },
            pointLights: {
               value: [],
               properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {}
               }
            },
            pointLightShadows: {
               value: [],
               properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {}
               }
            },
            pointShadowMap: {
               value: []
            },
            pointShadowMatrix: {
               value: []
            },
            hemisphereLights: {
               value: [],
               properties: {
                  direction: {},
                  skyColor: {},
                  groundColor: {}
               }
            },
            rectAreaLights: {
               value: [],
               properties: {
                  color: {},
                  position: {},
                  width: {},
                  height: {}
               }
            },
            ltc_1: {
               value: null
            },
            ltc_2: {
               value: null
            }
         },
         points: {
            diffuse: {
               value: new ke(16777215)
            },
            opacity: {
               value: 1
            },
            size: {
               value: 1
            },
            scale: {
               value: 1
            },
            map: {
               value: null
            },
            alphaMap: {
               value: null
            },
            alphaMapTransform: {
               value: new Ft
            },
            alphaTest: {
               value: 0
            },
            uvTransform: {
               value: new Ft
            }
         },
         sprite: {
            diffuse: {
               value: new ke(16777215)
            },
            opacity: {
               value: 1
            },
            center: {
               value: new Se(.5, .5)
            },
            rotation: {
               value: 0
            },
            map: {
               value: null
            },
            mapTransform: {
               value: new Ft
            },
            alphaMap: {
               value: null
            },
            alphaMapTransform: {
               value: new Ft
            },
            alphaTest: {
               value: 0
            }
         }
      },
      ds = {
         basic: {
            uniforms: Or([Ge.common, Ge.specularmap, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.fog]),
            vertexShader: Bt.meshbasic_vert,
            fragmentShader: Bt.meshbasic_frag
         },
         lambert: {
            uniforms: Or([Ge.common, Ge.specularmap, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.fog, Ge.lights, {
               emissive: {
                  value: new ke(0)
               }
            }]),
            vertexShader: Bt.meshlambert_vert,
            fragmentShader: Bt.meshlambert_frag
         },
         phong: {
            uniforms: Or([Ge.common, Ge.specularmap, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.fog, Ge.lights, {
               emissive: {
                  value: new ke(0)
               },
               specular: {
                  value: new ke(1118481)
               },
               shininess: {
                  value: 30
               }
            }]),
            vertexShader: Bt.meshphong_vert,
            fragmentShader: Bt.meshphong_frag
         },
         standard: {
            uniforms: Or([Ge.common, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.roughnessmap, Ge.metalnessmap, Ge.fog, Ge.lights, {
               emissive: {
                  value: new ke(0)
               },
               roughness: {
                  value: 1
               },
               metalness: {
                  value: 0
               },
               envMapIntensity: {
                  value: 1
               }
            }]),
            vertexShader: Bt.meshphysical_vert,
            fragmentShader: Bt.meshphysical_frag
         },
         toon: {
            uniforms: Or([Ge.common, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.gradientmap, Ge.fog, Ge.lights, {
               emissive: {
                  value: new ke(0)
               }
            }]),
            vertexShader: Bt.meshtoon_vert,
            fragmentShader: Bt.meshtoon_frag
         },
         matcap: {
            uniforms: Or([Ge.common, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.fog, {
               matcap: {
                  value: null
               }
            }]),
            vertexShader: Bt.meshmatcap_vert,
            fragmentShader: Bt.meshmatcap_frag
         },
         points: {
            uniforms: Or([Ge.points, Ge.fog]),
            vertexShader: Bt.points_vert,
            fragmentShader: Bt.points_frag
         },
         dashed: {
            uniforms: Or([Ge.common, Ge.fog, {
               scale: {
                  value: 1
               },
               dashSize: {
                  value: 1
               },
               totalSize: {
                  value: 2
               }
            }]),
            vertexShader: Bt.linedashed_vert,
            fragmentShader: Bt.linedashed_frag
         },
         depth: {
            uniforms: Or([Ge.common, Ge.displacementmap]),
            vertexShader: Bt.depth_vert,
            fragmentShader: Bt.depth_frag
         },
         normal: {
            uniforms: Or([Ge.common, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, {
               opacity: {
                  value: 1
               }
            }]),
            vertexShader: Bt.meshnormal_vert,
            fragmentShader: Bt.meshnormal_frag
         },
         sprite: {
            uniforms: Or([Ge.sprite, Ge.fog]),
            vertexShader: Bt.sprite_vert,
            fragmentShader: Bt.sprite_frag
         },
         background: {
            uniforms: {
               uvTransform: {
                  value: new Ft
               },
               t2D: {
                  value: null
               },
               backgroundIntensity: {
                  value: 1
               }
            },
            vertexShader: Bt.background_vert,
            fragmentShader: Bt.background_frag
         },
         backgroundCube: {
            uniforms: {
               envMap: {
                  value: null
               },
               flipEnvMap: {
                  value: -1
               },
               backgroundBlurriness: {
                  value: 0
               },
               backgroundIntensity: {
                  value: 1
               }
            },
            vertexShader: Bt.backgroundCube_vert,
            fragmentShader: Bt.backgroundCube_frag
         },
         cube: {
            uniforms: {
               tCube: {
                  value: null
               },
               tFlip: {
                  value: -1
               },
               opacity: {
                  value: 1
               }
            },
            vertexShader: Bt.cube_vert,
            fragmentShader: Bt.cube_frag
         },
         equirect: {
            uniforms: {
               tEquirect: {
                  value: null
               }
            },
            vertexShader: Bt.equirect_vert,
            fragmentShader: Bt.equirect_frag
         },
         distanceRGBA: {
            uniforms: Or([Ge.common, Ge.displacementmap, {
               referencePosition: {
                  value: new U
               },
               nearDistance: {
                  value: 1
               },
               farDistance: {
                  value: 1e3
               }
            }]),
            vertexShader: Bt.distanceRGBA_vert,
            fragmentShader: Bt.distanceRGBA_frag
         },
         shadow: {
            uniforms: Or([Ge.lights, Ge.fog, {
               color: {
                  value: new ke(0)
               },
               opacity: {
                  value: 1
               }
            }]),
            vertexShader: Bt.shadow_vert,
            fragmentShader: Bt.shadow_frag
         }
      };
   ds.physical = {
      uniforms: Or([ds.standard.uniforms, {
         clearcoat: {
            value: 0
         },
         clearcoatMap: {
            value: null
         },
         clearcoatMapTransform: {
            value: new Ft
         },
         clearcoatNormalMap: {
            value: null
         },
         clearcoatNormalMapTransform: {
            value: new Ft
         },
         clearcoatNormalScale: {
            value: new Se(1, 1)
         },
         clearcoatRoughness: {
            value: 0
         },
         clearcoatRoughnessMap: {
            value: null
         },
         clearcoatRoughnessMapTransform: {
            value: new Ft
         },
         iridescence: {
            value: 0
         },
         iridescenceMap: {
            value: null
         },
         iridescenceMapTransform: {
            value: new Ft
         },
         iridescenceIOR: {
            value: 1.3
         },
         iridescenceThicknessMinimum: {
            value: 100
         },
         iridescenceThicknessMaximum: {
            value: 400
         },
         iridescenceThicknessMap: {
            value: null
         },
         iridescenceThicknessMapTransform: {
            value: new Ft
         },
         sheen: {
            value: 0
         },
         sheenColor: {
            value: new ke(0)
         },
         sheenColorMap: {
            value: null
         },
         sheenColorMapTransform: {
            value: new Ft
         },
         sheenRoughness: {
            value: 1
         },
         sheenRoughnessMap: {
            value: null
         },
         sheenRoughnessMapTransform: {
            value: new Ft
         },
         transmission: {
            value: 0
         },
         transmissionMap: {
            value: null
         },
         transmissionMapTransform: {
            value: new Ft
         },
         transmissionSamplerSize: {
            value: new Se
         },
         transmissionSamplerMap: {
            value: null
         },
         thickness: {
            value: 0
         },
         thicknessMap: {
            value: null
         },
         thicknessMapTransform: {
            value: new Ft
         },
         attenuationDistance: {
            value: 0
         },
         attenuationColor: {
            value: new ke(0)
         },
         specularColor: {
            value: new ke(1, 1, 1)
         },
         specularColorMap: {
            value: null
         },
         specularColorMapTransform: {
            value: new Ft
         },
         specularIntensity: {
            value: 1
         },
         specularIntensityMap: {
            value: null
         },
         specularIntensityMapTransform: {
            value: new Ft
         },
         anisotropyVector: {
            value: new Se
         },
         anisotropyMap: {
            value: null
         },
         anisotropyMapTransform: {
            value: new Ft
         }
      }]),
      vertexShader: Bt.meshphysical_vert,
      fragmentShader: Bt.meshphysical_frag
   };
   const og = {
      r: 0,
      b: 0,
      g: 0
   };

   function aV(t, e, n, r, i, s, o) {
      const a = new ke(0);
      let l = s === !0 ? 0 : 1,
         u, h, d = null,
         p = 0,
         m = null;

      function v(x, g) {
         let S = !1,
            A = g.isScene === !0 ? g.background : null;
         switch (A && A.isTexture && (A = (g.backgroundBlurriness > 0 ? n : e).get(A)), A === null ? _(a, l) : A && A.isColor && (_(A, 1), S = !0), t.xr.getEnvironmentBlendMode()) {
            case "opaque":
               S = !0;
               break;
            case "additive":
               r.buffers.color.setClear(0, 0, 0, 1, o), S = !0;
               break;
            case "alpha-blend":
               r.buffers.color.setClear(0, 0, 0, 0, o), S = !0;
               break
         }(t.autoClear || S) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), A && (A.isCubeTexture || A.mapping === bf) ? (h === void 0 && (h = new Xn(new ru(1, 1, 1), new Qi({
            name: "BackgroundCubeMaterial",
            uniforms: pf(ds.backgroundCube.uniforms),
            vertexShader: ds.backgroundCube.vertexShader,
            fragmentShader: ds.backgroundCube.fragmentShader,
            side: zr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
         })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function (R, B, D) {
            this.matrixWorld.copyPosition(D.matrixWorld)
         }, Object.defineProperty(h.material, "envMap", {
            get: function () {
               return this.uniforms.envMap.value
            }
         }), i.update(h)), h.material.uniforms.envMap.value = A, h.material.uniforms.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, h.material.toneMapped = A.colorSpace !== Rt, (d !== A || p !== A.version || m !== t.toneMapping) && (h.material.needsUpdate = !0, d = A, p = A.version, m = t.toneMapping), h.layers.enableAll(), x.unshift(h, h.geometry, h.material, 0, 0, null)) : A && A.isTexture && (u === void 0 && (u = new Xn(new lp(2, 2), new Qi({
            name: "BackgroundMaterial",
            uniforms: pf(ds.background.uniforms),
            vertexShader: ds.background.vertexShader,
            fragmentShader: ds.background.fragmentShader,
            side: Js,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
         })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
            get: function () {
               return this.uniforms.t2D.value
            }
         }), i.update(u)), u.material.uniforms.t2D.value = A, u.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, u.material.toneMapped = A.colorSpace !== Rt, A.matrixAutoUpdate === !0 && A.updateMatrix(), u.material.uniforms.uvTransform.value.copy(A.matrix), (d !== A || p !== A.version || m !== t.toneMapping) && (u.material.needsUpdate = !0, d = A, p = A.version, m = t.toneMapping), u.layers.enableAll(), x.unshift(u, u.geometry, u.material, 0, 0, null))
      }

      function _(x, g) {
         x.getRGB(og, yF(t)), r.buffers.color.setClear(og.r, og.g, og.b, g, o)
      }
      return {
         getClearColor: function () {
            return a
         },
         setClearColor: function (x, g = 1) {
            a.set(x), l = g, _(a, l)
         },
         getClearAlpha: function () {
            return l
         },
         setClearAlpha: function (x) {
            l = x, _(a, l)
         },
         render: v
      }
   }

   function lV(t, e, n, r) {
      const i = t.getParameter(t.MAX_VERTEX_ATTRIBS),
         s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
         o = r.isWebGL2 || s !== null,
         a = {},
         l = x(null);
      let u = l,
         h = !1;

      function d(Z, te, se, oe, G) {
         let ne = !1;
         if (o) {
            const Y = _(oe, se, te);
            u !== Y && (u = Y, m(u.object)), ne = g(Z, oe, se, G), ne && S(Z, oe, se, G)
         } else {
            const Y = te.wireframe === !0;
            (u.geometry !== oe.id || u.program !== se.id || u.wireframe !== Y) && (u.geometry = oe.id, u.program = se.id, u.wireframe = Y, ne = !0)
         }
         G !== null && n.update(G, t.ELEMENT_ARRAY_BUFFER), (ne || h) && (h = !1, D(Z, te, se, oe), G !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(G).buffer))
      }

      function p() {
         return r.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()
      }

      function m(Z) {
         return r.isWebGL2 ? t.bindVertexArray(Z) : s.bindVertexArrayOES(Z)
      }

      function v(Z) {
         return r.isWebGL2 ? t.deleteVertexArray(Z) : s.deleteVertexArrayOES(Z)
      }

      function _(Z, te, se) {
         const oe = se.wireframe === !0;
         let G = a[Z.id];
         G === void 0 && (G = {}, a[Z.id] = G);
         let ne = G[te.id];
         ne === void 0 && (ne = {}, G[te.id] = ne);
         let Y = ne[oe];
         return Y === void 0 && (Y = x(p()), ne[oe] = Y), Y
      }

      function x(Z) {
         const te = [],
            se = [],
            oe = [];
         for (let G = 0; G < i; G++) te[G] = 0, se[G] = 0, oe[G] = 0;
         return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: te,
            enabledAttributes: se,
            attributeDivisors: oe,
            object: Z,
            attributes: {},
            index: null
         }
      }

      function g(Z, te, se, oe) {
         const G = u.attributes,
            ne = te.attributes;
         let Y = 0;
         const X = se.getAttributes();
         for (const Q in X)
            if (X[Q].location >= 0) {
               const Me = G[Q];
               let we = ne[Q];
               if (we === void 0 && (Q === "instanceMatrix" && Z.instanceMatrix && (we = Z.instanceMatrix), Q === "instanceColor" && Z.instanceColor && (we = Z.instanceColor)), Me === void 0 || Me.attribute !== we || we && Me.data !== we.data) return !0;
               Y++
            } return u.attributesNum !== Y || u.index !== oe
      }

      function S(Z, te, se, oe) {
         const G = {},
            ne = te.attributes;
         let Y = 0;
         const X = se.getAttributes();
         for (const Q in X)
            if (X[Q].location >= 0) {
               let Me = ne[Q];
               Me === void 0 && (Q === "instanceMatrix" && Z.instanceMatrix && (Me = Z.instanceMatrix), Q === "instanceColor" && Z.instanceColor && (Me = Z.instanceColor));
               const we = {};
               we.attribute = Me, Me && Me.data && (we.data = Me.data), G[Q] = we, Y++
            } u.attributes = G, u.attributesNum = Y, u.index = oe
      }

      function A() {
         const Z = u.newAttributes;
         for (let te = 0, se = Z.length; te < se; te++) Z[te] = 0
      }

      function E(Z) {
         C(Z, 0)
      }

      function C(Z, te) {
         const se = u.newAttributes,
            oe = u.enabledAttributes,
            G = u.attributeDivisors;
         se[Z] = 1, oe[Z] === 0 && (t.enableVertexAttribArray(Z), oe[Z] = 1), G[Z] !== te && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](Z, te), G[Z] = te)
      }

      function R() {
         const Z = u.newAttributes,
            te = u.enabledAttributes;
         for (let se = 0, oe = te.length; se < oe; se++) te[se] !== Z[se] && (t.disableVertexAttribArray(se), te[se] = 0)
      }

      function B(Z, te, se, oe, G, ne, Y) {
         Y === !0 ? t.vertexAttribIPointer(Z, te, se, G, ne) : t.vertexAttribPointer(Z, te, se, oe, G, ne)
      }

      function D(Z, te, se, oe) {
         if (r.isWebGL2 === !1 && (Z.isInstancedMesh || oe.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
         A();
         const G = oe.attributes,
            ne = se.getAttributes(),
            Y = te.defaultAttributeValues;
         for (const X in ne) {
            const Q = ne[X];
            if (Q.location >= 0) {
               let _e = G[X];
               if (_e === void 0 && (X === "instanceMatrix" && Z.instanceMatrix && (_e = Z.instanceMatrix), X === "instanceColor" && Z.instanceColor && (_e = Z.instanceColor)), _e !== void 0) {
                  const Me = _e.normalized,
                     we = _e.itemSize,
                     Ee = n.get(_e);
                  if (Ee === void 0) continue;
                  const Ue = Ee.buffer,
                     Qe = Ee.type,
                     Pt = Ee.bytesPerElement,
                     kt = r.isWebGL2 === !0 && (Qe === t.INT || Qe === t.UNSIGNED_INT || _e.gpuType === OM);
                  if (_e.isInterleavedBufferAttribute) {
                     const $e = _e.data,
                        J = $e.stride,
                        Ce = _e.offset;
                     if ($e.isInstancedInterleavedBuffer) {
                        for (let Ae = 0; Ae < Q.locationSize; Ae++) C(Q.location + Ae, $e.meshPerAttribute);
                        Z.isInstancedMesh !== !0 && oe._maxInstanceCount === void 0 && (oe._maxInstanceCount = $e.meshPerAttribute * $e.count)
                     } else
                        for (let Ae = 0; Ae < Q.locationSize; Ae++) E(Q.location + Ae);
                     t.bindBuffer(t.ARRAY_BUFFER, Ue);
                     for (let Ae = 0; Ae < Q.locationSize; Ae++) B(Q.location + Ae, we / Q.locationSize, Qe, Me, J * Pt, (Ce + we / Q.locationSize * Ae) * Pt, kt)
                  } else {
                     if (_e.isInstancedBufferAttribute) {
                        for (let $e = 0; $e < Q.locationSize; $e++) C(Q.location + $e, _e.meshPerAttribute);
                        Z.isInstancedMesh !== !0 && oe._maxInstanceCount === void 0 && (oe._maxInstanceCount = _e.meshPerAttribute * _e.count)
                     } else
                        for (let $e = 0; $e < Q.locationSize; $e++) E(Q.location + $e);
                     t.bindBuffer(t.ARRAY_BUFFER, Ue);
                     for (let $e = 0; $e < Q.locationSize; $e++) B(Q.location + $e, we / Q.locationSize, Qe, Me, we * Pt, we / Q.locationSize * $e * Pt, kt)
                  }
               } else if (Y !== void 0) {
                  const Me = Y[X];
                  if (Me !== void 0) switch (Me.length) {
                     case 2:
                        t.vertexAttrib2fv(Q.location, Me);
                        break;
                     case 3:
                        t.vertexAttrib3fv(Q.location, Me);
                        break;
                     case 4:
                        t.vertexAttrib4fv(Q.location, Me);
                        break;
                     default:
                        t.vertexAttrib1fv(Q.location, Me)
                  }
               }
            }
         }
         R()
      }

      function T() {
         q();
         for (const Z in a) {
            const te = a[Z];
            for (const se in te) {
               const oe = te[se];
               for (const G in oe) v(oe[G].object), delete oe[G];
               delete te[se]
            }
            delete a[Z]
         }
      }

      function I(Z) {
         if (a[Z.id] === void 0) return;
         const te = a[Z.id];
         for (const se in te) {
            const oe = te[se];
            for (const G in oe) v(oe[G].object), delete oe[G];
            delete te[se]
         }
         delete a[Z.id]
      }

      function N(Z) {
         for (const te in a) {
            const se = a[te];
            if (se[Z.id] === void 0) continue;
            const oe = se[Z.id];
            for (const G in oe) v(oe[G].object), delete oe[G];
            delete se[Z.id]
         }
      }

      function q() {
         K(), h = !0, u !== l && (u = l, m(u.object))
      }

      function K() {
         l.geometry = null, l.program = null, l.wireframe = !1
      }
      return {
         setup: d,
         reset: q,
         resetDefaultState: K,
         dispose: T,
         releaseStatesOfGeometry: I,
         releaseStatesOfProgram: N,
         initAttributes: A,
         enableAttribute: E,
         disableUnusedAttributes: R
      }
   }

   function uV(t, e, n, r) {
      const i = r.isWebGL2;
      let s;

      function o(u) {
         s = u
      }

      function a(u, h) {
         t.drawArrays(s, u, h), n.update(h, s, 1)
      }

      function l(u, h, d) {
         if (d === 0) return;
         let p, m;
         if (i) p = t, m = "drawArraysInstanced";
         else if (p = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", p === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
         }
         p[m](s, u, h, d), n.update(h, s, d)
      }
      this.setMode = o, this.render = a, this.renderInstances = l
   }

   function cV(t, e, n) {
      let r;

      function i() {
         if (r !== void 0) return r;
         if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const B = e.get("EXT_texture_filter_anisotropic");
            r = t.getParameter(B.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
         } else r = 0;
         return r
      }

      function s(B) {
         if (B === "highp") {
            if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
            B = "mediump"
         }
         return B === "mediump" && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
      }
      const o = typeof WebGL2RenderingContext < "u" && t.constructor.name === "WebGL2RenderingContext";
      let a = n.precision !== void 0 ? n.precision : "highp";
      const l = s(a);
      l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
      const u = o || e.has("WEBGL_draw_buffers"),
         h = n.logarithmicDepthBuffer === !0,
         d = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
         p = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
         m = t.getParameter(t.MAX_TEXTURE_SIZE),
         v = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
         _ = t.getParameter(t.MAX_VERTEX_ATTRIBS),
         x = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
         g = t.getParameter(t.MAX_VARYING_VECTORS),
         S = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
         A = p > 0,
         E = o || e.has("OES_texture_float"),
         C = A && E,
         R = o ? t.getParameter(t.MAX_SAMPLES) : 0;
      return {
         isWebGL2: o,
         drawBuffers: u,
         getMaxAnisotropy: i,
         getMaxPrecision: s,
         precision: a,
         logarithmicDepthBuffer: h,
         maxTextures: d,
         maxVertexTextures: p,
         maxTextureSize: m,
         maxCubemapSize: v,
         maxAttributes: _,
         maxVertexUniforms: x,
         maxVaryings: g,
         maxFragmentUniforms: S,
         vertexTextures: A,
         floatFragmentTextures: E,
         floatVertexTextures: C,
         maxSamples: R
      }
   }

   function fV(t) {
      const e = this;
      let n = null,
         r = 0,
         i = !1,
         s = !1;
      const o = new la,
         a = new Ft,
         l = {
            value: null,
            needsUpdate: !1
         };
      this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (d, p) {
         const m = d.length !== 0 || p || r !== 0 || i;
         return i = p, r = d.length, m
      }, this.beginShadows = function () {
         s = !0, h(null)
      }, this.endShadows = function () {
         s = !1
      }, this.setGlobalState = function (d, p) {
         n = h(d, p, 0)
      }, this.setState = function (d, p, m) {
         const v = d.clippingPlanes,
            _ = d.clipIntersection,
            x = d.clipShadows,
            g = t.get(d);
         if (!i || v === null || v.length === 0 || s && !x) s ? h(null) : u();
         else {
            const S = s ? 0 : r,
               A = S * 4;
            let E = g.clippingState || null;
            l.value = E, E = h(v, p, A, m);
            for (let C = 0; C !== A; ++C) E[C] = n[C];
            g.clippingState = E, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += S
         }
      };

      function u() {
         l.value !== n && (l.value = n, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
      }

      function h(d, p, m, v) {
         const _ = d !== null ? d.length : 0;
         let x = null;
         if (_ !== 0) {
            if (x = l.value, v !== !0 || x === null) {
               const g = m + _ * 4,
                  S = p.matrixWorldInverse;
               a.getNormalMatrix(S), (x === null || x.length < g) && (x = new Float32Array(g));
               for (let A = 0, E = m; A !== _; ++A, E += 4) o.copy(d[A]).applyMatrix4(S, a), o.normal.toArray(x, E), x[E + 3] = o.constant
            }
            l.value = x, l.needsUpdate = !0
         }
         return e.numPlanes = _, e.numIntersection = 0, x
      }
   }

   function hV(t) {
      let e = new WeakMap;

      function n(o, a) {
         return a === cf ? o.mapping = Ks : a === Fd && (o.mapping = Da), o
      }

      function r(o) {
         if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === cf || a === Fd)
               if (e.has(o)) {
                  const l = e.get(o).texture;
                  return n(l, o.mapping)
               } else {
                  const l = o.image;
                  if (l && l.height > 0) {
                     const u = new qM(l.height / 2);
                     return u.fromEquirectangularTexture(t, o), e.set(o, u), o.addEventListener("dispose", i), n(u.texture, o.mapping)
                  } else return null
               }
         }
         return o
      }

      function i(o) {
         const a = o.target;
         a.removeEventListener("dispose", i);
         const l = e.get(a);
         l !== void 0 && (e.delete(a), l.dispose())
      }

      function s() {
         e = new WeakMap
      }
      return {
         get: r,
         dispose: s
      }
   }
   class Tf extends op {
      constructor(e = -1, n = 1, r = 1, i = -1, s = .1, o = 2e3) {
         super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = r, this.bottom = i, this.near = s, this.far = o, this.updateProjectionMatrix()
      }
      copy(e, n) {
         return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
      }
      setViewOffset(e, n, r, i, s, o) {
         this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
         }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
      }
      clearViewOffset() {
         this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
      }
      updateProjectionMatrix() {
         const e = (this.right - this.left) / (2 * this.zoom),
            n = (this.top - this.bottom) / (2 * this.zoom),
            r = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
         let s = r - e,
            o = r + e,
            a = i + n,
            l = i - n;
         if (this.view !== null && this.view.enabled) {
            const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
               h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += u * this.view.offsetX, o = s + u * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height
         }
         this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n
      }
   }
   const Nc = 4,
      tR = [.125, .215, .35, .446, .526, .582],
      Cl = 20,
      x_ = new Tf,
      nR = new ke;
   let __ = null;
   const Al = (1 + Math.sqrt(5)) / 2,
      Ju = 1 / Al,
      rR = [new U(1, 1, 1), new U(-1, 1, 1), new U(1, 1, -1), new U(-1, 1, -1), new U(0, Al, Ju), new U(0, Al, -Ju), new U(Ju, 0, Al), new U(-Ju, 0, Al), new U(Al, Ju, 0), new U(-Al, Ju, 0)];
   class JA {
      constructor(e) {
         this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
      }
      fromScene(e, n = 0, r = .1, i = 100) {
         __ = this._renderer.getRenderTarget(), this._setSize(256);
         const s = this._allocateTargets();
         return s.depthBuffer = !0, this._sceneToCubeUV(e, r, i, s), n > 0 && this._blur(s, 0, 0, n), this._applyPMREM(s), this._cleanup(s), s
      }
      fromEquirectangular(e, n = null) {
         return this._fromTexture(e, n)
      }
      fromCubemap(e, n = null) {
         return this._fromTexture(e, n)
      }
      compileCubemapShader() {
         this._cubemapMaterial === null && (this._cubemapMaterial = oR(), this._compileMaterial(this._cubemapMaterial))
      }
      compileEquirectangularShader() {
         this._equirectMaterial === null && (this._equirectMaterial = sR(), this._compileMaterial(this._equirectMaterial))
      }
      dispose() {
         this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
      }
      _setSize(e) {
         this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
      }
      _dispose() {
         this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
         for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
      }
      _cleanup(e) {
         this._renderer.setRenderTarget(__), e.scissorTest = !1, ag(e, 0, 0, e.width, e.height)
      }
      _fromTexture(e, n) {
         e.mapping === Ks || e.mapping === Da ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), __ = this._renderer.getRenderTarget();
         const r = n || this._allocateTargets();
         return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
      }
      _allocateTargets() {
         const e = 3 * Math.max(this._cubeSize, 112),
            n = 4 * this._cubeSize,
            r = {
               magFilter: ln,
               minFilter: ln,
               generateMipmaps: !1,
               type: Cr,
               format: Hr,
               colorSpace: ys,
               depthBuffer: !1
            },
            i = iR(e, n, r);
         if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = iR(e, n, r);
            const {
               _lodMax: s
            } = this;
            ({
               sizeLods: this._sizeLods,
               lodPlanes: this._lodPlanes,
               sigmas: this._sigmas
            } = dV(s)), this._blurMaterial = pV(s, e, n)
         }
         return i
      }
      _compileMaterial(e) {
         const n = new Xn(this._lodPlanes[0], e);
         this._renderer.compile(n, x_)
      }
      _sceneToCubeUV(e, n, r, i) {
         const a = new Zn(90, 1, n, r),
            l = [1, -1, 1, 1, 1, 1],
            u = [1, 1, 1, -1, -1, -1],
            h = this._renderer,
            d = h.autoClear,
            p = h.toneMapping;
         h.getClearColor(nR), h.toneMapping = zs, h.autoClear = !1;
         const m = new mi({
               name: "PMREM.Background",
               side: zr,
               depthWrite: !1,
               depthTest: !1
            }),
            v = new Xn(new ru, m);
         let _ = !1;
         const x = e.background;
         x ? x.isColor && (m.color.copy(x), e.background = null, _ = !0) : (m.color.copy(nR), _ = !0);
         for (let g = 0; g < 6; g++) {
            const S = g % 3;
            S === 0 ? (a.up.set(0, l[g], 0), a.lookAt(u[g], 0, 0)) : S === 1 ? (a.up.set(0, 0, l[g]), a.lookAt(0, u[g], 0)) : (a.up.set(0, l[g], 0), a.lookAt(0, 0, u[g]));
            const A = this._cubeSize;
            ag(i, S * A, g > 2 ? A : 0, A, A), h.setRenderTarget(i), _ && h.render(v, a), h.render(e, a)
         }
         v.geometry.dispose(), v.material.dispose(), h.toneMapping = p, h.autoClear = d, e.background = x
      }
      _textureToCubeUV(e, n) {
         const r = this._renderer,
            i = e.mapping === Ks || e.mapping === Da;
         i ? (this._cubemapMaterial === null && (this._cubemapMaterial = oR()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = sR());
         const s = i ? this._cubemapMaterial : this._equirectMaterial,
            o = new Xn(this._lodPlanes[0], s),
            a = s.uniforms;
         a.envMap.value = e;
         const l = this._cubeSize;
         ag(n, 0, 0, 3 * l, 2 * l), r.setRenderTarget(n), r.render(o, x_)
      }
      _applyPMREM(e) {
         const n = this._renderer,
            r = n.autoClear;
         n.autoClear = !1;
         for (let i = 1; i < this._lodPlanes.length; i++) {
            const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]),
               o = rR[(i - 1) % rR.length];
            this._blur(e, i - 1, i, s, o)
         }
         n.autoClear = r
      }
      _blur(e, n, r, i, s) {
         const o = this._pingPongRenderTarget;
         this._halfBlur(e, o, n, r, i, "latitudinal", s), this._halfBlur(o, e, r, r, i, "longitudinal", s)
      }
      _halfBlur(e, n, r, i, s, o, a) {
         const l = this._renderer,
            u = this._blurMaterial;
         o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
         const h = 3,
            d = new Xn(this._lodPlanes[i], u),
            p = u.uniforms,
            m = this._sizeLods[r] - 1,
            v = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Cl - 1),
            _ = s / v,
            x = isFinite(s) ? 1 + Math.floor(h * _) : Cl;
         x > Cl && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Cl}`);
         const g = [];
         let S = 0;
         for (let B = 0; B < Cl; ++B) {
            const D = B / _,
               T = Math.exp(-D * D / 2);
            g.push(T), B === 0 ? S += T : B < x && (S += 2 * T)
         }
         for (let B = 0; B < g.length; B++) g[B] = g[B] / S;
         p.envMap.value = e.texture, p.samples.value = x, p.weights.value = g, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a);
         const {
            _lodMax: A
         } = this;
         p.dTheta.value = v, p.mipInt.value = A - r;
         const E = this._sizeLods[i],
            C = 3 * E * (i > A - Nc ? i - A + Nc : 0),
            R = 4 * (this._cubeSize - E);
         ag(n, C, R, 3 * E, 2 * E), l.setRenderTarget(n), l.render(d, x_)
      }
   }

   function dV(t) {
      const e = [],
         n = [],
         r = [];
      let i = t;
      const s = t - Nc + 1 + tR.length;
      for (let o = 0; o < s; o++) {
         const a = Math.pow(2, i);
         n.push(a);
         let l = 1 / a;
         o > t - Nc ? l = tR[o - t + Nc - 1] : o === 0 && (l = 0), r.push(l);
         const u = 1 / (a - 2),
            h = -u,
            d = 1 + u,
            p = [h, h, d, h, d, d, h, h, d, d, h, d],
            m = 6,
            v = 6,
            _ = 3,
            x = 2,
            g = 1,
            S = new Float32Array(_ * v * m),
            A = new Float32Array(x * v * m),
            E = new Float32Array(g * v * m);
         for (let R = 0; R < m; R++) {
            const B = R % 3 * 2 / 3 - 1,
               D = R > 2 ? 0 : -1,
               T = [B, D, 0, B + 2 / 3, D, 0, B + 2 / 3, D + 1, 0, B, D, 0, B + 2 / 3, D + 1, 0, B, D + 1, 0];
            S.set(T, _ * v * R), A.set(p, x * v * R);
            const I = [R, R, R, R, R, R];
            E.set(I, g * v * R)
         }
         const C = new Tt;
         C.setAttribute("position", new Zt(S, _)), C.setAttribute("uv", new Zt(A, x)), C.setAttribute("faceIndex", new Zt(E, g)), e.push(C), i > Nc && i--
      }
      return {
         lodPlanes: e,
         sizeLods: n,
         sigmas: r
      }
   }

   function iR(t, e, n) {
      const r = new Ai(t, e, n);
      return r.texture.mapping = bf, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
   }

   function ag(t, e, n, r, i) {
      t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
   }

   function pV(t, e, n) {
      const r = new Float32Array(Cl),
         i = new U(0, 1, 0);
      return new Qi({
         name: "SphericalGaussianBlur",
         defines: {
            n: Cl,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / n,
            CUBEUV_MAX_MIP: `${t}.0`
         },
         uniforms: {
            envMap: {
               value: null
            },
            samples: {
               value: 1
            },
            weights: {
               value: r
            },
            latitudinal: {
               value: !1
            },
            dTheta: {
               value: 0
            },
            mipInt: {
               value: 0
            },
            poleAxis: {
               value: i
            }
         },
         vertexShader: eE(),
         fragmentShader: `

            precision mediump float;
            precision mediump int;

            varying vec3 vOutputDirection;

            uniform sampler2D envMap;
            uniform int samples;
            uniform float weights[ n ];
            uniform bool latitudinal;
            uniform float dTheta;
            uniform float mipInt;
            uniform vec3 poleAxis;

            #define ENVMAP_TYPE_CUBE_UV
            #include <cube_uv_reflection_fragment>

            vec3 getSample( float theta, vec3 axis ) {

                float cosTheta = cos( theta );
                // Rodrigues' axis-angle rotation
                vec3 sampleDirection = vOutputDirection * cosTheta
                    + cross( axis, vOutputDirection ) * sin( theta )
                    + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

                return bilinearCubeUV( envMap, sampleDirection, mipInt );

            }

            void main() {

                vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

                if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

                    axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

                }

                axis = normalize( axis );

                gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
                gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

                for ( int i = 1; i < n; i++ ) {

                    if ( i >= samples ) {

                        break;

                    }

                    float theta = dTheta * float( i );
                    gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
                    gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

                }

            }
        `,
         blending: Co,
         depthTest: !1,
         depthWrite: !1
      })
   }

   function sR() {
      return new Qi({
         name: "EquirectangularToCubeUV",
         uniforms: {
            envMap: {
               value: null
            }
         },
         vertexShader: eE(),
         fragmentShader: `

            precision mediump float;
            precision mediump int;

            varying vec3 vOutputDirection;

            uniform sampler2D envMap;

            #include <common>

            void main() {

                vec3 outputDirection = normalize( vOutputDirection );
                vec2 uv = equirectUv( outputDirection );

                gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

            }
        `,
         blending: Co,
         depthTest: !1,
         depthWrite: !1
      })
   }

   function oR() {
      return new Qi({
         name: "CubemapToCubeUV",
         uniforms: {
            envMap: {
               value: null
            },
            flipEnvMap: {
               value: -1
            }
         },
         vertexShader: eE(),
         fragmentShader: `

            precision mediump float;
            precision mediump int;

            uniform float flipEnvMap;

            varying vec3 vOutputDirection;

            uniform samplerCube envMap;

            void main() {

                gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

            }
        `,
         blending: Co,
         depthTest: !1,
         depthWrite: !1
      })
   }

   function eE() {
      return `

        precision mediump float;
        precision mediump int;

        attribute float faceIndex;

        varying vec3 vOutputDirection;

        // RH coordinate system; PMREM face-indexing convention
        vec3 getDirection( vec2 uv, float face ) {

            uv = 2.0 * uv - 1.0;

            vec3 direction = vec3( uv, 1.0 );

            if ( face == 0.0 ) {

                direction = direction.zyx; // ( 1, v, u ) pos x

            } else if ( face == 1.0 ) {

                direction = direction.xzy;
                direction.xz *= -1.0; // ( -u, 1, -v ) pos y

            } else if ( face == 2.0 ) {

                direction.x *= -1.0; // ( -u, v, 1 ) pos z

            } else if ( face == 3.0 ) {

                direction = direction.zyx;
                direction.xz *= -1.0; // ( -1, v, -u ) neg x

            } else if ( face == 4.0 ) {

                direction = direction.xzy;
                direction.xy *= -1.0; // ( -u, -1, v ) neg y

            } else if ( face == 5.0 ) {

                direction.z *= -1.0; // ( u, v, -1 ) neg z

            }

            return direction;

        }

        void main() {

            vOutputDirection = getDirection( uv, faceIndex );
            gl_Position = vec4( position, 1.0 );

        }
    `
   }

   function mV(t) {
      let e = new WeakMap,
         n = null;

      function r(a) {
         if (a && a.isTexture) {
            const l = a.mapping,
               u = l === cf || l === Fd,
               h = l === Ks || l === Da;
            if (u || h)
               if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                  a.needsPMREMUpdate = !1;
                  let d = e.get(a);
                  return n === null && (n = new JA(t)), d = u ? n.fromEquirectangular(a, d) : n.fromCubemap(a, d), e.set(a, d), d.texture
               } else {
                  if (e.has(a)) return e.get(a).texture; {
                     const d = a.image;
                     if (u && d && d.height > 0 || h && d && i(d)) {
                        n === null && (n = new JA(t));
                        const p = u ? n.fromEquirectangular(a) : n.fromCubemap(a);
                        return e.set(a, p), a.addEventListener("dispose", s), p.texture
                     } else return null
                  }
               }
         }
         return a
      }

      function i(a) {
         let l = 0;
         const u = 6;
         for (let h = 0; h < u; h++) a[h] !== void 0 && l++;
         return l === u
      }

      function s(a) {
         const l = a.target;
         l.removeEventListener("dispose", s);
         const u = e.get(l);
         u !== void 0 && (e.delete(l), u.dispose())
      }

      function o() {
         e = new WeakMap, n !== null && (n.dispose(), n = null)
      }
      return {
         get: r,
         dispose: o
      }
   }

   function gV(t) {
      const e = {};

      function n(r) {
         if (e[r] !== void 0) return e[r];
         let i;
         switch (r) {
            case "WEBGL_depth_texture":
               i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
               break;
            case "EXT_texture_filter_anisotropic":
               i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
               break;
            case "WEBGL_compressed_texture_s3tc":
               i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
               break;
            case "WEBGL_compressed_texture_pvrtc":
               i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
               break;
            default:
               i = t.getExtension(r)
         }
         return e[r] = i, i
      }
      return {
         has: function (r) {
            return n(r) !== null
         },
         init: function (r) {
            r.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
         },
         get: function (r) {
            const i = n(r);
            return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), i
         }
      }
   }

   function vV(t, e, n, r) {
      const i = {},
         s = new WeakMap;

      function o(d) {
         const p = d.target;
         p.index !== null && e.remove(p.index);
         for (const v in p.attributes) e.remove(p.attributes[v]);
         for (const v in p.morphAttributes) {
            const _ = p.morphAttributes[v];
            for (let x = 0, g = _.length; x < g; x++) e.remove(_[x])
         }
         p.removeEventListener("dispose", o), delete i[p.id];
         const m = s.get(p);
         m && (e.remove(m), s.delete(p)), r.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, n.memory.geometries--
      }

      function a(d, p) {
         return i[p.id] === !0 || (p.addEventListener("dispose", o), i[p.id] = !0, n.memory.geometries++), p
      }

      function l(d) {
         const p = d.attributes;
         for (const v in p) e.update(p[v], t.ARRAY_BUFFER);
         const m = d.morphAttributes;
         for (const v in m) {
            const _ = m[v];
            for (let x = 0, g = _.length; x < g; x++) e.update(_[x], t.ARRAY_BUFFER)
         }
      }

      function u(d) {
         const p = [],
            m = d.index,
            v = d.attributes.position;
         let _ = 0;
         if (m !== null) {
            const S = m.array;
            _ = m.version;
            for (let A = 0, E = S.length; A < E; A += 3) {
               const C = S[A + 0],
                  R = S[A + 1],
                  B = S[A + 2];
               p.push(C, R, R, B, B, C)
            }
         } else if (v !== void 0) {
            const S = v.array;
            _ = v.version;
            for (let A = 0, E = S.length / 3 - 1; A < E; A += 3) {
               const C = A + 0,
                  R = A + 1,
                  B = A + 2;
               p.push(C, R, R, B, B, C)
            }
         } else return;
         const x = new(mF(p) ? QM : YM)(p, 1);
         x.version = _;
         const g = s.get(d);
         g && e.remove(g), s.set(d, x)
      }

      function h(d) {
         const p = s.get(d);
         if (p) {
            const m = d.index;
            m !== null && p.version < m.version && u(d)
         } else u(d);
         return s.get(d)
      }
      return {
         get: a,
         update: l,
         getWireframeAttribute: h
      }
   }

   function yV(t, e, n, r) {
      const i = r.isWebGL2;
      let s;

      function o(p) {
         s = p
      }
      let a, l;

      function u(p) {
         a = p.type, l = p.bytesPerElement
      }

      function h(p, m) {
         t.drawElements(s, m, a, p * l), n.update(m, s, 1)
      }

      function d(p, m, v) {
         if (v === 0) return;
         let _, x;
         if (i) _ = t, x = "drawElementsInstanced";
         else if (_ = e.get("ANGLE_instanced_arrays"), x = "drawElementsInstancedANGLE", _ === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
         }
         _[x](s, m, a, p * l, v), n.update(m, s, v)
      }
      this.setMode = o, this.setIndex = u, this.render = h, this.renderInstances = d
   }

   function xV(t) {
      const e = {
            geometries: 0,
            textures: 0
         },
         n = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
         };

      function r(s, o, a) {
         switch (n.calls++, o) {
            case t.TRIANGLES:
               n.triangles += a * (s / 3);
               break;
            case t.LINES:
               n.lines += a * (s / 2);
               break;
            case t.LINE_STRIP:
               n.lines += a * (s - 1);
               break;
            case t.LINE_LOOP:
               n.lines += a * s;
               break;
            case t.POINTS:
               n.points += a * s;
               break;
            default:
               console.error("THREE.WebGLInfo: Unknown draw mode:", o);
               break
         }
      }

      function i() {
         n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
      }
      return {
         memory: e,
         render: n,
         programs: null,
         autoReset: !0,
         reset: i,
         update: r
      }
   }

   function _V(t, e) {
      return t[0] - e[0]
   }

   function AV(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1])
   }

   function SV(t, e, n) {
      const r = {},
         i = new Float32Array(8),
         s = new WeakMap,
         o = new $t,
         a = [];
      for (let u = 0; u < 8; u++) a[u] = [u, 0];

      function l(u, h, d) {
         const p = u.morphTargetInfluences;
         if (e.isWebGL2 === !0) {
            const v = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color,
               _ = v !== void 0 ? v.length : 0;
            let x = s.get(h);
            if (x === void 0 || x.count !== _) {
               let te = function () {
                  K.dispose(), s.delete(h), h.removeEventListener("dispose", te)
               };
               var m = te;
               x !== void 0 && x.texture.dispose();
               const A = h.morphAttributes.position !== void 0,
                  E = h.morphAttributes.normal !== void 0,
                  C = h.morphAttributes.color !== void 0,
                  R = h.morphAttributes.position || [],
                  B = h.morphAttributes.normal || [],
                  D = h.morphAttributes.color || [];
               let T = 0;
               A === !0 && (T = 1), E === !0 && (T = 2), C === !0 && (T = 3);
               let I = h.attributes.position.count * T,
                  N = 1;
               I > e.maxTextureSize && (N = Math.ceil(I / e.maxTextureSize), I = e.maxTextureSize);
               const q = new Float32Array(I * N * 4 * _),
                  K = new Bv(q, I, N, _);
               K.type = dr, K.needsUpdate = !0;
               const Z = T * 4;
               for (let se = 0; se < _; se++) {
                  const oe = R[se],
                     G = B[se],
                     ne = D[se],
                     Y = I * N * 4 * se;
                  for (let X = 0; X < oe.count; X++) {
                     const Q = X * Z;
                     A === !0 && (o.fromBufferAttribute(oe, X), q[Y + Q + 0] = o.x, q[Y + Q + 1] = o.y, q[Y + Q + 2] = o.z, q[Y + Q + 3] = 0), E === !0 && (o.fromBufferAttribute(G, X), q[Y + Q + 4] = o.x, q[Y + Q + 5] = o.y, q[Y + Q + 6] = o.z, q[Y + Q + 7] = 0), C === !0 && (o.fromBufferAttribute(ne, X), q[Y + Q + 8] = o.x, q[Y + Q + 9] = o.y, q[Y + Q + 10] = o.z, q[Y + Q + 11] = ne.itemSize === 4 ? o.w : 1)
                  }
               }
               x = {
                  count: _,
                  texture: K,
                  size: new Se(I, N)
               }, s.set(h, x), h.addEventListener("dispose", te)
            }
            let g = 0;
            for (let A = 0; A < p.length; A++) g += p[A];
            const S = h.morphTargetsRelative ? 1 : 1 - g;
            d.getUniforms().setValue(t, "morphTargetBaseInfluence", S), d.getUniforms().setValue(t, "morphTargetInfluences", p), d.getUniforms().setValue(t, "morphTargetsTexture", x.texture, n), d.getUniforms().setValue(t, "morphTargetsTextureSize", x.size)
         } else {
            const v = p === void 0 ? 0 : p.length;
            let _ = r[h.id];
            if (_ === void 0 || _.length !== v) {
               _ = [];
               for (let E = 0; E < v; E++) _[E] = [E, 0];
               r[h.id] = _
            }
            for (let E = 0; E < v; E++) {
               const C = _[E];
               C[0] = E, C[1] = p[E]
            }
            _.sort(AV);
            for (let E = 0; E < 8; E++) E < v && _[E][1] ? (a[E][0] = _[E][0], a[E][1] = _[E][1]) : (a[E][0] = Number.MAX_SAFE_INTEGER, a[E][1] = 0);
            a.sort(_V);
            const x = h.morphAttributes.position,
               g = h.morphAttributes.normal;
            let S = 0;
            for (let E = 0; E < 8; E++) {
               const C = a[E],
                  R = C[0],
                  B = C[1];
               R !== Number.MAX_SAFE_INTEGER && B ? (x && h.getAttribute("morphTarget" + E) !== x[R] && h.setAttribute("morphTarget" + E, x[R]), g && h.getAttribute("morphNormal" + E) !== g[R] && h.setAttribute("morphNormal" + E, g[R]), i[E] = B, S += B) : (x && h.hasAttribute("morphTarget" + E) === !0 && h.deleteAttribute("morphTarget" + E), g && h.hasAttribute("morphNormal" + E) === !0 && h.deleteAttribute("morphNormal" + E), i[E] = 0)
            }
            const A = h.morphTargetsRelative ? 1 : 1 - S;
            d.getUniforms().setValue(t, "morphTargetBaseInfluence", A), d.getUniforms().setValue(t, "morphTargetInfluences", i)
         }
      }
      return {
         update: l
      }
   }

   function MV(t, e, n, r) {
      let i = new WeakMap;

      function s(l) {
         const u = r.render.frame,
            h = l.geometry,
            d = e.get(l, h);
         if (i.get(d) !== u && (e.update(d), i.set(d, u)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== u && (n.update(l.instanceMatrix, t.ARRAY_BUFFER), l.instanceColor !== null && n.update(l.instanceColor, t.ARRAY_BUFFER), i.set(l, u))), l.isSkinnedMesh) {
            const p = l.skeleton;
            i.get(p) !== u && (p.update(), i.set(p, u))
         }
         return d
      }

      function o() {
         i = new WeakMap
      }

      function a(l) {
         const u = l.target;
         u.removeEventListener("dispose", a), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor)
      }
      return {
         update: s,
         dispose: o
      }
   }
   const AF = new yn,
      SF = new Bv,
      MF = new KM,
      EF = new ap,
      aR = [],
      lR = [],
      uR = new Float32Array(16),
      cR = new Float32Array(9),
      fR = new Float32Array(4);

   function Rf(t, e, n) {
      const r = t[0];
      if (r <= 0 || r > 0) return t;
      const i = e * n;
      let s = aR[i];
      if (s === void 0 && (s = new Float32Array(i), aR[i] = s), e !== 0) {
         r.toArray(s, 0);
         for (let o = 1, a = 0; o !== e; ++o) a += n, t[o].toArray(s, a)
      }
      return s
   }

   function nr(t, e) {
      if (t.length !== e.length) return !1;
      for (let n = 0, r = t.length; n < r; n++)
         if (t[n] !== e[n]) return !1;
      return !0
   }

   function rr(t, e) {
      for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
   }

   function Lv(t, e) {
      let n = lR[e];
      n === void 0 && (n = new Int32Array(e), lR[e] = n);
      for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
      return n
   }

   function EV(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
   }

   function wV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
      else {
         if (nr(n, e)) return;
         t.uniform2fv(this.addr, e), rr(n, e)
      }
   }

   function bV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
      else if (e.r !== void 0)(n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
      else {
         if (nr(n, e)) return;
         t.uniform3fv(this.addr, e), rr(n, e)
      }
   }

   function CV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
      else {
         if (nr(n, e)) return;
         t.uniform4fv(this.addr, e), rr(n, e)
      }
   }

   function TV(t, e) {
      const n = this.cache,
         r = e.elements;
      if (r === void 0) {
         if (nr(n, e)) return;
         t.uniformMatrix2fv(this.addr, !1, e), rr(n, e)
      } else {
         if (nr(n, r)) return;
         fR.set(r), t.uniformMatrix2fv(this.addr, !1, fR), rr(n, r)
      }
   }

   function RV(t, e) {
      const n = this.cache,
         r = e.elements;
      if (r === void 0) {
         if (nr(n, e)) return;
         t.uniformMatrix3fv(this.addr, !1, e), rr(n, e)
      } else {
         if (nr(n, r)) return;
         cR.set(r), t.uniformMatrix3fv(this.addr, !1, cR), rr(n, r)
      }
   }

   function PV(t, e) {
      const n = this.cache,
         r = e.elements;
      if (r === void 0) {
         if (nr(n, e)) return;
         t.uniformMatrix4fv(this.addr, !1, e), rr(n, e)
      } else {
         if (nr(n, r)) return;
         uR.set(r), t.uniformMatrix4fv(this.addr, !1, uR), rr(n, r)
      }
   }

   function BV(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
   }

   function IV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
      else {
         if (nr(n, e)) return;
         t.uniform2iv(this.addr, e), rr(n, e)
      }
   }

   function LV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
      else {
         if (nr(n, e)) return;
         t.uniform3iv(this.addr, e), rr(n, e)
      }
   }

   function DV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
      else {
         if (nr(n, e)) return;
         t.uniform4iv(this.addr, e), rr(n, e)
      }
   }

   function FV(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
   }

   function OV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
      else {
         if (nr(n, e)) return;
         t.uniform2uiv(this.addr, e), rr(n, e)
      }
   }

   function NV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
      else {
         if (nr(n, e)) return;
         t.uniform3uiv(this.addr, e), rr(n, e)
      }
   }

   function UV(t, e) {
      const n = this.cache;
      if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
      else {
         if (nr(n, e)) return;
         t.uniform4uiv(this.addr, e), rr(n, e)
      }
   }

   function kV(t, e, n) {
      const r = this.cache,
         i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(e || AF, i)
   }

   function HV(t, e, n) {
      const r = this.cache,
         i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || MF, i)
   }

   function GV(t, e, n) {
      const r = this.cache,
         i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || EF, i)
   }

   function zV(t, e, n) {
      const r = this.cache,
         i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || SF, i)
   }

   function VV(t) {
      switch (t) {
         case 5126:
            return EV;
         case 35664:
            return wV;
         case 35665:
            return bV;
         case 35666:
            return CV;
         case 35674:
            return TV;
         case 35675:
            return RV;
         case 35676:
            return PV;
         case 5124:
         case 35670:
            return BV;
         case 35667:
         case 35671:
            return IV;
         case 35668:
         case 35672:
            return LV;
         case 35669:
         case 35673:
            return DV;
         case 5125:
            return FV;
         case 36294:
            return OV;
         case 36295:
            return NV;
         case 36296:
            return UV;
         case 35678:
         case 36198:
         case 36298:
         case 36306:
         case 35682:
            return kV;
         case 35679:
         case 36299:
         case 36307:
            return HV;
         case 35680:
         case 36300:
         case 36308:
         case 36293:
            return GV;
         case 36289:
         case 36303:
         case 36311:
         case 36292:
            return zV
      }
   }

   function WV(t, e) {
      t.uniform1fv(this.addr, e)
   }

   function jV(t, e) {
      const n = Rf(e, this.size, 2);
      t.uniform2fv(this.addr, n)
   }

   function $V(t, e) {
      const n = Rf(e, this.size, 3);
      t.uniform3fv(this.addr, n)
   }

   function XV(t, e) {
      const n = Rf(e, this.size, 4);
      t.uniform4fv(this.addr, n)
   }

   function JV(t, e) {
      const n = Rf(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, n)
   }

   function KV(t, e) {
      const n = Rf(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, n)
   }

   function YV(t, e) {
      const n = Rf(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, n)
   }

   function QV(t, e) {
      t.uniform1iv(this.addr, e)
   }

   function ZV(t, e) {
      t.uniform2iv(this.addr, e)
   }

   function qV(t, e) {
      t.uniform3iv(this.addr, e)
   }

   function e6(t, e) {
      t.uniform4iv(this.addr, e)
   }

   function t6(t, e) {
      t.uniform1uiv(this.addr, e)
   }

   function n6(t, e) {
      t.uniform2uiv(this.addr, e)
   }

   function r6(t, e) {
      t.uniform3uiv(this.addr, e)
   }

   function i6(t, e) {
      t.uniform4uiv(this.addr, e)
   }

   function s6(t, e, n) {
      const r = this.cache,
         i = e.length,
         s = Lv(n, i);
      nr(r, s) || (t.uniform1iv(this.addr, s), rr(r, s));
      for (let o = 0; o !== i; ++o) n.setTexture2D(e[o] || AF, s[o])
   }

   function o6(t, e, n) {
      const r = this.cache,
         i = e.length,
         s = Lv(n, i);
      nr(r, s) || (t.uniform1iv(this.addr, s), rr(r, s));
      for (let o = 0; o !== i; ++o) n.setTexture3D(e[o] || MF, s[o])
   }

   function a6(t, e, n) {
      const r = this.cache,
         i = e.length,
         s = Lv(n, i);
      nr(r, s) || (t.uniform1iv(this.addr, s), rr(r, s));
      for (let o = 0; o !== i; ++o) n.setTextureCube(e[o] || EF, s[o])
   }

   function l6(t, e, n) {
      const r = this.cache,
         i = e.length,
         s = Lv(n, i);
      nr(r, s) || (t.uniform1iv(this.addr, s), rr(r, s));
      for (let o = 0; o !== i; ++o) n.setTexture2DArray(e[o] || SF, s[o])
   }

   function u6(t) {
      switch (t) {
         case 5126:
            return WV;
         case 35664:
            return jV;
         case 35665:
            return $V;
         case 35666:
            return XV;
         case 35674:
            return JV;
         case 35675:
            return KV;
         case 35676:
            return YV;
         case 5124:
         case 35670:
            return QV;
         case 35667:
         case 35671:
            return ZV;
         case 35668:
         case 35672:
            return qV;
         case 35669:
         case 35673:
            return e6;
         case 5125:
            return t6;
         case 36294:
            return n6;
         case 36295:
            return r6;
         case 36296:
            return i6;
         case 35678:
         case 36198:
         case 36298:
         case 36306:
         case 35682:
            return s6;
         case 35679:
         case 36299:
         case 36307:
            return o6;
         case 35680:
         case 36300:
         case 36308:
         case 36293:
            return a6;
         case 36289:
         case 36303:
         case 36311:
         case 36292:
            return l6
      }
   }
   class c6 {
      constructor(e, n, r) {
         this.id = e, this.addr = r, this.cache = [], this.setValue = VV(n.type)
      }
   }
   class f6 {
      constructor(e, n, r) {
         this.id = e, this.addr = r, this.cache = [], this.size = n.size, this.setValue = u6(n.type)
      }
   }
   class h6 {
      constructor(e) {
         this.id = e, this.seq = [], this.map = {}
      }
      setValue(e, n, r) {
         const i = this.seq;
         for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(e, n[a.id], r)
         }
      }
   }
   const A_ = /(\w+)(\])?(\[|\.)?/g;

   function hR(t, e) {
      t.seq.push(e), t.map[e.id] = e
   }

   function d6(t, e, n) {
      const r = t.name,
         i = r.length;
      for (A_.lastIndex = 0;;) {
         const s = A_.exec(r),
            o = A_.lastIndex;
         let a = s[1];
         const l = s[2] === "]",
            u = s[3];
         if (l && (a = a | 0), u === void 0 || u === "[" && o + 2 === i) {
            hR(n, u === void 0 ? new c6(a, t, e) : new f6(a, t, e));
            break
         } else {
            let d = n.map[a];
            d === void 0 && (d = new h6(a), hR(n, d)), n = d
         }
      }
   }
   class u0 {
      constructor(e, n) {
         this.seq = [], this.map = {};
         const r = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
         for (let i = 0; i < r; ++i) {
            const s = e.getActiveUniform(n, i),
               o = e.getUniformLocation(n, s.name);
            d6(s, o, this)
         }
      }
      setValue(e, n, r, i) {
         const s = this.map[n];
         s !== void 0 && s.setValue(e, r, i)
      }
      setOptional(e, n, r) {
         const i = n[r];
         i !== void 0 && this.setValue(e, r, i)
      }
      static upload(e, n, r, i) {
         for (let s = 0, o = n.length; s !== o; ++s) {
            const a = n[s],
               l = r[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, i)
         }
      }
      static seqWithValue(e, n) {
         const r = [];
         for (let i = 0, s = e.length; i !== s; ++i) {
            const o = e[i];
            o.id in n && r.push(o)
         }
         return r
      }
   }

   function dR(t, e, n) {
      const r = t.createShader(e);
      return t.shaderSource(r, n), t.compileShader(r), r
   }
   let p6 = 0;

   function m6(t, e) {
      const n = t.split(`
`),
         r = [],
         i = Math.max(e - 6, 0),
         s = Math.min(e + 6, n.length);
      for (let o = i; o < s; o++) {
         const a = o + 1;
         r.push(`${a===e?">":" "} ${a}: ${n[o]}`)
      }
      return r.join(`
`)
   }

   function g6(t) {
      switch (t) {
         case ys:
            return ["Linear", "( value )"];
         case Rt:
            return ["sRGB", "( value )"];
         default:
            return console.warn("THREE.WebGLProgram: Unsupported color space:", t), ["Linear", "( value )"]
      }
   }

   function pR(t, e, n) {
      const r = t.getShaderParameter(e, t.COMPILE_STATUS),
         i = t.getShaderInfoLog(e).trim();
      if (r && i === "") return "";
      const s = /ERROR: 0:(\d+)/.exec(i);
      if (s) {
         const o = parseInt(s[1]);
         return n.toUpperCase() + `

` + i + `

` + m6(t.getShaderSource(e), o)
      } else return i
   }

   function v6(t, e) {
      const n = g6(e);
      return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
   }

   function y6(t, e) {
      let n;
      switch (e) {
         case H3:
            n = "Linear";
            break;
         case G3:
            n = "Reinhard";
            break;
         case z3:
            n = "OptimizedCineon";
            break;
         case FM:
            n = "ACESFilmic";
            break;
         case V3:
            n = "Custom";
            break;
         default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
      }
      return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
   }

   function x6(t) {
      return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || t.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter($h).join(`
`)
   }

   function _6(t) {
      const e = [];
      for (const n in t) {
         const r = t[n];
         r !== !1 && e.push("#define " + n + " " + r)
      }
      return e.join(`
`)
   }

   function A6(t, e) {
      const n = {},
         r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
      for (let i = 0; i < r; i++) {
         const s = t.getActiveAttrib(e, i),
            o = s.name;
         let a = 1;
         s.type === t.FLOAT_MAT2 && (a = 2), s.type === t.FLOAT_MAT3 && (a = 3), s.type === t.FLOAT_MAT4 && (a = 4), n[o] = {
            type: s.type,
            location: t.getAttribLocation(e, o),
            locationSize: a
         }
      }
      return n
   }

   function $h(t) {
      return t !== ""
   }

   function mR(t, e) {
      const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
      return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
   }

   function gR(t, e) {
      return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
   }
   const S6 = /^[ \t]*#include +<([\w\d./]+)>/gm;

   function KA(t) {
      return t.replace(S6, E6)
   }
   const M6 = new Map([
      ["encodings_fragment", "colorspace_fragment"],
      ["encodings_pars_fragment", "colorspace_pars_fragment"],
      ["output_fragment", "opaque_fragment"]
   ]);

   function E6(t, e) {
      let n = Bt[e];
      if (n === void 0) {
         const r = M6.get(e);
         if (r !== void 0) n = Bt[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r);
         else throw new Error("Can not resolve #include <" + e + ">")
      }
      return KA(n)
   }
   const w6 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

   function vR(t) {
      return t.replace(w6, b6)
   }

   function b6(t, e, n, r) {
      let i = "";
      for (let s = parseInt(e); s < parseInt(n); s++) i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
      return i
   }

   function yR(t) {
      let e = "precision " + t.precision + ` float;
precision ` + t.precision + " int;";
      return t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
   }

   function C6(t) {
      let e = "SHADOWMAP_TYPE_BASIC";
      return t.shadowMapType === bv ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === od ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === cs && (e = "SHADOWMAP_TYPE_VSM"), e
   }

   function T6(t) {
      let e = "ENVMAP_TYPE_CUBE";
      if (t.envMap) switch (t.envMapMode) {
         case Ks:
         case Da:
            e = "ENVMAP_TYPE_CUBE";
            break;
         case bf:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
      }
      return e
   }

   function R6(t) {
      let e = "ENVMAP_MODE_REFLECTION";
      if (t.envMap) switch (t.envMapMode) {
         case Da:
            e = "ENVMAP_MODE_REFRACTION";
            break
      }
      return e
   }

   function P6(t) {
      let e = "ENVMAP_BLENDING_NONE";
      if (t.envMap) switch (t.combine) {
         case sp:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
         case U3:
            e = "ENVMAP_BLENDING_MIX";
            break;
         case k3:
            e = "ENVMAP_BLENDING_ADD";
            break
      }
      return e
   }

   function B6(t) {
      const e = t.envMapCubeUVHeight;
      if (e === null) return null;
      const n = Math.log2(e) - 2,
         r = 1 / e;
      return {
         texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
         texelHeight: r,
         maxMip: n
      }
   }

   function I6(t, e, n, r) {
      const i = t.getContext(),
         s = n.defines;
      let o = n.vertexShader,
         a = n.fragmentShader;
      const l = C6(n),
         u = T6(n),
         h = R6(n),
         d = P6(n),
         p = B6(n),
         m = n.isWebGL2 ? "" : x6(n),
         v = _6(s),
         _ = i.createProgram();
      let x, g, S = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
      n.isRawShaderMaterial ? (x = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter($h).join(`
`), x.length > 0 && (x += `
`), g = [m, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter($h).join(`
`), g.length > 0 && (g += `
`)) : (x = [yR(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "  attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", " attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "   attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", " attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", " attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", " attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", " attribute vec4 color;", "#elif defined( USE_COLOR )", " attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", " attribute vec3 morphTarget0;", "    attribute vec3 morphTarget1;", "    attribute vec3 morphTarget2;", "    attribute vec3 morphTarget3;", "    #ifdef USE_MORPHNORMALS", "     attribute vec3 morphNormal0;", "        attribute vec3 morphNormal1;", "        attribute vec3 morphNormal2;", "        attribute vec3 morphNormal3;", "    #else", "       attribute vec3 morphTarget4;", "        attribute vec3 morphTarget5;", "        attribute vec3 morphTarget6;", "        attribute vec3 morphTarget7;", "    #endif", "#endif", "#ifdef USE_SKINNING", " attribute vec4 skinIndex;", "   attribute vec4 skinWeight;", "#endif", `
`].filter($h).join(`
`), g = [m, yR(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== zs ? "#define TONE_MAPPING" : "", n.toneMapping !== zs ? Bt.tonemapping_pars_fragment : "", n.toneMapping !== zs ? y6("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Bt.colorspace_pars_fragment, v6("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter($h).join(`
`)), o = KA(o), o = mR(o, n), o = gR(o, n), a = KA(a), a = mR(a, n), a = gR(a, n), o = vR(o), a = vR(a), n.isWebGL2 && n.isRawShaderMaterial !== !0 && (S = `#version 300 es
`, x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + x, g = ["#define varying in", n.glslVersion === $A ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === $A ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + g);
      const A = S + x + o,
         E = S + g + a,
         C = dR(i, i.VERTEX_SHADER, A),
         R = dR(i, i.FRAGMENT_SHADER, E);
      if (i.attachShader(_, C), i.attachShader(_, R), n.index0AttributeName !== void 0 ? i.bindAttribLocation(_, 0, n.index0AttributeName) : n.morphTargets === !0 && i.bindAttribLocation(_, 0, "position"), i.linkProgram(_), t.debug.checkShaderErrors) {
         const T = i.getProgramInfoLog(_).trim(),
            I = i.getShaderInfoLog(C).trim(),
            N = i.getShaderInfoLog(R).trim();
         let q = !0,
            K = !0;
         if (i.getProgramParameter(_, i.LINK_STATUS) === !1)
            if (q = !1, typeof t.debug.onShaderError == "function") t.debug.onShaderError(i, _, C, R);
            else {
               const Z = pR(i, C, "vertex"),
                  te = pR(i, R, "fragment");
               console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(_, i.VALIDATE_STATUS) + `

Program Info Log: ` + T + `
` + Z + `
` + te)
            }
         else T !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", T) : (I === "" || N === "") && (K = !1);
         K && (this.diagnostics = {
            runnable: q,
            programLog: T,
            vertexShader: {
               log: I,
               prefix: x
            },
            fragmentShader: {
               log: N,
               prefix: g
            }
         })
      }
      i.deleteShader(C), i.deleteShader(R);
      let B;
      this.getUniforms = function () {
         return B === void 0 && (B = new u0(i, _)), B
      };
      let D;
      return this.getAttributes = function () {
         return D === void 0 && (D = A6(i, _)), D
      }, this.destroy = function () {
         r.releaseStatesOfProgram(this), i.deleteProgram(_), this.program = void 0
      }, this.type = n.shaderType, this.name = n.shaderName, this.id = p6++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = R, this
   }
   let L6 = 0;
   class D6 {
      constructor() {
         this.shaderCache = new Map, this.materialCache = new Map
      }
      update(e) {
         const n = e.vertexShader,
            r = e.fragmentShader,
            i = this._getShaderStage(n),
            s = this._getShaderStage(r),
            o = this._getShaderCacheForMaterial(e);
         return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
      }
      remove(e) {
         const n = this.materialCache.get(e);
         for (const r of n) r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
         return this.materialCache.delete(e), this
      }
      getVertexShaderID(e) {
         return this._getShaderStage(e.vertexShader).id
      }
      getFragmentShaderID(e) {
         return this._getShaderStage(e.fragmentShader).id
      }
      dispose() {
         this.shaderCache.clear(), this.materialCache.clear()
      }
      _getShaderCacheForMaterial(e) {
         const n = this.materialCache;
         let r = n.get(e);
         return r === void 0 && (r = new Set, n.set(e, r)), r
      }
      _getShaderStage(e) {
         const n = this.shaderCache;
         let r = n.get(e);
         return r === void 0 && (r = new F6(e), n.set(e, r)), r
      }
   }
   class F6 {
      constructor(e) {
         this.id = L6++, this.code = e, this.usedTimes = 0
      }
   }

   function O6(t, e, n, r, i, s, o) {
      const a = new zl,
         l = new D6,
         u = [],
         h = i.isWebGL2,
         d = i.logarithmicDepthBuffer,
         p = i.vertexTextures;
      let m = i.precision;
      const v = {
         MeshDepthMaterial: "depth",
         MeshDistanceMaterial: "distanceRGBA",
         MeshNormalMaterial: "normal",
         MeshBasicMaterial: "basic",
         MeshLambertMaterial: "lambert",
         MeshPhongMaterial: "phong",
         MeshToonMaterial: "toon",
         MeshStandardMaterial: "physical",
         MeshPhysicalMaterial: "physical",
         MeshMatcapMaterial: "matcap",
         LineBasicMaterial: "basic",
         LineDashedMaterial: "dashed",
         PointsMaterial: "points",
         ShadowMaterial: "shadow",
         SpriteMaterial: "sprite"
      };

      function _(T) {
         return T === 0 ? "uv" : `uv${T}`
      }

      function x(T, I, N, q, K) {
         const Z = q.fog,
            te = K.geometry,
            se = T.isMeshStandardMaterial ? q.environment : null,
            oe = (T.isMeshStandardMaterial ? n : e).get(T.envMap || se),
            G = oe && oe.mapping === bf ? oe.image.height : null,
            ne = v[T.type];
         T.precision !== null && (m = i.getMaxPrecision(T.precision), m !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", m, "instead."));
         const Y = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color,
            X = Y !== void 0 ? Y.length : 0;
         let Q = 0;
         te.morphAttributes.position !== void 0 && (Q = 1), te.morphAttributes.normal !== void 0 && (Q = 2), te.morphAttributes.color !== void 0 && (Q = 3);
         let _e, Me, we, Ee;
         if (ne) {
            const en = ds[ne];
            _e = en.vertexShader, Me = en.fragmentShader
         } else _e = T.vertexShader, Me = T.fragmentShader, l.update(T), we = l.getVertexShaderID(T), Ee = l.getFragmentShaderID(T);
         const Ue = t.getRenderTarget(),
            Qe = K.isInstancedMesh === !0,
            Pt = !!T.map,
            kt = !!T.matcap,
            $e = !!oe,
            J = !!T.aoMap,
            Ce = !!T.lightMap,
            Ae = !!T.bumpMap,
            Ie = !!T.normalMap,
            be = !!T.displacementMap,
            lt = !!T.emissiveMap,
            Je = !!T.metalnessMap,
            qe = !!T.roughnessMap,
            vt = T.anisotropy > 0,
            Ot = T.clearcoat > 0,
            un = T.iridescence > 0,
            j = T.sheen > 0,
            O = T.transmission > 0,
            ue = vt && !!T.anisotropyMap,
            Pe = Ot && !!T.clearcoatMap,
            Te = Ot && !!T.clearcoatNormalMap,
            Be = Ot && !!T.clearcoatRoughnessMap,
            rt = un && !!T.iridescenceMap,
            Le = un && !!T.iridescenceThicknessMap,
            de = j && !!T.sheenColorMap,
            ht = j && !!T.sheenRoughnessMap,
            st = !!T.specularMap,
            Ke = !!T.specularColorMap,
            et = !!T.specularIntensityMap,
            Ye = O && !!T.transmissionMap,
            pt = O && !!T.thicknessMap,
            Mt = !!T.gradientMap,
            ee = !!T.alphaMap,
            fe = T.alphaTest > 0,
            he = !!T.alphaHash,
            Fe = !!T.extensions,
            ze = !!te.attributes.uv1,
            Ut = !!te.attributes.uv2,
            sn = !!te.attributes.uv3;
         let xn = zs;
         return T.toneMapped && (Ue === null || Ue.isXRRenderTarget === !0) && (xn = t.toneMapping), {
            isWebGL2: h,
            shaderID: ne,
            shaderType: T.type,
            shaderName: T.name,
            vertexShader: _e,
            fragmentShader: Me,
            defines: T.defines,
            customVertexShaderID: we,
            customFragmentShaderID: Ee,
            isRawShaderMaterial: T.isRawShaderMaterial === !0,
            glslVersion: T.glslVersion,
            precision: m,
            instancing: Qe,
            instancingColor: Qe && K.instanceColor !== null,
            supportsVertexTextures: p,
            outputColorSpace: Ue === null ? t.outputColorSpace : Ue.isXRRenderTarget === !0 ? Ue.texture.colorSpace : ys,
            map: Pt,
            matcap: kt,
            envMap: $e,
            envMapMode: $e && oe.mapping,
            envMapCubeUVHeight: G,
            aoMap: J,
            lightMap: Ce,
            bumpMap: Ae,
            normalMap: Ie,
            displacementMap: p && be,
            emissiveMap: lt,
            normalMapObjectSpace: Ie && T.normalMapType === iF,
            normalMapTangentSpace: Ie && T.normalMapType === $a,
            metalnessMap: Je,
            roughnessMap: qe,
            anisotropy: vt,
            anisotropyMap: ue,
            clearcoat: Ot,
            clearcoatMap: Pe,
            clearcoatNormalMap: Te,
            clearcoatRoughnessMap: Be,
            iridescence: un,
            iridescenceMap: rt,
            iridescenceThicknessMap: Le,
            sheen: j,
            sheenColorMap: de,
            sheenRoughnessMap: ht,
            specularMap: st,
            specularColorMap: Ke,
            specularIntensityMap: et,
            transmission: O,
            transmissionMap: Ye,
            thicknessMap: pt,
            gradientMap: Mt,
            opaque: T.transparent === !1 && T.blending === Hl,
            alphaMap: ee,
            alphaTest: fe,
            alphaHash: he,
            combine: T.combine,
            mapUv: Pt && _(T.map.channel),
            aoMapUv: J && _(T.aoMap.channel),
            lightMapUv: Ce && _(T.lightMap.channel),
            bumpMapUv: Ae && _(T.bumpMap.channel),
            normalMapUv: Ie && _(T.normalMap.channel),
            displacementMapUv: be && _(T.displacementMap.channel),
            emissiveMapUv: lt && _(T.emissiveMap.channel),
            metalnessMapUv: Je && _(T.metalnessMap.channel),
            roughnessMapUv: qe && _(T.roughnessMap.channel),
            anisotropyMapUv: ue && _(T.anisotropyMap.channel),
            clearcoatMapUv: Pe && _(T.clearcoatMap.channel),
            clearcoatNormalMapUv: Te && _(T.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Be && _(T.clearcoatRoughnessMap.channel),
            iridescenceMapUv: rt && _(T.iridescenceMap.channel),
            iridescenceThicknessMapUv: Le && _(T.iridescenceThicknessMap.channel),
            sheenColorMapUv: de && _(T.sheenColorMap.channel),
            sheenRoughnessMapUv: ht && _(T.sheenRoughnessMap.channel),
            specularMapUv: st && _(T.specularMap.channel),
            specularColorMapUv: Ke && _(T.specularColorMap.channel),
            specularIntensityMapUv: et && _(T.specularIntensityMap.channel),
            transmissionMapUv: Ye && _(T.transmissionMap.channel),
            thicknessMapUv: pt && _(T.thicknessMap.channel),
            alphaMapUv: ee && _(T.alphaMap.channel),
            vertexTangents: !!te.attributes.tangent && (Ie || vt),
            vertexColors: T.vertexColors,
            vertexAlphas: T.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4,
            vertexUv1s: ze,
            vertexUv2s: Ut,
            vertexUv3s: sn,
            pointsUvs: K.isPoints === !0 && !!te.attributes.uv && (Pt || ee),
            fog: !!Z,
            useFog: T.fog === !0,
            fogExp2: Z && Z.isFogExp2,
            flatShading: T.flatShading === !0,
            sizeAttenuation: T.sizeAttenuation === !0,
            logarithmicDepthBuffer: d,
            skinning: K.isSkinnedMesh === !0,
            morphTargets: te.morphAttributes.position !== void 0,
            morphNormals: te.morphAttributes.normal !== void 0,
            morphColors: te.morphAttributes.color !== void 0,
            morphTargetsCount: X,
            morphTextureStride: Q,
            numDirLights: I.directional.length,
            numPointLights: I.point.length,
            numSpotLights: I.spot.length,
            numSpotLightMaps: I.spotLightMap.length,
            numRectAreaLights: I.rectArea.length,
            numHemiLights: I.hemi.length,
            numDirLightShadows: I.directionalShadowMap.length,
            numPointLightShadows: I.pointShadowMap.length,
            numSpotLightShadows: I.spotShadowMap.length,
            numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: T.dithering,
            shadowMapEnabled: t.shadowMap.enabled && N.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: xn,
            useLegacyLights: t._useLegacyLights,
            premultipliedAlpha: T.premultipliedAlpha,
            doubleSided: T.side === Wi,
            flipSided: T.side === zr,
            useDepthPacking: T.depthPacking >= 0,
            depthPacking: T.depthPacking || 0,
            index0AttributeName: T.index0AttributeName,
            extensionDerivatives: Fe && T.extensions.derivatives === !0,
            extensionFragDepth: Fe && T.extensions.fragDepth === !0,
            extensionDrawBuffers: Fe && T.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: Fe && T.extensions.shaderTextureLOD === !0,
            rendererExtensionFragDepth: h || r.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || r.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: h || r.has("EXT_shader_texture_lod"),
            customProgramCacheKey: T.customProgramCacheKey()
         }
      }

      function g(T) {
         const I = [];
         if (T.shaderID ? I.push(T.shaderID) : (I.push(T.customVertexShaderID), I.push(T.customFragmentShaderID)), T.defines !== void 0)
            for (const N in T.defines) I.push(N), I.push(T.defines[N]);
         return T.isRawShaderMaterial === !1 && (S(I, T), A(I, T), I.push(t.outputColorSpace)), I.push(T.customProgramCacheKey), I.join()
      }

      function S(T, I) {
         T.push(I.precision), T.push(I.outputColorSpace), T.push(I.envMapMode), T.push(I.envMapCubeUVHeight), T.push(I.mapUv), T.push(I.alphaMapUv), T.push(I.lightMapUv), T.push(I.aoMapUv), T.push(I.bumpMapUv), T.push(I.normalMapUv), T.push(I.displacementMapUv), T.push(I.emissiveMapUv), T.push(I.metalnessMapUv), T.push(I.roughnessMapUv), T.push(I.anisotropyMapUv), T.push(I.clearcoatMapUv), T.push(I.clearcoatNormalMapUv), T.push(I.clearcoatRoughnessMapUv), T.push(I.iridescenceMapUv), T.push(I.iridescenceThicknessMapUv), T.push(I.sheenColorMapUv), T.push(I.sheenRoughnessMapUv), T.push(I.specularMapUv), T.push(I.specularColorMapUv), T.push(I.specularIntensityMapUv), T.push(I.transmissionMapUv), T.push(I.thicknessMapUv), T.push(I.combine), T.push(I.fogExp2), T.push(I.sizeAttenuation), T.push(I.morphTargetsCount), T.push(I.morphAttributeCount), T.push(I.numDirLights), T.push(I.numPointLights), T.push(I.numSpotLights), T.push(I.numSpotLightMaps), T.push(I.numHemiLights), T.push(I.numRectAreaLights), T.push(I.numDirLightShadows), T.push(I.numPointLightShadows), T.push(I.numSpotLightShadows), T.push(I.numSpotLightShadowsWithMaps), T.push(I.shadowMapType), T.push(I.toneMapping), T.push(I.numClippingPlanes), T.push(I.numClipIntersection), T.push(I.depthPacking)
      }

      function A(T, I) {
         a.disableAll(), I.isWebGL2 && a.enable(0), I.supportsVertexTextures && a.enable(1), I.instancing && a.enable(2), I.instancingColor && a.enable(3), I.matcap && a.enable(4), I.envMap && a.enable(5), I.normalMapObjectSpace && a.enable(6), I.normalMapTangentSpace && a.enable(7), I.clearcoat && a.enable(8), I.iridescence && a.enable(9), I.alphaTest && a.enable(10), I.vertexColors && a.enable(11), I.vertexAlphas && a.enable(12), I.vertexUv1s && a.enable(13), I.vertexUv2s && a.enable(14), I.vertexUv3s && a.enable(15), I.vertexTangents && a.enable(16), I.anisotropy && a.enable(17), T.push(a.mask), a.disableAll(), I.fog && a.enable(0), I.useFog && a.enable(1), I.flatShading && a.enable(2), I.logarithmicDepthBuffer && a.enable(3), I.skinning && a.enable(4), I.morphTargets && a.enable(5), I.morphNormals && a.enable(6), I.morphColors && a.enable(7), I.premultipliedAlpha && a.enable(8), I.shadowMapEnabled && a.enable(9), I.useLegacyLights && a.enable(10), I.doubleSided && a.enable(11), I.flipSided && a.enable(12), I.useDepthPacking && a.enable(13), I.dithering && a.enable(14), I.transmission && a.enable(15), I.sheen && a.enable(16), I.opaque && a.enable(17), I.pointsUvs && a.enable(18), T.push(a.mask)
      }

      function E(T) {
         const I = v[T.type];
         let N;
         if (I) {
            const q = ds[I];
            N = ZM.clone(q.uniforms)
         } else N = T.uniforms;
         return N
      }

      function C(T, I) {
         let N;
         for (let q = 0, K = u.length; q < K; q++) {
            const Z = u[q];
            if (Z.cacheKey === I) {
               N = Z, ++N.usedTimes;
               break
            }
         }
         return N === void 0 && (N = new I6(t, I, T, s), u.push(N)), N
      }

      function R(T) {
         if (--T.usedTimes === 0) {
            const I = u.indexOf(T);
            u[I] = u[u.length - 1], u.pop(), T.destroy()
         }
      }

      function B(T) {
         l.remove(T)
      }

      function D() {
         l.dispose()
      }
      return {
         getParameters: x,
         getProgramCacheKey: g,
         getUniforms: E,
         acquireProgram: C,
         releaseProgram: R,
         releaseShaderCache: B,
         programs: u,
         dispose: D
      }
   }

   function N6() {
      let t = new WeakMap;

      function e(s) {
         let o = t.get(s);
         return o === void 0 && (o = {}, t.set(s, o)), o
      }

      function n(s) {
         t.delete(s)
      }

      function r(s, o, a) {
         t.get(s)[o] = a
      }

      function i() {
         t = new WeakMap
      }
      return {
         get: e,
         remove: n,
         update: r,
         dispose: i
      }
   }

   function U6(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
   }

   function xR(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
   }

   function _R() {
      const t = [];
      let e = 0;
      const n = [],
         r = [],
         i = [];

      function s() {
         e = 0, n.length = 0, r.length = 0, i.length = 0
      }

      function o(d, p, m, v, _, x) {
         let g = t[e];
         return g === void 0 ? (g = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: v,
            renderOrder: d.renderOrder,
            z: _,
            group: x
         }, t[e] = g) : (g.id = d.id, g.object = d, g.geometry = p, g.material = m, g.groupOrder = v, g.renderOrder = d.renderOrder, g.z = _, g.group = x), e++, g
      }

      function a(d, p, m, v, _, x) {
         const g = o(d, p, m, v, _, x);
         m.transmission > 0 ? r.push(g) : m.transparent === !0 ? i.push(g) : n.push(g)
      }

      function l(d, p, m, v, _, x) {
         const g = o(d, p, m, v, _, x);
         m.transmission > 0 ? r.unshift(g) : m.transparent === !0 ? i.unshift(g) : n.unshift(g)
      }

      function u(d, p) {
         n.length > 1 && n.sort(d || U6), r.length > 1 && r.sort(p || xR), i.length > 1 && i.sort(p || xR)
      }

      function h() {
         for (let d = e, p = t.length; d < p; d++) {
            const m = t[d];
            if (m.id === null) break;
            m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null
         }
      }
      return {
         opaque: n,
         transmissive: r,
         transparent: i,
         init: s,
         push: a,
         unshift: l,
         finish: h,
         sort: u
      }
   }

   function k6() {
      let t = new WeakMap;

      function e(r, i) {
         const s = t.get(r);
         let o;
         return s === void 0 ? (o = new _R, t.set(r, [o])) : i >= s.length ? (o = new _R, s.push(o)) : o = s[i], o
      }

      function n() {
         t = new WeakMap
      }
      return {
         get: e,
         dispose: n
      }
   }

   function H6() {
      const t = {};
      return {
         get: function (e) {
            if (t[e.id] !== void 0) return t[e.id];
            let n;
            switch (e.type) {
               case "DirectionalLight":
                  n = {
                     direction: new U,
                     color: new ke
                  };
                  break;
               case "SpotLight":
                  n = {
                     position: new U,
                     direction: new U,
                     color: new ke,
                     distance: 0,
                     coneCos: 0,
                     penumbraCos: 0,
                     decay: 0
                  };
                  break;
               case "PointLight":
                  n = {
                     position: new U,
                     color: new ke,
                     distance: 0,
                     decay: 0
                  };
                  break;
               case "HemisphereLight":
                  n = {
                     direction: new U,
                     skyColor: new ke,
                     groundColor: new ke
                  };
                  break;
               case "RectAreaLight":
                  n = {
                     color: new ke,
                     position: new U,
                     halfWidth: new U,
                     halfHeight: new U
                  };
                  break
            }
            return t[e.id] = n, n
         }
      }
   }

   function G6() {
      const t = {};
      return {
         get: function (e) {
            if (t[e.id] !== void 0) return t[e.id];
            let n;
            switch (e.type) {
               case "DirectionalLight":
                  n = {
                     shadowBias: 0,
                     shadowNormalBias: 0,
                     shadowRadius: 1,
                     shadowMapSize: new Se
                  };
                  break;
               case "SpotLight":
                  n = {
                     shadowBias: 0,
                     shadowNormalBias: 0,
                     shadowRadius: 1,
                     shadowMapSize: new Se
                  };
                  break;
               case "PointLight":
                  n = {
                     shadowBias: 0,
                     shadowNormalBias: 0,
                     shadowRadius: 1,
                     shadowMapSize: new Se,
                     shadowCameraNear: 1,
                     shadowCameraFar: 1e3
                  };
                  break
            }
            return t[e.id] = n, n
         }
      }
   }
   let z6 = 0;

   function V6(t, e) {
      return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
   }

   function W6(t, e) {
      const n = new H6,
         r = G6(),
         i = {
            version: 0,
            hash: {
               directionalLength: -1,
               pointLength: -1,
               spotLength: -1,
               rectAreaLength: -1,
               hemiLength: -1,
               numDirectionalShadows: -1,
               numPointShadows: -1,
               numSpotShadows: -1,
               numSpotMaps: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0
         };
      for (let h = 0; h < 9; h++) i.probe.push(new U);
      const s = new U,
         o = new yt,
         a = new yt;

      function l(h, d) {
         let p = 0,
            m = 0,
            v = 0;
         for (let N = 0; N < 9; N++) i.probe[N].set(0, 0, 0);
         let _ = 0,
            x = 0,
            g = 0,
            S = 0,
            A = 0,
            E = 0,
            C = 0,
            R = 0,
            B = 0,
            D = 0;
         h.sort(V6);
         const T = d === !0 ? Math.PI : 1;
         for (let N = 0, q = h.length; N < q; N++) {
            const K = h[N],
               Z = K.color,
               te = K.intensity,
               se = K.distance,
               oe = K.shadow && K.shadow.map ? K.shadow.map.texture : null;
            if (K.isAmbientLight) p += Z.r * te * T, m += Z.g * te * T, v += Z.b * te * T;
            else if (K.isLightProbe)
               for (let G = 0; G < 9; G++) i.probe[G].addScaledVector(K.sh.coefficients[G], te);
            else if (K.isDirectionalLight) {
               const G = n.get(K);
               if (G.color.copy(K.color).multiplyScalar(K.intensity * T), K.castShadow) {
                  const ne = K.shadow,
                     Y = r.get(K);
                  Y.shadowBias = ne.bias, Y.shadowNormalBias = ne.normalBias, Y.shadowRadius = ne.radius, Y.shadowMapSize = ne.mapSize, i.directionalShadow[_] = Y, i.directionalShadowMap[_] = oe, i.directionalShadowMatrix[_] = K.shadow.matrix, E++
               }
               i.directional[_] = G, _++
            } else if (K.isSpotLight) {
               const G = n.get(K);
               G.position.setFromMatrixPosition(K.matrixWorld), G.color.copy(Z).multiplyScalar(te * T), G.distance = se, G.coneCos = Math.cos(K.angle), G.penumbraCos = Math.cos(K.angle * (1 - K.penumbra)), G.decay = K.decay, i.spot[g] = G;
               const ne = K.shadow;
               if (K.map && (i.spotLightMap[B] = K.map, B++, ne.updateMatrices(K), K.castShadow && D++), i.spotLightMatrix[g] = ne.matrix, K.castShadow) {
                  const Y = r.get(K);
                  Y.shadowBias = ne.bias, Y.shadowNormalBias = ne.normalBias, Y.shadowRadius = ne.radius, Y.shadowMapSize = ne.mapSize, i.spotShadow[g] = Y, i.spotShadowMap[g] = oe, R++
               }
               g++
            } else if (K.isRectAreaLight) {
               const G = n.get(K);
               G.color.copy(Z).multiplyScalar(te), G.halfWidth.set(K.width * .5, 0, 0), G.halfHeight.set(0, K.height * .5, 0), i.rectArea[S] = G, S++
            } else if (K.isPointLight) {
               const G = n.get(K);
               if (G.color.copy(K.color).multiplyScalar(K.intensity * T), G.distance = K.distance, G.decay = K.decay, K.castShadow) {
                  const ne = K.shadow,
                     Y = r.get(K);
                  Y.shadowBias = ne.bias, Y.shadowNormalBias = ne.normalBias, Y.shadowRadius = ne.radius, Y.shadowMapSize = ne.mapSize, Y.shadowCameraNear = ne.camera.near, Y.shadowCameraFar = ne.camera.far, i.pointShadow[x] = Y, i.pointShadowMap[x] = oe, i.pointShadowMatrix[x] = K.shadow.matrix, C++
               }
               i.point[x] = G, x++
            } else if (K.isHemisphereLight) {
               const G = n.get(K);
               G.skyColor.copy(K.color).multiplyScalar(te * T), G.groundColor.copy(K.groundColor).multiplyScalar(te * T), i.hemi[A] = G, A++
            }
         }
         S > 0 && (e.isWebGL2 || t.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Ge.LTC_FLOAT_1, i.rectAreaLTC2 = Ge.LTC_FLOAT_2) : t.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = Ge.LTC_HALF_1, i.rectAreaLTC2 = Ge.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = p, i.ambient[1] = m, i.ambient[2] = v;
         const I = i.hash;
         (I.directionalLength !== _ || I.pointLength !== x || I.spotLength !== g || I.rectAreaLength !== S || I.hemiLength !== A || I.numDirectionalShadows !== E || I.numPointShadows !== C || I.numSpotShadows !== R || I.numSpotMaps !== B) && (i.directional.length = _, i.spot.length = g, i.rectArea.length = S, i.point.length = x, i.hemi.length = A, i.directionalShadow.length = E, i.directionalShadowMap.length = E, i.pointShadow.length = C, i.pointShadowMap.length = C, i.spotShadow.length = R, i.spotShadowMap.length = R, i.directionalShadowMatrix.length = E, i.pointShadowMatrix.length = C, i.spotLightMatrix.length = R + B - D, i.spotLightMap.length = B, i.numSpotLightShadowsWithMaps = D, I.directionalLength = _, I.pointLength = x, I.spotLength = g, I.rectAreaLength = S, I.hemiLength = A, I.numDirectionalShadows = E, I.numPointShadows = C, I.numSpotShadows = R, I.numSpotMaps = B, i.version = z6++)
      }

      function u(h, d) {
         let p = 0,
            m = 0,
            v = 0,
            _ = 0,
            x = 0;
         const g = d.matrixWorldInverse;
         for (let S = 0, A = h.length; S < A; S++) {
            const E = h[S];
            if (E.isDirectionalLight) {
               const C = i.directional[p];
               C.direction.setFromMatrixPosition(E.matrixWorld), s.setFromMatrixPosition(E.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(g), p++
            } else if (E.isSpotLight) {
               const C = i.spot[v];
               C.position.setFromMatrixPosition(E.matrixWorld), C.position.applyMatrix4(g), C.direction.setFromMatrixPosition(E.matrixWorld), s.setFromMatrixPosition(E.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(g), v++
            } else if (E.isRectAreaLight) {
               const C = i.rectArea[_];
               C.position.setFromMatrixPosition(E.matrixWorld), C.position.applyMatrix4(g), a.identity(), o.copy(E.matrixWorld), o.premultiply(g), a.extractRotation(o), C.halfWidth.set(E.width * .5, 0, 0), C.halfHeight.set(0, E.height * .5, 0), C.halfWidth.applyMatrix4(a), C.halfHeight.applyMatrix4(a), _++
            } else if (E.isPointLight) {
               const C = i.point[m];
               C.position.setFromMatrixPosition(E.matrixWorld), C.position.applyMatrix4(g), m++
            } else if (E.isHemisphereLight) {
               const C = i.hemi[x];
               C.direction.setFromMatrixPosition(E.matrixWorld), C.direction.transformDirection(g), x++
            }
         }
      }
      return {
         setup: l,
         setupView: u,
         state: i
      }
   }

   function AR(t, e) {
      const n = new W6(t, e),
         r = [],
         i = [];

      function s() {
         r.length = 0, i.length = 0
      }

      function o(d) {
         r.push(d)
      }

      function a(d) {
         i.push(d)
      }

      function l(d) {
         n.setup(r, d)
      }

      function u(d) {
         n.setupView(r, d)
      }
      return {
         init: s,
         state: {
            lightsArray: r,
            shadowsArray: i,
            lights: n
         },
         setupLights: l,
         setupLightsView: u,
         pushLight: o,
         pushShadow: a
      }
   }

   function j6(t, e) {
      let n = new WeakMap;

      function r(s, o = 0) {
         const a = n.get(s);
         let l;
         return a === void 0 ? (l = new AR(t, e), n.set(s, [l])) : o >= a.length ? (l = new AR(t, e), a.push(l)) : l = a[o], l
      }

      function i() {
         n = new WeakMap
      }
      return {
         get: r,
         dispose: i
      }
   }
   class tE extends Jn {
      constructor(e) {
         super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = nF, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
      }
   }
   class nE extends Jn {
      constructor(e) {
         super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
      }
   }
   const $6 = `void main() {
    gl_Position = vec4( position, 1.0 );
}`,
      X6 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
    const float samples = float( VSM_SAMPLES );
    float mean = 0.0;
    float squared_mean = 0.0;
    float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
    float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
    for ( float i = 0.0; i < samples; i ++ ) {
        float uvOffset = uvStart + i * uvStride;
        #ifdef HORIZONTAL_PASS
            vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
            mean += distribution.x;
            squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
        #else
            float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
            mean += depth;
            squared_mean += depth * depth;
        #endif
    }
    mean = mean / samples;
    squared_mean = squared_mean / samples;
    float std_dev = sqrt( squared_mean - mean * mean );
    gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

   function J6(t, e, n) {
      let r = new Iv;
      const i = new Se,
         s = new Se,
         o = new $t,
         a = new tE({
            depthPacking: rF
         }),
         l = new nE,
         u = {},
         h = n.maxTextureSize,
         d = {
            [Js]: zr,
            [zr]: Js,
            [Wi]: Wi
         },
         p = new Qi({
            defines: {
               VSM_SAMPLES: 8
            },
            uniforms: {
               shadow_pass: {
                  value: null
               },
               resolution: {
                  value: new Se
               },
               radius: {
                  value: 4
               }
            },
            vertexShader: $6,
            fragmentShader: X6
         }),
         m = p.clone();
      m.defines.HORIZONTAL_PASS = 1;
      const v = new Tt;
      v.setAttribute("position", new Zt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
      const _ = new Xn(v, p),
         x = this;
      this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = bv;
      let g = this.type;
      this.render = function (C, R, B) {
         if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || C.length === 0) return;
         const D = t.getRenderTarget(),
            T = t.getActiveCubeFace(),
            I = t.getActiveMipmapLevel(),
            N = t.state;
         N.setBlending(Co), N.buffers.color.setClear(1, 1, 1, 1), N.buffers.depth.setTest(!0), N.setScissorTest(!1);
         const q = g !== cs && this.type === cs,
            K = g === cs && this.type !== cs;
         for (let Z = 0, te = C.length; Z < te; Z++) {
            const se = C[Z],
               oe = se.shadow;
            if (oe === void 0) {
               console.warn("THREE.WebGLShadowMap:", se, "has no shadow.");
               continue
            }
            if (oe.autoUpdate === !1 && oe.needsUpdate === !1) continue;
            i.copy(oe.mapSize);
            const G = oe.getFrameExtents();
            if (i.multiply(G), s.copy(oe.mapSize), (i.x > h || i.y > h) && (i.x > h && (s.x = Math.floor(h / G.x), i.x = s.x * G.x, oe.mapSize.x = s.x), i.y > h && (s.y = Math.floor(h / G.y), i.y = s.y * G.y, oe.mapSize.y = s.y)), oe.map === null || q === !0 || K === !0) {
               const Y = this.type !== cs ? {
                  minFilter: Fn,
                  magFilter: Fn
               } : {};
               oe.map !== null && oe.map.dispose(), oe.map = new Ai(i.x, i.y, Y), oe.map.texture.name = se.name + ".shadowMap", oe.camera.updateProjectionMatrix()
            }
            t.setRenderTarget(oe.map), t.clear();
            const ne = oe.getViewportCount();
            for (let Y = 0; Y < ne; Y++) {
               const X = oe.getViewport(Y);
               o.set(s.x * X.x, s.y * X.y, s.x * X.z, s.y * X.w), N.viewport(o), oe.updateMatrices(se, Y), r = oe.getFrustum(), E(R, B, oe.camera, se, this.type)
            }
            oe.isPointLightShadow !== !0 && this.type === cs && S(oe, B), oe.needsUpdate = !1
         }
         g = this.type, x.needsUpdate = !1, t.setRenderTarget(D, T, I)
      };

      function S(C, R) {
         const B = e.update(_);
         p.defines.VSM_SAMPLES !== C.blurSamples && (p.defines.VSM_SAMPLES = C.blurSamples, m.defines.VSM_SAMPLES = C.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), C.mapPass === null && (C.mapPass = new Ai(i.x, i.y)), p.uniforms.shadow_pass.value = C.map.texture, p.uniforms.resolution.value = C.mapSize, p.uniforms.radius.value = C.radius, t.setRenderTarget(C.mapPass), t.clear(), t.renderBufferDirect(R, null, B, p, _, null), m.uniforms.shadow_pass.value = C.mapPass.texture, m.uniforms.resolution.value = C.mapSize, m.uniforms.radius.value = C.radius, t.setRenderTarget(C.map), t.clear(), t.renderBufferDirect(R, null, B, m, _, null)
      }

      function A(C, R, B, D) {
         let T = null;
         const I = B.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
         if (I !== void 0) T = I;
         else if (T = B.isPointLight === !0 ? l : a, t.localClippingEnabled && R.clipShadows === !0 && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
            const N = T.uuid,
               q = R.uuid;
            let K = u[N];
            K === void 0 && (K = {}, u[N] = K);
            let Z = K[q];
            Z === void 0 && (Z = T.clone(), K[q] = Z), T = Z
         }
         if (T.visible = R.visible, T.wireframe = R.wireframe, D === cs ? T.side = R.shadowSide !== null ? R.shadowSide : R.side : T.side = R.shadowSide !== null ? R.shadowSide : d[R.side], T.alphaMap = R.alphaMap, T.alphaTest = R.alphaTest, T.map = R.map, T.clipShadows = R.clipShadows, T.clippingPlanes = R.clippingPlanes, T.clipIntersection = R.clipIntersection, T.displacementMap = R.displacementMap, T.displacementScale = R.displacementScale, T.displacementBias = R.displacementBias, T.wireframeLinewidth = R.wireframeLinewidth, T.linewidth = R.linewidth, B.isPointLight === !0 && T.isMeshDistanceMaterial === !0) {
            const N = t.properties.get(T);
            N.light = B
         }
         return T
      }

      function E(C, R, B, D, T) {
         if (C.visible === !1) return;
         if (C.layers.test(R.layers) && (C.isMesh || C.isLine || C.isPoints) && (C.castShadow || C.receiveShadow && T === cs) && (!C.frustumCulled || r.intersectsObject(C))) {
            C.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, C.matrixWorld);
            const q = e.update(C),
               K = C.material;
            if (Array.isArray(K)) {
               const Z = q.groups;
               for (let te = 0, se = Z.length; te < se; te++) {
                  const oe = Z[te],
                     G = K[oe.materialIndex];
                  if (G && G.visible) {
                     const ne = A(C, G, D, T);
                     t.renderBufferDirect(B, null, q, ne, C, oe)
                  }
               }
            } else if (K.visible) {
               const Z = A(C, K, D, T);
               t.renderBufferDirect(B, null, q, Z, C, null)
            }
         }
         const N = C.children;
         for (let q = 0, K = N.length; q < K; q++) E(N[q], R, B, D, T)
      }
   }

   function K6(t, e, n) {
      const r = n.isWebGL2;

      function i() {
         let ee = !1;
         const fe = new $t;
         let he = null;
         const Fe = new $t(0, 0, 0, 0);
         return {
            setMask: function (ze) {
               he !== ze && !ee && (t.colorMask(ze, ze, ze, ze), he = ze)
            },
            setLocked: function (ze) {
               ee = ze
            },
            setClear: function (ze, Ut, sn, xn, si) {
               si === !0 && (ze *= xn, Ut *= xn, sn *= xn), fe.set(ze, Ut, sn, xn), Fe.equals(fe) === !1 && (t.clearColor(ze, Ut, sn, xn), Fe.copy(fe))
            },
            reset: function () {
               ee = !1, he = null, Fe.set(-1, 0, 0, 0)
            }
         }
      }

      function s() {
         let ee = !1,
            fe = null,
            he = null,
            Fe = null;
         return {
            setTest: function (ze) {
               ze ? Ue(t.DEPTH_TEST) : Qe(t.DEPTH_TEST)
            },
            setMask: function (ze) {
               fe !== ze && !ee && (t.depthMask(ze), fe = ze)
            },
            setFunc: function (ze) {
               if (he !== ze) {
                  switch (ze) {
                     case B3:
                        t.depthFunc(t.NEVER);
                        break;
                     case I3:
                        t.depthFunc(t.ALWAYS);
                        break;
                     case L3:
                        t.depthFunc(t.LESS);
                        break;
                     case U0:
                        t.depthFunc(t.LEQUAL);
                        break;
                     case D3:
                        t.depthFunc(t.EQUAL);
                        break;
                     case F3:
                        t.depthFunc(t.GEQUAL);
                        break;
                     case O3:
                        t.depthFunc(t.GREATER);
                        break;
                     case N3:
                        t.depthFunc(t.NOTEQUAL);
                        break;
                     default:
                        t.depthFunc(t.LEQUAL)
                  }
                  he = ze
               }
            },
            setLocked: function (ze) {
               ee = ze
            },
            setClear: function (ze) {
               Fe !== ze && (t.clearDepth(ze), Fe = ze)
            },
            reset: function () {
               ee = !1, fe = null, he = null, Fe = null
            }
         }
      }

      function o() {
         let ee = !1,
            fe = null,
            he = null,
            Fe = null,
            ze = null,
            Ut = null,
            sn = null,
            xn = null,
            si = null;
         return {
            setTest: function (en) {
               ee || (en ? Ue(t.STENCIL_TEST) : Qe(t.STENCIL_TEST))
            },
            setMask: function (en) {
               fe !== en && !ee && (t.stencilMask(en), fe = en)
            },
            setFunc: function (en, Br, Kn) {
               (he !== en || Fe !== Br || ze !== Kn) && (t.stencilFunc(en, Br, Kn), he = en, Fe = Br, ze = Kn)
            },
            setOp: function (en, Br, Kn) {
               (Ut !== en || sn !== Br || xn !== Kn) && (t.stencilOp(en, Br, Kn), Ut = en, sn = Br, xn = Kn)
            },
            setLocked: function (en) {
               ee = en
            },
            setClear: function (en) {
               si !== en && (t.clearStencil(en), si = en)
            },
            reset: function () {
               ee = !1, fe = null, he = null, Fe = null, ze = null, Ut = null, sn = null, xn = null, si = null
            }
         }
      }
      const a = new i,
         l = new s,
         u = new o,
         h = new WeakMap,
         d = new WeakMap;
      let p = {},
         m = {},
         v = new WeakMap,
         _ = [],
         x = null,
         g = !1,
         S = null,
         A = null,
         E = null,
         C = null,
         R = null,
         B = null,
         D = null,
         T = !1,
         I = null,
         N = null,
         q = null,
         K = null,
         Z = null;
      const te = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      let se = !1,
         oe = 0;
      const G = t.getParameter(t.VERSION);
      G.indexOf("WebGL") !== -1 ? (oe = parseFloat(/^WebGL (\d)/.exec(G)[1]), se = oe >= 1) : G.indexOf("OpenGL ES") !== -1 && (oe = parseFloat(/^OpenGL ES (\d)/.exec(G)[1]), se = oe >= 2);
      let ne = null,
         Y = {};
      const X = t.getParameter(t.SCISSOR_BOX),
         Q = t.getParameter(t.VIEWPORT),
         _e = new $t().fromArray(X),
         Me = new $t().fromArray(Q);

      function we(ee, fe, he, Fe) {
         const ze = new Uint8Array(4),
            Ut = t.createTexture();
         t.bindTexture(ee, Ut), t.texParameteri(ee, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(ee, t.TEXTURE_MAG_FILTER, t.NEAREST);
         for (let sn = 0; sn < he; sn++) r && (ee === t.TEXTURE_3D || ee === t.TEXTURE_2D_ARRAY) ? t.texImage3D(fe, 0, t.RGBA, 1, 1, Fe, 0, t.RGBA, t.UNSIGNED_BYTE, ze) : t.texImage2D(fe + sn, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, ze);
         return Ut
      }
      const Ee = {};
      Ee[t.TEXTURE_2D] = we(t.TEXTURE_2D, t.TEXTURE_2D, 1), Ee[t.TEXTURE_CUBE_MAP] = we(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && (Ee[t.TEXTURE_2D_ARRAY] = we(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), Ee[t.TEXTURE_3D] = we(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), u.setClear(0), Ue(t.DEPTH_TEST), l.setFunc(U0), be(!1), lt(vA), Ue(t.CULL_FACE), Ae(Co);

      function Ue(ee) {
         p[ee] !== !0 && (t.enable(ee), p[ee] = !0)
      }

      function Qe(ee) {
         p[ee] !== !1 && (t.disable(ee), p[ee] = !1)
      }

      function Pt(ee, fe) {
         return m[ee] !== fe ? (t.bindFramebuffer(ee, fe), m[ee] = fe, r && (ee === t.DRAW_FRAMEBUFFER && (m[t.FRAMEBUFFER] = fe), ee === t.FRAMEBUFFER && (m[t.DRAW_FRAMEBUFFER] = fe)), !0) : !1
      }

      function kt(ee, fe) {
         let he = _,
            Fe = !1;
         if (ee)
            if (he = v.get(fe), he === void 0 && (he = [], v.set(fe, he)), ee.isWebGLMultipleRenderTargets) {
               const ze = ee.texture;
               if (he.length !== ze.length || he[0] !== t.COLOR_ATTACHMENT0) {
                  for (let Ut = 0, sn = ze.length; Ut < sn; Ut++) he[Ut] = t.COLOR_ATTACHMENT0 + Ut;
                  he.length = ze.length, Fe = !0
               }
            } else he[0] !== t.COLOR_ATTACHMENT0 && (he[0] = t.COLOR_ATTACHMENT0, Fe = !0);
         else he[0] !== t.BACK && (he[0] = t.BACK, Fe = !0);
         Fe && (n.isWebGL2 ? t.drawBuffers(he) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(he))
      }

      function $e(ee) {
         return x !== ee ? (t.useProgram(ee), x = ee, !0) : !1
      }
      const J = {
         [bl]: t.FUNC_ADD,
         [_3]: t.FUNC_SUBTRACT,
         [A3]: t.FUNC_REVERSE_SUBTRACT
      };
      if (r) J[AA] = t.MIN, J[SA] = t.MAX;
      else {
         const ee = e.get("EXT_blend_minmax");
         ee !== null && (J[AA] = ee.MIN_EXT, J[SA] = ee.MAX_EXT)
      }
      const Ce = {
         [S3]: t.ZERO,
         [M3]: t.ONE,
         [E3]: t.SRC_COLOR,
         [LM]: t.SRC_ALPHA,
         [P3]: t.SRC_ALPHA_SATURATE,
         [T3]: t.DST_COLOR,
         [b3]: t.DST_ALPHA,
         [w3]: t.ONE_MINUS_SRC_COLOR,
         [DM]: t.ONE_MINUS_SRC_ALPHA,
         [R3]: t.ONE_MINUS_DST_COLOR,
         [C3]: t.ONE_MINUS_DST_ALPHA
      };

      function Ae(ee, fe, he, Fe, ze, Ut, sn, xn) {
         if (ee === Co) {
            g === !0 && (Qe(t.BLEND), g = !1);
            return
         }
         if (g === !1 && (Ue(t.BLEND), g = !0), ee !== x3) {
            if (ee !== S || xn !== T) {
               if ((A !== bl || R !== bl) && (t.blendEquation(t.FUNC_ADD), A = bl, R = bl), xn) switch (ee) {
                  case Hl:
                     t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                     break;
                  case yA:
                     t.blendFunc(t.ONE, t.ONE);
                     break;
                  case xA:
                     t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                     break;
                  case _A:
                     t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                     break;
                  default:
                     console.error("THREE.WebGLState: Invalid blending: ", ee);
                     break
               } else switch (ee) {
                  case Hl:
                     t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                     break;
                  case yA:
                     t.blendFunc(t.SRC_ALPHA, t.ONE);
                     break;
                  case xA:
                     t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                     break;
                  case _A:
                     t.blendFunc(t.ZERO, t.SRC_COLOR);
                     break;
                  default:
                     console.error("THREE.WebGLState: Invalid blending: ", ee);
                     break
               }
               E = null, C = null, B = null, D = null, S = ee, T = xn
            }
            return
         }
         ze = ze || fe, Ut = Ut || he, sn = sn || Fe, (fe !== A || ze !== R) && (t.blendEquationSeparate(J[fe], J[ze]), A = fe, R = ze), (he !== E || Fe !== C || Ut !== B || sn !== D) && (t.blendFuncSeparate(Ce[he], Ce[Fe], Ce[Ut], Ce[sn]), E = he, C = Fe, B = Ut, D = sn), S = ee, T = !1
      }

      function Ie(ee, fe) {
         ee.side === Wi ? Qe(t.CULL_FACE) : Ue(t.CULL_FACE);
         let he = ee.side === zr;
         fe && (he = !he), be(he), ee.blending === Hl && ee.transparent === !1 ? Ae(Co) : Ae(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.premultipliedAlpha), l.setFunc(ee.depthFunc), l.setTest(ee.depthTest), l.setMask(ee.depthWrite), a.setMask(ee.colorWrite);
         const Fe = ee.stencilWrite;
         u.setTest(Fe), Fe && (u.setMask(ee.stencilWriteMask), u.setFunc(ee.stencilFunc, ee.stencilRef, ee.stencilFuncMask), u.setOp(ee.stencilFail, ee.stencilZFail, ee.stencilZPass)), qe(ee.polygonOffset, ee.polygonOffsetFactor, ee.polygonOffsetUnits), ee.alphaToCoverage === !0 ? Ue(t.SAMPLE_ALPHA_TO_COVERAGE) : Qe(t.SAMPLE_ALPHA_TO_COVERAGE)
      }

      function be(ee) {
         I !== ee && (ee ? t.frontFace(t.CW) : t.frontFace(t.CCW), I = ee)
      }

      function lt(ee) {
         ee !== g3 ? (Ue(t.CULL_FACE), ee !== N && (ee === vA ? t.cullFace(t.BACK) : ee === v3 ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Qe(t.CULL_FACE), N = ee
      }

      function Je(ee) {
         ee !== q && (se && t.lineWidth(ee), q = ee)
      }

      function qe(ee, fe, he) {
         ee ? (Ue(t.POLYGON_OFFSET_FILL), (K !== fe || Z !== he) && (t.polygonOffset(fe, he), K = fe, Z = he)) : Qe(t.POLYGON_OFFSET_FILL)
      }

      function vt(ee) {
         ee ? Ue(t.SCISSOR_TEST) : Qe(t.SCISSOR_TEST)
      }

      function Ot(ee) {
         ee === void 0 && (ee = t.TEXTURE0 + te - 1), ne !== ee && (t.activeTexture(ee), ne = ee)
      }

      function un(ee, fe, he) {
         he === void 0 && (ne === null ? he = t.TEXTURE0 + te - 1 : he = ne);
         let Fe = Y[he];
         Fe === void 0 && (Fe = {
            type: void 0,
            texture: void 0
         }, Y[he] = Fe), (Fe.type !== ee || Fe.texture !== fe) && (ne !== he && (t.activeTexture(he), ne = he), t.bindTexture(ee, fe || Ee[ee]), Fe.type = ee, Fe.texture = fe)
      }

      function j() {
         const ee = Y[ne];
         ee !== void 0 && ee.type !== void 0 && (t.bindTexture(ee.type, null), ee.type = void 0, ee.texture = void 0)
      }

      function O() {
         try {
            t.compressedTexImage2D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function ue() {
         try {
            t.compressedTexImage3D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function Pe() {
         try {
            t.texSubImage2D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function Te() {
         try {
            t.texSubImage3D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function Be() {
         try {
            t.compressedTexSubImage2D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function rt() {
         try {
            t.compressedTexSubImage3D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function Le() {
         try {
            t.texStorage2D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function de() {
         try {
            t.texStorage3D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function ht() {
         try {
            t.texImage2D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function st() {
         try {
            t.texImage3D.apply(t, arguments)
         } catch (ee) {
            console.error("THREE.WebGLState:", ee)
         }
      }

      function Ke(ee) {
         _e.equals(ee) === !1 && (t.scissor(ee.x, ee.y, ee.z, ee.w), _e.copy(ee))
      }

      function et(ee) {
         Me.equals(ee) === !1 && (t.viewport(ee.x, ee.y, ee.z, ee.w), Me.copy(ee))
      }

      function Ye(ee, fe) {
         let he = d.get(fe);
         he === void 0 && (he = new WeakMap, d.set(fe, he));
         let Fe = he.get(ee);
         Fe === void 0 && (Fe = t.getUniformBlockIndex(fe, ee.name), he.set(ee, Fe))
      }

      function pt(ee, fe) {
         const Fe = d.get(fe).get(ee);
         h.get(fe) !== Fe && (t.uniformBlockBinding(fe, Fe, ee.__bindingPointIndex), h.set(fe, Fe))
      }

      function Mt() {
         t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), r === !0 && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), p = {}, ne = null, Y = {}, m = {}, v = new WeakMap, _ = [], x = null, g = !1, S = null, A = null, E = null, C = null, R = null, B = null, D = null, T = !1, I = null, N = null, q = null, K = null, Z = null, _e.set(0, 0, t.canvas.width, t.canvas.height), Me.set(0, 0, t.canvas.width, t.canvas.height), a.reset(), l.reset(), u.reset()
      }
      return {
         buffers: {
            color: a,
            depth: l,
            stencil: u
         },
         enable: Ue,
         disable: Qe,
         bindFramebuffer: Pt,
         drawBuffers: kt,
         useProgram: $e,
         setBlending: Ae,
         setMaterial: Ie,
         setFlipSided: be,
         setCullFace: lt,
         setLineWidth: Je,
         setPolygonOffset: qe,
         setScissorTest: vt,
         activeTexture: Ot,
         bindTexture: un,
         unbindTexture: j,
         compressedTexImage2D: O,
         compressedTexImage3D: ue,
         texImage2D: ht,
         texImage3D: st,
         updateUBOMapping: Ye,
         uniformBlockBinding: pt,
         texStorage2D: Le,
         texStorage3D: de,
         texSubImage2D: Pe,
         texSubImage3D: Te,
         compressedTexSubImage2D: Be,
         compressedTexSubImage3D: rt,
         scissor: Ke,
         viewport: et,
         reset: Mt
      }
   }

   function Y6(t, e, n, r, i, s, o) {
      const a = i.isWebGL2,
         l = i.maxTextures,
         u = i.maxCubemapSize,
         h = i.maxTextureSize,
         d = i.maxSamples,
         p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
         m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
         v = new WeakMap;
      let _;
      const x = new WeakMap;
      let g = !1;
      try {
         g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
      } catch {}

      function S(j, O) {
         return g ? new OffscreenCanvas(j, O) : Hd("canvas")
      }

      function A(j, O, ue, Pe) {
         let Te = 1;
         if ((j.width > Pe || j.height > Pe) && (Te = Pe / Math.max(j.width, j.height)), Te < 1 || O === !0)
            if (typeof HTMLImageElement < "u" && j instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && j instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && j instanceof ImageBitmap) {
               const Be = O ? G0 : Math.floor,
                  rt = Be(Te * j.width),
                  Le = Be(Te * j.height);
               _ === void 0 && (_ = S(rt, Le));
               const de = ue ? S(rt, Le) : _;
               return de.width = rt, de.height = Le, de.getContext("2d").drawImage(j, 0, 0, rt, Le), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + j.width + "x" + j.height + ") to (" + rt + "x" + Le + ")."), de
            } else return "data" in j && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + j.width + "x" + j.height + ")."), j;
         return j
      }

      function E(j) {
         return XA(j.width) && XA(j.height)
      }

      function C(j) {
         return a ? !1 : j.wrapS !== hr || j.wrapT !== hr || j.minFilter !== Fn && j.minFilter !== ln
      }

      function R(j, O) {
         return j.generateMipmaps && O && j.minFilter !== Fn && j.minFilter !== ln
      }

      function B(j) {
         t.generateMipmap(j)
      }

      function D(j, O, ue, Pe, Te = !1) {
         if (a === !1) return O;
         if (j !== null) {
            if (t[j] !== void 0) return t[j];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + j + "'")
         }
         let Be = O;
         return O === t.RED && (ue === t.FLOAT && (Be = t.R32F), ue === t.HALF_FLOAT && (Be = t.R16F), ue === t.UNSIGNED_BYTE && (Be = t.R8)), O === t.RED_INTEGER && (ue === t.UNSIGNED_BYTE && (Be = t.R8UI), ue === t.UNSIGNED_SHORT && (Be = t.R16UI), ue === t.UNSIGNED_INT && (Be = t.R32UI), ue === t.BYTE && (Be = t.R8I), ue === t.SHORT && (Be = t.R16I), ue === t.INT && (Be = t.R32I)), O === t.RG && (ue === t.FLOAT && (Be = t.RG32F), ue === t.HALF_FLOAT && (Be = t.RG16F), ue === t.UNSIGNED_BYTE && (Be = t.RG8)), O === t.RGBA && (ue === t.FLOAT && (Be = t.RGBA32F), ue === t.HALF_FLOAT && (Be = t.RGBA16F), ue === t.UNSIGNED_BYTE && (Be = Pe === Rt && Te === !1 ? t.SRGB8_ALPHA8 : t.RGBA8), ue === t.UNSIGNED_SHORT_4_4_4_4 && (Be = t.RGBA4), ue === t.UNSIGNED_SHORT_5_5_5_1 && (Be = t.RGB5_A1)), (Be === t.R16F || Be === t.R32F || Be === t.RG16F || Be === t.RG32F || Be === t.RGBA16F || Be === t.RGBA32F) && e.get("EXT_color_buffer_float"), Be
      }

      function T(j, O, ue) {
         return R(j, ue) === !0 || j.isFramebufferTexture && j.minFilter !== Fn && j.minFilter !== ln ? Math.log2(Math.max(O.width, O.height)) + 1 : j.mipmaps !== void 0 && j.mipmaps.length > 0 ? j.mipmaps.length : j.isCompressedTexture && Array.isArray(j.image) ? O.mipmaps.length : 1
      }

      function I(j) {
         return j === Fn || j === Od || j === Yc ? t.NEAREST : t.LINEAR
      }

      function N(j) {
         const O = j.target;
         O.removeEventListener("dispose", N), K(O), O.isVideoTexture && v.delete(O)
      }

      function q(j) {
         const O = j.target;
         O.removeEventListener("dispose", q), te(O)
      }

      function K(j) {
         const O = r.get(j);
         if (O.__webglInit === void 0) return;
         const ue = j.source,
            Pe = x.get(ue);
         if (Pe) {
            const Te = Pe[O.__cacheKey];
            Te.usedTimes--, Te.usedTimes === 0 && Z(j), Object.keys(Pe).length === 0 && x.delete(ue)
         }
         r.remove(j)
      }

      function Z(j) {
         const O = r.get(j);
         t.deleteTexture(O.__webglTexture);
         const ue = j.source,
            Pe = x.get(ue);
         delete Pe[O.__cacheKey], o.memory.textures--
      }

      function te(j) {
         const O = j.texture,
            ue = r.get(j),
            Pe = r.get(O);
         if (Pe.__webglTexture !== void 0 && (t.deleteTexture(Pe.__webglTexture), o.memory.textures--), j.depthTexture && j.depthTexture.dispose(), j.isWebGLCubeRenderTarget)
            for (let Te = 0; Te < 6; Te++) {
               if (Array.isArray(ue.__webglFramebuffer[Te]))
                  for (let Be = 0; Be < ue.__webglFramebuffer[Te].length; Be++) t.deleteFramebuffer(ue.__webglFramebuffer[Te][Be]);
               else t.deleteFramebuffer(ue.__webglFramebuffer[Te]);
               ue.__webglDepthbuffer && t.deleteRenderbuffer(ue.__webglDepthbuffer[Te])
            } else {
               if (Array.isArray(ue.__webglFramebuffer))
                  for (let Te = 0; Te < ue.__webglFramebuffer.length; Te++) t.deleteFramebuffer(ue.__webglFramebuffer[Te]);
               else t.deleteFramebuffer(ue.__webglFramebuffer);
               if (ue.__webglDepthbuffer && t.deleteRenderbuffer(ue.__webglDepthbuffer), ue.__webglMultisampledFramebuffer && t.deleteFramebuffer(ue.__webglMultisampledFramebuffer), ue.__webglColorRenderbuffer)
                  for (let Te = 0; Te < ue.__webglColorRenderbuffer.length; Te++) ue.__webglColorRenderbuffer[Te] && t.deleteRenderbuffer(ue.__webglColorRenderbuffer[Te]);
               ue.__webglDepthRenderbuffer && t.deleteRenderbuffer(ue.__webglDepthRenderbuffer)
            }
         if (j.isWebGLMultipleRenderTargets)
            for (let Te = 0, Be = O.length; Te < Be; Te++) {
               const rt = r.get(O[Te]);
               rt.__webglTexture && (t.deleteTexture(rt.__webglTexture), o.memory.textures--), r.remove(O[Te])
            }
         r.remove(O), r.remove(j)
      }
      let se = 0;

      function oe() {
         se = 0
      }

      function G() {
         const j = se;
         return j >= l && console.warn("THREE.WebGLTextures: Trying to use " + j + " texture units while this GPU supports only " + l), se += 1, j
      }

      function ne(j) {
         const O = [];
         return O.push(j.wrapS), O.push(j.wrapT), O.push(j.wrapR || 0), O.push(j.magFilter), O.push(j.minFilter), O.push(j.anisotropy), O.push(j.internalFormat), O.push(j.format), O.push(j.type), O.push(j.generateMipmaps), O.push(j.premultiplyAlpha), O.push(j.flipY), O.push(j.unpackAlignment), O.push(j.colorSpace), O.join()
      }

      function Y(j, O) {
         const ue = r.get(j);
         if (j.isVideoTexture && Ot(j), j.isRenderTargetTexture === !1 && j.version > 0 && ue.__version !== j.version) {
            const Pe = j.image;
            if (Pe === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Pe.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
               Pt(ue, j, O);
               return
            }
         }
         n.bindTexture(t.TEXTURE_2D, ue.__webglTexture, t.TEXTURE0 + O)
      }

      function X(j, O) {
         const ue = r.get(j);
         if (j.version > 0 && ue.__version !== j.version) {
            Pt(ue, j, O);
            return
         }
         n.bindTexture(t.TEXTURE_2D_ARRAY, ue.__webglTexture, t.TEXTURE0 + O)
      }

      function Q(j, O) {
         const ue = r.get(j);
         if (j.version > 0 && ue.__version !== j.version) {
            Pt(ue, j, O);
            return
         }
         n.bindTexture(t.TEXTURE_3D, ue.__webglTexture, t.TEXTURE0 + O)
      }

      function _e(j, O) {
         const ue = r.get(j);
         if (j.version > 0 && ue.__version !== j.version) {
            kt(ue, j, O);
            return
         }
         n.bindTexture(t.TEXTURE_CUBE_MAP, ue.__webglTexture, t.TEXTURE0 + O)
      }
      const Me = {
            [Fa]: t.REPEAT,
            [hr]: t.CLAMP_TO_EDGE,
            [ff]: t.MIRRORED_REPEAT
         },
         we = {
            [Fn]: t.NEAREST,
            [Od]: t.NEAREST_MIPMAP_NEAREST,
            [Yc]: t.NEAREST_MIPMAP_LINEAR,
            [ln]: t.LINEAR,
            [Tv]: t.LINEAR_MIPMAP_NEAREST,
            [Ys]: t.LINEAR_MIPMAP_LINEAR
         },
         Ee = {
            [oF]: t.NEVER,
            [dF]: t.ALWAYS,
            [aF]: t.LESS,
            [uF]: t.LEQUAL,
            [lF]: t.EQUAL,
            [hF]: t.GEQUAL,
            [cF]: t.GREATER,
            [fF]: t.NOTEQUAL
         };

      function Ue(j, O, ue) {
         if (ue ? (t.texParameteri(j, t.TEXTURE_WRAP_S, Me[O.wrapS]), t.texParameteri(j, t.TEXTURE_WRAP_T, Me[O.wrapT]), (j === t.TEXTURE_3D || j === t.TEXTURE_2D_ARRAY) && t.texParameteri(j, t.TEXTURE_WRAP_R, Me[O.wrapR]), t.texParameteri(j, t.TEXTURE_MAG_FILTER, we[O.magFilter]), t.texParameteri(j, t.TEXTURE_MIN_FILTER, we[O.minFilter])) : (t.texParameteri(j, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(j, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), (j === t.TEXTURE_3D || j === t.TEXTURE_2D_ARRAY) && t.texParameteri(j, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), (O.wrapS !== hr || O.wrapT !== hr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(j, t.TEXTURE_MAG_FILTER, I(O.magFilter)), t.texParameteri(j, t.TEXTURE_MIN_FILTER, I(O.minFilter)), O.minFilter !== Fn && O.minFilter !== ln && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), O.compareFunction && (t.texParameteri(j, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(j, t.TEXTURE_COMPARE_FUNC, Ee[O.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
            const Pe = e.get("EXT_texture_filter_anisotropic");
            if (O.magFilter === Fn || O.minFilter !== Yc && O.minFilter !== Ys || O.type === dr && e.has("OES_texture_float_linear") === !1 || a === !1 && O.type === Cr && e.has("OES_texture_half_float_linear") === !1) return;
            (O.anisotropy > 1 || r.get(O).__currentAnisotropy) && (t.texParameterf(j, Pe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(O.anisotropy, i.getMaxAnisotropy())), r.get(O).__currentAnisotropy = O.anisotropy)
         }
      }

      function Qe(j, O) {
         let ue = !1;
         j.__webglInit === void 0 && (j.__webglInit = !0, O.addEventListener("dispose", N));
         const Pe = O.source;
         let Te = x.get(Pe);
         Te === void 0 && (Te = {}, x.set(Pe, Te));
         const Be = ne(O);
         if (Be !== j.__cacheKey) {
            Te[Be] === void 0 && (Te[Be] = {
               texture: t.createTexture(),
               usedTimes: 0
            }, o.memory.textures++, ue = !0), Te[Be].usedTimes++;
            const rt = Te[j.__cacheKey];
            rt !== void 0 && (Te[j.__cacheKey].usedTimes--, rt.usedTimes === 0 && Z(O)), j.__cacheKey = Be, j.__webglTexture = Te[Be].texture
         }
         return ue
      }

      function Pt(j, O, ue) {
         let Pe = t.TEXTURE_2D;
         (O.isDataArrayTexture || O.isCompressedArrayTexture) && (Pe = t.TEXTURE_2D_ARRAY), O.isData3DTexture && (Pe = t.TEXTURE_3D);
         const Te = Qe(j, O),
            Be = O.source;
         n.bindTexture(Pe, j.__webglTexture, t.TEXTURE0 + ue);
         const rt = r.get(Be);
         if (Be.version !== rt.__version || Te === !0) {
            n.activeTexture(t.TEXTURE0 + ue), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, O.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, O.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
            const Le = C(O) && E(O.image) === !1;
            let de = A(O.image, Le, !1, h);
            de = un(O, de);
            const ht = E(de) || a,
               st = s.convert(O.format, O.colorSpace);
            let Ke = s.convert(O.type),
               et = D(O.internalFormat, st, Ke, O.colorSpace);
            Ue(Pe, O, ht);
            let Ye;
            const pt = O.mipmaps,
               Mt = a && O.isVideoTexture !== !0,
               ee = rt.__version === void 0 || Te === !0,
               fe = T(O, de, ht);
            if (O.isDepthTexture) et = t.DEPTH_COMPONENT, a ? O.type === dr ? et = t.DEPTH_COMPONENT32F : O.type === So ? et = t.DEPTH_COMPONENT24 : O.type === ba ? et = t.DEPTH24_STENCIL8 : et = t.DEPTH_COMPONENT16 : O.type === dr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), O.format === Ca && et === t.DEPTH_COMPONENT && O.type !== Rv && O.type !== So && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), O.type = So, Ke = s.convert(O.type)), O.format === Kl && et === t.DEPTH_COMPONENT && (et = t.DEPTH_STENCIL, O.type !== ba && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), O.type = ba, Ke = s.convert(O.type))), ee && (Mt ? n.texStorage2D(t.TEXTURE_2D, 1, et, de.width, de.height) : n.texImage2D(t.TEXTURE_2D, 0, et, de.width, de.height, 0, st, Ke, null));
            else if (O.isDataTexture)
               if (pt.length > 0 && ht) {
                  Mt && ee && n.texStorage2D(t.TEXTURE_2D, fe, et, pt[0].width, pt[0].height);
                  for (let he = 0, Fe = pt.length; he < Fe; he++) Ye = pt[he], Mt ? n.texSubImage2D(t.TEXTURE_2D, he, 0, 0, Ye.width, Ye.height, st, Ke, Ye.data) : n.texImage2D(t.TEXTURE_2D, he, et, Ye.width, Ye.height, 0, st, Ke, Ye.data);
                  O.generateMipmaps = !1
               } else Mt ? (ee && n.texStorage2D(t.TEXTURE_2D, fe, et, de.width, de.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, de.width, de.height, st, Ke, de.data)) : n.texImage2D(t.TEXTURE_2D, 0, et, de.width, de.height, 0, st, Ke, de.data);
            else if (O.isCompressedTexture)
               if (O.isCompressedArrayTexture) {
                  Mt && ee && n.texStorage3D(t.TEXTURE_2D_ARRAY, fe, et, pt[0].width, pt[0].height, de.depth);
                  for (let he = 0, Fe = pt.length; he < Fe; he++) Ye = pt[he], O.format !== Hr ? st !== null ? Mt ? n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, he, 0, 0, 0, Ye.width, Ye.height, de.depth, st, Ye.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, he, et, Ye.width, Ye.height, de.depth, 0, Ye.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Mt ? n.texSubImage3D(t.TEXTURE_2D_ARRAY, he, 0, 0, 0, Ye.width, Ye.height, de.depth, st, Ke, Ye.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, he, et, Ye.width, Ye.height, de.depth, 0, st, Ke, Ye.data)
               } else {
                  Mt && ee && n.texStorage2D(t.TEXTURE_2D, fe, et, pt[0].width, pt[0].height);
                  for (let he = 0, Fe = pt.length; he < Fe; he++) Ye = pt[he], O.format !== Hr ? st !== null ? Mt ? n.compressedTexSubImage2D(t.TEXTURE_2D, he, 0, 0, Ye.width, Ye.height, st, Ye.data) : n.compressedTexImage2D(t.TEXTURE_2D, he, et, Ye.width, Ye.height, 0, Ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Mt ? n.texSubImage2D(t.TEXTURE_2D, he, 0, 0, Ye.width, Ye.height, st, Ke, Ye.data) : n.texImage2D(t.TEXTURE_2D, he, et, Ye.width, Ye.height, 0, st, Ke, Ye.data)
               }
            else if (O.isDataArrayTexture) Mt ? (ee && n.texStorage3D(t.TEXTURE_2D_ARRAY, fe, et, de.width, de.height, de.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, de.width, de.height, de.depth, st, Ke, de.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, et, de.width, de.height, de.depth, 0, st, Ke, de.data);
            else if (O.isData3DTexture) Mt ? (ee && n.texStorage3D(t.TEXTURE_3D, fe, et, de.width, de.height, de.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, de.width, de.height, de.depth, st, Ke, de.data)) : n.texImage3D(t.TEXTURE_3D, 0, et, de.width, de.height, de.depth, 0, st, Ke, de.data);
            else if (O.isFramebufferTexture) {
               if (ee)
                  if (Mt) n.texStorage2D(t.TEXTURE_2D, fe, et, de.width, de.height);
                  else {
                     let he = de.width,
                        Fe = de.height;
                     for (let ze = 0; ze < fe; ze++) n.texImage2D(t.TEXTURE_2D, ze, et, he, Fe, 0, st, Ke, null), he >>= 1, Fe >>= 1
                  }
            } else if (pt.length > 0 && ht) {
               Mt && ee && n.texStorage2D(t.TEXTURE_2D, fe, et, pt[0].width, pt[0].height);
               for (let he = 0, Fe = pt.length; he < Fe; he++) Ye = pt[he], Mt ? n.texSubImage2D(t.TEXTURE_2D, he, 0, 0, st, Ke, Ye) : n.texImage2D(t.TEXTURE_2D, he, et, st, Ke, Ye);
               O.generateMipmaps = !1
            } else Mt ? (ee && n.texStorage2D(t.TEXTURE_2D, fe, et, de.width, de.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, st, Ke, de)) : n.texImage2D(t.TEXTURE_2D, 0, et, st, Ke, de);
            R(O, ht) && B(Pe), rt.__version = Be.version, O.onUpdate && O.onUpdate(O)
         }
         j.__version = O.version
      }

      function kt(j, O, ue) {
         if (O.image.length !== 6) return;
         const Pe = Qe(j, O),
            Te = O.source;
         n.bindTexture(t.TEXTURE_CUBE_MAP, j.__webglTexture, t.TEXTURE0 + ue);
         const Be = r.get(Te);
         if (Te.version !== Be.__version || Pe === !0) {
            n.activeTexture(t.TEXTURE0 + ue), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, O.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, O.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
            const rt = O.isCompressedTexture || O.image[0].isCompressedTexture,
               Le = O.image[0] && O.image[0].isDataTexture,
               de = [];
            for (let he = 0; he < 6; he++) !rt && !Le ? de[he] = A(O.image[he], !1, !0, u) : de[he] = Le ? O.image[he].image : O.image[he], de[he] = un(O, de[he]);
            const ht = de[0],
               st = E(ht) || a,
               Ke = s.convert(O.format, O.colorSpace),
               et = s.convert(O.type),
               Ye = D(O.internalFormat, Ke, et, O.colorSpace),
               pt = a && O.isVideoTexture !== !0,
               Mt = Be.__version === void 0 || Pe === !0;
            let ee = T(O, ht, st);
            Ue(t.TEXTURE_CUBE_MAP, O, st);
            let fe;
            if (rt) {
               pt && Mt && n.texStorage2D(t.TEXTURE_CUBE_MAP, ee, Ye, ht.width, ht.height);
               for (let he = 0; he < 6; he++) {
                  fe = de[he].mipmaps;
                  for (let Fe = 0; Fe < fe.length; Fe++) {
                     const ze = fe[Fe];
                     O.format !== Hr ? Ke !== null ? pt ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe, 0, 0, ze.width, ze.height, Ke, ze.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe, Ye, ze.width, ze.height, 0, ze.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : pt ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe, 0, 0, ze.width, ze.height, Ke, et, ze.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe, Ye, ze.width, ze.height, 0, Ke, et, ze.data)
                  }
               }
            } else {
               fe = O.mipmaps, pt && Mt && (fe.length > 0 && ee++, n.texStorage2D(t.TEXTURE_CUBE_MAP, ee, Ye, de[0].width, de[0].height));
               for (let he = 0; he < 6; he++)
                  if (Le) {
                     pt ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, 0, 0, de[he].width, de[he].height, Ke, et, de[he].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, Ye, de[he].width, de[he].height, 0, Ke, et, de[he].data);
                     for (let Fe = 0; Fe < fe.length; Fe++) {
                        const Ut = fe[Fe].image[he].image;
                        pt ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe + 1, 0, 0, Ut.width, Ut.height, Ke, et, Ut.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe + 1, Ye, Ut.width, Ut.height, 0, Ke, et, Ut.data)
                     }
                  } else {
                     pt ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, 0, 0, Ke, et, de[he]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, Ye, Ke, et, de[he]);
                     for (let Fe = 0; Fe < fe.length; Fe++) {
                        const ze = fe[Fe];
                        pt ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe + 1, 0, 0, Ke, et, ze.image[he]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + he, Fe + 1, Ye, Ke, et, ze.image[he])
                     }
                  }
            }
            R(O, st) && B(t.TEXTURE_CUBE_MAP), Be.__version = Te.version, O.onUpdate && O.onUpdate(O)
         }
         j.__version = O.version
      }

      function $e(j, O, ue, Pe, Te, Be) {
         const rt = s.convert(ue.format, ue.colorSpace),
            Le = s.convert(ue.type),
            de = D(ue.internalFormat, rt, Le, ue.colorSpace);
         if (!r.get(O).__hasExternalTextures) {
            const st = Math.max(1, O.width >> Be),
               Ke = Math.max(1, O.height >> Be);
            Te === t.TEXTURE_3D || Te === t.TEXTURE_2D_ARRAY ? n.texImage3D(Te, Be, de, st, Ke, O.depth, 0, rt, Le, null) : n.texImage2D(Te, Be, de, st, Ke, 0, rt, Le, null)
         }
         n.bindFramebuffer(t.FRAMEBUFFER, j), vt(O) ? p.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, Pe, Te, r.get(ue).__webglTexture, 0, qe(O)) : (Te === t.TEXTURE_2D || Te >= t.TEXTURE_CUBE_MAP_POSITIVE_X && Te <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, Pe, Te, r.get(ue).__webglTexture, Be), n.bindFramebuffer(t.FRAMEBUFFER, null)
      }

      function J(j, O, ue) {
         if (t.bindRenderbuffer(t.RENDERBUFFER, j), O.depthBuffer && !O.stencilBuffer) {
            let Pe = t.DEPTH_COMPONENT16;
            if (ue || vt(O)) {
               const Te = O.depthTexture;
               Te && Te.isDepthTexture && (Te.type === dr ? Pe = t.DEPTH_COMPONENT32F : Te.type === So && (Pe = t.DEPTH_COMPONENT24));
               const Be = qe(O);
               vt(O) ? p.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, Be, Pe, O.width, O.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, Be, Pe, O.width, O.height)
            } else t.renderbufferStorage(t.RENDERBUFFER, Pe, O.width, O.height);
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, j)
         } else if (O.depthBuffer && O.stencilBuffer) {
            const Pe = qe(O);
            ue && vt(O) === !1 ? t.renderbufferStorageMultisample(t.RENDERBUFFER, Pe, t.DEPTH24_STENCIL8, O.width, O.height) : vt(O) ? p.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, Pe, t.DEPTH24_STENCIL8, O.width, O.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, O.width, O.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, j)
         } else {
            const Pe = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
            for (let Te = 0; Te < Pe.length; Te++) {
               const Be = Pe[Te],
                  rt = s.convert(Be.format, Be.colorSpace),
                  Le = s.convert(Be.type),
                  de = D(Be.internalFormat, rt, Le, Be.colorSpace),
                  ht = qe(O);
               ue && vt(O) === !1 ? t.renderbufferStorageMultisample(t.RENDERBUFFER, ht, de, O.width, O.height) : vt(O) ? p.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, ht, de, O.width, O.height) : t.renderbufferStorage(t.RENDERBUFFER, de, O.width, O.height)
            }
         }
         t.bindRenderbuffer(t.RENDERBUFFER, null)
      }

      function Ce(j, O) {
         if (O && O.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
         if (n.bindFramebuffer(t.FRAMEBUFFER, j), !(O.depthTexture && O.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
         (!r.get(O.depthTexture).__webglTexture || O.depthTexture.image.width !== O.width || O.depthTexture.image.height !== O.height) && (O.depthTexture.image.width = O.width, O.depthTexture.image.height = O.height, O.depthTexture.needsUpdate = !0), Y(O.depthTexture, 0);
         const Pe = r.get(O.depthTexture).__webglTexture,
            Te = qe(O);
         if (O.depthTexture.format === Ca) vt(O) ? p.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, Pe, 0, Te) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, Pe, 0);
         else if (O.depthTexture.format === Kl) vt(O) ? p.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, Pe, 0, Te) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, Pe, 0);
         else throw new Error("Unknown depthTexture format")
      }

      function Ae(j) {
         const O = r.get(j),
            ue = j.isWebGLCubeRenderTarget === !0;
         if (j.depthTexture && !O.__autoAllocateDepthBuffer) {
            if (ue) throw new Error("target.depthTexture not supported in Cube render targets");
            Ce(O.__webglFramebuffer, j)
         } else if (ue) {
            O.__webglDepthbuffer = [];
            for (let Pe = 0; Pe < 6; Pe++) n.bindFramebuffer(t.FRAMEBUFFER, O.__webglFramebuffer[Pe]), O.__webglDepthbuffer[Pe] = t.createRenderbuffer(), J(O.__webglDepthbuffer[Pe], j, !1)
         } else n.bindFramebuffer(t.FRAMEBUFFER, O.__webglFramebuffer), O.__webglDepthbuffer = t.createRenderbuffer(), J(O.__webglDepthbuffer, j, !1);
         n.bindFramebuffer(t.FRAMEBUFFER, null)
      }

      function Ie(j, O, ue) {
         const Pe = r.get(j);
         O !== void 0 && $e(Pe.__webglFramebuffer, j, j.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), ue !== void 0 && Ae(j)
      }

      function be(j) {
         const O = j.texture,
            ue = r.get(j),
            Pe = r.get(O);
         j.addEventListener("dispose", q), j.isWebGLMultipleRenderTargets !== !0 && (Pe.__webglTexture === void 0 && (Pe.__webglTexture = t.createTexture()), Pe.__version = O.version, o.memory.textures++);
         const Te = j.isWebGLCubeRenderTarget === !0,
            Be = j.isWebGLMultipleRenderTargets === !0,
            rt = E(j) || a;
         if (Te) {
            ue.__webglFramebuffer = [];
            for (let Le = 0; Le < 6; Le++)
               if (a && O.mipmaps && O.mipmaps.length > 0) {
                  ue.__webglFramebuffer[Le] = [];
                  for (let de = 0; de < O.mipmaps.length; de++) ue.__webglFramebuffer[Le][de] = t.createFramebuffer()
               } else ue.__webglFramebuffer[Le] = t.createFramebuffer()
         } else {
            if (a && O.mipmaps && O.mipmaps.length > 0) {
               ue.__webglFramebuffer = [];
               for (let Le = 0; Le < O.mipmaps.length; Le++) ue.__webglFramebuffer[Le] = t.createFramebuffer()
            } else ue.__webglFramebuffer = t.createFramebuffer();
            if (Be)
               if (i.drawBuffers) {
                  const Le = j.texture;
                  for (let de = 0, ht = Le.length; de < ht; de++) {
                     const st = r.get(Le[de]);
                     st.__webglTexture === void 0 && (st.__webglTexture = t.createTexture(), o.memory.textures++)
                  }
               } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && j.samples > 0 && vt(j) === !1) {
               const Le = Be ? O : [O];
               ue.__webglMultisampledFramebuffer = t.createFramebuffer(), ue.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, ue.__webglMultisampledFramebuffer);
               for (let de = 0; de < Le.length; de++) {
                  const ht = Le[de];
                  ue.__webglColorRenderbuffer[de] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, ue.__webglColorRenderbuffer[de]);
                  const st = s.convert(ht.format, ht.colorSpace),
                     Ke = s.convert(ht.type),
                     et = D(ht.internalFormat, st, Ke, ht.colorSpace, j.isXRRenderTarget === !0),
                     Ye = qe(j);
                  t.renderbufferStorageMultisample(t.RENDERBUFFER, Ye, et, j.width, j.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + de, t.RENDERBUFFER, ue.__webglColorRenderbuffer[de])
               }
               t.bindRenderbuffer(t.RENDERBUFFER, null), j.depthBuffer && (ue.__webglDepthRenderbuffer = t.createRenderbuffer(), J(ue.__webglDepthRenderbuffer, j, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
         }
         if (Te) {
            n.bindTexture(t.TEXTURE_CUBE_MAP, Pe.__webglTexture), Ue(t.TEXTURE_CUBE_MAP, O, rt);
            for (let Le = 0; Le < 6; Le++)
               if (a && O.mipmaps && O.mipmaps.length > 0)
                  for (let de = 0; de < O.mipmaps.length; de++) $e(ue.__webglFramebuffer[Le][de], j, O, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + Le, de);
               else $e(ue.__webglFramebuffer[Le], j, O, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + Le, 0);
            R(O, rt) && B(t.TEXTURE_CUBE_MAP), n.unbindTexture()
         } else if (Be) {
            const Le = j.texture;
            for (let de = 0, ht = Le.length; de < ht; de++) {
               const st = Le[de],
                  Ke = r.get(st);
               n.bindTexture(t.TEXTURE_2D, Ke.__webglTexture), Ue(t.TEXTURE_2D, st, rt), $e(ue.__webglFramebuffer, j, st, t.COLOR_ATTACHMENT0 + de, t.TEXTURE_2D, 0), R(st, rt) && B(t.TEXTURE_2D)
            }
            n.unbindTexture()
         } else {
            let Le = t.TEXTURE_2D;
            if ((j.isWebGL3DRenderTarget || j.isWebGLArrayRenderTarget) && (a ? Le = j.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(Le, Pe.__webglTexture), Ue(Le, O, rt), a && O.mipmaps && O.mipmaps.length > 0)
               for (let de = 0; de < O.mipmaps.length; de++) $e(ue.__webglFramebuffer[de], j, O, t.COLOR_ATTACHMENT0, Le, de);
            else $e(ue.__webglFramebuffer, j, O, t.COLOR_ATTACHMENT0, Le, 0);
            R(O, rt) && B(Le), n.unbindTexture()
         }
         j.depthBuffer && Ae(j)
      }

      function lt(j) {
         const O = E(j) || a,
            ue = j.isWebGLMultipleRenderTargets === !0 ? j.texture : [j.texture];
         for (let Pe = 0, Te = ue.length; Pe < Te; Pe++) {
            const Be = ue[Pe];
            if (R(Be, O)) {
               const rt = j.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                  Le = r.get(Be).__webglTexture;
               n.bindTexture(rt, Le), B(rt), n.unbindTexture()
            }
         }
      }

      function Je(j) {
         if (a && j.samples > 0 && vt(j) === !1) {
            const O = j.isWebGLMultipleRenderTargets ? j.texture : [j.texture],
               ue = j.width,
               Pe = j.height;
            let Te = t.COLOR_BUFFER_BIT;
            const Be = [],
               rt = j.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
               Le = r.get(j),
               de = j.isWebGLMultipleRenderTargets === !0;
            if (de)
               for (let ht = 0; ht < O.length; ht++) n.bindFramebuffer(t.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + ht, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, Le.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + ht, t.TEXTURE_2D, null, 0);
            n.bindFramebuffer(t.READ_FRAMEBUFFER, Le.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Le.__webglFramebuffer);
            for (let ht = 0; ht < O.length; ht++) {
               Be.push(t.COLOR_ATTACHMENT0 + ht), j.depthBuffer && Be.push(rt);
               const st = Le.__ignoreDepthValues !== void 0 ? Le.__ignoreDepthValues : !1;
               if (st === !1 && (j.depthBuffer && (Te |= t.DEPTH_BUFFER_BIT), j.stencilBuffer && (Te |= t.STENCIL_BUFFER_BIT)), de && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, Le.__webglColorRenderbuffer[ht]), st === !0 && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [rt]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [rt])), de) {
                  const Ke = r.get(O[ht]).__webglTexture;
                  t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, Ke, 0)
               }
               t.blitFramebuffer(0, 0, ue, Pe, 0, 0, ue, Pe, Te, t.NEAREST), m && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, Be)
            }
            if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), de)
               for (let ht = 0; ht < O.length; ht++) {
                  n.bindFramebuffer(t.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + ht, t.RENDERBUFFER, Le.__webglColorRenderbuffer[ht]);
                  const st = r.get(O[ht]).__webglTexture;
                  n.bindFramebuffer(t.FRAMEBUFFER, Le.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + ht, t.TEXTURE_2D, st, 0)
               }
            n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Le.__webglMultisampledFramebuffer)
         }
      }

      function qe(j) {
         return Math.min(d, j.samples)
      }

      function vt(j) {
         const O = r.get(j);
         return a && j.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && O.__useRenderToTexture !== !1
      }

      function Ot(j) {
         const O = o.render.frame;
         v.get(j) !== O && (v.set(j, O), j.update())
      }

      function un(j, O) {
         const ue = j.colorSpace,
            Pe = j.format,
            Te = j.type;
         return j.isCompressedTexture === !0 || j.format === H0 || ue !== ys && ue !== Ra && (ue === Rt ? a === !1 ? e.has("EXT_sRGB") === !0 && Pe === Hr ? (j.format = H0, j.minFilter = ln, j.generateMipmaps = !1) : O = JM.sRGBToLinear(O) : (Pe !== Hr || Te !== Vs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ue)), O
      }
      this.allocateTextureUnit = G, this.resetTextureUnits = oe, this.setTexture2D = Y, this.setTexture2DArray = X, this.setTexture3D = Q, this.setTextureCube = _e, this.rebindTextures = Ie, this.setupRenderTarget = be, this.updateRenderTargetMipmap = lt, this.updateMultisampleRenderTarget = Je, this.setupDepthRenderbuffer = Ae, this.setupFrameBufferTexture = $e, this.useMultisampledRTT = vt
   }

   function wF(t, e, n) {
      const r = n.isWebGL2;

      function i(s, o = Ra) {
         let a;
         if (s === Vs) return t.UNSIGNED_BYTE;
         if (s === NM) return t.UNSIGNED_SHORT_4_4_4_4;
         if (s === UM) return t.UNSIGNED_SHORT_5_5_5_1;
         if (s === W3) return t.BYTE;
         if (s === j3) return t.SHORT;
         if (s === Rv) return t.UNSIGNED_SHORT;
         if (s === OM) return t.INT;
         if (s === So) return t.UNSIGNED_INT;
         if (s === dr) return t.FLOAT;
         if (s === Cr) return r ? t.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
         if (s === $3) return t.ALPHA;
         if (s === Hr) return t.RGBA;
         if (s === X3) return t.LUMINANCE;
         if (s === J3) return t.LUMINANCE_ALPHA;
         if (s === Ca) return t.DEPTH_COMPONENT;
         if (s === Kl) return t.DEPTH_STENCIL;
         if (s === H0) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
         if (s === kM) return t.RED;
         if (s === HM) return t.RED_INTEGER;
         if (s === K3) return t.RG;
         if (s === GM) return t.RG_INTEGER;
         if (s === zM) return t.RGBA_INTEGER;
         if (s === n0 || s === r0 || s === i0 || s === s0)
            if (o === Rt)
               if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
                  if (s === n0) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                  if (s === r0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                  if (s === i0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                  if (s === s0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
               } else return null;
         else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
            if (s === n0) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (s === r0) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (s === i0) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (s === s0) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
         } else return null;
         if (s === MA || s === EA || s === wA || s === bA)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
               if (s === MA) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
               if (s === EA) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
               if (s === wA) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
               if (s === bA) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else return null;
         if (s === Y3) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
         if (s === CA || s === TA)
            if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
               if (s === CA) return o === Rt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
               if (s === TA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else return null;
         if (s === RA || s === PA || s === BA || s === IA || s === LA || s === DA || s === FA || s === OA || s === NA || s === UA || s === kA || s === HA || s === GA || s === zA)
            if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
               if (s === RA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
               if (s === PA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
               if (s === BA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
               if (s === IA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
               if (s === LA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
               if (s === DA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
               if (s === FA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
               if (s === OA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
               if (s === NA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
               if (s === UA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
               if (s === kA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
               if (s === HA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
               if (s === GA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
               if (s === zA) return o === Rt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else return null;
         if (s === o0)
            if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
               if (s === o0) return o === Rt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else return null;
         if (s === Q3 || s === VA || s === WA || s === jA)
            if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
               if (s === o0) return a.COMPRESSED_RED_RGTC1_EXT;
               if (s === VA) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
               if (s === WA) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
               if (s === jA) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else return null;
         return s === ba ? r ? t.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : t[s] !== void 0 ? t[s] : null
      }
      return {
         convert: i
      }
   }
   class bF extends Zn {
      constructor(e = []) {
         super(), this.isArrayCamera = !0, this.cameras = e
      }
   }
   class Mo extends Wt {
      constructor() {
         super(), this.isGroup = !0, this.type = "Group"
      }
   }
   const Q6 = {
      type: "move"
   };
   class S_ {
      constructor() {
         this._targetRay = null, this._grip = null, this._hand = null
      }
      getHandSpace() {
         return this._hand === null && (this._hand = new Mo, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
         }), this._hand
      }
      getTargetRaySpace() {
         return this._targetRay === null && (this._targetRay = new Mo, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new U, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new U), this._targetRay
      }
      getGripSpace() {
         return this._grip === null && (this._grip = new Mo, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new U, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new U), this._grip
      }
      dispatchEvent(e) {
         return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
      }
      connect(e) {
         if (e && e.hand) {
            const n = this._hand;
            if (n)
               for (const r of e.hand.values()) this._getHandJoint(n, r)
         }
         return this.dispatchEvent({
            type: "connected",
            data: e
         }), this
      }
      disconnect(e) {
         return this.dispatchEvent({
            type: "disconnected",
            data: e
         }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
      }
      update(e, n, r) {
         let i = null,
            s = null,
            o = null;
         const a = this._targetRay,
            l = this._grip,
            u = this._hand;
         if (e && n.session.visibilityState !== "visible-blurred") {
            if (u && e.hand) {
               o = !0;
               for (const _ of e.hand.values()) {
                  const x = n.getJointPose(_, r),
                     g = this._getHandJoint(u, _);
                  x !== null && (g.matrix.fromArray(x.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = x.radius), g.visible = x !== null
               }
               const h = u.joints["index-finger-tip"],
                  d = u.joints["thumb-tip"],
                  p = h.position.distanceTo(d.position),
                  m = .02,
                  v = .005;
               u.inputState.pinching && p > m + v ? (u.inputState.pinching = !1, this.dispatchEvent({
                  type: "pinchend",
                  handedness: e.handedness,
                  target: this
               })) : !u.inputState.pinching && p <= m - v && (u.inputState.pinching = !0, this.dispatchEvent({
                  type: "pinchstart",
                  handedness: e.handedness,
                  target: this
               }))
            } else l !== null && e.gripSpace && (s = n.getPose(e.gripSpace, r), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = n.getPose(e.targetRaySpace, r), i === null && s !== null && (i = s), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Q6)))
         }
         return a !== null && (a.visible = i !== null), l !== null && (l.visible = s !== null), u !== null && (u.visible = o !== null), this
      }
      _getHandJoint(e, n) {
         if (e.joints[n.jointName] === void 0) {
            const r = new Mo;
            r.matrixAutoUpdate = !1, r.visible = !1, e.joints[n.jointName] = r, e.add(r)
         }
         return e.joints[n.jointName]
      }
   }
   class CF extends yn {
      constructor(e, n, r, i, s, o, a, l, u, h) {
         if (h = h !== void 0 ? h : Ca, h !== Ca && h !== Kl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
         r === void 0 && h === Ca && (r = So), r === void 0 && h === Kl && (r = ba), super(null, i, s, o, a, l, h, r, u), this.isDepthTexture = !0, this.image = {
            width: e,
            height: n
         }, this.magFilter = a !== void 0 ? a : Fn, this.minFilter = l !== void 0 ? l : Fn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
      }
      copy(e) {
         return super.copy(e), this.compareFunction = e.compareFunction, this
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n
      }
   }
   class Z6 extends Uo {
      constructor(e, n) {
         super();
         const r = this;
         let i = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            u = null,
            h = null,
            d = null,
            p = null,
            m = null,
            v = null;
         const _ = n.getContextAttributes();
         let x = null,
            g = null;
         const S = [],
            A = [],
            E = new Zn;
         E.layers.enable(1), E.viewport = new $t;
         const C = new Zn;
         C.layers.enable(2), C.viewport = new $t;
         const R = [E, C],
            B = new bF;
         B.layers.enable(1), B.layers.enable(2);
         let D = null,
            T = null;
         this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (X) {
            let Q = S[X];
            return Q === void 0 && (Q = new S_, S[X] = Q), Q.getTargetRaySpace()
         }, this.getControllerGrip = function (X) {
            let Q = S[X];
            return Q === void 0 && (Q = new S_, S[X] = Q), Q.getGripSpace()
         }, this.getHand = function (X) {
            let Q = S[X];
            return Q === void 0 && (Q = new S_, S[X] = Q), Q.getHandSpace()
         };

         function I(X) {
            const Q = A.indexOf(X.inputSource);
            if (Q === -1) return;
            const _e = S[Q];
            _e !== void 0 && (_e.update(X.inputSource, X.frame, u || o), _e.dispatchEvent({
               type: X.type,
               data: X.inputSource
            }))
         }

         function N() {
            i.removeEventListener("select", I), i.removeEventListener("selectstart", I), i.removeEventListener("selectend", I), i.removeEventListener("squeeze", I), i.removeEventListener("squeezestart", I), i.removeEventListener("squeezeend", I), i.removeEventListener("end", N), i.removeEventListener("inputsourceschange", q);
            for (let X = 0; X < S.length; X++) {
               const Q = A[X];
               Q !== null && (A[X] = null, S[X].disconnect(Q))
            }
            D = null, T = null, e.setRenderTarget(x), m = null, p = null, d = null, i = null, g = null, Y.stop(), r.isPresenting = !1, r.dispatchEvent({
               type: "sessionend"
            })
         }
         this.setFramebufferScaleFactor = function (X) {
            s = X, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
         }, this.setReferenceSpaceType = function (X) {
            a = X, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
         }, this.getReferenceSpace = function () {
            return u || o
         }, this.setReferenceSpace = function (X) {
            u = X
         }, this.getBaseLayer = function () {
            return p !== null ? p : m
         }, this.getBinding = function () {
            return d
         }, this.getFrame = function () {
            return v
         }, this.getSession = function () {
            return i
         }, this.setSession = async function (X) {
            if (i = X, i !== null) {
               if (x = e.getRenderTarget(), i.addEventListener("select", I), i.addEventListener("selectstart", I), i.addEventListener("selectend", I), i.addEventListener("squeeze", I), i.addEventListener("squeezestart", I), i.addEventListener("squeezeend", I), i.addEventListener("end", N), i.addEventListener("inputsourceschange", q), _.xrCompatible !== !0 && await n.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                  const Q = {
                     antialias: i.renderState.layers === void 0 ? _.antialias : !0,
                     alpha: !0,
                     depth: _.depth,
                     stencil: _.stencil,
                     framebufferScaleFactor: s
                  };
                  m = new XRWebGLLayer(i, n, Q), i.updateRenderState({
                     baseLayer: m
                  }), g = new Ai(m.framebufferWidth, m.framebufferHeight, {
                     format: Hr,
                     type: Vs,
                     colorSpace: e.outputColorSpace,
                     stencilBuffer: _.stencil
                  })
               } else {
                  let Q = null,
                     _e = null,
                     Me = null;
                  _.depth && (Me = _.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, Q = _.stencil ? Kl : Ca, _e = _.stencil ? ba : So);
                  const we = {
                     colorFormat: n.RGBA8,
                     depthFormat: Me,
                     scaleFactor: s
                  };
                  d = new XRWebGLBinding(i, n), p = d.createProjectionLayer(we), i.updateRenderState({
                     layers: [p]
                  }), g = new Ai(p.textureWidth, p.textureHeight, {
                     format: Hr,
                     type: Vs,
                     depthTexture: new CF(p.textureWidth, p.textureHeight, _e, void 0, void 0, void 0, void 0, void 0, void 0, Q),
                     stencilBuffer: _.stencil,
                     colorSpace: e.outputColorSpace,
                     samples: _.antialias ? 4 : 0
                  });
                  const Ee = e.properties.get(g);
                  Ee.__ignoreDepthValues = p.ignoreDepthValues
               }
               g.isXRRenderTarget = !0, this.setFoveation(l), u = null, o = await i.requestReferenceSpace(a), Y.setContext(i), Y.start(), r.isPresenting = !0, r.dispatchEvent({
                  type: "sessionstart"
               })
            }
         }, this.getEnvironmentBlendMode = function () {
            if (i !== null) return i.environmentBlendMode
         };

         function q(X) {
            for (let Q = 0; Q < X.removed.length; Q++) {
               const _e = X.removed[Q],
                  Me = A.indexOf(_e);
               Me >= 0 && (A[Me] = null, S[Me].disconnect(_e))
            }
            for (let Q = 0; Q < X.added.length; Q++) {
               const _e = X.added[Q];
               let Me = A.indexOf(_e);
               if (Me === -1) {
                  for (let Ee = 0; Ee < S.length; Ee++)
                     if (Ee >= A.length) {
                        A.push(_e), Me = Ee;
                        break
                     } else if (A[Ee] === null) {
                     A[Ee] = _e, Me = Ee;
                     break
                  }
                  if (Me === -1) break
               }
               const we = S[Me];
               we && we.connect(_e)
            }
         }
         const K = new U,
            Z = new U;

         function te(X, Q, _e) {
            K.setFromMatrixPosition(Q.matrixWorld), Z.setFromMatrixPosition(_e.matrixWorld);
            const Me = K.distanceTo(Z),
               we = Q.projectionMatrix.elements,
               Ee = _e.projectionMatrix.elements,
               Ue = we[14] / (we[10] - 1),
               Qe = we[14] / (we[10] + 1),
               Pt = (we[9] + 1) / we[5],
               kt = (we[9] - 1) / we[5],
               $e = (we[8] - 1) / we[0],
               J = (Ee[8] + 1) / Ee[0],
               Ce = Ue * $e,
               Ae = Ue * J,
               Ie = Me / (-$e + J),
               be = Ie * -$e;
            Q.matrixWorld.decompose(X.position, X.quaternion, X.scale), X.translateX(be), X.translateZ(Ie), X.matrixWorld.compose(X.position, X.quaternion, X.scale), X.matrixWorldInverse.copy(X.matrixWorld).invert();
            const lt = Ue + Ie,
               Je = Qe + Ie,
               qe = Ce - be,
               vt = Ae + (Me - be),
               Ot = Pt * Qe / Je * lt,
               un = kt * Qe / Je * lt;
            X.projectionMatrix.makePerspective(qe, vt, Ot, un, lt, Je), X.projectionMatrixInverse.copy(X.projectionMatrix).invert()
         }

         function se(X, Q) {
            Q === null ? X.matrixWorld.copy(X.matrix) : X.matrixWorld.multiplyMatrices(Q.matrixWorld, X.matrix), X.matrixWorldInverse.copy(X.matrixWorld).invert()
         }
         this.updateCamera = function (X) {
            if (i === null) return;
            B.near = C.near = E.near = X.near, B.far = C.far = E.far = X.far, (D !== B.near || T !== B.far) && (i.updateRenderState({
               depthNear: B.near,
               depthFar: B.far
            }), D = B.near, T = B.far);
            const Q = X.parent,
               _e = B.cameras;
            se(B, Q);
            for (let Me = 0; Me < _e.length; Me++) se(_e[Me], Q);
            _e.length === 2 ? te(B, E, C) : B.projectionMatrix.copy(E.projectionMatrix), oe(X, B, Q)
         };

         function oe(X, Q, _e) {
            _e === null ? X.matrix.copy(Q.matrixWorld) : (X.matrix.copy(_e.matrixWorld), X.matrix.invert(), X.matrix.multiply(Q.matrixWorld)), X.matrix.decompose(X.position, X.quaternion, X.scale), X.updateMatrixWorld(!0);
            const Me = X.children;
            for (let we = 0, Ee = Me.length; we < Ee; we++) Me[we].updateMatrixWorld(!0);
            X.projectionMatrix.copy(Q.projectionMatrix), X.projectionMatrixInverse.copy(Q.projectionMatrixInverse), X.isPerspectiveCamera && (X.fov = df * 2 * Math.atan(1 / X.projectionMatrix.elements[5]), X.zoom = 1)
         }
         this.getCamera = function () {
            return B
         }, this.getFoveation = function () {
            if (!(p === null && m === null)) return l
         }, this.setFoveation = function (X) {
            l = X, p !== null && (p.fixedFoveation = X), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = X)
         };
         let G = null;

         function ne(X, Q) {
            if (h = Q.getViewerPose(u || o), v = Q, h !== null) {
               const _e = h.views;
               m !== null && (e.setRenderTargetFramebuffer(g, m.framebuffer), e.setRenderTarget(g));
               let Me = !1;
               _e.length !== B.cameras.length && (B.cameras.length = 0, Me = !0);
               for (let we = 0; we < _e.length; we++) {
                  const Ee = _e[we];
                  let Ue = null;
                  if (m !== null) Ue = m.getViewport(Ee);
                  else {
                     const Pt = d.getViewSubImage(p, Ee);
                     Ue = Pt.viewport, we === 0 && (e.setRenderTargetTextures(g, Pt.colorTexture, p.ignoreDepthValues ? void 0 : Pt.depthStencilTexture), e.setRenderTarget(g))
                  }
                  let Qe = R[we];
                  Qe === void 0 && (Qe = new Zn, Qe.layers.enable(we), Qe.viewport = new $t, R[we] = Qe), Qe.matrix.fromArray(Ee.transform.matrix), Qe.matrix.decompose(Qe.position, Qe.quaternion, Qe.scale), Qe.projectionMatrix.fromArray(Ee.projectionMatrix), Qe.projectionMatrixInverse.copy(Qe.projectionMatrix).invert(), Qe.viewport.set(Ue.x, Ue.y, Ue.width, Ue.height), we === 0 && (B.matrix.copy(Qe.matrix), B.matrix.decompose(B.position, B.quaternion, B.scale)), Me === !0 && B.cameras.push(Qe)
               }
            }
            for (let _e = 0; _e < S.length; _e++) {
               const Me = A[_e],
                  we = S[_e];
               Me !== null && we !== void 0 && we.update(Me, Q, u || o)
            }
            G && G(X, Q), Q.detectedPlanes && r.dispatchEvent({
               type: "planesdetected",
               data: Q
            }), v = null
         }
         const Y = new _F;
         Y.setAnimationLoop(ne), this.setAnimationLoop = function (X) {
            G = X
         }, this.dispose = function () {}
      }
   }

   function q6(t, e) {
      function n(x, g) {
         x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix)
      }

      function r(x, g) {
         g.color.getRGB(x.fogColor.value, yF(t)), g.isFog ? (x.fogNear.value = g.near, x.fogFar.value = g.far) : g.isFogExp2 && (x.fogDensity.value = g.density)
      }

      function i(x, g, S, A, E) {
         g.isMeshBasicMaterial || g.isMeshLambertMaterial ? s(x, g) : g.isMeshToonMaterial ? (s(x, g), d(x, g)) : g.isMeshPhongMaterial ? (s(x, g), h(x, g)) : g.isMeshStandardMaterial ? (s(x, g), p(x, g), g.isMeshPhysicalMaterial && m(x, g, E)) : g.isMeshMatcapMaterial ? (s(x, g), v(x, g)) : g.isMeshDepthMaterial ? s(x, g) : g.isMeshDistanceMaterial ? (s(x, g), _(x, g)) : g.isMeshNormalMaterial ? s(x, g) : g.isLineBasicMaterial ? (o(x, g), g.isLineDashedMaterial && a(x, g)) : g.isPointsMaterial ? l(x, g, S, A) : g.isSpriteMaterial ? u(x, g) : g.isShadowMaterial ? (x.color.value.copy(g.color), x.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1)
      }

      function s(x, g) {
         x.opacity.value = g.opacity, g.color && x.diffuse.value.copy(g.color), g.emissive && x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (x.map.value = g.map, n(g.map, x.mapTransform)), g.alphaMap && (x.alphaMap.value = g.alphaMap, n(g.alphaMap, x.alphaMapTransform)), g.bumpMap && (x.bumpMap.value = g.bumpMap, n(g.bumpMap, x.bumpMapTransform), x.bumpScale.value = g.bumpScale, g.side === zr && (x.bumpScale.value *= -1)), g.normalMap && (x.normalMap.value = g.normalMap, n(g.normalMap, x.normalMapTransform), x.normalScale.value.copy(g.normalScale), g.side === zr && x.normalScale.value.negate()), g.displacementMap && (x.displacementMap.value = g.displacementMap, n(g.displacementMap, x.displacementMapTransform), x.displacementScale.value = g.displacementScale, x.displacementBias.value = g.displacementBias), g.emissiveMap && (x.emissiveMap.value = g.emissiveMap, n(g.emissiveMap, x.emissiveMapTransform)), g.specularMap && (x.specularMap.value = g.specularMap, n(g.specularMap, x.specularMapTransform)), g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
         const S = e.get(g).envMap;
         if (S && (x.envMap.value = S, x.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, x.reflectivity.value = g.reflectivity, x.ior.value = g.ior, x.refractionRatio.value = g.refractionRatio), g.lightMap) {
            x.lightMap.value = g.lightMap;
            const A = t._useLegacyLights === !0 ? Math.PI : 1;
            x.lightMapIntensity.value = g.lightMapIntensity * A, n(g.lightMap, x.lightMapTransform)
         }
         g.aoMap && (x.aoMap.value = g.aoMap, x.aoMapIntensity.value = g.aoMapIntensity, n(g.aoMap, x.aoMapTransform))
      }

      function o(x, g) {
         x.diffuse.value.copy(g.color), x.opacity.value = g.opacity, g.map && (x.map.value = g.map, n(g.map, x.mapTransform))
      }

      function a(x, g) {
         x.dashSize.value = g.dashSize, x.totalSize.value = g.dashSize + g.gapSize, x.scale.value = g.scale
      }

      function l(x, g, S, A) {
         x.diffuse.value.copy(g.color), x.opacity.value = g.opacity, x.size.value = g.size * S, x.scale.value = A * .5, g.map && (x.map.value = g.map, n(g.map, x.uvTransform)), g.alphaMap && (x.alphaMap.value = g.alphaMap, n(g.alphaMap, x.alphaMapTransform)), g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest)
      }

      function u(x, g) {
         x.diffuse.value.copy(g.color), x.opacity.value = g.opacity, x.rotation.value = g.rotation, g.map && (x.map.value = g.map, n(g.map, x.mapTransform)), g.alphaMap && (x.alphaMap.value = g.alphaMap, n(g.alphaMap, x.alphaMapTransform)), g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest)
      }

      function h(x, g) {
         x.specular.value.copy(g.specular), x.shininess.value = Math.max(g.shininess, 1e-4)
      }

      function d(x, g) {
         g.gradientMap && (x.gradientMap.value = g.gradientMap)
      }

      function p(x, g) {
         x.metalness.value = g.metalness, g.metalnessMap && (x.metalnessMap.value = g.metalnessMap, n(g.metalnessMap, x.metalnessMapTransform)), x.roughness.value = g.roughness, g.roughnessMap && (x.roughnessMap.value = g.roughnessMap, n(g.roughnessMap, x.roughnessMapTransform)), e.get(g).envMap && (x.envMapIntensity.value = g.envMapIntensity)
      }

      function m(x, g, S) {
         x.ior.value = g.ior, g.sheen > 0 && (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), x.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (x.sheenColorMap.value = g.sheenColorMap, n(g.sheenColorMap, x.sheenColorMapTransform)), g.sheenRoughnessMap && (x.sheenRoughnessMap.value = g.sheenRoughnessMap, n(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))), g.clearcoat > 0 && (x.clearcoat.value = g.clearcoat, x.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (x.clearcoatMap.value = g.clearcoatMap, n(g.clearcoatMap, x.clearcoatMapTransform)), g.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, n(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (x.clearcoatNormalMap.value = g.clearcoatNormalMap, n(g.clearcoatNormalMap, x.clearcoatNormalMapTransform), x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === zr && x.clearcoatNormalScale.value.negate())), g.iridescence > 0 && (x.iridescence.value = g.iridescence, x.iridescenceIOR.value = g.iridescenceIOR, x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (x.iridescenceMap.value = g.iridescenceMap, n(g.iridescenceMap, x.iridescenceMapTransform)), g.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = g.iridescenceThicknessMap, n(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))), g.transmission > 0 && (x.transmission.value = g.transmission, x.transmissionSamplerMap.value = S.texture, x.transmissionSamplerSize.value.set(S.width, S.height), g.transmissionMap && (x.transmissionMap.value = g.transmissionMap, n(g.transmissionMap, x.transmissionMapTransform)), x.thickness.value = g.thickness, g.thicknessMap && (x.thicknessMap.value = g.thicknessMap, n(g.thicknessMap, x.thicknessMapTransform)), x.attenuationDistance.value = g.attenuationDistance, x.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (x.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (x.anisotropyMap.value = g.anisotropyMap, n(g.anisotropyMap, x.anisotropyMapTransform))), x.specularIntensity.value = g.specularIntensity, x.specularColor.value.copy(g.specularColor), g.specularColorMap && (x.specularColorMap.value = g.specularColorMap, n(g.specularColorMap, x.specularColorMapTransform)), g.specularIntensityMap && (x.specularIntensityMap.value = g.specularIntensityMap, n(g.specularIntensityMap, x.specularIntensityMapTransform))
      }

      function v(x, g) {
         g.matcap && (x.matcap.value = g.matcap)
      }

      function _(x, g) {
         const S = e.get(g).light;
         x.referencePosition.value.setFromMatrixPosition(S.matrixWorld), x.nearDistance.value = S.shadow.camera.near, x.farDistance.value = S.shadow.camera.far
      }
      return {
         refreshFogUniforms: r,
         refreshMaterialUniforms: i
      }
   }

   function eW(t, e, n, r) {
      let i = {},
         s = {},
         o = [];
      const a = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

      function l(S, A) {
         const E = A.program;
         r.uniformBlockBinding(S, E)
      }

      function u(S, A) {
         let E = i[S.id];
         E === void 0 && (v(S), E = h(S), i[S.id] = E, S.addEventListener("dispose", x));
         const C = A.program;
         r.updateUBOMapping(S, C);
         const R = e.render.frame;
         s[S.id] !== R && (p(S), s[S.id] = R)
      }

      function h(S) {
         const A = d();
         S.__bindingPointIndex = A;
         const E = t.createBuffer(),
            C = S.__size,
            R = S.usage;
         return t.bindBuffer(t.UNIFORM_BUFFER, E), t.bufferData(t.UNIFORM_BUFFER, C, R), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, A, E), E
      }

      function d() {
         for (let S = 0; S < a; S++)
            if (o.indexOf(S) === -1) return o.push(S), S;
         return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
      }

      function p(S) {
         const A = i[S.id],
            E = S.uniforms,
            C = S.__cache;
         t.bindBuffer(t.UNIFORM_BUFFER, A);
         for (let R = 0, B = E.length; R < B; R++) {
            const D = E[R];
            if (m(D, R, C) === !0) {
               const T = D.__offset,
                  I = Array.isArray(D.value) ? D.value : [D.value];
               let N = 0;
               for (let q = 0; q < I.length; q++) {
                  const K = I[q],
                     Z = _(K);
                  typeof K == "number" ? (D.__data[0] = K, t.bufferSubData(t.UNIFORM_BUFFER, T + N, D.__data)) : K.isMatrix3 ? (D.__data[0] = K.elements[0], D.__data[1] = K.elements[1], D.__data[2] = K.elements[2], D.__data[3] = K.elements[0], D.__data[4] = K.elements[3], D.__data[5] = K.elements[4], D.__data[6] = K.elements[5], D.__data[7] = K.elements[0], D.__data[8] = K.elements[6], D.__data[9] = K.elements[7], D.__data[10] = K.elements[8], D.__data[11] = K.elements[0]) : (K.toArray(D.__data, N), N += Z.storage / Float32Array.BYTES_PER_ELEMENT)
               }
               t.bufferSubData(t.UNIFORM_BUFFER, T, D.__data)
            }
         }
         t.bindBuffer(t.UNIFORM_BUFFER, null)
      }

      function m(S, A, E) {
         const C = S.value;
         if (E[A] === void 0) {
            if (typeof C == "number") E[A] = C;
            else {
               const R = Array.isArray(C) ? C : [C],
                  B = [];
               for (let D = 0; D < R.length; D++) B.push(R[D].clone());
               E[A] = B
            }
            return !0
         } else if (typeof C == "number") {
            if (E[A] !== C) return E[A] = C, !0
         } else {
            const R = Array.isArray(E[A]) ? E[A] : [E[A]],
               B = Array.isArray(C) ? C : [C];
            for (let D = 0; D < R.length; D++) {
               const T = R[D];
               if (T.equals(B[D]) === !1) return T.copy(B[D]), !0
            }
         }
         return !1
      }

      function v(S) {
         const A = S.uniforms;
         let E = 0;
         const C = 16;
         let R = 0;
         for (let B = 0, D = A.length; B < D; B++) {
            const T = A[B],
               I = {
                  boundary: 0,
                  storage: 0
               },
               N = Array.isArray(T.value) ? T.value : [T.value];
            for (let q = 0, K = N.length; q < K; q++) {
               const Z = N[q],
                  te = _(Z);
               I.boundary += te.boundary, I.storage += te.storage
            }
            if (T.__data = new Float32Array(I.storage / Float32Array.BYTES_PER_ELEMENT), T.__offset = E, B > 0) {
               R = E % C;
               const q = C - R;
               R !== 0 && q - I.boundary < 0 && (E += C - R, T.__offset = E)
            }
            E += I.storage
         }
         return R = E % C, R > 0 && (E += C - R), S.__size = E, S.__cache = {}, this
      }

      function _(S) {
         const A = {
            boundary: 0,
            storage: 0
         };
         return typeof S == "number" ? (A.boundary = 4, A.storage = 4) : S.isVector2 ? (A.boundary = 8, A.storage = 8) : S.isVector3 || S.isColor ? (A.boundary = 16, A.storage = 12) : S.isVector4 ? (A.boundary = 16, A.storage = 16) : S.isMatrix3 ? (A.boundary = 48, A.storage = 48) : S.isMatrix4 ? (A.boundary = 64, A.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), A
      }

      function x(S) {
         const A = S.target;
         A.removeEventListener("dispose", x);
         const E = o.indexOf(A.__bindingPointIndex);
         o.splice(E, 1), t.deleteBuffer(i[A.id]), delete i[A.id], delete s[A.id]
      }

      function g() {
         for (const S in i) t.deleteBuffer(i[S]);
         o = [], i = {}, s = {}
      }
      return {
         bind: l,
         update: u,
         dispose: g
      }
   }

   function tW() {
      const t = Hd("canvas");
      return t.style.display = "block", t
   }
   class rE {
      constructor(e = {}) {
         const {
            canvas: n = tW(),
            context: r = null,
            depth: i = !0,
            stencil: s = !0,
            alpha: o = !1,
            antialias: a = !1,
            premultipliedAlpha: l = !0,
            preserveDrawingBuffer: u = !1,
            powerPreference: h = "default",
            failIfMajorPerformanceCaveat: d = !1
         } = e;
         this.isWebGLRenderer = !0;
         let p;
         r !== null ? p = r.getContextAttributes().alpha : p = o;
         const m = new Uint32Array(4),
            v = new Int32Array(4);
         let _ = null,
            x = null;
         const g = [],
            S = [];
         this.domElement = n, this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
         }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = Rt, this._useLegacyLights = !1, this.toneMapping = zs, this.toneMappingExposure = 1;
         const A = this;
         let E = !1,
            C = 0,
            R = 0,
            B = null,
            D = -1,
            T = null;
         const I = new $t,
            N = new $t;
         let q = null;
         const K = new ke(0);
         let Z = 0,
            te = n.width,
            se = n.height,
            oe = 1,
            G = null,
            ne = null;
         const Y = new $t(0, 0, te, se),
            X = new $t(0, 0, te, se);
         let Q = !1;
         const _e = new Iv;
         let Me = !1,
            we = !1,
            Ee = null;
         const Ue = new yt,
            Qe = new Se,
            Pt = new U,
            kt = {
               background: null,
               fog: null,
               environment: null,
               overrideMaterial: null,
               isScene: !0
            };

         function $e() {
            return B === null ? oe : 1
         }
         let J = r;

         function Ce(b, F) {
            for (let H = 0; H < b.length; H++) {
               const k = b[H],
                  W = n.getContext(k, F);
               if (W !== null) return W
            }
            return null
         }
         try {
            const b = {
               alpha: !0,
               depth: i,
               stencil: s,
               antialias: a,
               premultipliedAlpha: l,
               preserveDrawingBuffer: u,
               powerPreference: h,
               failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${nu}`), n.addEventListener("webglcontextlost", fe, !1), n.addEventListener("webglcontextrestored", he, !1), n.addEventListener("webglcontextcreationerror", Fe, !1), J === null) {
               const F = ["webgl2", "webgl", "experimental-webgl"];
               if (A.isWebGL1Renderer === !0 && F.shift(), J = Ce(F, b), J === null) throw Ce(F) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            typeof WebGLRenderingContext < "u" && J instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), J.getShaderPrecisionFormat === void 0 && (J.getShaderPrecisionFormat = function () {
               return {
                  rangeMin: 1,
                  rangeMax: 1,
                  precision: 1
               }
            })
         } catch (b) {
            throw console.error("THREE.WebGLRenderer: " + b.message), b
         }
         let Ae, Ie, be, lt, Je, qe, vt, Ot, un, j, O, ue, Pe, Te, Be, rt, Le, de, ht, st, Ke, et, Ye, pt;

         function Mt() {
            Ae = new gV(J), Ie = new cV(J, Ae, e), Ae.init(Ie), et = new wF(J, Ae, Ie), be = new K6(J, Ae, Ie), lt = new xV(J), Je = new N6, qe = new Y6(J, Ae, be, Je, Ie, et, lt), vt = new hV(A), Ot = new mV(A), un = new R5(J, Ie), Ye = new lV(J, Ae, un, Ie), j = new vV(J, un, lt, Ye), O = new MV(J, j, un, lt), ht = new SV(J, Ie, qe), rt = new fV(Je), ue = new O6(A, vt, Ot, Ae, Ie, Ye, rt), Pe = new q6(A, Je), Te = new k6, Be = new j6(Ae, Ie), de = new aV(A, vt, Ot, be, O, p, l), Le = new J6(A, O, Ie), pt = new eW(J, lt, Ie, be), st = new uV(J, Ae, lt, Ie), Ke = new yV(J, Ae, lt, Ie), lt.programs = ue.programs, A.capabilities = Ie, A.extensions = Ae, A.properties = Je, A.renderLists = Te, A.shadowMap = Le, A.state = be, A.info = lt
         }
         Mt();
         const ee = new Z6(A, J);
         this.xr = ee, this.getContext = function () {
            return J
         }, this.getContextAttributes = function () {
            return J.getContextAttributes()
         }, this.forceContextLoss = function () {
            const b = Ae.get("WEBGL_lose_context");
            b && b.loseContext()
         }, this.forceContextRestore = function () {
            const b = Ae.get("WEBGL_lose_context");
            b && b.restoreContext()
         }, this.getPixelRatio = function () {
            return oe
         }, this.setPixelRatio = function (b) {
            b !== void 0 && (oe = b, this.setSize(te, se, !1))
         }, this.getSize = function (b) {
            return b.set(te, se)
         }, this.setSize = function (b, F, H = !0) {
            if (ee.isPresenting) {
               console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
               return
            }
            te = b, se = F, n.width = Math.floor(b * oe), n.height = Math.floor(F * oe), H === !0 && (n.style.width = b + "px", n.style.height = F + "px"), this.setViewport(0, 0, b, F)
         }, this.getDrawingBufferSize = function (b) {
            return b.set(te * oe, se * oe).floor()
         }, this.setDrawingBufferSize = function (b, F, H) {
            te = b, se = F, oe = H, n.width = Math.floor(b * H), n.height = Math.floor(F * H), this.setViewport(0, 0, b, F)
         }, this.getCurrentViewport = function (b) {
            return b.copy(I)
         }, this.getViewport = function (b) {
            return b.copy(Y)
         }, this.setViewport = function (b, F, H, k) {
            b.isVector4 ? Y.set(b.x, b.y, b.z, b.w) : Y.set(b, F, H, k), be.viewport(I.copy(Y).multiplyScalar(oe).floor())
         }, this.getScissor = function (b) {
            return b.copy(X)
         }, this.setScissor = function (b, F, H, k) {
            b.isVector4 ? X.set(b.x, b.y, b.z, b.w) : X.set(b, F, H, k), be.scissor(N.copy(X).multiplyScalar(oe).floor())
         }, this.getScissorTest = function () {
            return Q
         }, this.setScissorTest = function (b) {
            be.setScissorTest(Q = b)
         }, this.setOpaqueSort = function (b) {
            G = b
         }, this.setTransparentSort = function (b) {
            ne = b
         }, this.getClearColor = function (b) {
            return b.copy(de.getClearColor())
         }, this.setClearColor = function () {
            de.setClearColor.apply(de, arguments)
         }, this.getClearAlpha = function () {
            return de.getClearAlpha()
         }, this.setClearAlpha = function () {
            de.setClearAlpha.apply(de, arguments)
         }, this.clear = function (b = !0, F = !0, H = !0) {
            let k = 0;
            if (b) {
               let W = !1;
               if (B !== null) {
                  const ae = B.texture.format;
                  W = ae === zM || ae === GM || ae === HM
               }
               if (W) {
                  const ae = B.texture.type,
                     ce = ae === Vs || ae === So || ae === Rv || ae === ba || ae === NM || ae === UM,
                     ye = de.getClearColor(),
                     ge = de.getClearAlpha(),
                     xe = ye.r,
                     me = ye.g,
                     Xe = ye.b;
                  ce ? (m[0] = xe, m[1] = me, m[2] = Xe, m[3] = ge, J.clearBufferuiv(J.COLOR, 0, m)) : (v[0] = xe, v[1] = me, v[2] = Xe, v[3] = ge, J.clearBufferiv(J.COLOR, 0, v))
               } else k |= J.COLOR_BUFFER_BIT
            }
            F && (k |= J.DEPTH_BUFFER_BIT), H && (k |= J.STENCIL_BUFFER_BIT), J.clear(k)
         }, this.clearColor = function () {
            this.clear(!0, !1, !1)
         }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
         }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
         }, this.dispose = function () {
            n.removeEventListener("webglcontextlost", fe, !1), n.removeEventListener("webglcontextrestored", he, !1), n.removeEventListener("webglcontextcreationerror", Fe, !1), Te.dispose(), Be.dispose(), Je.dispose(), vt.dispose(), Ot.dispose(), O.dispose(), Ye.dispose(), pt.dispose(), ue.dispose(), ee.dispose(), ee.removeEventListener("sessionstart", en), ee.removeEventListener("sessionend", Br), Ee && (Ee.dispose(), Ee = null), Kn.stop()
         };

         function fe(b) {
            b.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), E = !0
         }

         function he() {
            console.log("THREE.WebGLRenderer: Context Restored."), E = !1;
            const b = lt.autoReset,
               F = Le.enabled,
               H = Le.autoUpdate,
               k = Le.needsUpdate,
               W = Le.type;
            Mt(), lt.autoReset = b, Le.enabled = F, Le.autoUpdate = H, Le.needsUpdate = k, Le.type = W
         }

         function Fe(b) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", b.statusMessage)
         }

         function ze(b) {
            const F = b.target;
            F.removeEventListener("dispose", ze), Ut(F)
         }

         function Ut(b) {
            sn(b), Je.remove(b)
         }

         function sn(b) {
            const F = Je.get(b).programs;
            F !== void 0 && (F.forEach(function (H) {
               ue.releaseProgram(H)
            }), b.isShaderMaterial && ue.releaseShaderCache(b))
         }
         this.renderBufferDirect = function (b, F, H, k, W, ae) {
            F === null && (F = kt);
            const ce = W.isMesh && W.matrixWorld.determinant() < 0,
               ye = xu(b, F, H, k, W);
            be.setMaterial(k, ce);
            let ge = H.index,
               xe = 1;
            if (k.wireframe === !0) {
               if (ge = j.getWireframeAttribute(H), ge === void 0) return;
               xe = 2
            }
            const me = H.drawRange,
               Xe = H.attributes.position;
            let Oe = me.start * xe,
               He = (me.start + me.count) * xe;
            ae !== null && (Oe = Math.max(Oe, ae.start * xe), He = Math.min(He, (ae.start + ae.count) * xe)), ge !== null ? (Oe = Math.max(Oe, 0), He = Math.min(He, ge.count)) : Xe != null && (Oe = Math.max(Oe, 0), He = Math.min(He, Xe.count));
            const ct = He - Oe;
            if (ct < 0 || ct === 1 / 0) return;
            Ye.setup(W, k, ye, H, ge);
            let mt, dt = st;
            if (ge !== null && (mt = un.get(ge), dt = Ke, dt.setIndex(mt)), W.isMesh) k.wireframe === !0 ? (be.setLineWidth(k.wireframeLinewidth * $e()), dt.setMode(J.LINES)) : dt.setMode(J.TRIANGLES);
            else if (W.isLine) {
               let We = k.linewidth;
               We === void 0 && (We = 1), be.setLineWidth(We * $e()), W.isLineSegments ? dt.setMode(J.LINES) : W.isLineLoop ? dt.setMode(J.LINE_LOOP) : dt.setMode(J.LINE_STRIP)
            } else W.isPoints ? dt.setMode(J.POINTS) : W.isSprite && dt.setMode(J.TRIANGLES);
            if (W.isInstancedMesh) dt.renderInstances(Oe, ct, W.count);
            else if (H.isInstancedBufferGeometry) {
               const We = H._maxInstanceCount !== void 0 ? H._maxInstanceCount : 1 / 0,
                  xt = Math.min(H.instanceCount, We);
               dt.renderInstances(Oe, ct, xt)
            } else dt.render(Oe, ct)
         }, this.compile = function (b, F) {
            function H(k, W, ae) {
               k.transparent === !0 && k.side === Wi && k.forceSinglePass === !1 ? (k.side = zr, k.needsUpdate = !0, gr(k, W, ae), k.side = Js, k.needsUpdate = !0, gr(k, W, ae), k.side = Wi) : gr(k, W, ae)
            }
            x = Be.get(b), x.init(), S.push(x), b.traverseVisible(function (k) {
               k.isLight && k.layers.test(F.layers) && (x.pushLight(k), k.castShadow && x.pushShadow(k))
            }), x.setupLights(A._useLegacyLights), b.traverse(function (k) {
               const W = k.material;
               if (W)
                  if (Array.isArray(W))
                     for (let ae = 0; ae < W.length; ae++) {
                        const ce = W[ae];
                        H(ce, b, k)
                     } else H(W, b, k)
            }), S.pop(), x = null
         };
         let xn = null;

         function si(b) {
            xn && xn(b)
         }

         function en() {
            Kn.stop()
         }

         function Br() {
            Kn.start()
         }
         const Kn = new _F;
         Kn.setAnimationLoop(si), typeof self < "u" && Kn.setContext(self), this.setAnimationLoop = function (b) {
            xn = b, ee.setAnimationLoop(b), b === null ? Kn.stop() : Kn.start()
         }, ee.addEventListener("sessionstart", en), ee.addEventListener("sessionend", Br), this.render = function (b, F) {
            if (F !== void 0 && F.isCamera !== !0) {
               console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
               return
            }
            if (E === !0) return;
            b.matrixWorldAutoUpdate === !0 && b.updateMatrixWorld(), F.parent === null && F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), ee.enabled === !0 && ee.isPresenting === !0 && (ee.cameraAutoUpdate === !0 && ee.updateCamera(F), F = ee.getCamera()), b.isScene === !0 && b.onBeforeRender(A, b, F, B), x = Be.get(b, S.length), x.init(), S.push(x), Ue.multiplyMatrices(F.projectionMatrix, F.matrixWorldInverse), _e.setFromProjectionMatrix(Ue), we = this.localClippingEnabled, Me = rt.init(this.clippingPlanes, we), _ = Te.get(b, g.length), _.init(), g.push(_), vu(b, F, 0, A.sortObjects), _.finish(), A.sortObjects === !0 && _.sort(G, ne), this.info.render.frame++, Me === !0 && rt.beginShadows();
            const H = x.state.shadowsArray;
            if (Le.render(H, b, F), Me === !0 && rt.endShadows(), this.info.autoReset === !0 && this.info.reset(), de.render(_, b), x.setupLights(A._useLegacyLights), F.isArrayCamera) {
               const k = F.cameras;
               for (let W = 0, ae = k.length; W < ae; W++) {
                  const ce = k[W];
                  yu(_, b, ce, ce.viewport)
               }
            } else yu(_, b, F);
            B !== null && (qe.updateMultisampleRenderTarget(B), qe.updateRenderTargetMipmap(B)), b.isScene === !0 && b.onAfterRender(A, b, F), Ye.resetDefaultState(), D = -1, T = null, S.pop(), S.length > 0 ? x = S[S.length - 1] : x = null, g.pop(), g.length > 0 ? _ = g[g.length - 1] : _ = null
         };

         function vu(b, F, H, k) {
            if (b.visible === !1) return;
            if (b.layers.test(F.layers)) {
               if (b.isGroup) H = b.renderOrder;
               else if (b.isLOD) b.autoUpdate === !0 && b.update(F);
               else if (b.isLight) x.pushLight(b), b.castShadow && x.pushShadow(b);
               else if (b.isSprite) {
                  if (!b.frustumCulled || _e.intersectsSprite(b)) {
                     k && Pt.setFromMatrixPosition(b.matrixWorld).applyMatrix4(Ue);
                     const ce = O.update(b),
                        ye = b.material;
                     ye.visible && _.push(b, ce, ye, H, Pt.z, null)
                  }
               } else if ((b.isMesh || b.isLine || b.isPoints) && (!b.frustumCulled || _e.intersectsObject(b))) {
                  const ce = O.update(b),
                     ye = b.material;
                  if (k && (b.boundingSphere !== void 0 ? (b.boundingSphere === null && b.computeBoundingSphere(), Pt.copy(b.boundingSphere.center)) : (ce.boundingSphere === null && ce.computeBoundingSphere(), Pt.copy(ce.boundingSphere.center)), Pt.applyMatrix4(b.matrixWorld).applyMatrix4(Ue)), Array.isArray(ye)) {
                     const ge = ce.groups;
                     for (let xe = 0, me = ge.length; xe < me; xe++) {
                        const Xe = ge[xe],
                           Oe = ye[Xe.materialIndex];
                        Oe && Oe.visible && _.push(b, ce, Oe, H, Pt.z, Xe)
                     }
                  } else ye.visible && _.push(b, ce, ye, H, Pt.z, null)
               }
            }
            const ae = b.children;
            for (let ce = 0, ye = ae.length; ce < ye; ce++) vu(ae[ce], F, H, k)
         }

         function yu(b, F, H, k) {
            const W = b.opaque,
               ae = b.transmissive,
               ce = b.transparent;
            x.setupLightsView(H), Me === !0 && rt.setGlobalState(A.clippingPlanes, H), ae.length > 0 && qs(W, ae, F, H), k && be.viewport(I.copy(k)), W.length > 0 && Es(W, F, H), ae.length > 0 && Es(ae, F, H), ce.length > 0 && Es(ce, F, H), be.buffers.depth.setTest(!0), be.buffers.depth.setMask(!0), be.buffers.color.setMask(!0), be.setPolygonOffset(!1)
         }

         function qs(b, F, H, k) {
            const W = Ie.isWebGL2;
            Ee === null && (Ee = new Ai(1, 1, {
               generateMipmaps: !0,
               type: Ae.has("EXT_color_buffer_half_float") ? Cr : Vs,
               minFilter: Ys,
               samples: W ? 4 : 0
            })), A.getDrawingBufferSize(Qe), W ? Ee.setSize(Qe.x, Qe.y) : Ee.setSize(G0(Qe.x), G0(Qe.y));
            const ae = A.getRenderTarget();
            A.setRenderTarget(Ee), A.getClearColor(K), Z = A.getClearAlpha(), Z < 1 && A.setClearColor(16777215, .5), A.clear();
            const ce = A.toneMapping;
            A.toneMapping = zs, Es(b, H, k), qe.updateMultisampleRenderTarget(Ee), qe.updateRenderTargetMipmap(Ee);
            let ye = !1;
            for (let ge = 0, xe = F.length; ge < xe; ge++) {
               const me = F[ge],
                  Xe = me.object,
                  Oe = me.geometry,
                  He = me.material,
                  ct = me.group;
               if (He.side === Wi && Xe.layers.test(k.layers)) {
                  const mt = He.side;
                  He.side = zr, He.needsUpdate = !0, ws(Xe, H, k, Oe, He, ct), He.side = mt, He.needsUpdate = !0, ye = !0
               }
            }
            ye === !0 && (qe.updateMultisampleRenderTarget(Ee), qe.updateRenderTargetMipmap(Ee)), A.setRenderTarget(ae), A.setClearColor(K, Z), A.toneMapping = ce
         }

         function Es(b, F, H) {
            const k = F.isScene === !0 ? F.overrideMaterial : null;
            for (let W = 0, ae = b.length; W < ae; W++) {
               const ce = b[W],
                  ye = ce.object,
                  ge = ce.geometry,
                  xe = k === null ? ce.material : k,
                  me = ce.group;
               ye.layers.test(H.layers) && ws(ye, F, H, ge, xe, me)
            }
         }

         function ws(b, F, H, k, W, ae) {
            b.onBeforeRender(A, F, H, k, W, ae), b.modelViewMatrix.multiplyMatrices(H.matrixWorldInverse, b.matrixWorld), b.normalMatrix.getNormalMatrix(b.modelViewMatrix), W.onBeforeRender(A, F, H, k, b, ae), W.transparent === !0 && W.side === Wi && W.forceSinglePass === !1 ? (W.side = zr, W.needsUpdate = !0, A.renderBufferDirect(H, F, k, W, b, ae), W.side = Js, W.needsUpdate = !0, A.renderBufferDirect(H, F, k, W, b, ae), W.side = Wi) : A.renderBufferDirect(H, F, k, W, b, ae), b.onAfterRender(A, F, H, k, W, ae)
         }

         function gr(b, F, H) {
            F.isScene !== !0 && (F = kt);
            const k = Je.get(b),
               W = x.state.lights,
               ae = x.state.shadowsArray,
               ce = W.state.version,
               ye = ue.getParameters(b, W.state, ae, F, H),
               ge = ue.getProgramCacheKey(ye);
            let xe = k.programs;
            k.environment = b.isMeshStandardMaterial ? F.environment : null, k.fog = F.fog, k.envMap = (b.isMeshStandardMaterial ? Ot : vt).get(b.envMap || k.environment), xe === void 0 && (b.addEventListener("dispose", ze), xe = new Map, k.programs = xe);
            let me = xe.get(ge);
            if (me !== void 0) {
               if (k.currentProgram === me && k.lightsStateVersion === ce) return Lt(b, ye), me
            } else ye.uniforms = ue.getUniforms(b), b.onBuild(H, ye, A), b.onBeforeCompile(ye, A), me = ue.acquireProgram(ye, ge), xe.set(ge, me), k.uniforms = ye.uniforms;
            const Xe = k.uniforms;
            (!b.isShaderMaterial && !b.isRawShaderMaterial || b.clipping === !0) && (Xe.clippingPlanes = rt.uniform), Lt(b, ye), k.needsLights = L(b), k.lightsStateVersion = ce, k.needsLights && (Xe.ambientLightColor.value = W.state.ambient, Xe.lightProbe.value = W.state.probe, Xe.directionalLights.value = W.state.directional, Xe.directionalLightShadows.value = W.state.directionalShadow, Xe.spotLights.value = W.state.spot, Xe.spotLightShadows.value = W.state.spotShadow, Xe.rectAreaLights.value = W.state.rectArea, Xe.ltc_1.value = W.state.rectAreaLTC1, Xe.ltc_2.value = W.state.rectAreaLTC2, Xe.pointLights.value = W.state.point, Xe.pointLightShadows.value = W.state.pointShadow, Xe.hemisphereLights.value = W.state.hemi, Xe.directionalShadowMap.value = W.state.directionalShadowMap, Xe.directionalShadowMatrix.value = W.state.directionalShadowMatrix, Xe.spotShadowMap.value = W.state.spotShadowMap, Xe.spotLightMatrix.value = W.state.spotLightMatrix, Xe.spotLightMap.value = W.state.spotLightMap, Xe.pointShadowMap.value = W.state.pointShadowMap, Xe.pointShadowMatrix.value = W.state.pointShadowMatrix);
            const Oe = me.getUniforms(),
               He = u0.seqWithValue(Oe.seq, Xe);
            return k.currentProgram = me, k.uniformsList = He, me
         }

         function Lt(b, F) {
            const H = Je.get(b);
            H.outputColorSpace = F.outputColorSpace, H.instancing = F.instancing, H.instancingColor = F.instancingColor, H.skinning = F.skinning, H.morphTargets = F.morphTargets, H.morphNormals = F.morphNormals, H.morphColors = F.morphColors, H.morphTargetsCount = F.morphTargetsCount, H.numClippingPlanes = F.numClippingPlanes, H.numIntersection = F.numClipIntersection, H.vertexAlphas = F.vertexAlphas, H.vertexTangents = F.vertexTangents, H.toneMapping = F.toneMapping
         }

         function xu(b, F, H, k, W) {
            F.isScene !== !0 && (F = kt), qe.resetTextureUnits();
            const ae = F.fog,
               ce = k.isMeshStandardMaterial ? F.environment : null,
               ye = B === null ? A.outputColorSpace : B.isXRRenderTarget === !0 ? B.texture.colorSpace : ys,
               ge = (k.isMeshStandardMaterial ? Ot : vt).get(k.envMap || ce),
               xe = k.vertexColors === !0 && !!H.attributes.color && H.attributes.color.itemSize === 4,
               me = !!H.attributes.tangent && (!!k.normalMap || k.anisotropy > 0),
               Xe = !!H.morphAttributes.position,
               Oe = !!H.morphAttributes.normal,
               He = !!H.morphAttributes.color;
            let ct = zs;
            k.toneMapped && (B === null || B.isXRRenderTarget === !0) && (ct = A.toneMapping);
            const mt = H.morphAttributes.position || H.morphAttributes.normal || H.morphAttributes.color,
               dt = mt !== void 0 ? mt.length : 0,
               We = Je.get(k),
               xt = x.state.lights;
            if (Me === !0 && (we === !0 || b !== T)) {
               const Et = b === T && k.id === D;
               rt.setState(k, b, Et)
            }
            let it = !1;
            k.version === We.__version ? (We.needsLights && We.lightsStateVersion !== xt.state.version || We.outputColorSpace !== ye || W.isInstancedMesh && We.instancing === !1 || !W.isInstancedMesh && We.instancing === !0 || W.isSkinnedMesh && We.skinning === !1 || !W.isSkinnedMesh && We.skinning === !0 || W.isInstancedMesh && We.instancingColor === !0 && W.instanceColor === null || W.isInstancedMesh && We.instancingColor === !1 && W.instanceColor !== null || We.envMap !== ge || k.fog === !0 && We.fog !== ae || We.numClippingPlanes !== void 0 && (We.numClippingPlanes !== rt.numPlanes || We.numIntersection !== rt.numIntersection) || We.vertexAlphas !== xe || We.vertexTangents !== me || We.morphTargets !== Xe || We.morphNormals !== Oe || We.morphColors !== He || We.toneMapping !== ct || Ie.isWebGL2 === !0 && We.morphTargetsCount !== dt) && (it = !0) : (it = !0, We.__version = k.version);
            let wt = We.currentProgram;
            it === !0 && (wt = gr(k, F, W));
            let tn = !1,
               At = !1,
               nn = !1;
            const Jt = wt.getUniforms(),
               on = We.uniforms;
            if (be.useProgram(wt.program) && (tn = !0, At = !0, nn = !0), k.id !== D && (D = k.id, At = !0), tn || T !== b) {
               if (Jt.setValue(J, "projectionMatrix", b.projectionMatrix), Ie.logarithmicDepthBuffer && Jt.setValue(J, "logDepthBufFC", 2 / (Math.log(b.far + 1) / Math.LN2)), T !== b && (T = b, At = !0, nn = !0), k.isShaderMaterial || k.isMeshPhongMaterial || k.isMeshToonMaterial || k.isMeshStandardMaterial || k.envMap) {
                  const Et = Jt.map.cameraPosition;
                  Et !== void 0 && Et.setValue(J, Pt.setFromMatrixPosition(b.matrixWorld))
               }(k.isMeshPhongMaterial || k.isMeshToonMaterial || k.isMeshLambertMaterial || k.isMeshBasicMaterial || k.isMeshStandardMaterial || k.isShaderMaterial) && Jt.setValue(J, "isOrthographic", b.isOrthographicCamera === !0), (k.isMeshPhongMaterial || k.isMeshToonMaterial || k.isMeshLambertMaterial || k.isMeshBasicMaterial || k.isMeshStandardMaterial || k.isShaderMaterial || k.isShadowMaterial || W.isSkinnedMesh) && Jt.setValue(J, "viewMatrix", b.matrixWorldInverse)
            }
            if (W.isSkinnedMesh) {
               Jt.setOptional(J, W, "bindMatrix"), Jt.setOptional(J, W, "bindMatrixInverse");
               const Et = W.skeleton;
               Et && (Ie.floatVertexTextures ? (Et.boneTexture === null && Et.computeBoneTexture(), Jt.setValue(J, "boneTexture", Et.boneTexture, qe), Jt.setValue(J, "boneTextureSize", Et.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            const Un = H.morphAttributes;
            if ((Un.position !== void 0 || Un.normal !== void 0 || Un.color !== void 0 && Ie.isWebGL2 === !0) && ht.update(W, H, wt), (At || We.receiveShadow !== W.receiveShadow) && (We.receiveShadow = W.receiveShadow, Jt.setValue(J, "receiveShadow", W.receiveShadow)), k.isMeshGouraudMaterial && k.envMap !== null && (on.envMap.value = ge, on.flipEnvMap.value = ge.isCubeTexture && ge.isRenderTargetTexture === !1 ? -1 : 1), At && (Jt.setValue(J, "toneMappingExposure", A.toneMappingExposure), We.needsLights && zf(on, nn), ae && k.fog === !0 && Pe.refreshFogUniforms(on, ae), Pe.refreshMaterialUniforms(on, k, oe, se, Ee), u0.upload(J, We.uniformsList, on, qe)), k.isShaderMaterial && k.uniformsNeedUpdate === !0 && (u0.upload(J, We.uniformsList, on, qe), k.uniformsNeedUpdate = !1), k.isSpriteMaterial && Jt.setValue(J, "center", W.center), Jt.setValue(J, "modelViewMatrix", W.modelViewMatrix), Jt.setValue(J, "normalMatrix", W.normalMatrix), Jt.setValue(J, "modelMatrix", W.matrixWorld), k.isShaderMaterial || k.isRawShaderMaterial) {
               const Et = k.uniformsGroups;
               for (let wn = 0, qt = Et.length; wn < qt; wn++)
                  if (Ie.isWebGL2) {
                     const Gt = Et[wn];
                     pt.update(Gt, wt), pt.bind(Gt, wt)
                  } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return wt
         }

         function zf(b, F) {
            b.ambientLightColor.needsUpdate = F, b.lightProbe.needsUpdate = F, b.directionalLights.needsUpdate = F, b.directionalLightShadows.needsUpdate = F, b.pointLights.needsUpdate = F, b.pointLightShadows.needsUpdate = F, b.spotLights.needsUpdate = F, b.spotLightShadows.needsUpdate = F, b.rectAreaLights.needsUpdate = F, b.hemisphereLights.needsUpdate = F
         }

         function L(b) {
            return b.isMeshLambertMaterial || b.isMeshToonMaterial || b.isMeshPhongMaterial || b.isMeshStandardMaterial || b.isShadowMaterial || b.isShaderMaterial && b.lights === !0
         }
         this.getActiveCubeFace = function () {
            return C
         }, this.getActiveMipmapLevel = function () {
            return R
         }, this.getRenderTarget = function () {
            return B
         }, this.setRenderTargetTextures = function (b, F, H) {
            Je.get(b.texture).__webglTexture = F, Je.get(b.depthTexture).__webglTexture = H;
            const k = Je.get(b);
            k.__hasExternalTextures = !0, k.__hasExternalTextures && (k.__autoAllocateDepthBuffer = H === void 0, k.__autoAllocateDepthBuffer || Ae.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), k.__useRenderToTexture = !1))
         }, this.setRenderTargetFramebuffer = function (b, F) {
            const H = Je.get(b);
            H.__webglFramebuffer = F, H.__useDefaultFramebuffer = F === void 0
         }, this.setRenderTarget = function (b, F = 0, H = 0) {
            B = b, C = F, R = H;
            let k = !0,
               W = null,
               ae = !1,
               ce = !1;
            if (b) {
               const ge = Je.get(b);
               ge.__useDefaultFramebuffer !== void 0 ? (be.bindFramebuffer(J.FRAMEBUFFER, null), k = !1) : ge.__webglFramebuffer === void 0 ? qe.setupRenderTarget(b) : ge.__hasExternalTextures && qe.rebindTextures(b, Je.get(b.texture).__webglTexture, Je.get(b.depthTexture).__webglTexture);
               const xe = b.texture;
               (xe.isData3DTexture || xe.isDataArrayTexture || xe.isCompressedArrayTexture) && (ce = !0);
               const me = Je.get(b).__webglFramebuffer;
               b.isWebGLCubeRenderTarget ? (Array.isArray(me[F]) ? W = me[F][H] : W = me[F], ae = !0) : Ie.isWebGL2 && b.samples > 0 && qe.useMultisampledRTT(b) === !1 ? W = Je.get(b).__webglMultisampledFramebuffer : Array.isArray(me) ? W = me[H] : W = me, I.copy(b.viewport), N.copy(b.scissor), q = b.scissorTest
            } else I.copy(Y).multiplyScalar(oe).floor(), N.copy(X).multiplyScalar(oe).floor(), q = Q;
            if (be.bindFramebuffer(J.FRAMEBUFFER, W) && Ie.drawBuffers && k && be.drawBuffers(b, W), be.viewport(I), be.scissor(N), be.setScissorTest(q), ae) {
               const ge = Je.get(b.texture);
               J.framebufferTexture2D(J.FRAMEBUFFER, J.COLOR_ATTACHMENT0, J.TEXTURE_CUBE_MAP_POSITIVE_X + F, ge.__webglTexture, H)
            } else if (ce) {
               const ge = Je.get(b.texture),
                  xe = F || 0;
               J.framebufferTextureLayer(J.FRAMEBUFFER, J.COLOR_ATTACHMENT0, ge.__webglTexture, H || 0, xe)
            }
            D = -1
         }, this.readRenderTargetPixels = function (b, F, H, k, W, ae, ce) {
            if (!(b && b.isWebGLRenderTarget)) {
               console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
               return
            }
            let ye = Je.get(b).__webglFramebuffer;
            if (b.isWebGLCubeRenderTarget && ce !== void 0 && (ye = ye[ce]), ye) {
               be.bindFramebuffer(J.FRAMEBUFFER, ye);
               try {
                  const ge = b.texture,
                     xe = ge.format,
                     me = ge.type;
                  if (xe !== Hr && et.convert(xe) !== J.getParameter(J.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                     console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                     return
                  }
                  const Xe = me === Cr && (Ae.has("EXT_color_buffer_half_float") || Ie.isWebGL2 && Ae.has("EXT_color_buffer_float"));
                  if (me !== Vs && et.convert(me) !== J.getParameter(J.IMPLEMENTATION_COLOR_READ_TYPE) && !(me === dr && (Ie.isWebGL2 || Ae.has("OES_texture_float") || Ae.has("WEBGL_color_buffer_float"))) && !Xe) {
                     console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                     return
                  }
                  F >= 0 && F <= b.width - k && H >= 0 && H <= b.height - W && J.readPixels(F, H, k, W, et.convert(xe), et.convert(me), ae)
               } finally {
                  const ge = B !== null ? Je.get(B).__webglFramebuffer : null;
                  be.bindFramebuffer(J.FRAMEBUFFER, ge)
               }
            }
         }, this.copyFramebufferToTexture = function (b, F, H = 0) {
            const k = Math.pow(2, -H),
               W = Math.floor(F.image.width * k),
               ae = Math.floor(F.image.height * k);
            qe.setTexture2D(F, 0), J.copyTexSubImage2D(J.TEXTURE_2D, H, 0, 0, b.x, b.y, W, ae), be.unbindTexture()
         }, this.copyTextureToTexture = function (b, F, H, k = 0) {
            const W = F.image.width,
               ae = F.image.height,
               ce = et.convert(H.format),
               ye = et.convert(H.type);
            qe.setTexture2D(H, 0), J.pixelStorei(J.UNPACK_FLIP_Y_WEBGL, H.flipY), J.pixelStorei(J.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha), J.pixelStorei(J.UNPACK_ALIGNMENT, H.unpackAlignment), F.isDataTexture ? J.texSubImage2D(J.TEXTURE_2D, k, b.x, b.y, W, ae, ce, ye, F.image.data) : F.isCompressedTexture ? J.compressedTexSubImage2D(J.TEXTURE_2D, k, b.x, b.y, F.mipmaps[0].width, F.mipmaps[0].height, ce, F.mipmaps[0].data) : J.texSubImage2D(J.TEXTURE_2D, k, b.x, b.y, ce, ye, F.image), k === 0 && H.generateMipmaps && J.generateMipmap(J.TEXTURE_2D), be.unbindTexture()
         }, this.copyTextureToTexture3D = function (b, F, H, k, W = 0) {
            if (A.isWebGL1Renderer) {
               console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
               return
            }
            const ae = b.max.x - b.min.x + 1,
               ce = b.max.y - b.min.y + 1,
               ye = b.max.z - b.min.z + 1,
               ge = et.convert(k.format),
               xe = et.convert(k.type);
            let me;
            if (k.isData3DTexture) qe.setTexture3D(k, 0), me = J.TEXTURE_3D;
            else if (k.isDataArrayTexture) qe.setTexture2DArray(k, 0), me = J.TEXTURE_2D_ARRAY;
            else {
               console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
               return
            }
            J.pixelStorei(J.UNPACK_FLIP_Y_WEBGL, k.flipY), J.pixelStorei(J.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha), J.pixelStorei(J.UNPACK_ALIGNMENT, k.unpackAlignment);
            const Xe = J.getParameter(J.UNPACK_ROW_LENGTH),
               Oe = J.getParameter(J.UNPACK_IMAGE_HEIGHT),
               He = J.getParameter(J.UNPACK_SKIP_PIXELS),
               ct = J.getParameter(J.UNPACK_SKIP_ROWS),
               mt = J.getParameter(J.UNPACK_SKIP_IMAGES),
               dt = H.isCompressedTexture ? H.mipmaps[0] : H.image;
            J.pixelStorei(J.UNPACK_ROW_LENGTH, dt.width), J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, dt.height), J.pixelStorei(J.UNPACK_SKIP_PIXELS, b.min.x), J.pixelStorei(J.UNPACK_SKIP_ROWS, b.min.y), J.pixelStorei(J.UNPACK_SKIP_IMAGES, b.min.z), H.isDataTexture || H.isData3DTexture ? J.texSubImage3D(me, W, F.x, F.y, F.z, ae, ce, ye, ge, xe, dt.data) : H.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), J.compressedTexSubImage3D(me, W, F.x, F.y, F.z, ae, ce, ye, ge, dt.data)) : J.texSubImage3D(me, W, F.x, F.y, F.z, ae, ce, ye, ge, xe, dt), J.pixelStorei(J.UNPACK_ROW_LENGTH, Xe), J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, Oe), J.pixelStorei(J.UNPACK_SKIP_PIXELS, He), J.pixelStorei(J.UNPACK_SKIP_ROWS, ct), J.pixelStorei(J.UNPACK_SKIP_IMAGES, mt), W === 0 && k.generateMipmaps && J.generateMipmap(me), be.unbindTexture()
         }, this.initTexture = function (b) {
            b.isCubeTexture ? qe.setTextureCube(b, 0) : b.isData3DTexture ? qe.setTexture3D(b, 0) : b.isDataArrayTexture || b.isCompressedArrayTexture ? qe.setTexture2DArray(b, 0) : qe.setTexture2D(b, 0), be.unbindTexture()
         }, this.resetState = function () {
            C = 0, R = 0, B = null, be.reset(), Ye.reset()
         }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
         }))
      }
      get coordinateSystem() {
         return ks
      }
      get physicallyCorrectLights() {
         return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights
      }
      set physicallyCorrectLights(e) {
         console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e
      }
      get outputEncoding() {
         return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Rt ? Ta : jM
      }
      set outputEncoding(e) {
         console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Ta ? Rt : ys
      }
      get useLegacyLights() {
         return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
      }
      set useLegacyLights(e) {
         console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
      }
   }
   class TF extends rE {}
   TF.prototype.isWebGL1Renderer = !0;
   class Dv {
      constructor(e, n = 25e-5) {
         this.isFogExp2 = !0, this.name = "", this.color = new ke(e), this.density = n
      }
      clone() {
         return new Dv(this.color, this.density)
      }
      toJSON() {
         return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
         }
      }
   }
   class Fv {
      constructor(e, n = 1, r = 1e3) {
         this.isFog = !0, this.name = "", this.color = new ke(e), this.near = n, this.far = r
      }
      clone() {
         return new Fv(this.color, this.near, this.far)
      }
      toJSON() {
         return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
         }
      }
   }
   class Gd extends Wt {
      constructor() {
         super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
         }))
      }
      copy(e, n) {
         return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n
      }
   }
   class up {
      constructor(e, n) {
         this.isInterleavedBuffer = !0, this.array = e, this.stride = n, this.count = e !== void 0 ? e.length / n : 0, this.usage = Ud, this.updateRange = {
            offset: 0,
            count: -1
         }, this.version = 0, this.uuid = xi()
      }
      onUploadCallback() {}
      set needsUpdate(e) {
         e === !0 && this.version++
      }
      setUsage(e) {
         return this.usage = e, this
      }
      copy(e) {
         return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
      }
      copyAt(e, n, r) {
         e *= this.stride, r *= n.stride;
         for (let i = 0, s = this.stride; i < s; i++) this.array[e + i] = n.array[r + i];
         return this
      }
      set(e, n = 0) {
         return this.array.set(e, n), this
      }
      clone(e) {
         e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = xi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
         const n = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            r = new this.constructor(n, this.stride);
         return r.setUsage(this.usage), r
      }
      onUpload(e) {
         return this.onUploadCallback = e, this
      }
      toJSON(e) {
         return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = xi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
         }
      }
   }
   const Fr = new U;
   class Oa {
      constructor(e, n, r, i = !1) {
         this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = n, this.offset = r, this.normalized = i
      }
      get count() {
         return this.data.count
      }
      get array() {
         return this.data.array
      }
      set needsUpdate(e) {
         this.data.needsUpdate = e
      }
      applyMatrix4(e) {
         for (let n = 0, r = this.data.count; n < r; n++) Fr.fromBufferAttribute(this, n), Fr.applyMatrix4(e), this.setXYZ(n, Fr.x, Fr.y, Fr.z);
         return this
      }
      applyNormalMatrix(e) {
         for (let n = 0, r = this.count; n < r; n++) Fr.fromBufferAttribute(this, n), Fr.applyNormalMatrix(e), this.setXYZ(n, Fr.x, Fr.y, Fr.z);
         return this
      }
      transformDirection(e) {
         for (let n = 0, r = this.count; n < r; n++) Fr.fromBufferAttribute(this, n), Fr.transformDirection(e), this.setXYZ(n, Fr.x, Fr.y, Fr.z);
         return this
      }
      setX(e, n) {
         return this.normalized && (n = It(n, this.array)), this.data.array[e * this.data.stride + this.offset] = n, this
      }
      setY(e, n) {
         return this.normalized && (n = It(n, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = n, this
      }
      setZ(e, n) {
         return this.normalized && (n = It(n, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = n, this
      }
      setW(e, n) {
         return this.normalized && (n = It(n, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = n, this
      }
      getX(e) {
         let n = this.data.array[e * this.data.stride + this.offset];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      getY(e) {
         let n = this.data.array[e * this.data.stride + this.offset + 1];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      getZ(e) {
         let n = this.data.array[e * this.data.stride + this.offset + 2];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      getW(e) {
         let n = this.data.array[e * this.data.stride + this.offset + 3];
         return this.normalized && (n = Qr(n, this.array)), n
      }
      setXY(e, n, r) {
         return e = e * this.data.stride + this.offset, this.normalized && (n = It(n, this.array), r = It(r, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this
      }
      setXYZ(e, n, r, i) {
         return e = e * this.data.stride + this.offset, this.normalized && (n = It(n, this.array), r = It(r, this.array), i = It(i, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this
      }
      setXYZW(e, n, r, i, s) {
         return e = e * this.data.stride + this.offset, this.normalized && (n = It(n, this.array), r = It(r, this.array), i = It(i, this.array), s = It(s, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this
      }
      clone(e) {
         if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const n = [];
            for (let r = 0; r < this.count; r++) {
               const i = r * this.data.stride + this.offset;
               for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[i + s])
            }
            return new Zt(new this.array.constructor(n), this.itemSize, this.normalized)
         } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Oa(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
      }
      toJSON(e) {
         if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const n = [];
            for (let r = 0; r < this.count; r++) {
               const i = r * this.data.stride + this.offset;
               for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[i + s])
            }
            return {
               itemSize: this.itemSize,
               type: this.array.constructor.name,
               array: n,
               normalized: this.normalized
            }
         } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
         }
      }
   }
   class iE extends Jn {
      constructor(e) {
         super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new ke(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
      }
   }
   let Ku;
   const _h = new U,
      Yu = new U,
      Qu = new U,
      Zu = new Se,
      Ah = new Se,
      RF = new yt,
      lg = new U,
      Sh = new U,
      ug = new U,
      SR = new Se,
      M_ = new Se,
      MR = new Se;
   class PF extends Wt {
      constructor(e) {
         if (super(), this.isSprite = !0, this.type = "Sprite", Ku === void 0) {
            Ku = new Tt;
            const n = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
               r = new up(n, 5);
            Ku.setIndex([0, 1, 2, 0, 2, 3]), Ku.setAttribute("position", new Oa(r, 3, 0, !1)), Ku.setAttribute("uv", new Oa(r, 2, 3, !1))
         }
         this.geometry = Ku, this.material = e !== void 0 ? e : new iE, this.center = new Se(.5, .5)
      }
      raycast(e, n) {
         e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Yu.setFromMatrixScale(this.matrixWorld), RF.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Qu.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Yu.multiplyScalar(-Qu.z);
         const r = this.material.rotation;
         let i, s;
         r !== 0 && (s = Math.cos(r), i = Math.sin(r));
         const o = this.center;
         cg(lg.set(-.5, -.5, 0), Qu, o, Yu, i, s), cg(Sh.set(.5, -.5, 0), Qu, o, Yu, i, s), cg(ug.set(.5, .5, 0), Qu, o, Yu, i, s), SR.set(0, 0), M_.set(1, 0), MR.set(1, 1);
         let a = e.ray.intersectTriangle(lg, Sh, ug, !1, _h);
         if (a === null && (cg(Sh.set(-.5, .5, 0), Qu, o, Yu, i, s), M_.set(0, 1), a = e.ray.intersectTriangle(lg, ug, Sh, !1, _h), a === null)) return;
         const l = e.ray.origin.distanceTo(_h);
         l < e.near || l > e.far || n.push({
            distance: l,
            point: _h.clone(),
            uv: Yr.getInterpolation(_h, lg, Sh, ug, SR, M_, MR, new Se),
            face: null,
            object: this
         })
      }
      copy(e, n) {
         return super.copy(e, n), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
      }
   }

   function cg(t, e, n, r, i, s) {
      Zu.subVectors(t, n).addScalar(.5).multiply(r), i !== void 0 ? (Ah.x = s * Zu.x - i * Zu.y, Ah.y = i * Zu.x + s * Zu.y) : Ah.copy(Zu), t.copy(e), t.x += Ah.x, t.y += Ah.y, t.applyMatrix4(RF)
   }
   const fg = new U,
      ER = new U;
   class BF extends Wt {
      constructor() {
         super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
               enumerable: !0,
               value: []
            },
            isLOD: {
               value: !0
            }
         }), this.autoUpdate = !0
      }
      copy(e) {
         super.copy(e, !1);
         const n = e.levels;
         for (let r = 0, i = n.length; r < i; r++) {
            const s = n[r];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
         }
         return this.autoUpdate = e.autoUpdate, this
      }
      addLevel(e, n = 0, r = 0) {
         n = Math.abs(n);
         const i = this.levels;
         let s;
         for (s = 0; s < i.length && !(n < i[s].distance); s++);
         return i.splice(s, 0, {
            distance: n,
            hysteresis: r,
            object: e
         }), this.add(e), this
      }
      getCurrentLevel() {
         return this._currentLevel
      }
      getObjectForDistance(e) {
         const n = this.levels;
         if (n.length > 0) {
            let r, i;
            for (r = 1, i = n.length; r < i; r++) {
               let s = n[r].distance;
               if (n[r].object.visible && (s -= s * n[r].hysteresis), e < s) break
            }
            return n[r - 1].object
         }
         return null
      }
      raycast(e, n) {
         if (this.levels.length > 0) {
            fg.setFromMatrixPosition(this.matrixWorld);
            const i = e.ray.origin.distanceTo(fg);
            this.getObjectForDistance(i).raycast(e, n)
         }
      }
      update(e) {
         const n = this.levels;
         if (n.length > 1) {
            fg.setFromMatrixPosition(e.matrixWorld), ER.setFromMatrixPosition(this.matrixWorld);
            const r = fg.distanceTo(ER) / e.zoom;
            n[0].object.visible = !0;
            let i, s;
            for (i = 1, s = n.length; i < s; i++) {
               let o = n[i].distance;
               if (n[i].object.visible && (o -= o * n[i].hysteresis), r >= o) n[i - 1].object.visible = !1, n[i].object.visible = !0;
               else break
            }
            for (this._currentLevel = i - 1; i < s; i++) n[i].object.visible = !1
         }
      }
      toJSON(e) {
         const n = super.toJSON(e);
         this.autoUpdate === !1 && (n.object.autoUpdate = !1), n.object.levels = [];
         const r = this.levels;
         for (let i = 0, s = r.length; i < s; i++) {
            const o = r[i];
            n.object.levels.push({
               object: o.object.uuid,
               distance: o.distance,
               hysteresis: o.hysteresis
            })
         }
         return n
      }
   }
   const wR = new U,
      bR = new $t,
      CR = new $t,
      nW = new U,
      TR = new yt,
      qu = new U,
      E_ = new Ci,
      RR = new yt,
      w_ = new Cf;
   class sE extends Xn {
      constructor(e, n) {
         super(e, n), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new yt, this.bindMatrixInverse = new yt, this.boundingBox = null, this.boundingSphere = null
      }
      computeBoundingBox() {
         const e = this.geometry;
         this.boundingBox === null && (this.boundingBox = new qi), this.boundingBox.makeEmpty();
         const n = e.getAttribute("position");
         for (let r = 0; r < n.count; r++) qu.fromBufferAttribute(n, r), this.applyBoneTransform(r, qu), this.boundingBox.expandByPoint(qu)
      }
      computeBoundingSphere() {
         const e = this.geometry;
         this.boundingSphere === null && (this.boundingSphere = new Ci), this.boundingSphere.makeEmpty();
         const n = e.getAttribute("position");
         for (let r = 0; r < n.count; r++) qu.fromBufferAttribute(n, r), this.applyBoneTransform(r, qu), this.boundingSphere.expandByPoint(qu)
      }
      copy(e, n) {
         return super.copy(e, n), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
      }
      raycast(e, n) {
         const r = this.material,
            i = this.matrixWorld;
         r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), E_.copy(this.boundingSphere), E_.applyMatrix4(i), e.ray.intersectsSphere(E_) !== !1 && (RR.copy(i).invert(), w_.copy(e.ray).applyMatrix4(RR), !(this.boundingBox !== null && w_.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, n, w_)))
      }
      getVertexPosition(e, n) {
         return super.getVertexPosition(e, n), this.applyBoneTransform(e, n), n
      }
      bind(e, n) {
         this.skeleton = e, n === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), n = this.matrixWorld), this.bindMatrix.copy(n), this.bindMatrixInverse.copy(n).invert()
      }
      pose() {
         this.skeleton.pose()
      }
      normalizeSkinWeights() {
         const e = new $t,
            n = this.geometry.attributes.skinWeight;
         for (let r = 0, i = n.count; r < i; r++) {
            e.fromBufferAttribute(n, r);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), n.setXYZW(r, e.x, e.y, e.z, e.w)
         }
      }
      updateMatrixWorld(e) {
         super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
      }
      applyBoneTransform(e, n) {
         const r = this.skeleton,
            i = this.geometry;
         bR.fromBufferAttribute(i.attributes.skinIndex, e), CR.fromBufferAttribute(i.attributes.skinWeight, e), wR.copy(n).applyMatrix4(this.bindMatrix), n.set(0, 0, 0);
         for (let s = 0; s < 4; s++) {
            const o = CR.getComponent(s);
            if (o !== 0) {
               const a = bR.getComponent(s);
               TR.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]), n.addScaledVector(nW.copy(wR).applyMatrix4(TR), o)
            }
         }
         return n.applyMatrix4(this.bindMatrixInverse)
      }
      boneTransform(e, n) {
         return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, n)
      }
   }
   class Ov extends Wt {
      constructor() {
         super(), this.isBone = !0, this.type = "Bone"
      }
   }
   class qc extends yn {
      constructor(e = null, n = 1, r = 1, i, s, o, a, l, u = Fn, h = Fn, d, p) {
         super(null, o, a, l, u, h, i, s, d, p), this.isDataTexture = !0, this.image = {
            data: e,
            width: n,
            height: r
         }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
      }
   }
   const PR = new yt,
      rW = new yt;
   class cp {
      constructor(e = [], n = []) {
         this.uuid = xi(), this.bones = e.slice(0), this.boneInverses = n, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init()
      }
      init() {
         const e = this.bones,
            n = this.boneInverses;
         if (this.boneMatrices = new Float32Array(e.length * 16), n.length === 0) this.calculateInverses();
         else if (e.length !== n.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let r = 0, i = this.bones.length; r < i; r++) this.boneInverses.push(new yt)
         }
      }
      calculateInverses() {
         this.boneInverses.length = 0;
         for (let e = 0, n = this.bones.length; e < n; e++) {
            const r = new yt;
            this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r)
         }
      }
      pose() {
         for (let e = 0, n = this.bones.length; e < n; e++) {
            const r = this.bones[e];
            r && r.matrixWorld.copy(this.boneInverses[e]).invert()
         }
         for (let e = 0, n = this.bones.length; e < n; e++) {
            const r = this.bones[e];
            r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale))
         }
      }
      update() {
         const e = this.bones,
            n = this.boneInverses,
            r = this.boneMatrices,
            i = this.boneTexture;
         for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : rW;
            PR.multiplyMatrices(a, n[s]), PR.toArray(r, s * 16)
         }
         i !== null && (i.needsUpdate = !0)
      }
      clone() {
         return new cp(this.bones, this.boneInverses)
      }
      computeBoneTexture() {
         let e = Math.sqrt(this.bones.length * 4);
         e = pF(e), e = Math.max(e, 4);
         const n = new Float32Array(e * e * 4);
         n.set(this.boneMatrices);
         const r = new qc(n, e, e, Hr, dr);
         return r.needsUpdate = !0, this.boneMatrices = n, this.boneTexture = r, this.boneTextureSize = e, this
      }
      getBoneByName(e) {
         for (let n = 0, r = this.bones.length; n < r; n++) {
            const i = this.bones[n];
            if (i.name === e) return i
         }
      }
      dispose() {
         this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
      }
      fromJSON(e, n) {
         this.uuid = e.uuid;
         for (let r = 0, i = e.bones.length; r < i; r++) {
            const s = e.bones[r];
            let o = n[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Ov), this.bones.push(o), this.boneInverses.push(new yt().fromArray(e.boneInverses[r]))
         }
         return this.init(), this
      }
      toJSON() {
         const e = {
            metadata: {
               version: 4.6,
               type: "Skeleton",
               generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
         };
         e.uuid = this.uuid;
         const n = this.bones,
            r = this.boneInverses;
         for (let i = 0, s = n.length; i < s; i++) {
            const o = n[i];
            e.bones.push(o.uuid);
            const a = r[i];
            e.boneInverses.push(a.toArray())
         }
         return e
      }
   }
   class mf extends Zt {
      constructor(e, n, r, i = 1) {
         super(e, n, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
      }
      copy(e) {
         return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
      }
      toJSON() {
         const e = super.toJSON();
         return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
      }
   }
   const ec = new yt,
      BR = new yt,
      hg = [],
      IR = new qi,
      iW = new yt,
      Mh = new Xn,
      Eh = new Ci;
   class oE extends Xn {
      constructor(e, n, r) {
         super(e, n), this.isInstancedMesh = !0, this.instanceMatrix = new mf(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.boundingBox = null, this.boundingSphere = null;
         for (let i = 0; i < r; i++) this.setMatrixAt(i, iW)
      }
      computeBoundingBox() {
         const e = this.geometry,
            n = this.count;
         this.boundingBox === null && (this.boundingBox = new qi), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
         for (let r = 0; r < n; r++) this.getMatrixAt(r, ec), IR.copy(e.boundingBox).applyMatrix4(ec), this.boundingBox.union(IR)
      }
      computeBoundingSphere() {
         const e = this.geometry,
            n = this.count;
         this.boundingSphere === null && (this.boundingSphere = new Ci), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
         for (let r = 0; r < n; r++) this.getMatrixAt(r, ec), Eh.copy(e.boundingSphere).applyMatrix4(ec), this.boundingSphere.union(Eh)
      }
      copy(e, n) {
         return super.copy(e, n), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
      }
      getColorAt(e, n) {
         n.fromArray(this.instanceColor.array, e * 3)
      }
      getMatrixAt(e, n) {
         n.fromArray(this.instanceMatrix.array, e * 16)
      }
      raycast(e, n) {
         const r = this.matrixWorld,
            i = this.count;
         if (Mh.geometry = this.geometry, Mh.material = this.material, Mh.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Eh.copy(this.boundingSphere), Eh.applyMatrix4(r), e.ray.intersectsSphere(Eh) !== !1))
            for (let s = 0; s < i; s++) {
               this.getMatrixAt(s, ec), BR.multiplyMatrices(r, ec), Mh.matrixWorld = BR, Mh.raycast(e, hg);
               for (let o = 0, a = hg.length; o < a; o++) {
                  const l = hg[o];
                  l.instanceId = s, l.object = this, n.push(l)
               }
               hg.length = 0
            }
      }
      setColorAt(e, n) {
         this.instanceColor === null && (this.instanceColor = new mf(new Float32Array(this.instanceMatrix.count * 3), 3)), n.toArray(this.instanceColor.array, e * 3)
      }
      setMatrixAt(e, n) {
         n.toArray(this.instanceMatrix.array, e * 16)
      }
      updateMorphTargets() {}
      dispose() {
         this.dispatchEvent({
            type: "dispose"
         })
      }
   }
   class Rr extends Jn {
      constructor(e) {
         super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ke(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
      }
   }
   const LR = new U,
      DR = new U,
      FR = new yt,
      b_ = new Cf,
      dg = new Ci;
   class Fo extends Wt {
      constructor(e = new Tt, n = new Rr) {
         super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets()
      }
      copy(e, n) {
         return super.copy(e, n), this.material = e.material, this.geometry = e.geometry, this
      }
      computeLineDistances() {
         const e = this.geometry;
         if (e.index === null) {
            const n = e.attributes.position,
               r = [0];
            for (let i = 1, s = n.count; i < s; i++) LR.fromBufferAttribute(n, i - 1), DR.fromBufferAttribute(n, i), r[i] = r[i - 1], r[i] += LR.distanceTo(DR);
            e.setAttribute("lineDistance", new nt(r, 1))
         } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
         return this
      }
      raycast(e, n) {
         const r = this.geometry,
            i = this.matrixWorld,
            s = e.params.Line.threshold,
            o = r.drawRange;
         if (r.boundingSphere === null && r.computeBoundingSphere(), dg.copy(r.boundingSphere), dg.applyMatrix4(i), dg.radius += s, e.ray.intersectsSphere(dg) === !1) return;
         FR.copy(i).invert(), b_.copy(e.ray).applyMatrix4(FR);
         const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            u = new U,
            h = new U,
            d = new U,
            p = new U,
            m = this.isLineSegments ? 2 : 1,
            v = r.index,
            x = r.attributes.position;
         if (v !== null) {
            const g = Math.max(0, o.start),
               S = Math.min(v.count, o.start + o.count);
            for (let A = g, E = S - 1; A < E; A += m) {
               const C = v.getX(A),
                  R = v.getX(A + 1);
               if (u.fromBufferAttribute(x, C), h.fromBufferAttribute(x, R), b_.distanceSqToSegment(u, h, p, d) > l) continue;
               p.applyMatrix4(this.matrixWorld);
               const D = e.ray.origin.distanceTo(p);
               D < e.near || D > e.far || n.push({
                  distance: D,
                  point: d.clone().applyMatrix4(this.matrixWorld),
                  index: A,
                  face: null,
                  faceIndex: null,
                  object: this
               })
            }
         } else {
            const g = Math.max(0, o.start),
               S = Math.min(x.count, o.start + o.count);
            for (let A = g, E = S - 1; A < E; A += m) {
               if (u.fromBufferAttribute(x, A), h.fromBufferAttribute(x, A + 1), b_.distanceSqToSegment(u, h, p, d) > l) continue;
               p.applyMatrix4(this.matrixWorld);
               const R = e.ray.origin.distanceTo(p);
               R < e.near || R > e.far || n.push({
                  distance: R,
                  point: d.clone().applyMatrix4(this.matrixWorld),
                  index: A,
                  face: null,
                  faceIndex: null,
                  object: this
               })
            }
         }
      }
      updateMorphTargets() {
         const n = this.geometry.morphAttributes,
            r = Object.keys(n);
         if (r.length > 0) {
            const i = n[r[0]];
            if (i !== void 0) {
               this.morphTargetInfluences = [], this.morphTargetDictionary = {};
               for (let s = 0, o = i.length; s < o; s++) {
                  const a = i[s].name || String(s);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
               }
            }
         }
      }
   }
   const OR = new U,
      NR = new U;
   class xs extends Fo {
      constructor(e, n) {
         super(e, n), this.isLineSegments = !0, this.type = "LineSegments"
      }
      computeLineDistances() {
         const e = this.geometry;
         if (e.index === null) {
            const n = e.attributes.position,
               r = [];
            for (let i = 0, s = n.count; i < s; i += 2) OR.fromBufferAttribute(n, i), NR.fromBufferAttribute(n, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + OR.distanceTo(NR);
            e.setAttribute("lineDistance", new nt(r, 1))
         } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
         return this
      }
   }
   class aE extends Fo {
      constructor(e, n) {
         super(e, n), this.isLineLoop = !0, this.type = "LineLoop"
      }
   }
   class Nv extends Jn {
      constructor(e) {
         super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ke(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
      }
   }
   const UR = new yt,
      YA = new Cf,
      pg = new Ci,
      mg = new U;
   class lE extends Wt {
      constructor(e = new Tt, n = new Nv) {
         super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = n, this.updateMorphTargets()
      }
      copy(e, n) {
         return super.copy(e, n), this.material = e.material, this.geometry = e.geometry, this
      }
      raycast(e, n) {
         const r = this.geometry,
            i = this.matrixWorld,
            s = e.params.Points.threshold,
            o = r.drawRange;
         if (r.boundingSphere === null && r.computeBoundingSphere(), pg.copy(r.boundingSphere), pg.applyMatrix4(i), pg.radius += s, e.ray.intersectsSphere(pg) === !1) return;
         UR.copy(i).invert(), YA.copy(e.ray).applyMatrix4(UR);
         const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            u = r.index,
            d = r.attributes.position;
         if (u !== null) {
            const p = Math.max(0, o.start),
               m = Math.min(u.count, o.start + o.count);
            for (let v = p, _ = m; v < _; v++) {
               const x = u.getX(v);
               mg.fromBufferAttribute(d, x), kR(mg, x, l, i, e, n, this)
            }
         } else {
            const p = Math.max(0, o.start),
               m = Math.min(d.count, o.start + o.count);
            for (let v = p, _ = m; v < _; v++) mg.fromBufferAttribute(d, v), kR(mg, v, l, i, e, n, this)
         }
      }
      updateMorphTargets() {
         const n = this.geometry.morphAttributes,
            r = Object.keys(n);
         if (r.length > 0) {
            const i = n[r[0]];
            if (i !== void 0) {
               this.morphTargetInfluences = [], this.morphTargetDictionary = {};
               for (let s = 0, o = i.length; s < o; s++) {
                  const a = i[s].name || String(s);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
               }
            }
         }
      }
   }

   function kR(t, e, n, r, i, s, o) {
      const a = YA.distanceSqToPoint(t);
      if (a < n) {
         const l = new U;
         YA.closestPointToPoint(t, l), l.applyMatrix4(r);
         const u = i.ray.origin.distanceTo(l);
         if (u < i.near || u > i.far) return;
         s.push({
            distance: u,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
         })
      }
   }
   class sW extends yn {
      constructor(e, n, r, i, s, o, a, l, u) {
         super(e, n, r, i, s, o, a, l, u), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : ln, this.magFilter = s !== void 0 ? s : ln, this.generateMipmaps = !1;
         const h = this;

         function d() {
            h.needsUpdate = !0, e.requestVideoFrameCallback(d)
         }
         "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d)
      }
      clone() {
         return new this.constructor(this.image).copy(this)
      }
      update() {
         const e = this.image;
         "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
      }
   }
   class oW extends yn {
      constructor(e, n) {
         super({
            width: e,
            height: n
         }), this.isFramebufferTexture = !0, this.magFilter = Fn, this.minFilter = Fn, this.generateMipmaps = !1, this.needsUpdate = !0
      }
   }
   class Uv extends yn {
      constructor(e, n, r, i, s, o, a, l, u, h, d, p) {
         super(null, o, a, l, u, h, i, s, d, p), this.isCompressedTexture = !0, this.image = {
            width: n,
            height: r
         }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
      }
   }
   class aW extends Uv {
      constructor(e, n, r, i, s, o) {
         super(e, n, r, s, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = hr
      }
   }
   class lW extends Uv {
      constructor(e, n, r) {
         super(void 0, e[0].width, e[0].height, n, r, Ks), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
      }
   }
   class uW extends yn {
      constructor(e, n, r, i, s, o, a, l, u) {
         super(e, n, r, i, s, o, a, l, u), this.isCanvasTexture = !0, this.needsUpdate = !0
      }
   }
   class _s {
      constructor() {
         this.type = "Curve", this.arcLengthDivisions = 200
      }
      getPoint() {
         return console.warn("THREE.Curve: .getPoint() not implemented."), null
      }
      getPointAt(e, n) {
         const r = this.getUtoTmapping(e);
         return this.getPoint(r, n)
      }
      getPoints(e = 5) {
         const n = [];
         for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
         return n
      }
      getSpacedPoints(e = 5) {
         const n = [];
         for (let r = 0; r <= e; r++) n.push(this.getPointAt(r / e));
         return n
      }
      getLength() {
         const e = this.getLengths();
         return e[e.length - 1]
      }
      getLengths(e = this.arcLengthDivisions) {
         if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
         this.needsUpdate = !1;
         const n = [];
         let r, i = this.getPoint(0),
            s = 0;
         n.push(0);
         for (let o = 1; o <= e; o++) r = this.getPoint(o / e), s += r.distanceTo(i), n.push(s), i = r;
         return this.cacheArcLengths = n, n
      }
      updateArcLengths() {
         this.needsUpdate = !0, this.getLengths()
      }
      getUtoTmapping(e, n) {
         const r = this.getLengths();
         let i = 0;
         const s = r.length;
         let o;
         n ? o = n : o = e * r[s - 1];
         let a = 0,
            l = s - 1,
            u;
         for (; a <= l;)
            if (i = Math.floor(a + (l - a) / 2), u = r[i] - o, u < 0) a = i + 1;
            else if (u > 0) l = i - 1;
         else {
            l = i;
            break
         }
         if (i = l, r[i] === o) return i / (s - 1);
         const h = r[i],
            p = r[i + 1] - h,
            m = (o - h) / p;
         return (i + m) / (s - 1)
      }
      getTangent(e, n) {
         let i = e - 1e-4,
            s = e + 1e-4;
         i < 0 && (i = 0), s > 1 && (s = 1);
         const o = this.getPoint(i),
            a = this.getPoint(s),
            l = n || (o.isVector2 ? new Se : new U);
         return l.copy(a).sub(o).normalize(), l
      }
      getTangentAt(e, n) {
         const r = this.getUtoTmapping(e);
         return this.getTangent(r, n)
      }
      computeFrenetFrames(e, n) {
         const r = new U,
            i = [],
            s = [],
            o = [],
            a = new U,
            l = new yt;
         for (let m = 0; m <= e; m++) {
            const v = m / e;
            i[m] = this.getTangentAt(v, new U)
         }
         s[0] = new U, o[0] = new U;
         let u = Number.MAX_VALUE;
         const h = Math.abs(i[0].x),
            d = Math.abs(i[0].y),
            p = Math.abs(i[0].z);
         h <= u && (u = h, r.set(1, 0, 0)), d <= u && (u = d, r.set(0, 1, 0)), p <= u && r.set(0, 0, 1), a.crossVectors(i[0], r).normalize(), s[0].crossVectors(i[0], a), o[0].crossVectors(i[0], s[0]);
         for (let m = 1; m <= e; m++) {
            if (s[m] = s[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(i[m - 1], i[m]), a.length() > Number.EPSILON) {
               a.normalize();
               const v = Math.acos(On(i[m - 1].dot(i[m]), -1, 1));
               s[m].applyMatrix4(l.makeRotationAxis(a, v))
            }
            o[m].crossVectors(i[m], s[m])
         }
         if (n === !0) {
            let m = Math.acos(On(s[0].dot(s[e]), -1, 1));
            m /= e, i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
            for (let v = 1; v <= e; v++) s[v].applyMatrix4(l.makeRotationAxis(i[v], m * v)), o[v].crossVectors(i[v], s[v])
         }
         return {
            tangents: i,
            normals: s,
            binormals: o
         }
      }
      clone() {
         return new this.constructor().copy(this)
      }
      copy(e) {
         return this.arcLengthDivisions = e.arcLengthDivisions, this
      }
      toJSON() {
         const e = {
            metadata: {
               version: 4.6,
               type: "Curve",
               generator: "Curve.toJSON"
            }
         };
         return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
      }
      fromJSON(e) {
         return this.arcLengthDivisions = e.arcLengthDivisions, this
      }
   }
   class kv extends _s {
      constructor(e = 0, n = 0, r = 1, i = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
         super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = r, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
      }
      getPoint(e, n) {
         const r = n || new Se,
            i = Math.PI * 2;
         let s = this.aEndAngle - this.aStartAngle;
         const o = Math.abs(s) < Number.EPSILON;
         for (; s < 0;) s += i;
         for (; s > i;) s -= i;
         s < Number.EPSILON && (o ? s = 0 : s = i), this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
         const a = this.aStartAngle + e * s;
         let l = this.aX + this.xRadius * Math.cos(a),
            u = this.aY + this.yRadius * Math.sin(a);
         if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation),
               d = Math.sin(this.aRotation),
               p = l - this.aX,
               m = u - this.aY;
            l = p * h - m * d + this.aX, u = p * d + m * h + this.aY
         }
         return r.set(l, u)
      }
      copy(e) {
         return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
      }
      toJSON() {
         const e = super.toJSON();
         return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
      }
   }
   class IF extends kv {
      constructor(e, n, r, i, s, o) {
         super(e, n, r, r, i, s, o), this.isArcCurve = !0, this.type = "ArcCurve"
      }
   }

   function uE() {
      let t = 0,
         e = 0,
         n = 0,
         r = 0;

      function i(s, o, a, l) {
         t = s, e = a, n = -3 * s + 3 * o - 2 * a - l, r = 2 * s - 2 * o + a + l
      }
      return {
         initCatmullRom: function (s, o, a, l, u) {
            i(o, a, u * (a - s), u * (l - o))
         },
         initNonuniformCatmullRom: function (s, o, a, l, u, h, d) {
            let p = (o - s) / u - (a - s) / (u + h) + (a - o) / h,
               m = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
            p *= h, m *= h, i(o, a, p, m)
         },
         calc: function (s) {
            const o = s * s,
               a = o * s;
            return t + e * s + n * o + r * a
         }
      }
   }
   const gg = new U,
      C_ = new uE,
      T_ = new uE,
      R_ = new uE;
   class LF extends _s {
      constructor(e = [], n = !1, r = "centripetal", i = .5) {
         super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = r, this.tension = i
      }
      getPoint(e, n = new U) {
         const r = n,
            i = this.points,
            s = i.length,
            o = (s - (this.closed ? 0 : 1)) * e;
         let a = Math.floor(o),
            l = o - a;
         this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
         let u, h;
         this.closed || a > 0 ? u = i[(a - 1) % s] : (gg.subVectors(i[0], i[1]).add(i[0]), u = gg);
         const d = i[a % s],
            p = i[(a + 1) % s];
         if (this.closed || a + 2 < s ? h = i[(a + 2) % s] : (gg.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), h = gg), this.curveType === "centripetal" || this.curveType === "chordal") {
            const m = this.curveType === "chordal" ? .5 : .25;
            let v = Math.pow(u.distanceToSquared(d), m),
               _ = Math.pow(d.distanceToSquared(p), m),
               x = Math.pow(p.distanceToSquared(h), m);
            _ < 1e-4 && (_ = 1), v < 1e-4 && (v = _), x < 1e-4 && (x = _), C_.initNonuniformCatmullRom(u.x, d.x, p.x, h.x, v, _, x), T_.initNonuniformCatmullRom(u.y, d.y, p.y, h.y, v, _, x), R_.initNonuniformCatmullRom(u.z, d.z, p.z, h.z, v, _, x)
         } else this.curveType === "catmullrom" && (C_.initCatmullRom(u.x, d.x, p.x, h.x, this.tension), T_.initCatmullRom(u.y, d.y, p.y, h.y, this.tension), R_.initCatmullRom(u.z, d.z, p.z, h.z, this.tension));
         return r.set(C_.calc(l), T_.calc(l), R_.calc(l)), r
      }
      copy(e) {
         super.copy(e), this.points = [];
         for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(i.clone())
         }
         return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
      }
      toJSON() {
         const e = super.toJSON();
         e.points = [];
         for (let n = 0, r = this.points.length; n < r; n++) {
            const i = this.points[n];
            e.points.push(i.toArray())
         }
         return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
      }
      fromJSON(e) {
         super.fromJSON(e), this.points = [];
         for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(new U().fromArray(i))
         }
         return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
      }
   }

   function HR(t, e, n, r, i) {
      const s = (r - e) * .5,
         o = (i - n) * .5,
         a = t * t,
         l = t * a;
      return (2 * n - 2 * r + s + o) * l + (-3 * n + 3 * r - 2 * s - o) * a + s * t + n
   }

   function cW(t, e) {
      const n = 1 - t;
      return n * n * e
   }

   function fW(t, e) {
      return 2 * (1 - t) * t * e
   }

   function hW(t, e) {
      return t * t * e
   }

   function ud(t, e, n, r) {
      return cW(t, e) + fW(t, n) + hW(t, r)
   }

   function dW(t, e) {
      const n = 1 - t;
      return n * n * n * e
   }

   function pW(t, e) {
      const n = 1 - t;
      return 3 * n * n * t * e
   }

   function mW(t, e) {
      return 3 * (1 - t) * t * t * e
   }

   function gW(t, e) {
      return t * t * t * e
   }

   function cd(t, e, n, r, i) {
      return dW(t, e) + pW(t, n) + mW(t, r) + gW(t, i)
   }
   class cE extends _s {
      constructor(e = new Se, n = new Se, r = new Se, i = new Se) {
         super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = i
      }
      getPoint(e, n = new Se) {
         const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
         return r.set(cd(e, i.x, s.x, o.x, a.x), cd(e, i.y, s.y, o.y, a.y)), r
      }
      copy(e) {
         return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
      }
   }
   class DF extends _s {
      constructor(e = new U, n = new U, r = new U, i = new U) {
         super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = i
      }
      getPoint(e, n = new U) {
         const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
         return r.set(cd(e, i.x, s.x, o.x, a.x), cd(e, i.y, s.y, o.y, a.y), cd(e, i.z, s.z, o.z, a.z)), r
      }
      copy(e) {
         return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
      }
   }
   class Hv extends _s {
      constructor(e = new Se, n = new Se) {
         super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n
      }
      getPoint(e, n = new Se) {
         const r = n;
         return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r
      }
      getPointAt(e, n) {
         return this.getPoint(e, n)
      }
      getTangent(e, n = new Se) {
         return n.subVectors(this.v2, this.v1).normalize()
      }
      getTangentAt(e, n) {
         return this.getTangent(e, n)
      }
      copy(e) {
         return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
      }
   }
   class FF extends _s {
      constructor(e = new U, n = new U) {
         super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n
      }
      getPoint(e, n = new U) {
         const r = n;
         return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r
      }
      getPointAt(e, n) {
         return this.getPoint(e, n)
      }
      getTangent(e, n = new U) {
         return n.subVectors(this.v2, this.v1).normalize()
      }
      getTangentAt(e, n) {
         return this.getTangent(e, n)
      }
      copy(e) {
         return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
      }
   }
   class fE extends _s {
      constructor(e = new Se, n = new Se, r = new Se) {
         super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r
      }
      getPoint(e, n = new Se) {
         const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2;
         return r.set(ud(e, i.x, s.x, o.x), ud(e, i.y, s.y, o.y)), r
      }
      copy(e) {
         return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
      }
   }
   class hE extends _s {
      constructor(e = new U, n = new U, r = new U) {
         super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r
      }
      getPoint(e, n = new U) {
         const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2;
         return r.set(ud(e, i.x, s.x, o.x), ud(e, i.y, s.y, o.y), ud(e, i.z, s.z, o.z)), r
      }
      copy(e) {
         return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
      }
   }
   class dE extends _s {
      constructor(e = []) {
         super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
      }
      getPoint(e, n = new Se) {
         const r = n,
            i = this.points,
            s = (i.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            l = i[o === 0 ? o : o - 1],
            u = i[o],
            h = i[o > i.length - 2 ? i.length - 1 : o + 1],
            d = i[o > i.length - 3 ? i.length - 1 : o + 2];
         return r.set(HR(a, l.x, u.x, h.x, d.x), HR(a, l.y, u.y, h.y, d.y)), r
      }
      copy(e) {
         super.copy(e), this.points = [];
         for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(i.clone())
         }
         return this
      }
      toJSON() {
         const e = super.toJSON();
         e.points = [];
         for (let n = 0, r = this.points.length; n < r; n++) {
            const i = this.points[n];
            e.points.push(i.toArray())
         }
         return e
      }
      fromJSON(e) {
         super.fromJSON(e), this.points = [];
         for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(new Se().fromArray(i))
         }
         return this
      }
   }
   var pE = Object.freeze({
      __proto__: null,
      ArcCurve: IF,
      CatmullRomCurve3: LF,
      CubicBezierCurve: cE,
      CubicBezierCurve3: DF,
      EllipseCurve: kv,
      LineCurve: Hv,
      LineCurve3: FF,
      QuadraticBezierCurve: fE,
      QuadraticBezierCurve3: hE,
      SplineCurve: dE
   });
   class OF extends _s {
      constructor() {
         super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
      }
      add(e) {
         this.curves.push(e)
      }
      closePath() {
         const e = this.curves[0].getPoint(0),
            n = this.curves[this.curves.length - 1].getPoint(1);
         e.equals(n) || this.curves.push(new Hv(n, e))
      }
      getPoint(e, n) {
         const r = e * this.getLength(),
            i = this.getCurveLengths();
         let s = 0;
         for (; s < i.length;) {
            if (i[s] >= r) {
               const o = i[s] - r,
                  a = this.curves[s],
                  l = a.getLength(),
                  u = l === 0 ? 0 : 1 - o / l;
               return a.getPointAt(u, n)
            }
            s++
         }
         return null
      }
      getLength() {
         const e = this.getCurveLengths();
         return e[e.length - 1]
      }
      updateArcLengths() {
         this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
      }
      getCurveLengths() {
         if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
         const e = [];
         let n = 0;
         for (let r = 0, i = this.curves.length; r < i; r++) n += this.curves[r].getLength(), e.push(n);
         return this.cacheLengths = e, e
      }
      getSpacedPoints(e = 40) {
         const n = [];
         for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
         return this.autoClose && n.push(n[0]), n
      }
      getPoints(e = 12) {
         const n = [];
         let r;
         for (let i = 0, s = this.curves; i < s.length; i++) {
            const o = s[i],
               a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
               l = o.getPoints(a);
            for (let u = 0; u < l.length; u++) {
               const h = l[u];
               r && r.equals(h) || (n.push(h), r = h)
            }
         }
         return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
      }
      copy(e) {
         super.copy(e), this.curves = [];
         for (let n = 0, r = e.curves.length; n < r; n++) {
            const i = e.curves[n];
            this.curves.push(i.clone())
         }
         return this.autoClose = e.autoClose, this
      }
      toJSON() {
         const e = super.toJSON();
         e.autoClose = this.autoClose, e.curves = [];
         for (let n = 0, r = this.curves.length; n < r; n++) {
            const i = this.curves[n];
            e.curves.push(i.toJSON())
         }
         return e
      }
      fromJSON(e) {
         super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
         for (let n = 0, r = e.curves.length; n < r; n++) {
            const i = e.curves[n];
            this.curves.push(new pE[i.type]().fromJSON(i))
         }
         return this
      }
   }
   class zd extends OF {
      constructor(e) {
         super(), this.type = "Path", this.currentPoint = new Se, e && this.setFromPoints(e)
      }
      setFromPoints(e) {
         this.moveTo(e[0].x, e[0].y);
         for (let n = 1, r = e.length; n < r; n++) this.lineTo(e[n].x, e[n].y);
         return this
      }
      moveTo(e, n) {
         return this.currentPoint.set(e, n), this
      }
      lineTo(e, n) {
         const r = new Hv(this.currentPoint.clone(), new Se(e, n));
         return this.curves.push(r), this.currentPoint.set(e, n), this
      }
      quadraticCurveTo(e, n, r, i) {
         const s = new fE(this.currentPoint.clone(), new Se(e, n), new Se(r, i));
         return this.curves.push(s), this.currentPoint.set(r, i), this
      }
      bezierCurveTo(e, n, r, i, s, o) {
         const a = new cE(this.currentPoint.clone(), new Se(e, n), new Se(r, i), new Se(s, o));
         return this.curves.push(a), this.currentPoint.set(s, o), this
      }
      splineThru(e) {
         const n = [this.currentPoint.clone()].concat(e),
            r = new dE(n);
         return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this
      }
      arc(e, n, r, i, s, o) {
         const a = this.currentPoint.x,
            l = this.currentPoint.y;
         return this.absarc(e + a, n + l, r, i, s, o), this
      }
      absarc(e, n, r, i, s, o) {
         return this.absellipse(e, n, r, r, i, s, o), this
      }
      ellipse(e, n, r, i, s, o, a, l) {
         const u = this.currentPoint.x,
            h = this.currentPoint.y;
         return this.absellipse(e + u, n + h, r, i, s, o, a, l), this
      }
      absellipse(e, n, r, i, s, o, a, l) {
         const u = new kv(e, n, r, i, s, o, a, l);
         if (this.curves.length > 0) {
            const d = u.getPoint(0);
            d.equals(this.currentPoint) || this.lineTo(d.x, d.y)
         }
         this.curves.push(u);
         const h = u.getPoint(1);
         return this.currentPoint.copy(h), this
      }
      copy(e) {
         return super.copy(e), this.currentPoint.copy(e.currentPoint), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.currentPoint = this.currentPoint.toArray(), e
      }
      fromJSON(e) {
         return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
      }
   }
   class fp extends Tt {
      constructor(e = [new Se(0, -.5), new Se(.5, 0), new Se(0, .5)], n = 12, r = 0, i = Math.PI * 2) {
         super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: n,
            phiStart: r,
            phiLength: i
         }, n = Math.floor(n), i = On(i, 0, Math.PI * 2);
         const s = [],
            o = [],
            a = [],
            l = [],
            u = [],
            h = 1 / n,
            d = new U,
            p = new Se,
            m = new U,
            v = new U,
            _ = new U;
         let x = 0,
            g = 0;
         for (let S = 0; S <= e.length - 1; S++) switch (S) {
            case 0:
               x = e[S + 1].x - e[S].x, g = e[S + 1].y - e[S].y, m.x = g * 1, m.y = -x, m.z = g * 0, _.copy(m), m.normalize(), l.push(m.x, m.y, m.z);
               break;
            case e.length - 1:
               l.push(_.x, _.y, _.z);
               break;
            default:
               x = e[S + 1].x - e[S].x, g = e[S + 1].y - e[S].y, m.x = g * 1, m.y = -x, m.z = g * 0, v.copy(m), m.x += _.x, m.y += _.y, m.z += _.z, m.normalize(), l.push(m.x, m.y, m.z), _.copy(v)
         }
         for (let S = 0; S <= n; S++) {
            const A = r + S * h * i,
               E = Math.sin(A),
               C = Math.cos(A);
            for (let R = 0; R <= e.length - 1; R++) {
               d.x = e[R].x * E, d.y = e[R].y, d.z = e[R].x * C, o.push(d.x, d.y, d.z), p.x = S / n, p.y = R / (e.length - 1), a.push(p.x, p.y);
               const B = l[3 * R + 0] * E,
                  D = l[3 * R + 1],
                  T = l[3 * R + 0] * C;
               u.push(B, D, T)
            }
         }
         for (let S = 0; S < n; S++)
            for (let A = 0; A < e.length - 1; A++) {
               const E = A + S * e.length,
                  C = E,
                  R = E + e.length,
                  B = E + e.length + 1,
                  D = E + 1;
               s.push(C, R, D), s.push(B, D, R)
            }
         this.setIndex(s), this.setAttribute("position", new nt(o, 3)), this.setAttribute("uv", new nt(a, 2)), this.setAttribute("normal", new nt(u, 3))
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new fp(e.points, e.segments, e.phiStart, e.phiLength)
      }
   }
   class Gv extends fp {
      constructor(e = 1, n = 1, r = 4, i = 8) {
         const s = new zd;
         s.absarc(0, -n / 2, e, Math.PI * 1.5, 0), s.absarc(0, n / 2, e, 0, Math.PI * .5), super(s.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = {
            radius: e,
            length: n,
            capSegments: r,
            radialSegments: i
         }
      }
      static fromJSON(e) {
         return new Gv(e.radius, e.length, e.capSegments, e.radialSegments)
      }
   }
   class zv extends Tt {
      constructor(e = 1, n = 32, r = 0, i = Math.PI * 2) {
         super(), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: n,
            thetaStart: r,
            thetaLength: i
         }, n = Math.max(3, n);
         const s = [],
            o = [],
            a = [],
            l = [],
            u = new U,
            h = new Se;
         o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5);
         for (let d = 0, p = 3; d <= n; d++, p += 3) {
            const m = r + d / n * i;
            u.x = e * Math.cos(m), u.y = e * Math.sin(m), o.push(u.x, u.y, u.z), a.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, l.push(h.x, h.y)
         }
         for (let d = 1; d <= n; d++) s.push(d, d + 1, 0);
         this.setIndex(s), this.setAttribute("position", new nt(o, 3)), this.setAttribute("normal", new nt(a, 3)), this.setAttribute("uv", new nt(l, 2))
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new zv(e.radius, e.segments, e.thetaStart, e.thetaLength)
      }
   }
   class Pf extends Tt {
      constructor(e = 1, n = 1, r = 1, i = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
         super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: n,
            height: r,
            radialSegments: i,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
         };
         const u = this;
         i = Math.floor(i), s = Math.floor(s);
         const h = [],
            d = [],
            p = [],
            m = [];
         let v = 0;
         const _ = [],
            x = r / 2;
         let g = 0;
         S(), o === !1 && (e > 0 && A(!0), n > 0 && A(!1)), this.setIndex(h), this.setAttribute("position", new nt(d, 3)), this.setAttribute("normal", new nt(p, 3)), this.setAttribute("uv", new nt(m, 2));

         function S() {
            const E = new U,
               C = new U;
            let R = 0;
            const B = (n - e) / r;
            for (let D = 0; D <= s; D++) {
               const T = [],
                  I = D / s,
                  N = I * (n - e) + e;
               for (let q = 0; q <= i; q++) {
                  const K = q / i,
                     Z = K * l + a,
                     te = Math.sin(Z),
                     se = Math.cos(Z);
                  C.x = N * te, C.y = -I * r + x, C.z = N * se, d.push(C.x, C.y, C.z), E.set(te, B, se).normalize(), p.push(E.x, E.y, E.z), m.push(K, 1 - I), T.push(v++)
               }
               _.push(T)
            }
            for (let D = 0; D < i; D++)
               for (let T = 0; T < s; T++) {
                  const I = _[T][D],
                     N = _[T + 1][D],
                     q = _[T + 1][D + 1],
                     K = _[T][D + 1];
                  h.push(I, N, K), h.push(N, q, K), R += 6
               }
            u.addGroup(g, R, 0), g += R
         }

         function A(E) {
            const C = v,
               R = new Se,
               B = new U;
            let D = 0;
            const T = E === !0 ? e : n,
               I = E === !0 ? 1 : -1;
            for (let q = 1; q <= i; q++) d.push(0, x * I, 0), p.push(0, I, 0), m.push(.5, .5), v++;
            const N = v;
            for (let q = 0; q <= i; q++) {
               const Z = q / i * l + a,
                  te = Math.cos(Z),
                  se = Math.sin(Z);
               B.x = T * se, B.y = x * I, B.z = T * te, d.push(B.x, B.y, B.z), p.push(0, I, 0), R.x = te * .5 + .5, R.y = se * .5 * I + .5, m.push(R.x, R.y), v++
            }
            for (let q = 0; q < i; q++) {
               const K = C + q,
                  Z = N + q;
               E === !0 ? h.push(Z, Z + 1, K) : h.push(Z + 1, Z, K), D += 3
            }
            u.addGroup(g, D, E === !0 ? 1 : 2), g += D
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new Pf(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
      }
   }
   class Vv extends Pf {
      constructor(e = 1, n = 1, r = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
         super(0, e, n, r, i, s, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
         }
      }
      static fromJSON(e) {
         return new Vv(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
      }
   }
   class Ja extends Tt {
      constructor(e = [], n = [], r = 1, i = 0) {
         super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: n,
            radius: r,
            detail: i
         };
         const s = [],
            o = [];
         a(i), u(r), h(), this.setAttribute("position", new nt(s, 3)), this.setAttribute("normal", new nt(s.slice(), 3)), this.setAttribute("uv", new nt(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();

         function a(S) {
            const A = new U,
               E = new U,
               C = new U;
            for (let R = 0; R < n.length; R += 3) m(n[R + 0], A), m(n[R + 1], E), m(n[R + 2], C), l(A, E, C, S)
         }

         function l(S, A, E, C) {
            const R = C + 1,
               B = [];
            for (let D = 0; D <= R; D++) {
               B[D] = [];
               const T = S.clone().lerp(E, D / R),
                  I = A.clone().lerp(E, D / R),
                  N = R - D;
               for (let q = 0; q <= N; q++) q === 0 && D === R ? B[D][q] = T : B[D][q] = T.clone().lerp(I, q / N)
            }
            for (let D = 0; D < R; D++)
               for (let T = 0; T < 2 * (R - D) - 1; T++) {
                  const I = Math.floor(T / 2);
                  T % 2 === 0 ? (p(B[D][I + 1]), p(B[D + 1][I]), p(B[D][I])) : (p(B[D][I + 1]), p(B[D + 1][I + 1]), p(B[D + 1][I]))
               }
         }

         function u(S) {
            const A = new U;
            for (let E = 0; E < s.length; E += 3) A.x = s[E + 0], A.y = s[E + 1], A.z = s[E + 2], A.normalize().multiplyScalar(S), s[E + 0] = A.x, s[E + 1] = A.y, s[E + 2] = A.z
         }

         function h() {
            const S = new U;
            for (let A = 0; A < s.length; A += 3) {
               S.x = s[A + 0], S.y = s[A + 1], S.z = s[A + 2];
               const E = x(S) / 2 / Math.PI + .5,
                  C = g(S) / Math.PI + .5;
               o.push(E, 1 - C)
            }
            v(), d()
         }

         function d() {
            for (let S = 0; S < o.length; S += 6) {
               const A = o[S + 0],
                  E = o[S + 2],
                  C = o[S + 4],
                  R = Math.max(A, E, C),
                  B = Math.min(A, E, C);
               R > .9 && B < .1 && (A < .2 && (o[S + 0] += 1), E < .2 && (o[S + 2] += 1), C < .2 && (o[S + 4] += 1))
            }
         }

         function p(S) {
            s.push(S.x, S.y, S.z)
         }

         function m(S, A) {
            const E = S * 3;
            A.x = e[E + 0], A.y = e[E + 1], A.z = e[E + 2]
         }

         function v() {
            const S = new U,
               A = new U,
               E = new U,
               C = new U,
               R = new Se,
               B = new Se,
               D = new Se;
            for (let T = 0, I = 0; T < s.length; T += 9, I += 6) {
               S.set(s[T + 0], s[T + 1], s[T + 2]), A.set(s[T + 3], s[T + 4], s[T + 5]), E.set(s[T + 6], s[T + 7], s[T + 8]), R.set(o[I + 0], o[I + 1]), B.set(o[I + 2], o[I + 3]), D.set(o[I + 4], o[I + 5]), C.copy(S).add(A).add(E).divideScalar(3);
               const N = x(C);
               _(R, I + 0, S, N), _(B, I + 2, A, N), _(D, I + 4, E, N)
            }
         }

         function _(S, A, E, C) {
            C < 0 && S.x === 1 && (o[A] = S.x - 1), E.x === 0 && E.z === 0 && (o[A] = C / 2 / Math.PI + .5)
         }

         function x(S) {
            return Math.atan2(S.z, -S.x)
         }

         function g(S) {
            return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z))
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new Ja(e.vertices, e.indices, e.radius, e.details)
      }
   }
   class Wv extends Ja {
      constructor(e = 1, n = 0) {
         const r = (1 + Math.sqrt(5)) / 2,
            i = 1 / r,
            s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i],
            o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
         super(s, o, e, n), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: n
         }
      }
      static fromJSON(e) {
         return new Wv(e.radius, e.detail)
      }
   }
   const vg = new U,
      yg = new U,
      P_ = new U,
      xg = new Yr;
   class NF extends Tt {
      constructor(e = null, n = 1) {
         if (super(), this.type = "EdgesGeometry", this.parameters = {
               geometry: e,
               thresholdAngle: n
            }, e !== null) {
            const i = Math.pow(10, 4),
               s = Math.cos(Gl * n),
               o = e.getIndex(),
               a = e.getAttribute("position"),
               l = o ? o.count : a.count,
               u = [0, 0, 0],
               h = ["a", "b", "c"],
               d = new Array(3),
               p = {},
               m = [];
            for (let v = 0; v < l; v += 3) {
               o ? (u[0] = o.getX(v), u[1] = o.getX(v + 1), u[2] = o.getX(v + 2)) : (u[0] = v, u[1] = v + 1, u[2] = v + 2);
               const {
                  a: _,
                  b: x,
                  c: g
               } = xg;
               if (_.fromBufferAttribute(a, u[0]), x.fromBufferAttribute(a, u[1]), g.fromBufferAttribute(a, u[2]), xg.getNormal(P_), d[0] = `${Math.round(_.x*i)},${Math.round(_.y*i)},${Math.round(_.z*i)}`, d[1] = `${Math.round(x.x*i)},${Math.round(x.y*i)},${Math.round(x.z*i)}`, d[2] = `${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
                  for (let S = 0; S < 3; S++) {
                     const A = (S + 1) % 3,
                        E = d[S],
                        C = d[A],
                        R = xg[h[S]],
                        B = xg[h[A]],
                        D = `${E}_${C}`,
                        T = `${C}_${E}`;
                     T in p && p[T] ? (P_.dot(p[T].normal) <= s && (m.push(R.x, R.y, R.z), m.push(B.x, B.y, B.z)), p[T] = null) : D in p || (p[D] = {
                        index0: u[S],
                        index1: u[A],
                        normal: P_.clone()
                     })
                  }
            }
            for (const v in p)
               if (p[v]) {
                  const {
                     index0: _,
                     index1: x
                  } = p[v];
                  vg.fromBufferAttribute(a, _), yg.fromBufferAttribute(a, x), m.push(vg.x, vg.y, vg.z), m.push(yg.x, yg.y, yg.z)
               } this.setAttribute("position", new nt(m, 3))
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
   }
   class Vl extends zd {
      constructor(e) {
         super(e), this.uuid = xi(), this.type = "Shape", this.holes = []
      }
      getPointsHoles(e) {
         const n = [];
         for (let r = 0, i = this.holes.length; r < i; r++) n[r] = this.holes[r].getPoints(e);
         return n
      }
      extractPoints(e) {
         return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
         }
      }
      copy(e) {
         super.copy(e), this.holes = [];
         for (let n = 0, r = e.holes.length; n < r; n++) {
            const i = e.holes[n];
            this.holes.push(i.clone())
         }
         return this
      }
      toJSON() {
         const e = super.toJSON();
         e.uuid = this.uuid, e.holes = [];
         for (let n = 0, r = this.holes.length; n < r; n++) {
            const i = this.holes[n];
            e.holes.push(i.toJSON())
         }
         return e
      }
      fromJSON(e) {
         super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
         for (let n = 0, r = e.holes.length; n < r; n++) {
            const i = e.holes[n];
            this.holes.push(new zd().fromJSON(i))
         }
         return this
      }
   }
   const vW = {
      triangulate: function (t, e, n = 2) {
         const r = e && e.length,
            i = r ? e[0] * n : t.length;
         let s = UF(t, 0, i, n, !0);
         const o = [];
         if (!s || s.next === s.prev) return o;
         let a, l, u, h, d, p, m;
         if (r && (s = SW(t, e, s, n)), t.length > 80 * n) {
            a = u = t[0], l = h = t[1];
            for (let v = n; v < i; v += n) d = t[v], p = t[v + 1], d < a && (a = d), p < l && (l = p), d > u && (u = d), p > h && (h = p);
            m = Math.max(u - a, h - l), m = m !== 0 ? 32767 / m : 0
         }
         return Vd(s, o, n, a, l, m, 0), o
      }
   };

   function UF(t, e, n, r, i) {
      let s, o;
      if (i === LW(t, e, n, r) > 0)
         for (s = e; s < n; s += r) o = GR(s, t[s], t[s + 1], o);
      else
         for (s = n - r; s >= e; s -= r) o = GR(s, t[s], t[s + 1], o);
      return o && jv(o, o.next) && (jd(o), o = o.next), o
   }

   function Ql(t, e) {
      if (!t) return t;
      e || (e = t);
      let n = t,
         r;
      do
         if (r = !1, !n.steiner && (jv(n, n.next) || Tn(n.prev, n, n.next) === 0)) {
            if (jd(n), n = e = n.prev, n === n.next) break;
            r = !0
         } else n = n.next; while (r || n !== e);
      return e
   }

   function Vd(t, e, n, r, i, s, o) {
      if (!t) return;
      !o && s && CW(t, r, i, s);
      let a = t,
         l, u;
      for (; t.prev !== t.next;) {
         if (l = t.prev, u = t.next, s ? xW(t, r, i, s) : yW(t)) {
            e.push(l.i / n | 0), e.push(t.i / n | 0), e.push(u.i / n | 0), jd(t), t = u.next, a = u.next;
            continue
         }
         if (t = u, t === a) {
            o ? o === 1 ? (t = _W(Ql(t), e, n), Vd(t, e, n, r, i, s, 2)) : o === 2 && AW(t, e, n, r, i, s) : Vd(Ql(t), e, n, r, i, s, 1);
            break
         }
      }
   }

   function yW(t) {
      const e = t.prev,
         n = t,
         r = t.next;
      if (Tn(e, n, r) >= 0) return !1;
      const i = e.x,
         s = n.x,
         o = r.x,
         a = e.y,
         l = n.y,
         u = r.y,
         h = i < s ? i < o ? i : o : s < o ? s : o,
         d = a < l ? a < u ? a : u : l < u ? l : u,
         p = i > s ? i > o ? i : o : s > o ? s : o,
         m = a > l ? a > u ? a : u : l > u ? l : u;
      let v = r.next;
      for (; v !== e;) {
         if (v.x >= h && v.x <= p && v.y >= d && v.y <= m && Uc(i, a, s, l, o, u, v.x, v.y) && Tn(v.prev, v, v.next) >= 0) return !1;
         v = v.next
      }
      return !0
   }

   function xW(t, e, n, r) {
      const i = t.prev,
         s = t,
         o = t.next;
      if (Tn(i, s, o) >= 0) return !1;
      const a = i.x,
         l = s.x,
         u = o.x,
         h = i.y,
         d = s.y,
         p = o.y,
         m = a < l ? a < u ? a : u : l < u ? l : u,
         v = h < d ? h < p ? h : p : d < p ? d : p,
         _ = a > l ? a > u ? a : u : l > u ? l : u,
         x = h > d ? h > p ? h : p : d > p ? d : p,
         g = QA(m, v, e, n, r),
         S = QA(_, x, e, n, r);
      let A = t.prevZ,
         E = t.nextZ;
      for (; A && A.z >= g && E && E.z <= S;) {
         if (A.x >= m && A.x <= _ && A.y >= v && A.y <= x && A !== i && A !== o && Uc(a, h, l, d, u, p, A.x, A.y) && Tn(A.prev, A, A.next) >= 0 || (A = A.prevZ, E.x >= m && E.x <= _ && E.y >= v && E.y <= x && E !== i && E !== o && Uc(a, h, l, d, u, p, E.x, E.y) && Tn(E.prev, E, E.next) >= 0)) return !1;
         E = E.nextZ
      }
      for (; A && A.z >= g;) {
         if (A.x >= m && A.x <= _ && A.y >= v && A.y <= x && A !== i && A !== o && Uc(a, h, l, d, u, p, A.x, A.y) && Tn(A.prev, A, A.next) >= 0) return !1;
         A = A.prevZ
      }
      for (; E && E.z <= S;) {
         if (E.x >= m && E.x <= _ && E.y >= v && E.y <= x && E !== i && E !== o && Uc(a, h, l, d, u, p, E.x, E.y) && Tn(E.prev, E, E.next) >= 0) return !1;
         E = E.nextZ
      }
      return !0
   }

   function _W(t, e, n) {
      let r = t;
      do {
         const i = r.prev,
            s = r.next.next;
         !jv(i, s) && kF(i, r, r.next, s) && Wd(i, s) && Wd(s, i) && (e.push(i.i / n | 0), e.push(r.i / n | 0), e.push(s.i / n | 0), jd(r), jd(r.next), r = t = s), r = r.next
      } while (r !== t);
      return Ql(r)
   }

   function AW(t, e, n, r, i, s) {
      let o = t;
      do {
         let a = o.next.next;
         for (; a !== o.prev;) {
            if (o.i !== a.i && PW(o, a)) {
               let l = HF(o, a);
               o = Ql(o, o.next), l = Ql(l, l.next), Vd(o, e, n, r, i, s, 0), Vd(l, e, n, r, i, s, 0);
               return
            }
            a = a.next
         }
         o = o.next
      } while (o !== t)
   }

   function SW(t, e, n, r) {
      const i = [];
      let s, o, a, l, u;
      for (s = 0, o = e.length; s < o; s++) a = e[s] * r, l = s < o - 1 ? e[s + 1] * r : t.length, u = UF(t, a, l, r, !1), u === u.next && (u.steiner = !0), i.push(RW(u));
      for (i.sort(MW), s = 0; s < i.length; s++) n = EW(i[s], n);
      return n
   }

   function MW(t, e) {
      return t.x - e.x
   }

   function EW(t, e) {
      const n = wW(t, e);
      if (!n) return e;
      const r = HF(n, t);
      return Ql(r, r.next), Ql(n, n.next)
   }

   function wW(t, e) {
      let n = e,
         r = -1 / 0,
         i;
      const s = t.x,
         o = t.y;
      do {
         if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
            const p = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
            if (p <= s && p > r && (r = p, i = n.x < n.next.x ? n : n.next, p === s)) return i
         }
         n = n.next
      } while (n !== e);
      if (!i) return null;
      const a = i,
         l = i.x,
         u = i.y;
      let h = 1 / 0,
         d;
      n = i;
      do s >= n.x && n.x >= l && s !== n.x && Uc(o < u ? s : r, o, l, u, o < u ? r : s, o, n.x, n.y) && (d = Math.abs(o - n.y) / (s - n.x), Wd(n, t) && (d < h || d === h && (n.x > i.x || n.x === i.x && bW(i, n))) && (i = n, h = d)), n = n.next; while (n !== a);
      return i
   }

   function bW(t, e) {
      return Tn(t.prev, t, e.prev) < 0 && Tn(e.next, t, t.next) < 0
   }

   function CW(t, e, n, r) {
      let i = t;
      do i.z === 0 && (i.z = QA(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== t);
      i.prevZ.nextZ = null, i.prevZ = null, TW(i)
   }

   function TW(t) {
      let e, n, r, i, s, o, a, l, u = 1;
      do {
         for (n = t, t = null, s = null, o = 0; n;) {
            for (o++, r = n, a = 0, e = 0; e < u && (a++, r = r.nextZ, !!r); e++);
            for (l = u; a > 0 || l > 0 && r;) a !== 0 && (l === 0 || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;
            n = r
         }
         s.nextZ = null, u *= 2
      } while (o > 1);
      return t
   }

   function QA(t, e, n, r, i) {
      return t = (t - n) * i | 0, e = (e - r) * i | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1
   }

   function RW(t) {
      let e = t,
         n = t;
      do(e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next; while (e !== t);
      return n
   }

   function Uc(t, e, n, r, i, s, o, a) {
      return (i - o) * (e - a) >= (t - o) * (s - a) && (t - o) * (r - a) >= (n - o) * (e - a) && (n - o) * (s - a) >= (i - o) * (r - a)
   }

   function PW(t, e) {
      return t.next.i !== e.i && t.prev.i !== e.i && !BW(t, e) && (Wd(t, e) && Wd(e, t) && IW(t, e) && (Tn(t.prev, t, e.prev) || Tn(t, e.prev, e)) || jv(t, e) && Tn(t.prev, t, t.next) > 0 && Tn(e.prev, e, e.next) > 0)
   }

   function Tn(t, e, n) {
      return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
   }

   function jv(t, e) {
      return t.x === e.x && t.y === e.y
   }

   function kF(t, e, n, r) {
      const i = Ag(Tn(t, e, n)),
         s = Ag(Tn(t, e, r)),
         o = Ag(Tn(n, r, t)),
         a = Ag(Tn(n, r, e));
      return !!(i !== s && o !== a || i === 0 && _g(t, n, e) || s === 0 && _g(t, r, e) || o === 0 && _g(n, t, r) || a === 0 && _g(n, e, r))
   }

   function _g(t, e, n) {
      return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
   }

   function Ag(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0
   }

   function BW(t, e) {
      let n = t;
      do {
         if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && kF(n, n.next, t, e)) return !0;
         n = n.next
      } while (n !== t);
      return !1
   }

   function Wd(t, e) {
      return Tn(t.prev, t, t.next) < 0 ? Tn(t, e, t.next) >= 0 && Tn(t, t.prev, e) >= 0 : Tn(t, e, t.prev) < 0 || Tn(t, t.next, e) < 0
   }

   function IW(t, e) {
      let n = t,
         r = !1;
      const i = (t.x + e.x) / 2,
         s = (t.y + e.y) / 2;
      do n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== t);
      return r
   }

   function HF(t, e) {
      const n = new ZA(t.i, t.x, t.y),
         r = new ZA(e.i, e.x, e.y),
         i = t.next,
         s = e.prev;
      return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
   }

   function GR(t, e, n, r) {
      const i = new ZA(t, e, n);
      return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
   }

   function jd(t) {
      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
   }

   function ZA(t, e, n) {
      this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
   }

   function LW(t, e, n, r) {
      let i = 0;
      for (let s = e, o = n - r; s < n; s += r) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
      return i
   }
   class Ws {
      static area(e) {
         const n = e.length;
         let r = 0;
         for (let i = n - 1, s = 0; s < n; i = s++) r += e[i].x * e[s].y - e[s].x * e[i].y;
         return r * .5
      }
      static isClockWise(e) {
         return Ws.area(e) < 0
      }
      static triangulateShape(e, n) {
         const r = [],
            i = [],
            s = [];
         zR(e), VR(r, e);
         let o = e.length;
         n.forEach(zR);
         for (let l = 0; l < n.length; l++) i.push(o), o += n[l].length, VR(r, n[l]);
         const a = vW.triangulate(r, i);
         for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
         return s
      }
   }

   function zR(t) {
      const e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop()
   }

   function VR(t, e) {
      for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
   }
   class $v extends Tt {
      constructor(e = new Vl([new Se(.5, .5), new Se(-.5, .5), new Se(-.5, -.5), new Se(.5, -.5)]), n = {}) {
         super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: n
         }, e = Array.isArray(e) ? e : [e];
         const r = this,
            i = [],
            s = [];
         for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a];
            o(u)
         }
         this.setAttribute("position", new nt(i, 3)), this.setAttribute("uv", new nt(s, 2)), this.computeVertexNormals();

         function o(a) {
            const l = [],
               u = n.curveSegments !== void 0 ? n.curveSegments : 12,
               h = n.steps !== void 0 ? n.steps : 1,
               d = n.depth !== void 0 ? n.depth : 1;
            let p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0,
               m = n.bevelThickness !== void 0 ? n.bevelThickness : .2,
               v = n.bevelSize !== void 0 ? n.bevelSize : m - .1,
               _ = n.bevelOffset !== void 0 ? n.bevelOffset : 0,
               x = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
            const g = n.extrudePath,
               S = n.UVGenerator !== void 0 ? n.UVGenerator : DW;
            let A, E = !1,
               C, R, B, D;
            g && (A = g.getSpacedPoints(h), E = !0, p = !1, C = g.computeFrenetFrames(h, !1), R = new U, B = new U, D = new U), p || (x = 0, m = 0, v = 0, _ = 0);
            const T = a.extractPoints(u);
            let I = T.shape;
            const N = T.holes;
            if (!Ws.isClockWise(I)) {
               I = I.reverse();
               for (let J = 0, Ce = N.length; J < Ce; J++) {
                  const Ae = N[J];
                  Ws.isClockWise(Ae) && (N[J] = Ae.reverse())
               }
            }
            const K = Ws.triangulateShape(I, N),
               Z = I;
            for (let J = 0, Ce = N.length; J < Ce; J++) {
               const Ae = N[J];
               I = I.concat(Ae)
            }

            function te(J, Ce, Ae) {
               return Ce || console.error("THREE.ExtrudeGeometry: vec does not exist"), J.clone().addScaledVector(Ce, Ae)
            }
            const se = I.length,
               oe = K.length;

            function G(J, Ce, Ae) {
               let Ie, be, lt;
               const Je = J.x - Ce.x,
                  qe = J.y - Ce.y,
                  vt = Ae.x - J.x,
                  Ot = Ae.y - J.y,
                  un = Je * Je + qe * qe,
                  j = Je * Ot - qe * vt;
               if (Math.abs(j) > Number.EPSILON) {
                  const O = Math.sqrt(un),
                     ue = Math.sqrt(vt * vt + Ot * Ot),
                     Pe = Ce.x - qe / O,
                     Te = Ce.y + Je / O,
                     Be = Ae.x - Ot / ue,
                     rt = Ae.y + vt / ue,
                     Le = ((Be - Pe) * Ot - (rt - Te) * vt) / (Je * Ot - qe * vt);
                  Ie = Pe + Je * Le - J.x, be = Te + qe * Le - J.y;
                  const de = Ie * Ie + be * be;
                  if (de <= 2) return new Se(Ie, be);
                  lt = Math.sqrt(de / 2)
               } else {
                  let O = !1;
                  Je > Number.EPSILON ? vt > Number.EPSILON && (O = !0) : Je < -Number.EPSILON ? vt < -Number.EPSILON && (O = !0) : Math.sign(qe) === Math.sign(Ot) && (O = !0), O ? (Ie = -qe, be = Je, lt = Math.sqrt(un)) : (Ie = Je, be = qe, lt = Math.sqrt(un / 2))
               }
               return new Se(Ie / lt, be / lt)
            }
            const ne = [];
            for (let J = 0, Ce = Z.length, Ae = Ce - 1, Ie = J + 1; J < Ce; J++, Ae++, Ie++) Ae === Ce && (Ae = 0), Ie === Ce && (Ie = 0), ne[J] = G(Z[J], Z[Ae], Z[Ie]);
            const Y = [];
            let X, Q = ne.concat();
            for (let J = 0, Ce = N.length; J < Ce; J++) {
               const Ae = N[J];
               X = [];
               for (let Ie = 0, be = Ae.length, lt = be - 1, Je = Ie + 1; Ie < be; Ie++, lt++, Je++) lt === be && (lt = 0), Je === be && (Je = 0), X[Ie] = G(Ae[Ie], Ae[lt], Ae[Je]);
               Y.push(X), Q = Q.concat(X)
            }
            for (let J = 0; J < x; J++) {
               const Ce = J / x,
                  Ae = m * Math.cos(Ce * Math.PI / 2),
                  Ie = v * Math.sin(Ce * Math.PI / 2) + _;
               for (let be = 0, lt = Z.length; be < lt; be++) {
                  const Je = te(Z[be], ne[be], Ie);
                  Ue(Je.x, Je.y, -Ae)
               }
               for (let be = 0, lt = N.length; be < lt; be++) {
                  const Je = N[be];
                  X = Y[be];
                  for (let qe = 0, vt = Je.length; qe < vt; qe++) {
                     const Ot = te(Je[qe], X[qe], Ie);
                     Ue(Ot.x, Ot.y, -Ae)
                  }
               }
            }
            const _e = v + _;
            for (let J = 0; J < se; J++) {
               const Ce = p ? te(I[J], Q[J], _e) : I[J];
               E ? (B.copy(C.normals[0]).multiplyScalar(Ce.x), R.copy(C.binormals[0]).multiplyScalar(Ce.y), D.copy(A[0]).add(B).add(R), Ue(D.x, D.y, D.z)) : Ue(Ce.x, Ce.y, 0)
            }
            for (let J = 1; J <= h; J++)
               for (let Ce = 0; Ce < se; Ce++) {
                  const Ae = p ? te(I[Ce], Q[Ce], _e) : I[Ce];
                  E ? (B.copy(C.normals[J]).multiplyScalar(Ae.x), R.copy(C.binormals[J]).multiplyScalar(Ae.y), D.copy(A[J]).add(B).add(R), Ue(D.x, D.y, D.z)) : Ue(Ae.x, Ae.y, d / h * J)
               }
            for (let J = x - 1; J >= 0; J--) {
               const Ce = J / x,
                  Ae = m * Math.cos(Ce * Math.PI / 2),
                  Ie = v * Math.sin(Ce * Math.PI / 2) + _;
               for (let be = 0, lt = Z.length; be < lt; be++) {
                  const Je = te(Z[be], ne[be], Ie);
                  Ue(Je.x, Je.y, d + Ae)
               }
               for (let be = 0, lt = N.length; be < lt; be++) {
                  const Je = N[be];
                  X = Y[be];
                  for (let qe = 0, vt = Je.length; qe < vt; qe++) {
                     const Ot = te(Je[qe], X[qe], Ie);
                     E ? Ue(Ot.x, Ot.y + A[h - 1].y, A[h - 1].x + Ae) : Ue(Ot.x, Ot.y, d + Ae)
                  }
               }
            }
            Me(), we();

            function Me() {
               const J = i.length / 3;
               if (p) {
                  let Ce = 0,
                     Ae = se * Ce;
                  for (let Ie = 0; Ie < oe; Ie++) {
                     const be = K[Ie];
                     Qe(be[2] + Ae, be[1] + Ae, be[0] + Ae)
                  }
                  Ce = h + x * 2, Ae = se * Ce;
                  for (let Ie = 0; Ie < oe; Ie++) {
                     const be = K[Ie];
                     Qe(be[0] + Ae, be[1] + Ae, be[2] + Ae)
                  }
               } else {
                  for (let Ce = 0; Ce < oe; Ce++) {
                     const Ae = K[Ce];
                     Qe(Ae[2], Ae[1], Ae[0])
                  }
                  for (let Ce = 0; Ce < oe; Ce++) {
                     const Ae = K[Ce];
                     Qe(Ae[0] + se * h, Ae[1] + se * h, Ae[2] + se * h)
                  }
               }
               r.addGroup(J, i.length / 3 - J, 0)
            }

            function we() {
               const J = i.length / 3;
               let Ce = 0;
               Ee(Z, Ce), Ce += Z.length;
               for (let Ae = 0, Ie = N.length; Ae < Ie; Ae++) {
                  const be = N[Ae];
                  Ee(be, Ce), Ce += be.length
               }
               r.addGroup(J, i.length / 3 - J, 1)
            }

            function Ee(J, Ce) {
               let Ae = J.length;
               for (; --Ae >= 0;) {
                  const Ie = Ae;
                  let be = Ae - 1;
                  be < 0 && (be = J.length - 1);
                  for (let lt = 0, Je = h + x * 2; lt < Je; lt++) {
                     const qe = se * lt,
                        vt = se * (lt + 1),
                        Ot = Ce + Ie + qe,
                        un = Ce + be + qe,
                        j = Ce + be + vt,
                        O = Ce + Ie + vt;
                     Pt(Ot, un, j, O)
                  }
               }
            }

            function Ue(J, Ce, Ae) {
               l.push(J), l.push(Ce), l.push(Ae)
            }

            function Qe(J, Ce, Ae) {
               kt(J), kt(Ce), kt(Ae);
               const Ie = i.length / 3,
                  be = S.generateTopUV(r, i, Ie - 3, Ie - 2, Ie - 1);
               $e(be[0]), $e(be[1]), $e(be[2])
            }

            function Pt(J, Ce, Ae, Ie) {
               kt(J), kt(Ce), kt(Ie), kt(Ce), kt(Ae), kt(Ie);
               const be = i.length / 3,
                  lt = S.generateSideWallUV(r, i, be - 6, be - 3, be - 2, be - 1);
               $e(lt[0]), $e(lt[1]), $e(lt[3]), $e(lt[1]), $e(lt[2]), $e(lt[3])
            }

            function kt(J) {
               i.push(l[J * 3 + 0]), i.push(l[J * 3 + 1]), i.push(l[J * 3 + 2])
            }

            function $e(J) {
               s.push(J.x), s.push(J.y)
            }
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      toJSON() {
         const e = super.toJSON(),
            n = this.parameters.shapes,
            r = this.parameters.options;
         return FW(n, r, e)
      }
      static fromJSON(e, n) {
         const r = [];
         for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = n[e.shapes[s]];
            r.push(a)
         }
         const i = e.options.extrudePath;
         return i !== void 0 && (e.options.extrudePath = new pE[i.type]().fromJSON(i)), new $v(r, e.options)
      }
   }
   const DW = {
      generateTopUV: function (t, e, n, r, i) {
         const s = e[n * 3],
            o = e[n * 3 + 1],
            a = e[r * 3],
            l = e[r * 3 + 1],
            u = e[i * 3],
            h = e[i * 3 + 1];
         return [new Se(s, o), new Se(a, l), new Se(u, h)]
      },
      generateSideWallUV: function (t, e, n, r, i, s) {
         const o = e[n * 3],
            a = e[n * 3 + 1],
            l = e[n * 3 + 2],
            u = e[r * 3],
            h = e[r * 3 + 1],
            d = e[r * 3 + 2],
            p = e[i * 3],
            m = e[i * 3 + 1],
            v = e[i * 3 + 2],
            _ = e[s * 3],
            x = e[s * 3 + 1],
            g = e[s * 3 + 2];
         return Math.abs(a - h) < Math.abs(o - u) ? [new Se(o, 1 - l), new Se(u, 1 - d), new Se(p, 1 - v), new Se(_, 1 - g)] : [new Se(a, 1 - l), new Se(h, 1 - d), new Se(m, 1 - v), new Se(x, 1 - g)]
      }
   };

   function FW(t, e, n) {
      if (n.shapes = [], Array.isArray(t))
         for (let r = 0, i = t.length; r < i; r++) {
            const s = t[r];
            n.shapes.push(s.uuid)
         } else n.shapes.push(t.uuid);
      return n.options = Object.assign({}, e), e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n
   }
   class hp extends Ja {
      constructor(e = 1, n = 0) {
         const r = (1 + Math.sqrt(5)) / 2,
            i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1],
            s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
         super(i, s, e, n), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: n
         }
      }
      static fromJSON(e) {
         return new hp(e.radius, e.detail)
      }
   }
   class dp extends Ja {
      constructor(e = 1, n = 0) {
         const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
         super(r, i, e, n), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: n
         }
      }
      static fromJSON(e) {
         return new dp(e.radius, e.detail)
      }
   }
   class Xv extends Tt {
      constructor(e = .5, n = 1, r = 32, i = 1, s = 0, o = Math.PI * 2) {
         super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: n,
            thetaSegments: r,
            phiSegments: i,
            thetaStart: s,
            thetaLength: o
         }, r = Math.max(3, r), i = Math.max(1, i);
         const a = [],
            l = [],
            u = [],
            h = [];
         let d = e;
         const p = (n - e) / i,
            m = new U,
            v = new Se;
         for (let _ = 0; _ <= i; _++) {
            for (let x = 0; x <= r; x++) {
               const g = s + x / r * o;
               m.x = d * Math.cos(g), m.y = d * Math.sin(g), l.push(m.x, m.y, m.z), u.push(0, 0, 1), v.x = (m.x / n + 1) / 2, v.y = (m.y / n + 1) / 2, h.push(v.x, v.y)
            }
            d += p
         }
         for (let _ = 0; _ < i; _++) {
            const x = _ * (r + 1);
            for (let g = 0; g < r; g++) {
               const S = g + x,
                  A = S,
                  E = S + r + 1,
                  C = S + r + 2,
                  R = S + 1;
               a.push(A, E, R), a.push(E, C, R)
            }
         }
         this.setIndex(a), this.setAttribute("position", new nt(l, 3)), this.setAttribute("normal", new nt(u, 3)), this.setAttribute("uv", new nt(h, 2))
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new Xv(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
      }
   }
   class Jv extends Tt {
      constructor(e = new Vl([new Se(0, .5), new Se(-.5, -.5), new Se(.5, -.5)]), n = 12) {
         super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: e,
            curveSegments: n
         };
         const r = [],
            i = [],
            s = [],
            o = [];
         let a = 0,
            l = 0;
         if (Array.isArray(e) === !1) u(e);
         else
            for (let h = 0; h < e.length; h++) u(e[h]), this.addGroup(a, l, h), a += l, l = 0;
         this.setIndex(r), this.setAttribute("position", new nt(i, 3)), this.setAttribute("normal", new nt(s, 3)), this.setAttribute("uv", new nt(o, 2));

         function u(h) {
            const d = i.length / 3,
               p = h.extractPoints(n);
            let m = p.shape;
            const v = p.holes;
            Ws.isClockWise(m) === !1 && (m = m.reverse());
            for (let x = 0, g = v.length; x < g; x++) {
               const S = v[x];
               Ws.isClockWise(S) === !0 && (v[x] = S.reverse())
            }
            const _ = Ws.triangulateShape(m, v);
            for (let x = 0, g = v.length; x < g; x++) {
               const S = v[x];
               m = m.concat(S)
            }
            for (let x = 0, g = m.length; x < g; x++) {
               const S = m[x];
               i.push(S.x, S.y, 0), s.push(0, 0, 1), o.push(S.x, S.y)
            }
            for (let x = 0, g = _.length; x < g; x++) {
               const S = _[x],
                  A = S[0] + d,
                  E = S[1] + d,
                  C = S[2] + d;
               r.push(A, E, C), l += 3
            }
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      toJSON() {
         const e = super.toJSON(),
            n = this.parameters.shapes;
         return OW(n, e)
      }
      static fromJSON(e, n) {
         const r = [];
         for (let i = 0, s = e.shapes.length; i < s; i++) {
            const o = n[e.shapes[i]];
            r.push(o)
         }
         return new Jv(r, e.curveSegments)
      }
   }

   function OW(t, e) {
      if (e.shapes = [], Array.isArray(t))
         for (let n = 0, r = t.length; n < r; n++) {
            const i = t[n];
            e.shapes.push(i.uuid)
         } else e.shapes.push(t.uuid);
      return e
   }
   class pp extends Tt {
      constructor(e = 1, n = 32, r = 16, i = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
         super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: n,
            heightSegments: r,
            phiStart: i,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
         }, n = Math.max(3, Math.floor(n)), r = Math.max(2, Math.floor(r));
         const l = Math.min(o + a, Math.PI);
         let u = 0;
         const h = [],
            d = new U,
            p = new U,
            m = [],
            v = [],
            _ = [],
            x = [];
         for (let g = 0; g <= r; g++) {
            const S = [],
               A = g / r;
            let E = 0;
            g === 0 && o === 0 ? E = .5 / n : g === r && l === Math.PI && (E = -.5 / n);
            for (let C = 0; C <= n; C++) {
               const R = C / n;
               d.x = -e * Math.cos(i + R * s) * Math.sin(o + A * a), d.y = e * Math.cos(o + A * a), d.z = e * Math.sin(i + R * s) * Math.sin(o + A * a), v.push(d.x, d.y, d.z), p.copy(d).normalize(), _.push(p.x, p.y, p.z), x.push(R + E, 1 - A), S.push(u++)
            }
            h.push(S)
         }
         for (let g = 0; g < r; g++)
            for (let S = 0; S < n; S++) {
               const A = h[g][S + 1],
                  E = h[g][S],
                  C = h[g + 1][S],
                  R = h[g + 1][S + 1];
               (g !== 0 || o > 0) && m.push(A, E, R), (g !== r - 1 || l < Math.PI) && m.push(E, C, R)
            }
         this.setIndex(m), this.setAttribute("position", new nt(v, 3)), this.setAttribute("normal", new nt(_, 3)), this.setAttribute("uv", new nt(x, 2))
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new pp(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
      }
   }
   class Kv extends Ja {
      constructor(e = 1, n = 0) {
         const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
         super(r, i, e, n), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: n
         }
      }
      static fromJSON(e) {
         return new Kv(e.radius, e.detail)
      }
   }
   class Yv extends Tt {
      constructor(e = 1, n = .4, r = 12, i = 48, s = Math.PI * 2) {
         super(), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: n,
            radialSegments: r,
            tubularSegments: i,
            arc: s
         }, r = Math.floor(r), i = Math.floor(i);
         const o = [],
            a = [],
            l = [],
            u = [],
            h = new U,
            d = new U,
            p = new U;
         for (let m = 0; m <= r; m++)
            for (let v = 0; v <= i; v++) {
               const _ = v / i * s,
                  x = m / r * Math.PI * 2;
               d.x = (e + n * Math.cos(x)) * Math.cos(_), d.y = (e + n * Math.cos(x)) * Math.sin(_), d.z = n * Math.sin(x), a.push(d.x, d.y, d.z), h.x = e * Math.cos(_), h.y = e * Math.sin(_), p.subVectors(d, h).normalize(), l.push(p.x, p.y, p.z), u.push(v / i), u.push(m / r)
            }
         for (let m = 1; m <= r; m++)
            for (let v = 1; v <= i; v++) {
               const _ = (i + 1) * m + v - 1,
                  x = (i + 1) * (m - 1) + v - 1,
                  g = (i + 1) * (m - 1) + v,
                  S = (i + 1) * m + v;
               o.push(_, x, S), o.push(x, g, S)
            }
         this.setIndex(o), this.setAttribute("position", new nt(a, 3)), this.setAttribute("normal", new nt(l, 3)), this.setAttribute("uv", new nt(u, 2))
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new Yv(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
      }
   }
   class Qv extends Tt {
      constructor(e = 1, n = .4, r = 64, i = 8, s = 2, o = 3) {
         super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: n,
            tubularSegments: r,
            radialSegments: i,
            p: s,
            q: o
         }, r = Math.floor(r), i = Math.floor(i);
         const a = [],
            l = [],
            u = [],
            h = [],
            d = new U,
            p = new U,
            m = new U,
            v = new U,
            _ = new U,
            x = new U,
            g = new U;
         for (let A = 0; A <= r; ++A) {
            const E = A / r * s * Math.PI * 2;
            S(E, s, o, e, m), S(E + .01, s, o, e, v), x.subVectors(v, m), g.addVectors(v, m), _.crossVectors(x, g), g.crossVectors(_, x), _.normalize(), g.normalize();
            for (let C = 0; C <= i; ++C) {
               const R = C / i * Math.PI * 2,
                  B = -n * Math.cos(R),
                  D = n * Math.sin(R);
               d.x = m.x + (B * g.x + D * _.x), d.y = m.y + (B * g.y + D * _.y), d.z = m.z + (B * g.z + D * _.z), l.push(d.x, d.y, d.z), p.subVectors(d, m).normalize(), u.push(p.x, p.y, p.z), h.push(A / r), h.push(C / i)
            }
         }
         for (let A = 1; A <= r; A++)
            for (let E = 1; E <= i; E++) {
               const C = (i + 1) * (A - 1) + (E - 1),
                  R = (i + 1) * A + (E - 1),
                  B = (i + 1) * A + E,
                  D = (i + 1) * (A - 1) + E;
               a.push(C, R, D), a.push(R, B, D)
            }
         this.setIndex(a), this.setAttribute("position", new nt(l, 3)), this.setAttribute("normal", new nt(u, 3)), this.setAttribute("uv", new nt(h, 2));

         function S(A, E, C, R, B) {
            const D = Math.cos(A),
               T = Math.sin(A),
               I = C / E * A,
               N = Math.cos(I);
            B.x = R * (2 + N) * .5 * D, B.y = R * (2 + N) * T * .5, B.z = R * Math.sin(I) * .5
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      static fromJSON(e) {
         return new Qv(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
      }
   }
   class Zv extends Tt {
      constructor(e = new hE(new U(-1, -1, 0), new U(-1, 1, 0), new U(1, 1, 0)), n = 64, r = 1, i = 8, s = !1) {
         super(), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: n,
            radius: r,
            radialSegments: i,
            closed: s
         };
         const o = e.computeFrenetFrames(n, s);
         this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
         const a = new U,
            l = new U,
            u = new Se;
         let h = new U;
         const d = [],
            p = [],
            m = [],
            v = [];
         _(), this.setIndex(v), this.setAttribute("position", new nt(d, 3)), this.setAttribute("normal", new nt(p, 3)), this.setAttribute("uv", new nt(m, 2));

         function _() {
            for (let A = 0; A < n; A++) x(A);
            x(s === !1 ? n : 0), S(), g()
         }

         function x(A) {
            h = e.getPointAt(A / n, h);
            const E = o.normals[A],
               C = o.binormals[A];
            for (let R = 0; R <= i; R++) {
               const B = R / i * Math.PI * 2,
                  D = Math.sin(B),
                  T = -Math.cos(B);
               l.x = T * E.x + D * C.x, l.y = T * E.y + D * C.y, l.z = T * E.z + D * C.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = h.x + r * l.x, a.y = h.y + r * l.y, a.z = h.z + r * l.z, d.push(a.x, a.y, a.z)
            }
         }

         function g() {
            for (let A = 1; A <= n; A++)
               for (let E = 1; E <= i; E++) {
                  const C = (i + 1) * (A - 1) + (E - 1),
                     R = (i + 1) * A + (E - 1),
                     B = (i + 1) * A + E,
                     D = (i + 1) * (A - 1) + E;
                  v.push(C, R, D), v.push(R, B, D)
               }
         }

         function S() {
            for (let A = 0; A <= n; A++)
               for (let E = 0; E <= i; E++) u.x = A / n, u.y = E / i, m.push(u.x, u.y)
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
      toJSON() {
         const e = super.toJSON();
         return e.path = this.parameters.path.toJSON(), e
      }
      static fromJSON(e) {
         return new Zv(new pE[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
      }
   }
   class GF extends Tt {
      constructor(e = null) {
         if (super(), this.type = "WireframeGeometry", this.parameters = {
               geometry: e
            }, e !== null) {
            const n = [],
               r = new Set,
               i = new U,
               s = new U;
            if (e.index !== null) {
               const o = e.attributes.position,
                  a = e.index;
               let l = e.groups;
               l.length === 0 && (l = [{
                  start: 0,
                  count: a.count,
                  materialIndex: 0
               }]);
               for (let u = 0, h = l.length; u < h; ++u) {
                  const d = l[u],
                     p = d.start,
                     m = d.count;
                  for (let v = p, _ = p + m; v < _; v += 3)
                     for (let x = 0; x < 3; x++) {
                        const g = a.getX(v + x),
                           S = a.getX(v + (x + 1) % 3);
                        i.fromBufferAttribute(o, g), s.fromBufferAttribute(o, S), WR(i, s, r) === !0 && (n.push(i.x, i.y, i.z), n.push(s.x, s.y, s.z))
                     }
               }
            } else {
               const o = e.attributes.position;
               for (let a = 0, l = o.count / 3; a < l; a++)
                  for (let u = 0; u < 3; u++) {
                     const h = 3 * a + u,
                        d = 3 * a + (u + 1) % 3;
                     i.fromBufferAttribute(o, h), s.fromBufferAttribute(o, d), WR(i, s, r) === !0 && (n.push(i.x, i.y, i.z), n.push(s.x, s.y, s.z))
                  }
            }
            this.setAttribute("position", new nt(n, 3))
         }
      }
      copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
      }
   }

   function WR(t, e, n) {
      const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
         i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
      return n.has(r) === !0 || n.has(i) === !0 ? !1 : (n.add(r), n.add(i), !0)
   }
   var jR = Object.freeze({
      __proto__: null,
      BoxGeometry: ru,
      CapsuleGeometry: Gv,
      CircleGeometry: zv,
      ConeGeometry: Vv,
      CylinderGeometry: Pf,
      DodecahedronGeometry: Wv,
      EdgesGeometry: NF,
      ExtrudeGeometry: $v,
      IcosahedronGeometry: hp,
      LatheGeometry: fp,
      OctahedronGeometry: dp,
      PlaneGeometry: lp,
      PolyhedronGeometry: Ja,
      RingGeometry: Xv,
      ShapeGeometry: Jv,
      SphereGeometry: pp,
      TetrahedronGeometry: Kv,
      TorusGeometry: Yv,
      TorusKnotGeometry: Qv,
      TubeGeometry: Zv,
      WireframeGeometry: GF
   });
   class zF extends Jn {
      constructor(e) {
         super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new ke(0), this.transparent = !0, this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
      }
   }
   class VF extends Qi {
      constructor(e) {
         super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
      }
   }
   class mp extends Jn {
      constructor(e) {
         super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
         }, this.type = "MeshStandardMaterial", this.color = new ke(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $a, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.defines = {
            STANDARD: ""
         }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
      }
   }
   class Qs extends mp {
      constructor(e) {
         super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
         }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Se(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function () {
               return On(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function (n) {
               this.ior = (1 + .4 * n) / (1 - .4 * n)
            }
         }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ke(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ke(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ke(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
      }
      get anisotropy() {
         return this._anisotropy
      }
      set anisotropy(e) {
         this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
      }
      get clearcoat() {
         return this._clearcoat
      }
      set clearcoat(e) {
         this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
      }
      get iridescence() {
         return this._iridescence
      }
      set iridescence(e) {
         this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
      }
      get sheen() {
         return this._sheen
      }
      set sheen(e) {
         this._sheen > 0 != e > 0 && this.version++, this._sheen = e
      }
      get transmission() {
         return this._transmission
      }
      set transmission(e) {
         this._transmission > 0 != e > 0 && this.version++, this._transmission = e
      }
      copy(e) {
         return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
         }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
      }
   }
   class WF extends Jn {
      constructor(e) {
         super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new ke(16777215), this.specular = new ke(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $a, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sp, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
      }
   }
   class jF extends Jn {
      constructor(e) {
         super(), this.isMeshToonMaterial = !0, this.defines = {
            TOON: ""
         }, this.type = "MeshToonMaterial", this.color = new ke(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $a, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
      }
   }
   class $F extends Jn {
      constructor(e) {
         super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $a, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
      }
   }
   class mE extends Jn {
      constructor(e) {
         super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new ke(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ke(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $a, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sp, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
      }
   }
   class XF extends Jn {
      constructor(e) {
         super(), this.isMeshMatcapMaterial = !0, this.defines = {
            MATCAP: ""
         }, this.type = "MeshMatcapMaterial", this.color = new ke(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $a, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.defines = {
            MATCAP: ""
         }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
      }
   }
   class JF extends Rr {
      constructor(e) {
         super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
      }
      copy(e) {
         return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
      }
   }

   function Gi(t, e, n) {
      return gE(t) ? new t.constructor(t.subarray(e, n !== void 0 ? n : t.length)) : t.slice(e, n)
   }

   function Fl(t, e, n) {
      return !t || !n && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t)
   }

   function gE(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView)
   }

   function KF(t) {
      function e(i, s) {
         return t[i] - t[s]
      }
      const n = t.length,
         r = new Array(n);
      for (let i = 0; i !== n; ++i) r[i] = i;
      return r.sort(e), r
   }

   function qA(t, e, n) {
      const r = t.length,
         i = new t.constructor(r);
      for (let s = 0, o = 0; o !== r; ++s) {
         const a = n[s] * e;
         for (let l = 0; l !== e; ++l) i[o++] = t[a + l]
      }
      return i
   }

   function vE(t, e, n, r) {
      let i = 1,
         s = t[0];
      for (; s !== void 0 && s[r] === void 0;) s = t[i++];
      if (s === void 0) return;
      let o = s[r];
      if (o !== void 0)
         if (Array.isArray(o))
            do o = s[r], o !== void 0 && (e.push(s.time), n.push.apply(n, o)), s = t[i++]; while (s !== void 0);
         else if (o.toArray !== void 0)
         do o = s[r], o !== void 0 && (e.push(s.time), o.toArray(n, n.length)), s = t[i++]; while (s !== void 0);
      else
         do o = s[r], o !== void 0 && (e.push(s.time), n.push(o)), s = t[i++]; while (s !== void 0)
   }

   function NW(t, e, n, r, i = 30) {
      const s = t.clone();
      s.name = e;
      const o = [];
      for (let l = 0; l < s.tracks.length; ++l) {
         const u = s.tracks[l],
            h = u.getValueSize(),
            d = [],
            p = [];
         for (let m = 0; m < u.times.length; ++m) {
            const v = u.times[m] * i;
            if (!(v < n || v >= r)) {
               d.push(u.times[m]);
               for (let _ = 0; _ < h; ++_) p.push(u.values[m * h + _])
            }
         }
         d.length !== 0 && (u.times = Fl(d, u.times.constructor), u.values = Fl(p, u.values.constructor), o.push(u))
      }
      s.tracks = o;
      let a = 1 / 0;
      for (let l = 0; l < s.tracks.length; ++l) a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
      for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
      return s.resetDuration(), s
   }

   function UW(t, e = 0, n = t, r = 30) {
      r <= 0 && (r = 30);
      const i = n.tracks.length,
         s = e / r;
      for (let o = 0; o < i; ++o) {
         const a = n.tracks[o],
            l = a.ValueTypeName;
         if (l === "bool" || l === "string") continue;
         const u = t.tracks.find(function (g) {
            return g.name === a.name && g.ValueTypeName === l
         });
         if (u === void 0) continue;
         let h = 0;
         const d = a.getValueSize();
         a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
         let p = 0;
         const m = u.getValueSize();
         u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3);
         const v = a.times.length - 1;
         let _;
         if (s <= a.times[0]) {
            const g = h,
               S = d - h;
            _ = Gi(a.values, g, S)
         } else if (s >= a.times[v]) {
            const g = v * d + h,
               S = g + d - h;
            _ = Gi(a.values, g, S)
         } else {
            const g = a.createInterpolant(),
               S = h,
               A = d - h;
            g.evaluate(s), _ = Gi(g.resultBuffer, S, A)
         }
         l === "quaternion" && new tr().fromArray(_).normalize().conjugate().toArray(_);
         const x = u.times.length;
         for (let g = 0; g < x; ++g) {
            const S = g * m + p;
            if (l === "quaternion") tr.multiplyQuaternionsFlat(u.values, S, _, 0, u.values, S);
            else {
               const A = m - p * 2;
               for (let E = 0; E < A; ++E) u.values[S + E] -= _[E]
            }
         }
      }
      return t.blendMode = VM, t
   }
   const kW = {
      arraySlice: Gi,
      convertArray: Fl,
      isTypedArray: gE,
      getKeyframeOrder: KF,
      sortedArray: qA,
      flattenJSON: vE,
      subclip: NW,
      makeClipAdditive: UW
   };
   class Bf {
      constructor(e, n, r, i) {
         this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new n.constructor(r), this.sampleValues = n, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {}
      }
      evaluate(e) {
         const n = this.parameterPositions;
         let r = this._cachedIndex,
            i = n[r],
            s = n[r - 1];
         e: {
            t: {
               let o;n: {
                  r: if (!(e < i)) {
                     for (let a = r + 2;;) {
                        if (i === void 0) {
                           if (e < s) break r;
                           return r = n.length, this._cachedIndex = r, this.copySampleValue_(r - 1)
                        }
                        if (r === a) break;
                        if (s = i, i = n[++r], e < i) break t
                     }
                     o = n.length;
                     break n
                  }if (!(e >= s)) {
                     const a = n[1];
                     e < a && (r = 2, s = a);
                     for (let l = r - 2;;) {
                        if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (r === l) break;
                        if (i = s, s = n[--r - 1], e >= s) break t
                     }
                     o = r, r = 0;
                     break n
                  }
                  break e
               }
               for (; r < o;) {
                  const a = r + o >>> 1;
                  e < n[a] ? o = a : r = a + 1
               }
               if (i = n[r], s = n[r - 1], s === void 0) return this._cachedIndex = 0,
               this.copySampleValue_(0);
               if (i === void 0) return r = n.length,
               this._cachedIndex = r,
               this.copySampleValue_(r - 1)
            }
            this._cachedIndex = r,
            this.intervalChanged_(r, s, i)
         }
         return this.interpolate_(r, s, e, i)
      }
      getSettings_() {
         return this.settings || this.DefaultSettings_
      }
      copySampleValue_(e) {
         const n = this.resultBuffer,
            r = this.sampleValues,
            i = this.valueSize,
            s = e * i;
         for (let o = 0; o !== i; ++o) n[o] = r[s + o];
         return n
      }
      interpolate_() {
         throw new Error("call to abstract method")
      }
      intervalChanged_() {}
   }
   class YF extends Bf {
      constructor(e, n, r, i) {
         super(e, n, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Bl,
            endingEnd: Bl
         }
      }
      intervalChanged_(e, n, r) {
         const i = this.parameterPositions;
         let s = e - 2,
            o = e + 1,
            a = i[s],
            l = i[o];
         if (a === void 0) switch (this.getSettings_().endingStart) {
            case Il:
               s = e, a = 2 * n - r;
               break;
            case Nd:
               s = i.length - 2, a = n + i[s] - i[s + 1];
               break;
            default:
               s = e, a = r
         }
         if (l === void 0) switch (this.getSettings_().endingEnd) {
            case Il:
               o = e, l = 2 * r - n;
               break;
            case Nd:
               o = 1, l = r + i[1] - i[0];
               break;
            default:
               o = e - 1, l = n
         }
         const u = (r - n) * .5,
            h = this.valueSize;
         this._weightPrev = u / (n - a), this._weightNext = u / (l - r), this._offsetPrev = s * h, this._offsetNext = o * h
      }
      interpolate_(e, n, r, i) {
         const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            u = l - a,
            h = this._offsetPrev,
            d = this._offsetNext,
            p = this._weightPrev,
            m = this._weightNext,
            v = (r - n) / (i - n),
            _ = v * v,
            x = _ * v,
            g = -p * x + 2 * p * _ - p * v,
            S = (1 + p) * x + (-1.5 - 2 * p) * _ + (-.5 + p) * v + 1,
            A = (-1 - m) * x + (1.5 + m) * _ + .5 * v,
            E = m * x - m * _;
         for (let C = 0; C !== a; ++C) s[C] = g * o[h + C] + S * o[u + C] + A * o[l + C] + E * o[d + C];
         return s
      }
   }
   class yE extends Bf {
      constructor(e, n, r, i) {
         super(e, n, r, i)
      }
      interpolate_(e, n, r, i) {
         const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            u = l - a,
            h = (r - n) / (i - n),
            d = 1 - h;
         for (let p = 0; p !== a; ++p) s[p] = o[u + p] * d + o[l + p] * h;
         return s
      }
   }
   class QF extends Bf {
      constructor(e, n, r, i) {
         super(e, n, r, i)
      }
      interpolate_(e) {
         return this.copySampleValue_(e - 1)
      }
   }
   class As {
      constructor(e, n, r, i) {
         if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
         if (n === void 0 || n.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
         this.name = e, this.times = Fl(n, this.TimeBufferType), this.values = Fl(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
      }
      static toJSON(e) {
         const n = e.constructor;
         let r;
         if (n.toJSON !== this.toJSON) r = n.toJSON(e);
         else {
            r = {
               name: e.name,
               times: Fl(e.times, Array),
               values: Fl(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (r.interpolation = i)
         }
         return r.type = e.ValueTypeName, r
      }
      InterpolantFactoryMethodDiscrete(e) {
         return new QF(this.times, this.values, this.getValueSize(), e)
      }
      InterpolantFactoryMethodLinear(e) {
         return new yE(this.times, this.values, this.getValueSize(), e)
      }
      InterpolantFactoryMethodSmooth(e) {
         return new YF(this.times, this.values, this.getValueSize(), e)
      }
      setInterpolation(e) {
         let n;
         switch (e) {
            case hf:
               n = this.InterpolantFactoryMethodDiscrete;
               break;
            case Yl:
               n = this.InterpolantFactoryMethodLinear;
               break;
            case a0:
               n = this.InterpolantFactoryMethodSmooth;
               break
         }
         if (n === void 0) {
            const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
               if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
               else throw new Error(r);
            return console.warn("THREE.KeyframeTrack:", r), this
         }
         return this.createInterpolant = n, this
      }
      getInterpolation() {
         switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
               return hf;
            case this.InterpolantFactoryMethodLinear:
               return Yl;
            case this.InterpolantFactoryMethodSmooth:
               return a0
         }
      }
      getValueSize() {
         return this.values.length / this.times.length
      }
      shift(e) {
         if (e !== 0) {
            const n = this.times;
            for (let r = 0, i = n.length; r !== i; ++r) n[r] += e
         }
         return this
      }
      scale(e) {
         if (e !== 1) {
            const n = this.times;
            for (let r = 0, i = n.length; r !== i; ++r) n[r] *= e
         }
         return this
      }
      trim(e, n) {
         const r = this.times,
            i = r.length;
         let s = 0,
            o = i - 1;
         for (; s !== i && r[s] < e;) ++s;
         for (; o !== -1 && r[o] > n;) --o;
         if (++o, s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1), s = o - 1);
            const a = this.getValueSize();
            this.times = Gi(r, s, o), this.values = Gi(this.values, s * a, o * a)
         }
         return this
      }
      validate() {
         let e = !0;
         const n = this.getValueSize();
         n - Math.floor(n) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
         const r = this.times,
            i = this.values,
            s = r.length;
         s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
         let o = null;
         for (let a = 0; a !== s; a++) {
            const l = r[a];
            if (typeof l == "number" && isNaN(l)) {
               console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
               break
            }
            if (o !== null && o > l) {
               console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
               break
            }
            o = l
         }
         if (i !== void 0 && gE(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
               const u = i[a];
               if (isNaN(u)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), e = !1;
                  break
               }
            }
         return e
      }
      optimize() {
         const e = Gi(this.times),
            n = Gi(this.values),
            r = this.getValueSize(),
            i = this.getInterpolation() === a0,
            s = e.length - 1;
         let o = 1;
         for (let a = 1; a < s; ++a) {
            let l = !1;
            const u = e[a],
               h = e[a + 1];
            if (u !== h && (a !== 1 || u !== e[0]))
               if (i) l = !0;
               else {
                  const d = a * r,
                     p = d - r,
                     m = d + r;
                  for (let v = 0; v !== r; ++v) {
                     const _ = n[d + v];
                     if (_ !== n[p + v] || _ !== n[m + v]) {
                        l = !0;
                        break
                     }
                  }
               } if (l) {
               if (a !== o) {
                  e[o] = e[a];
                  const d = a * r,
                     p = o * r;
                  for (let m = 0; m !== r; ++m) n[p + m] = n[d + m]
               }++o
            }
         }
         if (s > 0) {
            e[o] = e[s];
            for (let a = s * r, l = o * r, u = 0; u !== r; ++u) n[l + u] = n[a + u];
            ++o
         }
         return o !== e.length ? (this.times = Gi(e, 0, o), this.values = Gi(n, 0, o * r)) : (this.times = e, this.values = n), this
      }
      clone() {
         const e = Gi(this.times, 0),
            n = Gi(this.values, 0),
            r = this.constructor,
            i = new r(this.name, e, n);
         return i.createInterpolant = this.createInterpolant, i
      }
   }
   As.prototype.TimeBufferType = Float32Array;
   As.prototype.ValueBufferType = Float32Array;
   As.prototype.DefaultInterpolation = Yl;
   class iu extends As {}
   iu.prototype.ValueTypeName = "bool";
   iu.prototype.ValueBufferType = Array;
   iu.prototype.DefaultInterpolation = hf;
   iu.prototype.InterpolantFactoryMethodLinear = void 0;
   iu.prototype.InterpolantFactoryMethodSmooth = void 0;
   class xE extends As {}
   xE.prototype.ValueTypeName = "color";
   class gf extends As {}
   gf.prototype.ValueTypeName = "number";
   class ZF extends Bf {
      constructor(e, n, r, i) {
         super(e, n, r, i)
      }
      interpolate_(e, n, r, i) {
         const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (r - n) / (i - n);
         let u = e * a;
         for (let h = u + a; u !== h; u += 4) tr.slerpFlat(s, 0, o, u - a, o, u, l);
         return s
      }
   }
   class Na extends As {
      InterpolantFactoryMethodLinear(e) {
         return new ZF(this.times, this.values, this.getValueSize(), e)
      }
   }
   Na.prototype.ValueTypeName = "quaternion";
   Na.prototype.DefaultInterpolation = Yl;
   Na.prototype.InterpolantFactoryMethodSmooth = void 0;
   class su extends As {}
   su.prototype.ValueTypeName = "string";
   su.prototype.ValueBufferType = Array;
   su.prototype.DefaultInterpolation = hf;
   su.prototype.InterpolantFactoryMethodLinear = void 0;
   su.prototype.InterpolantFactoryMethodSmooth = void 0;
   class vf extends As {}
   vf.prototype.ValueTypeName = "vector";
   class yf {
      constructor(e, n = -1, r, i = Pv) {
         this.name = e, this.tracks = r, this.duration = n, this.blendMode = i, this.uuid = xi(), this.duration < 0 && this.resetDuration()
      }
      static parse(e) {
         const n = [],
            r = e.tracks,
            i = 1 / (e.fps || 1);
         for (let o = 0, a = r.length; o !== a; ++o) n.push(GW(r[o]).scale(i));
         const s = new this(e.name, e.duration, n, e.blendMode);
         return s.uuid = e.uuid, s
      }
      static toJSON(e) {
         const n = [],
            r = e.tracks,
            i = {
               name: e.name,
               duration: e.duration,
               tracks: n,
               uuid: e.uuid,
               blendMode: e.blendMode
            };
         for (let s = 0, o = r.length; s !== o; ++s) n.push(As.toJSON(r[s]));
         return i
      }
      static CreateFromMorphTargetSequence(e, n, r, i) {
         const s = n.length,
            o = [];
         for (let a = 0; a < s; a++) {
            let l = [],
               u = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0);
            const h = KF(l);
            l = qA(l, 1, h), u = qA(u, 1, h), !i && l[0] === 0 && (l.push(s), u.push(u[0])), o.push(new gf(".morphTargetInfluences[" + n[a].name + "]", l, u).scale(1 / r))
         }
         return new this(e, -1, o)
      }
      static findByName(e, n) {
         let r = e;
         if (!Array.isArray(e)) {
            const i = e;
            r = i.geometry && i.geometry.animations || i.animations
         }
         for (let i = 0; i < r.length; i++)
            if (r[i].name === n) return r[i];
         return null
      }
      static CreateClipsFromMorphTargetSequences(e, n, r) {
         const i = {},
            s = /^([\w-]*?)([\d]+)$/;
         for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a],
               h = u.name.match(s);
            if (h && h.length > 1) {
               const d = h[1];
               let p = i[d];
               p || (i[d] = p = []), p.push(u)
            }
         }
         const o = [];
         for (const a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], n, r));
         return o
      }
      static parseAnimation(e, n) {
         if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
         const r = function (d, p, m, v, _) {
               if (m.length !== 0) {
                  const x = [],
                     g = [];
                  vE(m, x, g, v), x.length !== 0 && _.push(new d(p, x, g))
               }
            },
            i = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
         let l = e.length || -1;
         const u = e.hierarchy || [];
         for (let d = 0; d < u.length; d++) {
            const p = u[d].keys;
            if (!(!p || p.length === 0))
               if (p[0].morphTargets) {
                  const m = {};
                  let v;
                  for (v = 0; v < p.length; v++)
                     if (p[v].morphTargets)
                        for (let _ = 0; _ < p[v].morphTargets.length; _++) m[p[v].morphTargets[_]] = -1;
                  for (const _ in m) {
                     const x = [],
                        g = [];
                     for (let S = 0; S !== p[v].morphTargets.length; ++S) {
                        const A = p[v];
                        x.push(A.time), g.push(A.morphTarget === _ ? 1 : 0)
                     }
                     i.push(new gf(".morphTargetInfluence[" + _ + "]", x, g))
                  }
                  l = m.length * o
               } else {
                  const m = ".bones[" + n[d].name + "]";
                  r(vf, m + ".position", p, "pos", i), r(Na, m + ".quaternion", p, "rot", i), r(vf, m + ".scale", p, "scl", i)
               }
         }
         return i.length === 0 ? null : new this(s, l, i, a)
      }
      resetDuration() {
         const e = this.tracks;
         let n = 0;
         for (let r = 0, i = e.length; r !== i; ++r) {
            const s = this.tracks[r];
            n = Math.max(n, s.times[s.times.length - 1])
         }
         return this.duration = n, this
      }
      trim() {
         for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
         return this
      }
      validate() {
         let e = !0;
         for (let n = 0; n < this.tracks.length; n++) e = e && this.tracks[n].validate();
         return e
      }
      optimize() {
         for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
         return this
      }
      clone() {
         const e = [];
         for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
         return new this.constructor(this.name, this.duration, e, this.blendMode)
      }
      toJSON() {
         return this.constructor.toJSON(this)
      }
   }

   function HW(t) {
      switch (t.toLowerCase()) {
         case "scalar":
         case "double":
         case "float":
         case "number":
         case "integer":
            return gf;
         case "vector":
         case "vector2":
         case "vector3":
         case "vector4":
            return vf;
         case "color":
            return xE;
         case "quaternion":
            return Na;
         case "bool":
         case "boolean":
            return iu;
         case "string":
            return su
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
   }

   function GW(t) {
      if (t.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      const e = HW(t.type);
      if (t.times === void 0) {
         const n = [],
            r = [];
         vE(t.keys, n, r, "value"), t.times = n, t.values = r
      }
      return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
   }
   const Zl = {
      enabled: !1,
      files: {},
      add: function (t, e) {
         this.enabled !== !1 && (this.files[t] = e)
      },
      get: function (t) {
         if (this.enabled !== !1) return this.files[t]
      },
      remove: function (t) {
         delete this.files[t]
      },
      clear: function () {
         this.files = {}
      }
   };
   class _E {
      constructor(e, n, r) {
         const i = this;
         let s = !1,
            o = 0,
            a = 0,
            l;
         const u = [];
         this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = r, this.itemStart = function (h) {
            a++, s === !1 && i.onStart !== void 0 && i.onStart(h, o, a), s = !0
         }, this.itemEnd = function (h) {
            o++, i.onProgress !== void 0 && i.onProgress(h, o, a), o === a && (s = !1, i.onLoad !== void 0 && i.onLoad())
         }, this.itemError = function (h) {
            i.onError !== void 0 && i.onError(h)
         }, this.resolveURL = function (h) {
            return l ? l(h) : h
         }, this.setURLModifier = function (h) {
            return l = h, this
         }, this.addHandler = function (h, d) {
            return u.push(h, d), this
         }, this.removeHandler = function (h) {
            const d = u.indexOf(h);
            return d !== -1 && u.splice(d, 2), this
         }, this.getHandler = function (h) {
            for (let d = 0, p = u.length; d < p; d += 2) {
               const m = u[d],
                  v = u[d + 1];
               if (m.global && (m.lastIndex = 0), m.test(h)) return v
            }
            return null
         }
      }
   }
   const qF = new _E;
   class Pr {
      constructor(e) {
         this.manager = e !== void 0 ? e : qF, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
      }
      load() {}
      loadAsync(e, n) {
         const r = this;
         return new Promise(function (i, s) {
            r.load(e, i, n, s)
         })
      }
      parse() {}
      setCrossOrigin(e) {
         return this.crossOrigin = e, this
      }
      setWithCredentials(e) {
         return this.withCredentials = e, this
      }
      setPath(e) {
         return this.path = e, this
      }
      setResourcePath(e) {
         return this.resourcePath = e, this
      }
      setRequestHeader(e) {
         return this.requestHeader = e, this
      }
   }
   Pr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
   const po = {};
   class zW extends Error {
      constructor(e, n) {
         super(e), this.response = n
      }
   }
   class Si extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
         const s = Zl.get(e);
         if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            n && n(s), this.manager.itemEnd(e)
         }, 0), s;
         if (po[e] !== void 0) {
            po[e].push({
               onLoad: n,
               onProgress: r,
               onError: i
            });
            return
         }
         po[e] = [], po[e].push({
            onLoad: n,
            onProgress: r,
            onError: i
         });
         const o = new Request(e, {
               headers: new Headers(this.requestHeader),
               credentials: this.withCredentials ? "include" : "same-origin"
            }),
            a = this.mimeType,
            l = this.responseType;
         fetch(o).then(u => {
            if (u.status === 200 || u.status === 0) {
               if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0) return u;
               const h = po[e],
                  d = u.body.getReader(),
                  p = u.headers.get("Content-Length") || u.headers.get("X-File-Size"),
                  m = p ? parseInt(p) : 0,
                  v = m !== 0;
               let _ = 0;
               const x = new ReadableStream({
                  start(g) {
                     S();

                     function S() {
                        d.read().then(({
                           done: A,
                           value: E
                        }) => {
                           if (A) g.close();
                           else {
                              _ += E.byteLength;
                              const C = new ProgressEvent("progress", {
                                 lengthComputable: v,
                                 loaded: _,
                                 total: m
                              });
                              for (let R = 0, B = h.length; R < B; R++) {
                                 const D = h[R];
                                 D.onProgress && D.onProgress(C)
                              }
                              g.enqueue(E), S()
                           }
                        })
                     }
                  }
               });
               return new Response(x)
            } else throw new zW(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u)
         }).then(u => {
            switch (l) {
               case "arraybuffer":
                  return u.arrayBuffer();
               case "blob":
                  return u.blob();
               case "document":
                  return u.text().then(h => new DOMParser().parseFromString(h, a));
               case "json":
                  return u.json();
               default:
                  if (a === void 0) return u.text(); {
                     const d = /charset="?([^;"\s]*)"?/i.exec(a),
                        p = d && d[1] ? d[1].toLowerCase() : void 0,
                        m = new TextDecoder(p);
                     return u.arrayBuffer().then(v => m.decode(v))
                  }
            }
         }).then(u => {
            Zl.add(e, u);
            const h = po[e];
            delete po[e];
            for (let d = 0, p = h.length; d < p; d++) {
               const m = h[d];
               m.onLoad && m.onLoad(u)
            }
         }).catch(u => {
            const h = po[e];
            if (h === void 0) throw this.manager.itemError(e), u;
            delete po[e];
            for (let d = 0, p = h.length; d < p; d++) {
               const m = h[d];
               m.onError && m.onError(u)
            }
            this.manager.itemError(e)
         }).finally(() => {
            this.manager.itemEnd(e)
         }), this.manager.itemStart(e)
      }
      setResponseType(e) {
         return this.responseType = e, this
      }
      setMimeType(e) {
         return this.mimeType = e, this
      }
   }
   class VW extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = this,
            o = new Si(this.manager);
         o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) {
            try {
               n(s.parse(JSON.parse(a)))
            } catch (l) {
               i ? i(l) : console.error(l), s.manager.itemError(e)
            }
         }, r, i)
      }
      parse(e) {
         const n = [];
         for (let r = 0; r < e.length; r++) {
            const i = yf.parse(e[r]);
            n.push(i)
         }
         return n
      }
   }
   class WW extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = this,
            o = [],
            a = new Uv,
            l = new Si(this.manager);
         l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
         let u = 0;

         function h(d) {
            l.load(e[d], function (p) {
               const m = s.parse(p, !0);
               o[d] = {
                  width: m.width,
                  height: m.height,
                  format: m.format,
                  mipmaps: m.mipmaps
               }, u += 1, u === 6 && (m.mipmapCount === 1 && (a.minFilter = ln), a.image = o, a.format = m.format, a.needsUpdate = !0, n && n(a))
            }, r, i)
         }
         if (Array.isArray(e))
            for (let d = 0, p = e.length; d < p; ++d) h(d);
         else l.load(e, function (d) {
            const p = s.parse(d, !0);
            if (p.isCubemap) {
               const m = p.mipmaps.length / p.mipmapCount;
               for (let v = 0; v < m; v++) {
                  o[v] = {
                     mipmaps: []
                  };
                  for (let _ = 0; _ < p.mipmapCount; _++) o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + _]), o[v].format = p.format, o[v].width = p.width, o[v].height = p.height
               }
               a.image = o
            } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps;
            p.mipmapCount === 1 && (a.minFilter = ln), a.format = p.format, a.needsUpdate = !0, n && n(a)
         }, r, i);
         return a
      }
   }
   class $d extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
         const s = this,
            o = Zl.get(e);
         if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () {
            n && n(o), s.manager.itemEnd(e)
         }, 0), o;
         const a = Hd("img");

         function l() {
            h(), Zl.add(e, this), n && n(this), s.manager.itemEnd(e)
         }

         function u(d) {
            h(), i && i(d), s.manager.itemError(e), s.manager.itemEnd(e)
         }

         function h() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", u, !1)
         }
         return a.addEventListener("load", l, !1), a.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
      }
   }
   class eO extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = new ap;
         s.colorSpace = Rt;
         const o = new $d(this.manager);
         o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
         let a = 0;

         function l(u) {
            o.load(e[u], function (h) {
               s.images[u] = h, a++, a === 6 && (s.needsUpdate = !0, n && n(s))
            }, void 0, i)
         }
         for (let u = 0; u < e.length; ++u) l(u);
         return s
      }
   }
   class AE extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = this,
            o = new qc,
            a = new Si(this.manager);
         return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function (l) {
            let u;
            try {
               u = s.parse(l)
            } catch (h) {
               if (i !== void 0) i(h);
               else {
                  console.error(h);
                  return
               }
            }
            if (!u) return i();
            u.image !== void 0 ? o.image = u.image : u.data !== void 0 && (o.image.width = u.width, o.image.height = u.height, o.image.data = u.data), o.wrapS = u.wrapS !== void 0 ? u.wrapS : hr, o.wrapT = u.wrapT !== void 0 ? u.wrapT : hr, o.magFilter = u.magFilter !== void 0 ? u.magFilter : ln, o.minFilter = u.minFilter !== void 0 ? u.minFilter : ln, o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.colorSpace !== void 0 ? o.colorSpace = u.colorSpace : u.encoding !== void 0 && (o.encoding = u.encoding), u.flipY !== void 0 && (o.flipY = u.flipY), u.format !== void 0 && (o.format = u.format), u.type !== void 0 && (o.type = u.type), u.mipmaps !== void 0 && (o.mipmaps = u.mipmaps, o.minFilter = Ys), u.mipmapCount === 1 && (o.minFilter = ln), u.generateMipmaps !== void 0 && (o.generateMipmaps = u.generateMipmaps), o.needsUpdate = !0, n && n(o, u)
         }, r, i), o
      }
   }
   class gp extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = new yn,
            o = new $d(this.manager);
         return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) {
            s.image = a, s.needsUpdate = !0, n !== void 0 && n(s)
         }, r, i), s
      }
   }
   class Ka extends Wt {
      constructor(e, n = 1) {
         super(), this.isLight = !0, this.type = "Light", this.color = new ke(e), this.intensity = n
      }
      dispose() {}
      copy(e, n) {
         return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), n
      }
   }
   class tO extends Ka {
      constructor(e, n, r) {
         super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Wt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ke(n)
      }
      copy(e, n) {
         return super.copy(e, n), this.groundColor.copy(e.groundColor), this
      }
   }
   const B_ = new yt,
      $R = new U,
      XR = new U;
   class SE {
      constructor(e) {
         this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Se(512, 512), this.map = null, this.mapPass = null, this.matrix = new yt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Iv, this._frameExtents = new Se(1, 1), this._viewportCount = 1, this._viewports = [new $t(0, 0, 1, 1)]
      }
      getViewportCount() {
         return this._viewportCount
      }
      getFrustum() {
         return this._frustum
      }
      updateMatrices(e) {
         const n = this.camera,
            r = this.matrix;
         $R.setFromMatrixPosition(e.matrixWorld), n.position.copy($R), XR.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(XR), n.updateMatrixWorld(), B_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(B_), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(B_)
      }
      getViewport(e) {
         return this._viewports[e]
      }
      getFrameExtents() {
         return this._frameExtents
      }
      dispose() {
         this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
      }
      copy(e) {
         return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
      }
      clone() {
         return new this.constructor().copy(this)
      }
      toJSON() {
         const e = {};
         return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
      }
   }
   class jW extends SE {
      constructor() {
         super(new Zn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
      }
      updateMatrices(e) {
         const n = this.camera,
            r = df * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            s = e.distance || n.far;
         (r !== n.fov || i !== n.aspect || s !== n.far) && (n.fov = r, n.aspect = i, n.far = s, n.updateProjectionMatrix()), super.updateMatrices(e)
      }
      copy(e) {
         return super.copy(e), this.focus = e.focus, this
      }
   }
   class ME extends Ka {
      constructor(e, n, r = 0, i = Math.PI / 3, s = 0, o = 2) {
         super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Wt.DEFAULT_UP), this.updateMatrix(), this.target = new Wt, this.distance = r, this.angle = i, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new jW
      }
      get power() {
         return this.intensity * Math.PI
      }
      set power(e) {
         this.intensity = e / Math.PI
      }
      dispose() {
         this.shadow.dispose()
      }
      copy(e, n) {
         return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
      }
   }
   const JR = new yt,
      wh = new U,
      I_ = new U;
   class $W extends SE {
      constructor() {
         super(new Zn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Se(4, 2), this._viewportCount = 6, this._viewports = [new $t(2, 1, 1, 1), new $t(0, 1, 1, 1), new $t(3, 1, 1, 1), new $t(1, 1, 1, 1), new $t(3, 0, 1, 1), new $t(1, 0, 1, 1)], this._cubeDirections = [new U(1, 0, 0), new U(-1, 0, 0), new U(0, 0, 1), new U(0, 0, -1), new U(0, 1, 0), new U(0, -1, 0)], this._cubeUps = [new U(0, 1, 0), new U(0, 1, 0), new U(0, 1, 0), new U(0, 1, 0), new U(0, 0, 1), new U(0, 0, -1)]
      }
      updateMatrices(e, n = 0) {
         const r = this.camera,
            i = this.matrix,
            s = e.distance || r.far;
         s !== r.far && (r.far = s, r.updateProjectionMatrix()), wh.setFromMatrixPosition(e.matrixWorld), r.position.copy(wh), I_.copy(r.position), I_.add(this._cubeDirections[n]), r.up.copy(this._cubeUps[n]), r.lookAt(I_), r.updateMatrixWorld(), i.makeTranslation(-wh.x, -wh.y, -wh.z), JR.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(JR)
      }
   }
   class EE extends Ka {
      constructor(e, n, r = 0, i = 2) {
         super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new $W
      }
      get power() {
         return this.intensity * 4 * Math.PI
      }
      set power(e) {
         this.intensity = e / (4 * Math.PI)
      }
      dispose() {
         this.shadow.dispose()
      }
      copy(e, n) {
         return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
      }
   }
   class XW extends SE {
      constructor() {
         super(new Tf(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
      }
   }
   class wE extends Ka {
      constructor(e, n) {
         super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Wt.DEFAULT_UP), this.updateMatrix(), this.target = new Wt, this.shadow = new XW
      }
      dispose() {
         this.shadow.dispose()
      }
      copy(e) {
         return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
      }
   }
   class nO extends Ka {
      constructor(e, n) {
         super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight"
      }
   }
   class rO extends Ka {
      constructor(e, n, r = 10, i = 10) {
         super(e, n), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i
      }
      get power() {
         return this.intensity * this.width * this.height * Math.PI
      }
      set power(e) {
         this.intensity = e / (this.width * this.height * Math.PI)
      }
      copy(e) {
         return super.copy(e), this.width = e.width, this.height = e.height, this
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return n.object.width = this.width, n.object.height = this.height, n
      }
   }
   class iO {
      constructor() {
         this.isSphericalHarmonics3 = !0, this.coefficients = [];
         for (let e = 0; e < 9; e++) this.coefficients.push(new U)
      }
      set(e) {
         for (let n = 0; n < 9; n++) this.coefficients[n].copy(e[n]);
         return this
      }
      zero() {
         for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
         return this
      }
      getAt(e, n) {
         const r = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
         return n.copy(o[0]).multiplyScalar(.282095), n.addScaledVector(o[1], .488603 * i), n.addScaledVector(o[2], .488603 * s), n.addScaledVector(o[3], .488603 * r), n.addScaledVector(o[4], 1.092548 * (r * i)), n.addScaledVector(o[5], 1.092548 * (i * s)), n.addScaledVector(o[6], .315392 * (3 * s * s - 1)), n.addScaledVector(o[7], 1.092548 * (r * s)), n.addScaledVector(o[8], .546274 * (r * r - i * i)), n
      }
      getIrradianceAt(e, n) {
         const r = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
         return n.copy(o[0]).multiplyScalar(.886227), n.addScaledVector(o[1], 2 * .511664 * i), n.addScaledVector(o[2], 2 * .511664 * s), n.addScaledVector(o[3], 2 * .511664 * r), n.addScaledVector(o[4], 2 * .429043 * r * i), n.addScaledVector(o[5], 2 * .429043 * i * s), n.addScaledVector(o[6], .743125 * s * s - .247708), n.addScaledVector(o[7], 2 * .429043 * r * s), n.addScaledVector(o[8], .429043 * (r * r - i * i)), n
      }
      add(e) {
         for (let n = 0; n < 9; n++) this.coefficients[n].add(e.coefficients[n]);
         return this
      }
      addScaledSH(e, n) {
         for (let r = 0; r < 9; r++) this.coefficients[r].addScaledVector(e.coefficients[r], n);
         return this
      }
      scale(e) {
         for (let n = 0; n < 9; n++) this.coefficients[n].multiplyScalar(e);
         return this
      }
      lerp(e, n) {
         for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], n);
         return this
      }
      equals(e) {
         for (let n = 0; n < 9; n++)
            if (!this.coefficients[n].equals(e.coefficients[n])) return !1;
         return !0
      }
      copy(e) {
         return this.set(e.coefficients)
      }
      clone() {
         return new this.constructor().copy(this)
      }
      fromArray(e, n = 0) {
         const r = this.coefficients;
         for (let i = 0; i < 9; i++) r[i].fromArray(e, n + i * 3);
         return this
      }
      toArray(e = [], n = 0) {
         const r = this.coefficients;
         for (let i = 0; i < 9; i++) r[i].toArray(e, n + i * 3);
         return e
      }
      static getBasisAt(e, n) {
         const r = e.x,
            i = e.y,
            s = e.z;
         n[0] = .282095, n[1] = .488603 * i, n[2] = .488603 * s, n[3] = .488603 * r, n[4] = 1.092548 * r * i, n[5] = 1.092548 * i * s, n[6] = .315392 * (3 * s * s - 1), n[7] = 1.092548 * r * s, n[8] = .546274 * (r * r - i * i)
      }
   }
   class qv extends Ka {
      constructor(e = new iO, n = 1) {
         super(void 0, n), this.isLightProbe = !0, this.sh = e
      }
      copy(e) {
         return super.copy(e), this.sh.copy(e.sh), this
      }
      fromJSON(e) {
         return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return n.object.sh = this.sh.toArray(), n
      }
   }
   class ey extends Pr {
      constructor(e) {
         super(e), this.textures = {}
      }
      load(e, n, r, i) {
         const s = this,
            o = new Si(s.manager);
         o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) {
            try {
               n(s.parse(JSON.parse(a)))
            } catch (l) {
               i ? i(l) : console.error(l), s.manager.itemError(e)
            }
         }, r, i)
      }
      parse(e) {
         const n = this.textures;

         function r(s) {
            return n[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), n[s]
         }
         const i = ey.createMaterialFromType(e.type);
         if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new ke().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== 1 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
            for (const s in e.uniforms) {
               const o = e.uniforms[s];
               switch (i.uniforms[s] = {}, o.type) {
                  case "t":
                     i.uniforms[s].value = r(o.value);
                     break;
                  case "c":
                     i.uniforms[s].value = new ke().setHex(o.value);
                     break;
                  case "v2":
                     i.uniforms[s].value = new Se().fromArray(o.value);
                     break;
                  case "v3":
                     i.uniforms[s].value = new U().fromArray(o.value);
                     break;
                  case "v4":
                     i.uniforms[s].value = new $t().fromArray(o.value);
                     break;
                  case "m3":
                     i.uniforms[s].value = new Ft().fromArray(o.value);
                     break;
                  case "m4":
                     i.uniforms[s].value = new yt().fromArray(o.value);
                     break;
                  default:
                     i.uniforms[s].value = o.value
               }
            }
         if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
            for (const s in e.extensions) i.extensions[s] = e.extensions[s];
         if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]), i.normalScale = new Se().fromArray(s)
         }
         return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Se().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i
      }
      setTextures(e) {
         return this.textures = e, this
      }
      static createMaterialFromType(e) {
         const n = {
            ShadowMaterial: zF,
            SpriteMaterial: iE,
            RawShaderMaterial: VF,
            ShaderMaterial: Qi,
            PointsMaterial: Nv,
            MeshPhysicalMaterial: Qs,
            MeshStandardMaterial: mp,
            MeshPhongMaterial: WF,
            MeshToonMaterial: jF,
            MeshNormalMaterial: $F,
            MeshLambertMaterial: mE,
            MeshDepthMaterial: tE,
            MeshDistanceMaterial: nE,
            MeshBasicMaterial: mi,
            MeshMatcapMaterial: XF,
            LineDashedMaterial: JF,
            LineBasicMaterial: Rr,
            Material: Jn
         };
         return new n[e]
      }
   }
   class js {
      static decodeText(e) {
         if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
         let n = "";
         for (let r = 0, i = e.length; r < i; r++) n += String.fromCharCode(e[r]);
         try {
            return decodeURIComponent(escape(n))
         } catch {
            return n
         }
      }
      static extractUrlBase(e) {
         const n = e.lastIndexOf("/");
         return n === -1 ? "./" : e.slice(0, n + 1)
      }
      static resolveURL(e, n) {
         return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(n) && /^\//.test(e) && (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : n + e)
      }
   }
   class sO extends Tt {
      constructor() {
         super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
      }
      copy(e) {
         return super.copy(e), this.instanceCount = e.instanceCount, this
      }
      toJSON() {
         const e = super.toJSON();
         return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
      }
   }
   class oO extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = this,
            o = new Si(s.manager);
         o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) {
            try {
               n(s.parse(JSON.parse(a)))
            } catch (l) {
               i ? i(l) : console.error(l), s.manager.itemError(e)
            }
         }, r, i)
      }
      parse(e) {
         const n = {},
            r = {};

         function i(m, v) {
            if (n[v] !== void 0) return n[v];
            const x = m.interleavedBuffers[v],
               g = s(m, x.buffer),
               S = Oc(x.type, g),
               A = new up(S, x.stride);
            return A.uuid = x.uuid, n[v] = A, A
         }

         function s(m, v) {
            if (r[v] !== void 0) return r[v];
            const x = m.arrayBuffers[v],
               g = new Uint32Array(x).buffer;
            return r[v] = g, g
         }
         const o = e.isInstancedBufferGeometry ? new sO : new Tt,
            a = e.data.index;
         if (a !== void 0) {
            const m = Oc(a.type, a.array);
            o.setIndex(new Zt(m, 1))
         }
         const l = e.data.attributes;
         for (const m in l) {
            const v = l[m];
            let _;
            if (v.isInterleavedBufferAttribute) {
               const x = i(e.data, v.data);
               _ = new Oa(x, v.itemSize, v.offset, v.normalized)
            } else {
               const x = Oc(v.type, v.array),
                  g = v.isInstancedBufferAttribute ? mf : Zt;
               _ = new g(x, v.itemSize, v.normalized)
            }
            v.name !== void 0 && (_.name = v.name), v.usage !== void 0 && _.setUsage(v.usage), v.updateRange !== void 0 && (_.updateRange.offset = v.updateRange.offset, _.updateRange.count = v.updateRange.count), o.setAttribute(m, _)
         }
         const u = e.data.morphAttributes;
         if (u)
            for (const m in u) {
               const v = u[m],
                  _ = [];
               for (let x = 0, g = v.length; x < g; x++) {
                  const S = v[x];
                  let A;
                  if (S.isInterleavedBufferAttribute) {
                     const E = i(e.data, S.data);
                     A = new Oa(E, S.itemSize, S.offset, S.normalized)
                  } else {
                     const E = Oc(S.type, S.array);
                     A = new Zt(E, S.itemSize, S.normalized)
                  }
                  S.name !== void 0 && (A.name = S.name), _.push(A)
               }
               o.morphAttributes[m] = _
            }
         e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
         const d = e.data.groups || e.data.drawcalls || e.data.offsets;
         if (d !== void 0)
            for (let m = 0, v = d.length; m !== v; ++m) {
               const _ = d[m];
               o.addGroup(_.start, _.count, _.materialIndex)
            }
         const p = e.data.boundingSphere;
         if (p !== void 0) {
            const m = new U;
            p.center !== void 0 && m.fromArray(p.center), o.boundingSphere = new Ci(m, p.radius)
         }
         return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
      }
   }
   class JW extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = this,
            o = this.path === "" ? js.extractUrlBase(e) : this.path;
         this.resourcePath = this.resourcePath || o;
         const a = new Si(this.manager);
         a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) {
            let u = null;
            try {
               u = JSON.parse(l)
            } catch (d) {
               i !== void 0 && i(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
               return
            }
            const h = u.metadata;
            if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
               i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
               return
            }
            s.parse(u, n)
         }, r, i)
      }
      async loadAsync(e, n) {
         const r = this,
            i = this.path === "" ? js.extractUrlBase(e) : this.path;
         this.resourcePath = this.resourcePath || i;
         const s = new Si(this.manager);
         s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
         const o = await s.loadAsync(e, n),
            a = JSON.parse(o),
            l = a.metadata;
         if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
         return await r.parseAsync(a)
      }
      parse(e, n) {
         const r = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            s = this.parseGeometries(e.geometries, i),
            o = this.parseImages(e.images, function () {
               n !== void 0 && n(u)
            }),
            a = this.parseTextures(e.textures, o),
            l = this.parseMaterials(e.materials, a),
            u = this.parseObject(e.object, s, l, a, r),
            h = this.parseSkeletons(e.skeletons, u);
         if (this.bindSkeletons(u, h), n !== void 0) {
            let d = !1;
            for (const p in o)
               if (o[p].data instanceof HTMLImageElement) {
                  d = !0;
                  break
               } d === !1 && n(u)
         }
         return u
      }
      async parseAsync(e) {
         const n = this.parseAnimations(e.animations),
            r = this.parseShapes(e.shapes),
            i = this.parseGeometries(e.geometries, r),
            s = await this.parseImagesAsync(e.images),
            o = this.parseTextures(e.textures, s),
            a = this.parseMaterials(e.materials, o),
            l = this.parseObject(e.object, i, a, o, n),
            u = this.parseSkeletons(e.skeletons, l);
         return this.bindSkeletons(l, u), l
      }
      parseShapes(e) {
         const n = {};
         if (e !== void 0)
            for (let r = 0, i = e.length; r < i; r++) {
               const s = new Vl().fromJSON(e[r]);
               n[s.uuid] = s
            }
         return n
      }
      parseSkeletons(e, n) {
         const r = {},
            i = {};
         if (n.traverse(function (s) {
               s.isBone && (i[s.uuid] = s)
            }), e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
               const a = new cp().fromJSON(e[s], i);
               r[a.uuid] = a
            }
         return r
      }
      parseGeometries(e, n) {
         const r = {};
         if (e !== void 0) {
            const i = new oO;
            for (let s = 0, o = e.length; s < o; s++) {
               let a;
               const l = e[s];
               switch (l.type) {
                  case "BufferGeometry":
                  case "InstancedBufferGeometry":
                     a = i.parse(l);
                     break;
                  default:
                     l.type in jR ? a = jR[l.type].fromJSON(l, n) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
               }
               a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), r[l.uuid] = a
            }
         }
         return r
      }
      parseMaterials(e, n) {
         const r = {},
            i = {};
         if (e !== void 0) {
            const s = new ey;
            s.setTextures(n);
            for (let o = 0, a = e.length; o < a; o++) {
               const l = e[o];
               r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)), i[l.uuid] = r[l.uuid]
            }
         }
         return i
      }
      parseAnimations(e) {
         const n = {};
         if (e !== void 0)
            for (let r = 0; r < e.length; r++) {
               const i = e[r],
                  s = yf.parse(i);
               n[s.uuid] = s
            }
         return n
      }
      parseImages(e, n) {
         const r = this,
            i = {};
         let s;

         function o(l) {
            return r.manager.itemStart(l), s.load(l, function () {
               r.manager.itemEnd(l)
            }, void 0, function () {
               r.manager.itemError(l), r.manager.itemEnd(l)
            })
         }

         function a(l) {
            if (typeof l == "string") {
               const u = l,
                  h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : r.resourcePath + u;
               return o(h)
            } else return l.data ? {
               data: Oc(l.type, l.data),
               width: l.width,
               height: l.height
            } : null
         }
         if (e !== void 0 && e.length > 0) {
            const l = new _E(n);
            s = new $d(l), s.setCrossOrigin(this.crossOrigin);
            for (let u = 0, h = e.length; u < h; u++) {
               const d = e[u],
                  p = d.url;
               if (Array.isArray(p)) {
                  const m = [];
                  for (let v = 0, _ = p.length; v < _; v++) {
                     const x = p[v],
                        g = a(x);
                     g !== null && (g instanceof HTMLImageElement ? m.push(g) : m.push(new qc(g.data, g.width, g.height)))
                  }
                  i[d.uuid] = new Ll(m)
               } else {
                  const m = a(d.url);
                  i[d.uuid] = new Ll(m)
               }
            }
         }
         return i
      }
      async parseImagesAsync(e) {
         const n = this,
            r = {};
         let i;
         async function s(o) {
            if (typeof o == "string") {
               const a = o,
                  l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : n.resourcePath + a;
               return await i.loadAsync(l)
            } else return o.data ? {
               data: Oc(o.type, o.data),
               width: o.width,
               height: o.height
            } : null
         }
         if (e !== void 0 && e.length > 0) {
            i = new $d(this.manager), i.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
               const l = e[o],
                  u = l.url;
               if (Array.isArray(u)) {
                  const h = [];
                  for (let d = 0, p = u.length; d < p; d++) {
                     const m = u[d],
                        v = await s(m);
                     v !== null && (v instanceof HTMLImageElement ? h.push(v) : h.push(new qc(v.data, v.width, v.height)))
                  }
                  r[l.uuid] = new Ll(h)
               } else {
                  const h = await s(l.url);
                  r[l.uuid] = new Ll(h)
               }
            }
         }
         return r
      }
      parseTextures(e, n) {
         function r(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s])
         }
         const i = {};
         if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
               const a = e[s];
               a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), n[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
               const l = n[a.image],
                  u = l.data;
               let h;
               Array.isArray(u) ? (h = new ap, u.length === 6 && (h.needsUpdate = !0)) : (u && u.data ? h = new qc : h = new yn, u && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = r(a.mapping, KW)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = r(a.wrap[0], KR), h.wrapT = r(a.wrap[1], KR)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = r(a.minFilter, YR)), a.magFilter !== void 0 && (h.magFilter = r(a.magFilter, YR)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), i[a.uuid] = h
            }
         return i
      }
      parseObject(e, n, r, i, s) {
         let o;

         function a(p) {
            return n[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), n[p]
         }

         function l(p) {
            if (p !== void 0) {
               if (Array.isArray(p)) {
                  const m = [];
                  for (let v = 0, _ = p.length; v < _; v++) {
                     const x = p[v];
                     r[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), m.push(r[x])
                  }
                  return m
               }
               return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), r[p]
            }
         }

         function u(p) {
            return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), i[p]
         }
         let h, d;
         switch (e.type) {
            case "Scene":
               o = new Gd, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new ke(e.background) : o.background = u(e.background)), e.environment !== void 0 && (o.environment = u(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new Fv(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Dv(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
               break;
            case "PerspectiveCamera":
               o = new Zn(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
               break;
            case "OrthographicCamera":
               o = new Tf(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
               break;
            case "AmbientLight":
               o = new nO(e.color, e.intensity);
               break;
            case "DirectionalLight":
               o = new wE(e.color, e.intensity);
               break;
            case "PointLight":
               o = new EE(e.color, e.intensity, e.distance, e.decay);
               break;
            case "RectAreaLight":
               o = new rO(e.color, e.intensity, e.width, e.height);
               break;
            case "SpotLight":
               o = new ME(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
               break;
            case "HemisphereLight":
               o = new tO(e.color, e.groundColor, e.intensity);
               break;
            case "LightProbe":
               o = new qv().fromJSON(e);
               break;
            case "SkinnedMesh":
               h = a(e.geometry), d = l(e.material), o = new sE(h, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
               break;
            case "Mesh":
               h = a(e.geometry), d = l(e.material), o = new Xn(h, d);
               break;
            case "InstancedMesh":
               h = a(e.geometry), d = l(e.material);
               const p = e.count,
                  m = e.instanceMatrix,
                  v = e.instanceColor;
               o = new oE(h, d, p), o.instanceMatrix = new mf(new Float32Array(m.array), 16), v !== void 0 && (o.instanceColor = new mf(new Float32Array(v.array), v.itemSize));
               break;
            case "LOD":
               o = new BF;
               break;
            case "Line":
               o = new Fo(a(e.geometry), l(e.material));
               break;
            case "LineLoop":
               o = new aE(a(e.geometry), l(e.material));
               break;
            case "LineSegments":
               o = new xs(a(e.geometry), l(e.material));
               break;
            case "PointCloud":
            case "Points":
               o = new lE(a(e.geometry), l(e.material));
               break;
            case "Sprite":
               o = new PF(l(e.material));
               break;
            case "Group":
               o = new Mo;
               break;
            case "Bone":
               o = new Ov;
               break;
            default:
               o = new Wt
         }
         if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
            const p = e.children;
            for (let m = 0; m < p.length; m++) o.add(this.parseObject(p[m], n, r, i, s))
         }
         if (e.animations !== void 0) {
            const p = e.animations;
            for (let m = 0; m < p.length; m++) {
               const v = p[m];
               o.animations.push(s[v])
            }
         }
         if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const p = e.levels;
            for (let m = 0; m < p.length; m++) {
               const v = p[m],
                  _ = o.getObjectByProperty("uuid", v.object);
               _ !== void 0 && o.addLevel(_, v.distance, v.hysteresis)
            }
         }
         return o
      }
      bindSkeletons(e, n) {
         Object.keys(n).length !== 0 && e.traverse(function (r) {
            if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
               const i = n[r.skeleton];
               i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix)
            }
         })
      }
   }
   const KW = {
         UVMapping: Cv,
         CubeReflectionMapping: Ks,
         CubeRefractionMapping: Da,
         EquirectangularReflectionMapping: cf,
         EquirectangularRefractionMapping: Fd,
         CubeUVReflectionMapping: bf
      },
      KR = {
         RepeatWrapping: Fa,
         ClampToEdgeWrapping: hr,
         MirroredRepeatWrapping: ff
      },
      YR = {
         NearestFilter: Fn,
         NearestMipmapNearestFilter: Od,
         NearestMipmapLinearFilter: Yc,
         LinearFilter: ln,
         LinearMipmapNearestFilter: Tv,
         LinearMipmapLinearFilter: Ys
      };
   class aO extends Pr {
      constructor(e) {
         super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
         }
      }
      setOptions(e) {
         return this.options = e, this
      }
      load(e, n, r, i) {
         e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
         const s = this,
            o = Zl.get(e);
         if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () {
            n && n(o), s.manager.itemEnd(e)
         }, 0), o;
         const a = {};
         a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function (l) {
            return l.blob()
         }).then(function (l) {
            return createImageBitmap(l, Object.assign(s.options, {
               colorSpaceConversion: "none"
            }))
         }).then(function (l) {
            Zl.add(e, l), n && n(l), s.manager.itemEnd(e)
         }).catch(function (l) {
            i && i(l), s.manager.itemError(e), s.manager.itemEnd(e)
         }), s.manager.itemStart(e)
      }
   }
   let Sg;
   class bE {
      static getContext() {
         return Sg === void 0 && (Sg = new(window.AudioContext || window.webkitAudioContext)), Sg
      }
      static setContext(e) {
         Sg = e
      }
   }
   class YW extends Pr {
      constructor(e) {
         super(e)
      }
      load(e, n, r, i) {
         const s = this,
            o = new Si(this.manager);
         o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (l) {
            try {
               const u = l.slice(0);
               bE.getContext().decodeAudioData(u, function (d) {
                  n(d)
               }, a)
            } catch (u) {
               a(u)
            }
         }, r, i);

         function a(l) {
            i ? i(l) : console.error(l), s.manager.itemError(e)
         }
      }
   }
   class QW extends qv {
      constructor(e, n, r = 1) {
         super(void 0, r), this.isHemisphereLightProbe = !0;
         const i = new ke().set(e),
            s = new ke().set(n),
            o = new U(i.r, i.g, i.b),
            a = new U(s.r, s.g, s.b),
            l = Math.sqrt(Math.PI),
            u = l * Math.sqrt(.75);
         this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(u)
      }
   }
   class ZW extends qv {
      constructor(e, n = 1) {
         super(void 0, n), this.isAmbientLightProbe = !0;
         const r = new ke().set(e);
         this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI))
      }
   }
   const QR = new yt,
      ZR = new yt,
      fl = new yt;
   class qW {
      constructor() {
         this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Zn, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Zn, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
         }
      }
      update(e) {
         const n = this._cache;
         if (n.focus !== e.focus || n.fov !== e.fov || n.aspect !== e.aspect * this.aspect || n.near !== e.near || n.far !== e.far || n.zoom !== e.zoom || n.eyeSep !== this.eyeSep) {
            n.focus = e.focus, n.fov = e.fov, n.aspect = e.aspect * this.aspect, n.near = e.near, n.far = e.far, n.zoom = e.zoom, n.eyeSep = this.eyeSep, fl.copy(e.projectionMatrix);
            const i = n.eyeSep / 2,
               s = i * n.near / n.focus,
               o = n.near * Math.tan(Gl * n.fov * .5) / n.zoom;
            let a, l;
            ZR.elements[12] = -i, QR.elements[12] = i, a = -o * n.aspect + s, l = o * n.aspect + s, fl.elements[0] = 2 * n.near / (l - a), fl.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(fl), a = -o * n.aspect - s, l = o * n.aspect - s, fl.elements[0] = 2 * n.near / (l - a), fl.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(fl)
         }
         this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(ZR), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(QR)
      }
   }
   class CE {
      constructor(e = !0) {
         this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
      }
      start() {
         this.startTime = qR(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
      }
      stop() {
         this.getElapsedTime(), this.running = !1, this.autoStart = !1
      }
      getElapsedTime() {
         return this.getDelta(), this.elapsedTime
      }
      getDelta() {
         let e = 0;
         if (this.autoStart && !this.running) return this.start(), 0;
         if (this.running) {
            const n = qR();
            e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e
         }
         return e
      }
   }

   function qR() {
      return (typeof performance > "u" ? Date : performance).now()
   }
   const hl = new U,
      e2 = new tr,
      e7 = new U,
      dl = new U;
   class t7 extends Wt {
      constructor() {
         super(), this.type = "AudioListener", this.context = bE.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new CE
      }
      getInput() {
         return this.gain
      }
      removeFilter() {
         return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
      }
      getFilter() {
         return this.filter
      }
      setFilter(e) {
         return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
      }
      getMasterVolume() {
         return this.gain.gain.value
      }
      setMasterVolume(e) {
         return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
      }
      updateMatrixWorld(e) {
         super.updateMatrixWorld(e);
         const n = this.context.listener,
            r = this.up;
         if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(hl, e2, e7), dl.set(0, 0, -1).applyQuaternion(e2), n.positionX) {
            const i = this.context.currentTime + this.timeDelta;
            n.positionX.linearRampToValueAtTime(hl.x, i), n.positionY.linearRampToValueAtTime(hl.y, i), n.positionZ.linearRampToValueAtTime(hl.z, i), n.forwardX.linearRampToValueAtTime(dl.x, i), n.forwardY.linearRampToValueAtTime(dl.y, i), n.forwardZ.linearRampToValueAtTime(dl.z, i), n.upX.linearRampToValueAtTime(r.x, i), n.upY.linearRampToValueAtTime(r.y, i), n.upZ.linearRampToValueAtTime(r.z, i)
         } else n.setPosition(hl.x, hl.y, hl.z), n.setOrientation(dl.x, dl.y, dl.z, r.x, r.y, r.z)
      }
   }
   class lO extends Wt {
      constructor(e) {
         super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
      }
      getOutput() {
         return this.gain
      }
      setNodeSource(e) {
         return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
      }
      setMediaElementSource(e) {
         return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
      }
      setMediaStreamSource(e) {
         return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
      }
      setBuffer(e) {
         return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
      }
      play(e = 0) {
         if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
         }
         if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
         }
         this._startedAt = this.context.currentTime + e;
         const n = this.context.createBufferSource();
         return n.buffer = this.buffer, n.loop = this.loop, n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.onended = this.onEnded.bind(this), n.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = n, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
      }
      pause() {
         if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
         }
         return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
      }
      stop() {
         if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
         }
         return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this
      }
      connect() {
         if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, n = this.filters.length; e < n; e++) this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
         } else this.source.connect(this.getOutput());
         return this._connected = !0, this
      }
      disconnect() {
         if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, n = this.filters.length; e < n; e++) this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
         } else this.source.disconnect(this.getOutput());
         return this._connected = !1, this
      }
      getFilters() {
         return this.filters
      }
      setFilters(e) {
         return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
      }
      setDetune(e) {
         if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
      }
      getDetune() {
         return this.detune
      }
      getFilter() {
         return this.getFilters()[0]
      }
      setFilter(e) {
         return this.setFilters(e ? [e] : [])
      }
      setPlaybackRate(e) {
         if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
         }
         return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
      }
      getPlaybackRate() {
         return this.playbackRate
      }
      onEnded() {
         this.isPlaying = !1
      }
      getLoop() {
         return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
      }
      setLoop(e) {
         if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
         }
         return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
      }
      setLoopStart(e) {
         return this.loopStart = e, this
      }
      setLoopEnd(e) {
         return this.loopEnd = e, this
      }
      getVolume() {
         return this.gain.gain.value
      }
      setVolume(e) {
         return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
      }
   }
   const pl = new U,
      t2 = new tr,
      n7 = new U,
      ml = new U;
   class r7 extends lO {
      constructor(e) {
         super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
      }
      connect() {
         super.connect(), this.panner.connect(this.gain)
      }
      disconnect() {
         super.disconnect(), this.panner.disconnect(this.gain)
      }
      getOutput() {
         return this.panner
      }
      getRefDistance() {
         return this.panner.refDistance
      }
      setRefDistance(e) {
         return this.panner.refDistance = e, this
      }
      getRolloffFactor() {
         return this.panner.rolloffFactor
      }
      setRolloffFactor(e) {
         return this.panner.rolloffFactor = e, this
      }
      getDistanceModel() {
         return this.panner.distanceModel
      }
      setDistanceModel(e) {
         return this.panner.distanceModel = e, this
      }
      getMaxDistance() {
         return this.panner.maxDistance
      }
      setMaxDistance(e) {
         return this.panner.maxDistance = e, this
      }
      setDirectionalCone(e, n, r) {
         return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = n, this.panner.coneOuterGain = r, this
      }
      updateMatrixWorld(e) {
         if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
         this.matrixWorld.decompose(pl, t2, n7), ml.set(0, 0, 1).applyQuaternion(t2);
         const n = this.panner;
         if (n.positionX) {
            const r = this.context.currentTime + this.listener.timeDelta;
            n.positionX.linearRampToValueAtTime(pl.x, r), n.positionY.linearRampToValueAtTime(pl.y, r), n.positionZ.linearRampToValueAtTime(pl.z, r), n.orientationX.linearRampToValueAtTime(ml.x, r), n.orientationY.linearRampToValueAtTime(ml.y, r), n.orientationZ.linearRampToValueAtTime(ml.z, r)
         } else n.setPosition(pl.x, pl.y, pl.z), n.setOrientation(ml.x, ml.y, ml.z)
      }
   }
   class i7 {
      constructor(e, n = 2048) {
         this.analyser = e.context.createAnalyser(), this.analyser.fftSize = n, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
      }
      getFrequencyData() {
         return this.analyser.getByteFrequencyData(this.data), this.data
      }
      getAverageFrequency() {
         let e = 0;
         const n = this.getFrequencyData();
         for (let r = 0; r < n.length; r++) e += n[r];
         return e / n.length
      }
   }
   class uO {
      constructor(e, n, r) {
         this.binding = e, this.valueSize = r;
         let i, s, o;
         switch (n) {
            case "quaternion":
               i = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
               break;
            case "string":
            case "bool":
               i = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
               break;
            default:
               i = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5)
         }
         this._mixBufferRegion = i, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
      }
      accumulate(e, n) {
         const r = this.buffer,
            i = this.valueSize,
            s = e * i + i;
         let o = this.cumulativeWeight;
         if (o === 0) {
            for (let a = 0; a !== i; ++a) r[s + a] = r[a];
            o = n
         } else {
            o += n;
            const a = n / o;
            this._mixBufferRegion(r, s, 0, a, i)
         }
         this.cumulativeWeight = o
      }
      accumulateAdditive(e) {
         const n = this.buffer,
            r = this.valueSize,
            i = r * this._addIndex;
         this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(n, i, 0, e, r), this.cumulativeWeightAdditive += e
      }
      apply(e) {
         const n = this.valueSize,
            r = this.buffer,
            i = e * n + n,
            s = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
         if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
            const l = n * this._origIndex;
            this._mixBufferRegion(r, i, l, 1 - s, n)
         }
         o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * n, 1, n);
         for (let l = n, u = n + n; l !== u; ++l)
            if (r[l] !== r[l + n]) {
               a.setValue(r, i);
               break
            }
      }
      saveOriginalState() {
         const e = this.binding,
            n = this.buffer,
            r = this.valueSize,
            i = r * this._origIndex;
         e.getValue(n, i);
         for (let s = r, o = i; s !== o; ++s) n[s] = n[i + s % r];
         this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
      }
      restoreOriginalState() {
         const e = this.valueSize * 3;
         this.binding.setValue(this.buffer, e)
      }
      _setAdditiveIdentityNumeric() {
         const e = this._addIndex * this.valueSize,
            n = e + this.valueSize;
         for (let r = e; r < n; r++) this.buffer[r] = 0
      }
      _setAdditiveIdentityQuaternion() {
         this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
      }
      _setAdditiveIdentityOther() {
         const e = this._origIndex * this.valueSize,
            n = this._addIndex * this.valueSize;
         for (let r = 0; r < this.valueSize; r++) this.buffer[n + r] = this.buffer[e + r]
      }
      _select(e, n, r, i, s) {
         if (i >= .5)
            for (let o = 0; o !== s; ++o) e[n + o] = e[r + o]
      }
      _slerp(e, n, r, i) {
         tr.slerpFlat(e, n, e, n, e, r, i)
      }
      _slerpAdditive(e, n, r, i, s) {
         const o = this._workIndex * s;
         tr.multiplyQuaternionsFlat(e, o, e, n, e, r), tr.slerpFlat(e, n, e, n, e, o, i)
      }
      _lerp(e, n, r, i, s) {
         const o = 1 - i;
         for (let a = 0; a !== s; ++a) {
            const l = n + a;
            e[l] = e[l] * o + e[r + a] * i
         }
      }
      _lerpAdditive(e, n, r, i, s) {
         for (let o = 0; o !== s; ++o) {
            const a = n + o;
            e[a] = e[a] + e[r + o] * i
         }
      }
   }
   const TE = "\\[\\]\\.:\\/",
      s7 = new RegExp("[" + TE + "]", "g"),
      RE = "[^" + TE + "]",
      o7 = "[^" + TE.replace("\\.", "") + "]",
      a7 = /((?:WC+[\/:])*)/.source.replace("WC", RE),
      l7 = /(WCOD+)?/.source.replace("WCOD", o7),
      u7 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", RE),
      c7 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", RE),
      f7 = new RegExp("^" + a7 + l7 + u7 + c7 + "$"),
      h7 = ["material", "materials", "bones", "map"];
   class d7 {
      constructor(e, n, r) {
         const i = r || jt.parseTrackName(n);
         this._targetGroup = e, this._bindings = e.subscribe_(n, i)
      }
      getValue(e, n) {
         this.bind();
         const r = this._targetGroup.nCachedObjects_,
            i = this._bindings[r];
         i !== void 0 && i.getValue(e, n)
      }
      setValue(e, n) {
         const r = this._bindings;
         for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i) r[i].setValue(e, n)
      }
      bind() {
         const e = this._bindings;
         for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n) e[n].bind()
      }
      unbind() {
         const e = this._bindings;
         for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n) e[n].unbind()
      }
   }
   class jt {
      constructor(e, n, r) {
         this.path = n, this.parsedPath = r || jt.parseTrackName(n), this.node = jt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
      }
      static create(e, n, r) {
         return e && e.isAnimationObjectGroup ? new jt.Composite(e, n, r) : new jt(e, n, r)
      }
      static sanitizeNodeName(e) {
         return e.replace(/\s/g, "_").replace(s7, "")
      }
      static parseTrackName(e) {
         const n = f7.exec(e);
         if (n === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
         const r = {
               nodeName: n[2],
               objectName: n[3],
               objectIndex: n[4],
               propertyName: n[5],
               propertyIndex: n[6]
            },
            i = r.nodeName && r.nodeName.lastIndexOf(".");
         if (i !== void 0 && i !== -1) {
            const s = r.nodeName.substring(i + 1);
            h7.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = s)
         }
         if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
         return r
      }
      static findNode(e, n) {
         if (n === void 0 || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid) return e;
         if (e.skeleton) {
            const r = e.skeleton.getBoneByName(n);
            if (r !== void 0) return r
         }
         if (e.children) {
            const r = function (s) {
                  for (let o = 0; o < s.length; o++) {
                     const a = s[o];
                     if (a.name === n || a.uuid === n) return a;
                     const l = r(a.children);
                     if (l) return l
                  }
                  return null
               },
               i = r(e.children);
            if (i) return i
         }
         return null
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(e, n) {
         e[n] = this.targetObject[this.propertyName]
      }
      _getValue_array(e, n) {
         const r = this.resolvedProperty;
         for (let i = 0, s = r.length; i !== s; ++i) e[n++] = r[i]
      }
      _getValue_arrayElement(e, n) {
         e[n] = this.resolvedProperty[this.propertyIndex]
      }
      _getValue_toArray(e, n) {
         this.resolvedProperty.toArray(e, n)
      }
      _setValue_direct(e, n) {
         this.targetObject[this.propertyName] = e[n]
      }
      _setValue_direct_setNeedsUpdate(e, n) {
         this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
         this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_array(e, n) {
         const r = this.resolvedProperty;
         for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++]
      }
      _setValue_array_setNeedsUpdate(e, n) {
         const r = this.resolvedProperty;
         for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++];
         this.targetObject.needsUpdate = !0
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
         const r = this.resolvedProperty;
         for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++];
         this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_arrayElement(e, n) {
         this.resolvedProperty[this.propertyIndex] = e[n]
      }
      _setValue_arrayElement_setNeedsUpdate(e, n) {
         this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
         this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_fromArray(e, n) {
         this.resolvedProperty.fromArray(e, n)
      }
      _setValue_fromArray_setNeedsUpdate(e, n) {
         this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
         this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _getValue_unbound(e, n) {
         this.bind(), this.getValue(e, n)
      }
      _setValue_unbound(e, n) {
         this.bind(), this.setValue(e, n)
      }
      bind() {
         let e = this.node;
         const n = this.parsedPath,
            r = n.objectName,
            i = n.propertyName;
         let s = n.propertyIndex;
         if (e || (e = jt.findNode(this.rootNode, n.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
         }
         if (r) {
            let u = n.objectIndex;
            switch (r) {
               case "materials":
                  if (!e.material) {
                     console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                     return
                  }
                  if (!e.material.materials) {
                     console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                     return
                  }
                  e = e.material.materials;
                  break;
               case "bones":
                  if (!e.skeleton) {
                     console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                     return
                  }
                  e = e.skeleton.bones;
                  for (let h = 0; h < e.length; h++)
                     if (e[h].name === u) {
                        u = h;
                        break
                     } break;
               case "map":
                  if ("map" in e) {
                     e = e.map;
                     break
                  }
                  if (!e.material) {
                     console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                     return
                  }
                  if (!e.material.map) {
                     console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                     return
                  }
                  e = e.material.map;
                  break;
               default:
                  if (e[r] === void 0) {
                     console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                     return
                  }
                  e = e[r]
            }
            if (u !== void 0) {
               if (e[u] === void 0) {
                  console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                  return
               }
               e = e[u]
            }
         }
         const o = e[i];
         if (o === void 0) {
            const u = n.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e);
            return
         }
         let a = this.Versioning.None;
         this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
         let l = this.BindingType.Direct;
         if (s !== void 0) {
            if (i === "morphTargetInfluences") {
               if (!e.geometry) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                  return
               }
               if (!e.geometry.morphAttributes) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  return
               }
               e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
         } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
         this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
      }
      unbind() {
         this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
      }
   }
   jt.Composite = d7;
   jt.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
   };
   jt.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
   };
   jt.prototype.GetterByBindingType = [jt.prototype._getValue_direct, jt.prototype._getValue_array, jt.prototype._getValue_arrayElement, jt.prototype._getValue_toArray];
   jt.prototype.SetterByBindingTypeAndVersioning = [
      [jt.prototype._setValue_direct, jt.prototype._setValue_direct_setNeedsUpdate, jt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
      [jt.prototype._setValue_array, jt.prototype._setValue_array_setNeedsUpdate, jt.prototype._setValue_array_setMatrixWorldNeedsUpdate],
      [jt.prototype._setValue_arrayElement, jt.prototype._setValue_arrayElement_setNeedsUpdate, jt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
      [jt.prototype._setValue_fromArray, jt.prototype._setValue_fromArray_setNeedsUpdate, jt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
   ];
   class p7 {
      constructor() {
         this.isAnimationObjectGroup = !0, this.uuid = xi(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
         const e = {};
         this._indicesByUUID = e;
         for (let r = 0, i = arguments.length; r !== i; ++r) e[arguments[r].uuid] = r;
         this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
         const n = this;
         this.stats = {
            objects: {
               get total() {
                  return n._objects.length
               },
               get inUse() {
                  return this.total - n.nCachedObjects_
               }
            },
            get bindingsPerObject() {
               return n._bindings.length
            }
         }
      }
      add() {
         const e = this._objects,
            n = this._indicesByUUID,
            r = this._paths,
            i = this._parsedPaths,
            s = this._bindings,
            o = s.length;
         let a, l = e.length,
            u = this.nCachedObjects_;
         for (let h = 0, d = arguments.length; h !== d; ++h) {
            const p = arguments[h],
               m = p.uuid;
            let v = n[m];
            if (v === void 0) {
               v = l++, n[m] = v, e.push(p);
               for (let _ = 0, x = o; _ !== x; ++_) s[_].push(new jt(p, r[_], i[_]))
            } else if (v < u) {
               a = e[v];
               const _ = --u,
                  x = e[_];
               n[x.uuid] = v, e[v] = x, n[m] = _, e[_] = p;
               for (let g = 0, S = o; g !== S; ++g) {
                  const A = s[g],
                     E = A[_];
                  let C = A[v];
                  A[v] = E, C === void 0 && (C = new jt(p, r[g], i[g])), A[_] = C
               }
            } else e[v] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
         }
         this.nCachedObjects_ = u
      }
      remove() {
         const e = this._objects,
            n = this._indicesByUUID,
            r = this._bindings,
            i = r.length;
         let s = this.nCachedObjects_;
         for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o],
               u = l.uuid,
               h = n[u];
            if (h !== void 0 && h >= s) {
               const d = s++,
                  p = e[d];
               n[p.uuid] = h, e[h] = p, n[u] = d, e[d] = l;
               for (let m = 0, v = i; m !== v; ++m) {
                  const _ = r[m],
                     x = _[d],
                     g = _[h];
                  _[h] = x, _[d] = g
               }
            }
         }
         this.nCachedObjects_ = s
      }
      uncache() {
         const e = this._objects,
            n = this._indicesByUUID,
            r = this._bindings,
            i = r.length;
         let s = this.nCachedObjects_,
            o = e.length;
         for (let a = 0, l = arguments.length; a !== l; ++a) {
            const u = arguments[a],
               h = u.uuid,
               d = n[h];
            if (d !== void 0)
               if (delete n[h], d < s) {
                  const p = --s,
                     m = e[p],
                     v = --o,
                     _ = e[v];
                  n[m.uuid] = d, e[d] = m, n[_.uuid] = p, e[p] = _, e.pop();
                  for (let x = 0, g = i; x !== g; ++x) {
                     const S = r[x],
                        A = S[p],
                        E = S[v];
                     S[d] = A, S[p] = E, S.pop()
                  }
               } else {
                  const p = --o,
                     m = e[p];
                  p > 0 && (n[m.uuid] = d), e[d] = m, e.pop();
                  for (let v = 0, _ = i; v !== _; ++v) {
                     const x = r[v];
                     x[d] = x[p], x.pop()
                  }
               }
         }
         this.nCachedObjects_ = s
      }
      subscribe_(e, n) {
         const r = this._bindingsIndicesByPath;
         let i = r[e];
         const s = this._bindings;
         if (i !== void 0) return s[i];
         const o = this._paths,
            a = this._parsedPaths,
            l = this._objects,
            u = l.length,
            h = this.nCachedObjects_,
            d = new Array(u);
         i = s.length, r[e] = i, o.push(e), a.push(n), s.push(d);
         for (let p = h, m = l.length; p !== m; ++p) {
            const v = l[p];
            d[p] = new jt(v, e, n)
         }
         return d
      }
      unsubscribe_(e) {
         const n = this._bindingsIndicesByPath,
            r = n[e];
         if (r !== void 0) {
            const i = this._paths,
               s = this._parsedPaths,
               o = this._bindings,
               a = o.length - 1,
               l = o[a],
               u = e[a];
            n[u] = r, o[r] = l, o.pop(), s[r] = s[a], s.pop(), i[r] = i[a], i.pop()
         }
      }
   }
   class cO {
      constructor(e, n, r = null, i = n.blendMode) {
         this._mixer = e, this._clip = n, this._localRoot = r, this.blendMode = i;
         const s = n.tracks,
            o = s.length,
            a = new Array(o),
            l = {
               endingStart: Bl,
               endingEnd: Bl
            };
         for (let u = 0; u !== o; ++u) {
            const h = s[u].createInterpolant(null);
            a[u] = h, h.settings = l
         }
         this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = q3, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
      }
      play() {
         return this._mixer._activateAction(this), this
      }
      stop() {
         return this._mixer._deactivateAction(this), this.reset()
      }
      reset() {
         return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
      }
      isRunning() {
         return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
      }
      isScheduled() {
         return this._mixer._isActiveAction(this)
      }
      startAt(e) {
         return this._startTime = e, this
      }
      setLoop(e, n) {
         return this.loop = e, this.repetitions = n, this
      }
      setEffectiveWeight(e) {
         return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
      }
      getEffectiveWeight() {
         return this._effectiveWeight
      }
      fadeIn(e) {
         return this._scheduleFading(e, 0, 1)
      }
      fadeOut(e) {
         return this._scheduleFading(e, 1, 0)
      }
      crossFadeFrom(e, n, r) {
         if (e.fadeOut(n), this.fadeIn(n), r) {
            const i = this._clip.duration,
               s = e._clip.duration,
               o = s / i,
               a = i / s;
            e.warp(1, o, n), this.warp(a, 1, n)
         }
         return this
      }
      crossFadeTo(e, n, r) {
         return e.crossFadeFrom(this, n, r)
      }
      stopFading() {
         const e = this._weightInterpolant;
         return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
      }
      setEffectiveTimeScale(e) {
         return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
      }
      getEffectiveTimeScale() {
         return this._effectiveTimeScale
      }
      setDuration(e) {
         return this.timeScale = this._clip.duration / e, this.stopWarping()
      }
      syncWith(e) {
         return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
      }
      halt(e) {
         return this.warp(this._effectiveTimeScale, 0, e)
      }
      warp(e, n, r) {
         const i = this._mixer,
            s = i.time,
            o = this.timeScale;
         let a = this._timeScaleInterpolant;
         a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
         const l = a.parameterPositions,
            u = a.sampleValues;
         return l[0] = s, l[1] = s + r, u[0] = e / o, u[1] = n / o, this
      }
      stopWarping() {
         const e = this._timeScaleInterpolant;
         return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
      }
      getMixer() {
         return this._mixer
      }
      getClip() {
         return this._clip
      }
      getRoot() {
         return this._localRoot || this._mixer._root
      }
      _update(e, n, r, i) {
         if (!this.enabled) {
            this._updateWeight(e);
            return
         }
         const s = this._startTime;
         if (s !== null) {
            const l = (e - s) * r;
            l < 0 || r === 0 ? n = 0 : (this._startTime = null, n = r * l)
         }
         n *= this._updateTimeScale(e);
         const o = this._updateTime(n),
            a = this._updateWeight(e);
         if (a > 0) {
            const l = this._interpolants,
               u = this._propertyBindings;
            switch (this.blendMode) {
               case VM:
                  for (let h = 0, d = l.length; h !== d; ++h) l[h].evaluate(o), u[h].accumulateAdditive(a);
                  break;
               case Pv:
               default:
                  for (let h = 0, d = l.length; h !== d; ++h) l[h].evaluate(o), u[h].accumulate(i, a)
            }
         }
      }
      _updateWeight(e) {
         let n = 0;
         if (this.enabled) {
            n = this.weight;
            const r = this._weightInterpolant;
            if (r !== null) {
               const i = r.evaluate(e)[0];
               n *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1))
            }
         }
         return this._effectiveWeight = n, n
      }
      _updateTimeScale(e) {
         let n = 0;
         if (!this.paused) {
            n = this.timeScale;
            const r = this._timeScaleInterpolant;
            if (r !== null) {
               const i = r.evaluate(e)[0];
               n *= i, e > r.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n)
            }
         }
         return this._effectiveTimeScale = n, n
      }
      _updateTime(e) {
         const n = this._clip.duration,
            r = this.loop;
         let i = this.time + e,
            s = this._loopCount;
         const o = r === eF;
         if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? n - i : i;
         if (r === Z3) {
            s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            e: {
               if (i >= n) i = n;
               else if (i < 0) i = 0;
               else {
                  this.time = i;
                  break e
               }
               this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
               this.time = i,
               this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1
               })
            }
         } else {
            if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), i >= n || i < 0) {
               const a = Math.floor(i / n);
               i -= n * a, s += Math.abs(a);
               const l = this.repetitions - s;
               if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? n : 0, this.time = i, this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e > 0 ? 1 : -1
               });
               else {
                  if (l === 1) {
                     const u = e < 0;
                     this._setEndings(u, !u, o)
                  } else this._setEndings(!1, !1, o);
                  this._loopCount = s, this.time = i, this._mixer.dispatchEvent({
                     type: "loop",
                     action: this,
                     loopDelta: a
                  })
               }
            } else this.time = i;
            if (o && (s & 1) === 1) return n - i
         }
         return i
      }
      _setEndings(e, n, r) {
         const i = this._interpolantSettings;
         r ? (i.endingStart = Il, i.endingEnd = Il) : (e ? i.endingStart = this.zeroSlopeAtStart ? Il : Bl : i.endingStart = Nd, n ? i.endingEnd = this.zeroSlopeAtEnd ? Il : Bl : i.endingEnd = Nd)
      }
      _scheduleFading(e, n, r) {
         const i = this._mixer,
            s = i.time;
         let o = this._weightInterpolant;
         o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
         const a = o.parameterPositions,
            l = o.sampleValues;
         return a[0] = s, l[0] = n, a[1] = s + e, l[1] = r, this
      }
   }
   const m7 = new Float32Array(1);
   class g7 extends Uo {
      constructor(e) {
         super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
      }
      _bindAction(e, n) {
         const r = e._localRoot || this._root,
            i = e._clip.tracks,
            s = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = r.uuid,
            u = this._bindingsByRootAndName;
         let h = u[l];
         h === void 0 && (h = {}, u[l] = h);
         for (let d = 0; d !== s; ++d) {
            const p = i[d],
               m = p.name;
            let v = h[m];
            if (v !== void 0) ++v.referenceCount, o[d] = v;
            else {
               if (v = o[d], v !== void 0) {
                  v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, l, m));
                  continue
               }
               const _ = n && n._propertyBindings[d].binding.parsedPath;
               v = new uO(jt.create(r, m, _), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, l, m), o[d] = v
            }
            a[d].resultBuffer = v.buffer
         }
      }
      _activateAction(e) {
         if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
               const r = (e._localRoot || this._root).uuid,
                  i = e._clip.uuid,
                  s = this._actionsByClip[i];
               this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, i, r)
            }
            const n = e._propertyBindings;
            for (let r = 0, i = n.length; r !== i; ++r) {
               const s = n[r];
               s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState())
            }
            this._lendAction(e)
         }
      }
      _deactivateAction(e) {
         if (this._isActiveAction(e)) {
            const n = e._propertyBindings;
            for (let r = 0, i = n.length; r !== i; ++r) {
               const s = n[r];
               --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s))
            }
            this._takeBackAction(e)
         }
      }
      _initMemoryManager() {
         this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
         const e = this;
         this.stats = {
            actions: {
               get total() {
                  return e._actions.length
               },
               get inUse() {
                  return e._nActiveActions
               }
            },
            bindings: {
               get total() {
                  return e._bindings.length
               },
               get inUse() {
                  return e._nActiveBindings
               }
            },
            controlInterpolants: {
               get total() {
                  return e._controlInterpolants.length
               },
               get inUse() {
                  return e._nActiveControlInterpolants
               }
            }
         }
      }
      _isActiveAction(e) {
         const n = e._cacheIndex;
         return n !== null && n < this._nActiveActions
      }
      _addInactiveAction(e, n, r) {
         const i = this._actions,
            s = this._actionsByClip;
         let o = s[n];
         if (o === void 0) o = {
            knownActions: [e],
            actionByRoot: {}
         }, e._byClipCacheIndex = 0, s[n] = o;
         else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length, a.push(e)
         }
         e._cacheIndex = i.length, i.push(e), o.actionByRoot[r] = e
      }
      _removeInactiveAction(e) {
         const n = this._actions,
            r = n[n.length - 1],
            i = e._cacheIndex;
         r._cacheIndex = i, n[i] = r, n.pop(), e._cacheIndex = null;
         const s = e._clip.uuid,
            o = this._actionsByClip,
            a = o[s],
            l = a.knownActions,
            u = l[l.length - 1],
            h = e._byClipCacheIndex;
         u._byClipCacheIndex = h, l[h] = u, l.pop(), e._byClipCacheIndex = null;
         const d = a.actionByRoot,
            p = (e._localRoot || this._root).uuid;
         delete d[p], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e)
      }
      _removeInactiveBindingsForAction(e) {
         const n = e._propertyBindings;
         for (let r = 0, i = n.length; r !== i; ++r) {
            const s = n[r];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
         }
      }
      _lendAction(e) {
         const n = this._actions,
            r = e._cacheIndex,
            i = this._nActiveActions++,
            s = n[i];
         e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
      }
      _takeBackAction(e) {
         const n = this._actions,
            r = e._cacheIndex,
            i = --this._nActiveActions,
            s = n[i];
         e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
      }
      _addInactiveBinding(e, n, r) {
         const i = this._bindingsByRootAndName,
            s = this._bindings;
         let o = i[n];
         o === void 0 && (o = {}, i[n] = o), o[r] = e, e._cacheIndex = s.length, s.push(e)
      }
      _removeInactiveBinding(e) {
         const n = this._bindings,
            r = e.binding,
            i = r.rootNode.uuid,
            s = r.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            l = n[n.length - 1],
            u = e._cacheIndex;
         l._cacheIndex = u, n[u] = l, n.pop(), delete a[s], Object.keys(a).length === 0 && delete o[i]
      }
      _lendBinding(e) {
         const n = this._bindings,
            r = e._cacheIndex,
            i = this._nActiveBindings++,
            s = n[i];
         e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
      }
      _takeBackBinding(e) {
         const n = this._bindings,
            r = e._cacheIndex,
            i = --this._nActiveBindings,
            s = n[i];
         e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
      }
      _lendControlInterpolant() {
         const e = this._controlInterpolants,
            n = this._nActiveControlInterpolants++;
         let r = e[n];
         return r === void 0 && (r = new yE(new Float32Array(2), new Float32Array(2), 1, m7), r.__cacheIndex = n, e[n] = r), r
      }
      _takeBackControlInterpolant(e) {
         const n = this._controlInterpolants,
            r = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            s = n[i];
         e.__cacheIndex = i, n[i] = e, s.__cacheIndex = r, n[r] = s
      }
      clipAction(e, n, r) {
         const i = n || this._root,
            s = i.uuid;
         let o = typeof e == "string" ? yf.findByName(i, e) : e;
         const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
         let u = null;
         if (r === void 0 && (o !== null ? r = o.blendMode : r = Pv), l !== void 0) {
            const d = l.actionByRoot[s];
            if (d !== void 0 && d.blendMode === r) return d;
            u = l.knownActions[0], o === null && (o = u._clip)
         }
         if (o === null) return null;
         const h = new cO(this, o, n, r);
         return this._bindAction(h, u), this._addInactiveAction(h, a, s), h
      }
      existingAction(e, n) {
         const r = n || this._root,
            i = r.uuid,
            s = typeof e == "string" ? yf.findByName(r, e) : e,
            o = s ? s.uuid : e,
            a = this._actionsByClip[o];
         return a !== void 0 && a.actionByRoot[i] || null
      }
      stopAllAction() {
         const e = this._actions,
            n = this._nActiveActions;
         for (let r = n - 1; r >= 0; --r) e[r].stop();
         return this
      }
      update(e) {
         e *= this.timeScale;
         const n = this._actions,
            r = this._nActiveActions,
            i = this.time += e,
            s = Math.sign(e),
            o = this._accuIndex ^= 1;
         for (let u = 0; u !== r; ++u) n[u]._update(i, e, s, o);
         const a = this._bindings,
            l = this._nActiveBindings;
         for (let u = 0; u !== l; ++u) a[u].apply(o);
         return this
      }
      setTime(e) {
         this.time = 0;
         for (let n = 0; n < this._actions.length; n++) this._actions[n].time = 0;
         return this.update(e)
      }
      getRoot() {
         return this._root
      }
      uncacheClip(e) {
         const n = this._actions,
            r = e.uuid,
            i = this._actionsByClip,
            s = i[r];
         if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
               const u = o[a];
               this._deactivateAction(u);
               const h = u._cacheIndex,
                  d = n[n.length - 1];
               u._cacheIndex = null, u._byClipCacheIndex = null, d._cacheIndex = h, n[h] = d, n.pop(), this._removeInactiveBindingsForAction(u)
            }
            delete i[r]
         }
      }
      uncacheRoot(e) {
         const n = e.uuid,
            r = this._actionsByClip;
         for (const o in r) {
            const a = r[o].actionByRoot,
               l = a[n];
            l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
         }
         const i = this._bindingsByRootAndName,
            s = i[n];
         if (s !== void 0)
            for (const o in s) {
               const a = s[o];
               a.restoreOriginalState(), this._removeInactiveBinding(a)
            }
      }
      uncacheAction(e, n) {
         const r = this.existingAction(e, n);
         r !== null && (this._deactivateAction(r), this._removeInactiveAction(r))
      }
   }
   class PE {
      constructor(e) {
         this.value = e
      }
      clone() {
         return new PE(this.value.clone === void 0 ? this.value : this.value.clone())
      }
   }
   let v7 = 0;
   class y7 extends Uo {
      constructor() {
         super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
            value: v7++
         }), this.name = "", this.usage = Ud, this.uniforms = []
      }
      add(e) {
         return this.uniforms.push(e), this
      }
      remove(e) {
         const n = this.uniforms.indexOf(e);
         return n !== -1 && this.uniforms.splice(n, 1), this
      }
      setName(e) {
         return this.name = e, this
      }
      setUsage(e) {
         return this.usage = e, this
      }
      dispose() {
         return this.dispatchEvent({
            type: "dispose"
         }), this
      }
      copy(e) {
         this.name = e.name, this.usage = e.usage;
         const n = e.uniforms;
         this.uniforms.length = 0;
         for (let r = 0, i = n.length; r < i; r++) this.uniforms.push(n[r].clone());
         return this
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   class x7 extends up {
      constructor(e, n, r = 1) {
         super(e, n), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r
      }
      copy(e) {
         return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
      }
      clone(e) {
         const n = super.clone(e);
         return n.meshPerAttribute = this.meshPerAttribute, n
      }
      toJSON(e) {
         const n = super.toJSON(e);
         return n.isInstancedInterleavedBuffer = !0, n.meshPerAttribute = this.meshPerAttribute, n
      }
   }
   class _7 {
      constructor(e, n, r, i, s) {
         this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = n, this.itemSize = r, this.elementSize = i, this.count = s, this.version = 0
      }
      set needsUpdate(e) {
         e === !0 && this.version++
      }
      setBuffer(e) {
         return this.buffer = e, this
      }
      setType(e, n) {
         return this.type = e, this.elementSize = n, this
      }
      setItemSize(e) {
         return this.itemSize = e, this
      }
      setCount(e) {
         return this.count = e, this
      }
   }
   class BE {
      constructor(e, n, r = 0, i = 1 / 0) {
         this.ray = new Cf(e, n), this.near = r, this.far = i, this.camera = null, this.layers = new zl, this.params = {
            Mesh: {},
            Line: {
               threshold: 1
            },
            LOD: {},
            Points: {
               threshold: 1
            },
            Sprite: {}
         }
      }
      set(e, n) {
         this.ray.set(e, n)
      }
      setFromCamera(e, n) {
         n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type)
      }
      intersectObject(e, n = !0, r = []) {
         return eS(e, this, r, n), r.sort(n2), r
      }
      intersectObjects(e, n = !0, r = []) {
         for (let i = 0, s = e.length; i < s; i++) eS(e[i], this, r, n);
         return r.sort(n2), r
      }
   }

   function n2(t, e) {
      return t.distance - e.distance
   }

   function eS(t, e, n, r) {
      if (t.layers.test(e.layers) && t.raycast(e, n), r === !0) {
         const i = t.children;
         for (let s = 0, o = i.length; s < o; s++) eS(i[s], e, n, !0)
      }
   }
   class fO {
      constructor(e = 1, n = 0, r = 0) {
         return this.radius = e, this.phi = n, this.theta = r, this
      }
      set(e, n, r) {
         return this.radius = e, this.phi = n, this.theta = r, this
      }
      copy(e) {
         return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
      }
      makeSafe() {
         return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
      }
      setFromVector3(e) {
         return this.setFromCartesianCoords(e.x, e.y, e.z)
      }
      setFromCartesianCoords(e, n, r) {
         return this.radius = Math.sqrt(e * e + n * n + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(On(n / this.radius, -1, 1))), this
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   class A7 {
      constructor(e = 1, n = 0, r = 0) {
         return this.radius = e, this.theta = n, this.y = r, this
      }
      set(e, n, r) {
         return this.radius = e, this.theta = n, this.y = r, this
      }
      copy(e) {
         return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
      }
      setFromVector3(e) {
         return this.setFromCartesianCoords(e.x, e.y, e.z)
      }
      setFromCartesianCoords(e, n, r) {
         return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = n, this
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   const r2 = new Se;
   class S7 {
      constructor(e = new Se(1 / 0, 1 / 0), n = new Se(-1 / 0, -1 / 0)) {
         this.isBox2 = !0, this.min = e, this.max = n
      }
      set(e, n) {
         return this.min.copy(e), this.max.copy(n), this
      }
      setFromPoints(e) {
         this.makeEmpty();
         for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
         return this
      }
      setFromCenterAndSize(e, n) {
         const r = r2.copy(n).multiplyScalar(.5);
         return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
      }
      clone() {
         return new this.constructor().copy(this)
      }
      copy(e) {
         return this.min.copy(e.min), this.max.copy(e.max), this
      }
      makeEmpty() {
         return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
      }
      isEmpty() {
         return this.max.x < this.min.x || this.max.y < this.min.y
      }
      getCenter(e) {
         return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
      }
      getSize(e) {
         return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
      }
      expandByPoint(e) {
         return this.min.min(e), this.max.max(e), this
      }
      expandByVector(e) {
         return this.min.sub(e), this.max.add(e), this
      }
      expandByScalar(e) {
         return this.min.addScalar(-e), this.max.addScalar(e), this
      }
      containsPoint(e) {
         return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
      }
      containsBox(e) {
         return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
      }
      getParameter(e, n) {
         return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
      }
      intersectsBox(e) {
         return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
      }
      clampPoint(e, n) {
         return n.copy(e).clamp(this.min, this.max)
      }
      distanceToPoint(e) {
         return this.clampPoint(e, r2).distanceTo(e)
      }
      intersect(e) {
         return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
      }
      union(e) {
         return this.min.min(e.min), this.max.max(e.max), this
      }
      translate(e) {
         return this.min.add(e), this.max.add(e), this
      }
      equals(e) {
         return e.min.equals(this.min) && e.max.equals(this.max)
      }
   }
   const i2 = new U,
      Mg = new U;
   class M7 {
      constructor(e = new U, n = new U) {
         this.start = e, this.end = n
      }
      set(e, n) {
         return this.start.copy(e), this.end.copy(n), this
      }
      copy(e) {
         return this.start.copy(e.start), this.end.copy(e.end), this
      }
      getCenter(e) {
         return e.addVectors(this.start, this.end).multiplyScalar(.5)
      }
      delta(e) {
         return e.subVectors(this.end, this.start)
      }
      distanceSq() {
         return this.start.distanceToSquared(this.end)
      }
      distance() {
         return this.start.distanceTo(this.end)
      }
      at(e, n) {
         return this.delta(n).multiplyScalar(e).add(this.start)
      }
      closestPointToPointParameter(e, n) {
         i2.subVectors(e, this.start), Mg.subVectors(this.end, this.start);
         const r = Mg.dot(Mg);
         let s = Mg.dot(i2) / r;
         return n && (s = On(s, 0, 1)), s
      }
      closestPointToPoint(e, n, r) {
         const i = this.closestPointToPointParameter(e, n);
         return this.delta(r).multiplyScalar(i).add(this.start)
      }
      applyMatrix4(e) {
         return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
      }
      equals(e) {
         return e.start.equals(this.start) && e.end.equals(this.end)
      }
      clone() {
         return new this.constructor().copy(this)
      }
   }
   const s2 = new U;
   class E7 extends Wt {
      constructor(e, n) {
         super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
         const r = new Tt,
            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
         for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
            const u = o / l * Math.PI * 2,
               h = a / l * Math.PI * 2;
            i.push(Math.cos(u), Math.sin(u), 1, Math.cos(h), Math.sin(h), 1)
         }
         r.setAttribute("position", new nt(i, 3));
         const s = new Rr({
            fog: !1,
            toneMapped: !1
         });
         this.cone = new xs(r, s), this.add(this.cone), this.update()
      }
      dispose() {
         this.cone.geometry.dispose(), this.cone.material.dispose()
      }
      update() {
         this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
         const e = this.light.distance ? this.light.distance : 1e3,
            n = e * Math.tan(this.light.angle);
         this.cone.scale.set(n, n, e), s2.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(s2), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
      }
   }
   const na = new U,
      Eg = new yt,
      L_ = new yt;
   class w7 extends xs {
      constructor(e) {
         const n = hO(e),
            r = new Tt,
            i = [],
            s = [],
            o = new ke(0, 0, 1),
            a = new ke(0, 1, 0);
         for (let u = 0; u < n.length; u++) {
            const h = n[u];
            h.parent && h.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b))
         }
         r.setAttribute("position", new nt(i, 3)), r.setAttribute("color", new nt(s, 3));
         const l = new Rr({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
         });
         super(r, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = n, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
      }
      updateMatrixWorld(e) {
         const n = this.bones,
            r = this.geometry,
            i = r.getAttribute("position");
         L_.copy(this.root.matrixWorld).invert();
         for (let s = 0, o = 0; s < n.length; s++) {
            const a = n[s];
            a.parent && a.parent.isBone && (Eg.multiplyMatrices(L_, a.matrixWorld), na.setFromMatrixPosition(Eg), i.setXYZ(o, na.x, na.y, na.z), Eg.multiplyMatrices(L_, a.parent.matrixWorld), na.setFromMatrixPosition(Eg), i.setXYZ(o + 1, na.x, na.y, na.z), o += 2)
         }
         r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
   }

   function hO(t) {
      const e = [];
      t.isBone === !0 && e.push(t);
      for (let n = 0; n < t.children.length; n++) e.push.apply(e, hO(t.children[n]));
      return e
   }
   class b7 extends Xn {
      constructor(e, n, r) {
         const i = new pp(n, 4, 2),
            s = new mi({
               wireframe: !0,
               fog: !1,
               toneMapped: !1
            });
         super(i, s), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
      update() {
         this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
      }
   }
   const C7 = new U,
      o2 = new ke,
      a2 = new ke;
   class T7 extends Wt {
      constructor(e, n, r) {
         super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper";
         const i = new dp(n);
         i.rotateY(Math.PI * .5), this.material = new mi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
         }), this.color === void 0 && (this.material.vertexColors = !0);
         const s = i.getAttribute("position"),
            o = new Float32Array(s.count * 3);
         i.setAttribute("color", new Zt(o, 3)), this.add(new Xn(i, this.material)), this.update()
      }
      dispose() {
         this.children[0].geometry.dispose(), this.children[0].material.dispose()
      }
      update() {
         const e = this.children[0];
         if (this.color !== void 0) this.material.color.set(this.color);
         else {
            const n = e.geometry.getAttribute("color");
            o2.copy(this.light.color), a2.copy(this.light.groundColor);
            for (let r = 0, i = n.count; r < i; r++) {
               const s = r < i / 2 ? o2 : a2;
               n.setXYZ(r, s.r, s.g, s.b)
            }
            n.needsUpdate = !0
         }
         this.light.updateWorldMatrix(!0, !1), e.lookAt(C7.setFromMatrixPosition(this.light.matrixWorld).negate())
      }
   }
   class R7 extends xs {
      constructor(e = 10, n = 10, r = 4473924, i = 8947848) {
         r = new ke(r), i = new ke(i);
         const s = n / 2,
            o = e / n,
            a = e / 2,
            l = [],
            u = [];
         for (let p = 0, m = 0, v = -a; p <= n; p++, v += o) {
            l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
            const _ = p === s ? r : i;
            _.toArray(u, m), m += 3, _.toArray(u, m), m += 3, _.toArray(u, m), m += 3, _.toArray(u, m), m += 3
         }
         const h = new Tt;
         h.setAttribute("position", new nt(l, 3)), h.setAttribute("color", new nt(u, 3));
         const d = new Rr({
            vertexColors: !0,
            toneMapped: !1
         });
         super(h, d), this.type = "GridHelper"
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
   }
   class P7 extends xs {
      constructor(e = 10, n = 16, r = 8, i = 64, s = 4473924, o = 8947848) {
         s = new ke(s), o = new ke(o);
         const a = [],
            l = [];
         if (n > 1)
            for (let d = 0; d < n; d++) {
               const p = d / n * (Math.PI * 2),
                  m = Math.sin(p) * e,
                  v = Math.cos(p) * e;
               a.push(0, 0, 0), a.push(m, 0, v);
               const _ = d & 1 ? s : o;
               l.push(_.r, _.g, _.b), l.push(_.r, _.g, _.b)
            }
         for (let d = 0; d < r; d++) {
            const p = d & 1 ? s : o,
               m = e - e / r * d;
            for (let v = 0; v < i; v++) {
               let _ = v / i * (Math.PI * 2),
                  x = Math.sin(_) * m,
                  g = Math.cos(_) * m;
               a.push(x, 0, g), l.push(p.r, p.g, p.b), _ = (v + 1) / i * (Math.PI * 2), x = Math.sin(_) * m, g = Math.cos(_) * m, a.push(x, 0, g), l.push(p.r, p.g, p.b)
            }
         }
         const u = new Tt;
         u.setAttribute("position", new nt(a, 3)), u.setAttribute("color", new nt(l, 3));
         const h = new Rr({
            vertexColors: !0,
            toneMapped: !1
         });
         super(u, h), this.type = "PolarGridHelper"
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
   }
   const l2 = new U,
      wg = new U,
      u2 = new U;
   class B7 extends Wt {
      constructor(e, n, r) {
         super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
         let i = new Tt;
         i.setAttribute("position", new nt([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3));
         const s = new Rr({
            fog: !1,
            toneMapped: !1
         });
         this.lightPlane = new Fo(i, s), this.add(this.lightPlane), i = new Tt, i.setAttribute("position", new nt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Fo(i, s), this.add(this.targetLine), this.update()
      }
      dispose() {
         this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
      }
      update() {
         this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), l2.setFromMatrixPosition(this.light.matrixWorld), wg.setFromMatrixPosition(this.light.target.matrixWorld), u2.subVectors(wg, l2), this.lightPlane.lookAt(wg), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(wg), this.targetLine.scale.z = u2.length()
      }
   }
   const bg = new U,
      Ln = new op;
   class I7 extends xs {
      constructor(e) {
         const n = new Tt,
            r = new Rr({
               color: 16777215,
               vertexColors: !0,
               toneMapped: !1
            }),
            i = [],
            s = [],
            o = {};
         a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");

         function a(v, _) {
            l(v), l(_)
         }

         function l(v) {
            i.push(0, 0, 0), s.push(0, 0, 0), o[v] === void 0 && (o[v] = []), o[v].push(i.length / 3 - 1)
         }
         n.setAttribute("position", new nt(i, 3)), n.setAttribute("color", new nt(s, 3)), super(n, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
         const u = new ke(16755200),
            h = new ke(16711680),
            d = new ke(43775),
            p = new ke(16777215),
            m = new ke(3355443);
         this.setColors(u, h, d, p, m)
      }
      setColors(e, n, r, i, s) {
         const a = this.geometry.getAttribute("color");
         a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, n.r, n.g, n.b), a.setXYZ(25, n.r, n.g, n.b), a.setXYZ(26, n.r, n.g, n.b), a.setXYZ(27, n.r, n.g, n.b), a.setXYZ(28, n.r, n.g, n.b), a.setXYZ(29, n.r, n.g, n.b), a.setXYZ(30, n.r, n.g, n.b), a.setXYZ(31, n.r, n.g, n.b), a.setXYZ(32, r.r, r.g, r.b), a.setXYZ(33, r.r, r.g, r.b), a.setXYZ(34, r.r, r.g, r.b), a.setXYZ(35, r.r, r.g, r.b), a.setXYZ(36, r.r, r.g, r.b), a.setXYZ(37, r.r, r.g, r.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0
      }
      update() {
         const e = this.geometry,
            n = this.pointMap,
            r = 1,
            i = 1;
         Ln.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Hn("c", n, e, Ln, 0, 0, -1), Hn("t", n, e, Ln, 0, 0, 1), Hn("n1", n, e, Ln, -r, -i, -1), Hn("n2", n, e, Ln, r, -i, -1), Hn("n3", n, e, Ln, -r, i, -1), Hn("n4", n, e, Ln, r, i, -1), Hn("f1", n, e, Ln, -r, -i, 1), Hn("f2", n, e, Ln, r, -i, 1), Hn("f3", n, e, Ln, -r, i, 1), Hn("f4", n, e, Ln, r, i, 1), Hn("u1", n, e, Ln, r * .7, i * 1.1, -1), Hn("u2", n, e, Ln, -r * .7, i * 1.1, -1), Hn("u3", n, e, Ln, 0, i * 2, -1), Hn("cf1", n, e, Ln, -r, 0, 1), Hn("cf2", n, e, Ln, r, 0, 1), Hn("cf3", n, e, Ln, 0, -i, 1), Hn("cf4", n, e, Ln, 0, i, 1), Hn("cn1", n, e, Ln, -r, 0, -1), Hn("cn2", n, e, Ln, r, 0, -1), Hn("cn3", n, e, Ln, 0, -i, -1), Hn("cn4", n, e, Ln, 0, i, -1), e.getAttribute("position").needsUpdate = !0
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
   }

   function Hn(t, e, n, r, i, s, o) {
      bg.set(i, s, o).unproject(r);
      const a = e[t];
      if (a !== void 0) {
         const l = n.getAttribute("position");
         for (let u = 0, h = a.length; u < h; u++) l.setXYZ(a[u], bg.x, bg.y, bg.z)
      }
   }
   const Cg = new qi;
   class L7 extends xs {
      constructor(e, n = 16776960) {
         const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new Float32Array(8 * 3),
            s = new Tt;
         s.setIndex(new Zt(r, 1)), s.setAttribute("position", new Zt(i, 3)), super(s, new Rr({
            color: n,
            toneMapped: !1
         })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
      }
      update(e) {
         if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Cg.setFromObject(this.object), Cg.isEmpty()) return;
         const n = Cg.min,
            r = Cg.max,
            i = this.geometry.attributes.position,
            s = i.array;
         s[0] = r.x, s[1] = r.y, s[2] = r.z, s[3] = n.x, s[4] = r.y, s[5] = r.z, s[6] = n.x, s[7] = n.y, s[8] = r.z, s[9] = r.x, s[10] = n.y, s[11] = r.z, s[12] = r.x, s[13] = r.y, s[14] = n.z, s[15] = n.x, s[16] = r.y, s[17] = n.z, s[18] = n.x, s[19] = n.y, s[20] = n.z, s[21] = r.x, s[22] = n.y, s[23] = n.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
      }
      setFromObject(e) {
         return this.object = e, this.update(), this
      }
      copy(e, n) {
         return super.copy(e, n), this.object = e.object, this
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
   }
   class D7 extends xs {
      constructor(e, n = 16776960) {
         const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
            s = new Tt;
         s.setIndex(new Zt(r, 1)), s.setAttribute("position", new nt(i, 3)), super(s, new Rr({
            color: n,
            toneMapped: !1
         })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
      }
      updateMatrixWorld(e) {
         const n = this.box;
         n.isEmpty() || (n.getCenter(this.position), n.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
   }
   class F7 extends Fo {
      constructor(e, n = 1, r = 16776960) {
         const i = r,
            s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
            o = new Tt;
         o.setAttribute("position", new nt(s, 3)), o.computeBoundingSphere(), super(o, new Rr({
            color: i,
            toneMapped: !1
         })), this.type = "PlaneHelper", this.plane = e, this.size = n;
         const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
            l = new Tt;
         l.setAttribute("position", new nt(a, 3)), l.computeBoundingSphere(), this.add(new Xn(l, new mi({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
         })))
      }
      updateMatrixWorld(e) {
         this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
      }
   }
   const c2 = new U;
   let Tg, D_;
   class O7 extends Wt {
      constructor(e = new U(0, 0, 1), n = new U(0, 0, 0), r = 1, i = 16776960, s = r * .2, o = s * .2) {
         super(), this.type = "ArrowHelper", Tg === void 0 && (Tg = new Tt, Tg.setAttribute("position", new nt([0, 0, 0, 0, 1, 0], 3)), D_ = new Pf(0, .5, 1, 5, 1), D_.translate(0, -.5, 0)), this.position.copy(n), this.line = new Fo(Tg, new Rr({
            color: i,
            toneMapped: !1
         })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Xn(D_, new mi({
            color: i,
            toneMapped: !1
         })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, s, o)
      }
      setDirection(e) {
         if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
         else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
         else {
            c2.set(e.z, 0, -e.x).normalize();
            const n = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(c2, n)
         }
      }
      setLength(e, n = e * .2, r = n * .2) {
         this.line.scale.set(1, Math.max(1e-4, e - n), 1), this.line.updateMatrix(), this.cone.scale.set(r, n, r), this.cone.position.y = e, this.cone.updateMatrix()
      }
      setColor(e) {
         this.line.material.color.set(e), this.cone.material.color.set(e)
      }
      copy(e) {
         return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
      }
      dispose() {
         this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
      }
   }
   class N7 extends xs {
      constructor(e = 1) {
         const n = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
            i = new Tt;
         i.setAttribute("position", new nt(n, 3)), i.setAttribute("color", new nt(r, 3));
         const s = new Rr({
            vertexColors: !0,
            toneMapped: !1
         });
         super(i, s), this.type = "AxesHelper"
      }
      setColors(e, n, r) {
         const i = new ke,
            s = this.geometry.attributes.color.array;
         return i.set(e), i.toArray(s, 0), i.toArray(s, 3), i.set(n), i.toArray(s, 6), i.toArray(s, 9), i.set(r), i.toArray(s, 12), i.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this
      }
      dispose() {
         this.geometry.dispose(), this.material.dispose()
      }
   }
   class U7 {
      constructor() {
         this.type = "ShapePath", this.color = new ke, this.subPaths = [], this.currentPath = null
      }
      moveTo(e, n) {
         return this.currentPath = new zd, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, n), this
      }
      lineTo(e, n) {
         return this.currentPath.lineTo(e, n), this
      }
      quadraticCurveTo(e, n, r, i) {
         return this.currentPath.quadraticCurveTo(e, n, r, i), this
      }
      bezierCurveTo(e, n, r, i, s, o) {
         return this.currentPath.bezierCurveTo(e, n, r, i, s, o), this
      }
      splineThru(e) {
         return this.currentPath.splineThru(e), this
      }
      toShapes(e) {
         function n(g) {
            const S = [];
            for (let A = 0, E = g.length; A < E; A++) {
               const C = g[A],
                  R = new Vl;
               R.curves = C.curves, S.push(R)
            }
            return S
         }

         function r(g, S) {
            const A = S.length;
            let E = !1;
            for (let C = A - 1, R = 0; R < A; C = R++) {
               let B = S[C],
                  D = S[R],
                  T = D.x - B.x,
                  I = D.y - B.y;
               if (Math.abs(I) > Number.EPSILON) {
                  if (I < 0 && (B = S[R], T = -T, D = S[C], I = -I), g.y < B.y || g.y > D.y) continue;
                  if (g.y === B.y) {
                     if (g.x === B.x) return !0
                  } else {
                     const N = I * (g.x - B.x) - T * (g.y - B.y);
                     if (N === 0) return !0;
                     if (N < 0) continue;
                     E = !E
                  }
               } else {
                  if (g.y !== B.y) continue;
                  if (D.x <= g.x && g.x <= B.x || B.x <= g.x && g.x <= D.x) return !0
               }
            }
            return E
         }
         const i = Ws.isClockWise,
            s = this.subPaths;
         if (s.length === 0) return [];
         let o, a, l;
         const u = [];
         if (s.length === 1) return a = s[0], l = new Vl, l.curves = a.curves, u.push(l), u;
         let h = !i(s[0].getPoints());
         h = e ? !h : h;
         const d = [],
            p = [];
         let m = [],
            v = 0,
            _;
         p[v] = void 0, m[v] = [];
         for (let g = 0, S = s.length; g < S; g++) a = s[g], _ = a.getPoints(), o = i(_), o = e ? !o : o, o ? (!h && p[v] && v++, p[v] = {
            s: new Vl,
            p: _
         }, p[v].s.curves = a.curves, h && v++, m[v] = []) : m[v].push({
            h: a,
            p: _[0]
         });
         if (!p[0]) return n(s);
         if (p.length > 1) {
            let g = !1,
               S = 0;
            for (let A = 0, E = p.length; A < E; A++) d[A] = [];
            for (let A = 0, E = p.length; A < E; A++) {
               const C = m[A];
               for (let R = 0; R < C.length; R++) {
                  const B = C[R];
                  let D = !0;
                  for (let T = 0; T < p.length; T++) r(B.p, p[T].p) && (A !== T && S++, D ? (D = !1, d[T].push(B)) : g = !0);
                  D && d[A].push(B)
               }
            }
            S > 0 && g === !1 && (m = d)
         }
         let x;
         for (let g = 0, S = p.length; g < S; g++) {
            l = p[g].s, u.push(l), x = m[g];
            for (let A = 0, E = x.length; A < E; A++) l.holes.push(x[A].h)
         }
         return u
      }
   }
   typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
      detail: {
         revision: nu
      }
   }));
   typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = nu);
   const k7 = Object.freeze(Object.defineProperty({
      __proto__: null,
      ACESFilmicToneMapping: FM,
      AddEquation: bl,
      AddOperation: k3,
      AdditiveAnimationBlendMode: VM,
      AdditiveBlending: yA,
      AlphaFormat: $3,
      AlwaysCompare: dF,
      AlwaysDepth: I3,
      AlwaysStencilFunc: sF,
      AmbientLight: nO,
      AmbientLightProbe: ZW,
      AnimationAction: cO,
      AnimationClip: yf,
      AnimationLoader: VW,
      AnimationMixer: g7,
      AnimationObjectGroup: p7,
      AnimationUtils: kW,
      ArcCurve: IF,
      ArrayCamera: bF,
      ArrowHelper: O7,
      Audio: lO,
      AudioAnalyser: i7,
      AudioContext: bE,
      AudioListener: t7,
      AudioLoader: YW,
      AxesHelper: N7,
      BackSide: zr,
      BasicDepthPacking: nF,
      BasicShadowMap: y3,
      Bone: Ov,
      BooleanKeyframeTrack: iu,
      Box2: S7,
      Box3: qi,
      Box3Helper: D7,
      BoxGeometry: ru,
      BoxHelper: L7,
      BufferAttribute: Zt,
      BufferGeometry: Tt,
      BufferGeometryLoader: oO,
      ByteType: W3,
      Cache: Zl,
      Camera: op,
      CameraHelper: I7,
      CanvasTexture: uW,
      CapsuleGeometry: Gv,
      CatmullRomCurve3: LF,
      CineonToneMapping: z3,
      CircleGeometry: zv,
      ClampToEdgeWrapping: hr,
      Clock: CE,
      Color: ke,
      ColorKeyframeTrack: xE,
      ColorManagement: ki,
      CompressedArrayTexture: aW,
      CompressedCubeTexture: lW,
      CompressedTexture: Uv,
      CompressedTextureLoader: WW,
      ConeGeometry: Vv,
      CubeCamera: xF,
      CubeReflectionMapping: Ks,
      CubeRefractionMapping: Da,
      CubeTexture: ap,
      CubeTextureLoader: eO,
      CubeUVReflectionMapping: bf,
      CubicBezierCurve: cE,
      CubicBezierCurve3: DF,
      CubicInterpolant: YF,
      CullFaceBack: vA,
      CullFaceFront: v3,
      CullFaceFrontBack: oz,
      CullFaceNone: g3,
      Curve: _s,
      CurvePath: OF,
      CustomBlending: x3,
      CustomToneMapping: V3,
      CylinderGeometry: Pf,
      Cylindrical: A7,
      Data3DTexture: KM,
      DataArrayTexture: Bv,
      DataTexture: qc,
      DataTextureLoader: AE,
      DataUtils: Dl,
      DecrementStencilOp: mz,
      DecrementWrapStencilOp: vz,
      DefaultLoadingManager: qF,
      DepthFormat: Ca,
      DepthStencilFormat: Kl,
      DepthTexture: CF,
      DirectionalLight: wE,
      DirectionalLightHelper: B7,
      DiscreteInterpolant: QF,
      DisplayP3ColorSpace: $M,
      DodecahedronGeometry: Wv,
      DoubleSide: Wi,
      DstAlphaFactor: b3,
      DstColorFactor: T3,
      DynamicCopyUsage: Iz,
      DynamicDrawUsage: bz,
      DynamicReadUsage: Rz,
      EdgesGeometry: NF,
      EllipseCurve: kv,
      EqualCompare: lF,
      EqualDepth: D3,
      EqualStencilFunc: Az,
      EquirectangularReflectionMapping: cf,
      EquirectangularRefractionMapping: Fd,
      Euler: Xa,
      EventDispatcher: Uo,
      ExtrudeGeometry: $v,
      FileLoader: Si,
      Float16BufferAttribute: _5,
      Float32BufferAttribute: nt,
      Float64BufferAttribute: A5,
      FloatType: dr,
      Fog: Fv,
      FogExp2: Dv,
      FramebufferTexture: oW,
      FrontSide: Js,
      Frustum: Iv,
      GLBufferAttribute: _7,
      GLSL1: Dz,
      GLSL3: $A,
      GreaterCompare: cF,
      GreaterDepth: O3,
      GreaterEqualCompare: hF,
      GreaterEqualDepth: F3,
      GreaterEqualStencilFunc: wz,
      GreaterStencilFunc: Mz,
      GridHelper: R7,
      Group: Mo,
      HalfFloatType: Cr,
      HemisphereLight: tO,
      HemisphereLightHelper: T7,
      HemisphereLightProbe: QW,
      IcosahedronGeometry: hp,
      ImageBitmapLoader: aO,
      ImageLoader: $d,
      ImageUtils: JM,
      IncrementStencilOp: pz,
      IncrementWrapStencilOp: gz,
      InstancedBufferAttribute: mf,
      InstancedBufferGeometry: sO,
      InstancedInterleavedBuffer: x7,
      InstancedMesh: oE,
      Int16BufferAttribute: y5,
      Int32BufferAttribute: x5,
      Int8BufferAttribute: m5,
      IntType: OM,
      InterleavedBuffer: up,
      InterleavedBufferAttribute: Oa,
      Interpolant: Bf,
      InterpolateDiscrete: hf,
      InterpolateLinear: Yl,
      InterpolateSmooth: a0,
      InvertStencilOp: yz,
      KeepStencilOp: l0,
      KeyframeTrack: As,
      LOD: BF,
      LatheGeometry: fp,
      Layers: zl,
      LessCompare: aF,
      LessDepth: L3,
      LessEqualCompare: uF,
      LessEqualDepth: U0,
      LessEqualStencilFunc: Sz,
      LessStencilFunc: _z,
      Light: Ka,
      LightProbe: qv,
      Line: Fo,
      Line3: M7,
      LineBasicMaterial: Rr,
      LineCurve: Hv,
      LineCurve3: FF,
      LineDashedMaterial: JF,
      LineLoop: aE,
      LineSegments: xs,
      LinearEncoding: jM,
      LinearFilter: ln,
      LinearInterpolant: yE,
      LinearMipMapLinearFilter: fz,
      LinearMipMapNearestFilter: cz,
      LinearMipmapLinearFilter: Ys,
      LinearMipmapNearestFilter: Tv,
      LinearSRGBColorSpace: ys,
      LinearToneMapping: H3,
      Loader: Pr,
      LoaderUtils: js,
      LoadingManager: _E,
      LoopOnce: Z3,
      LoopPingPong: eF,
      LoopRepeat: q3,
      LuminanceAlphaFormat: J3,
      LuminanceFormat: X3,
      MOUSE: iz,
      Material: Jn,
      MaterialLoader: ey,
      MathUtils: Qc,
      Matrix3: Ft,
      Matrix4: yt,
      MaxEquation: SA,
      Mesh: Xn,
      MeshBasicMaterial: mi,
      MeshDepthMaterial: tE,
      MeshDistanceMaterial: nE,
      MeshLambertMaterial: mE,
      MeshMatcapMaterial: XF,
      MeshNormalMaterial: $F,
      MeshPhongMaterial: WF,
      MeshPhysicalMaterial: Qs,
      MeshStandardMaterial: mp,
      MeshToonMaterial: jF,
      MinEquation: AA,
      MirroredRepeatWrapping: ff,
      MixOperation: U3,
      MultiplyBlending: _A,
      MultiplyOperation: sp,
      NearestFilter: Fn,
      NearestMipMapLinearFilter: uz,
      NearestMipMapNearestFilter: lz,
      NearestMipmapLinearFilter: Yc,
      NearestMipmapNearestFilter: Od,
      NeverCompare: oF,
      NeverDepth: B3,
      NeverStencilFunc: xz,
      NoBlending: Co,
      NoColorSpace: Ra,
      NoToneMapping: zs,
      NormalAnimationBlendMode: Pv,
      NormalBlending: Hl,
      NotEqualCompare: fF,
      NotEqualDepth: N3,
      NotEqualStencilFunc: Ez,
      NumberKeyframeTrack: gf,
      Object3D: Wt,
      ObjectLoader: JW,
      ObjectSpaceNormalMap: iF,
      OctahedronGeometry: dp,
      OneFactor: M3,
      OneMinusDstAlphaFactor: C3,
      OneMinusDstColorFactor: R3,
      OneMinusSrcAlphaFactor: DM,
      OneMinusSrcColorFactor: w3,
      OrthographicCamera: Tf,
      PCFShadowMap: bv,
      PCFSoftShadowMap: od,
      PMREMGenerator: JA,
      Path: zd,
      PerspectiveCamera: Zn,
      Plane: la,
      PlaneGeometry: lp,
      PlaneHelper: F7,
      PointLight: EE,
      PointLightHelper: b7,
      Points: lE,
      PointsMaterial: Nv,
      PolarGridHelper: P7,
      PolyhedronGeometry: Ja,
      PositionalAudio: r7,
      PropertyBinding: jt,
      PropertyMixer: uO,
      QuadraticBezierCurve: fE,
      QuadraticBezierCurve3: hE,
      Quaternion: tr,
      QuaternionKeyframeTrack: Na,
      QuaternionLinearInterpolant: ZF,
      RED_GREEN_RGTC2_Format: WA,
      RED_RGTC1_Format: Q3,
      REVISION: nu,
      RGBADepthPacking: rF,
      RGBAFormat: Hr,
      RGBAIntegerFormat: zM,
      RGBA_ASTC_10x10_Format: HA,
      RGBA_ASTC_10x5_Format: NA,
      RGBA_ASTC_10x6_Format: UA,
      RGBA_ASTC_10x8_Format: kA,
      RGBA_ASTC_12x10_Format: GA,
      RGBA_ASTC_12x12_Format: zA,
      RGBA_ASTC_4x4_Format: RA,
      RGBA_ASTC_5x4_Format: PA,
      RGBA_ASTC_5x5_Format: BA,
      RGBA_ASTC_6x5_Format: IA,
      RGBA_ASTC_6x6_Format: LA,
      RGBA_ASTC_8x5_Format: DA,
      RGBA_ASTC_8x6_Format: FA,
      RGBA_ASTC_8x8_Format: OA,
      RGBA_BPTC_Format: o0,
      RGBA_ETC2_EAC_Format: TA,
      RGBA_PVRTC_2BPPV1_Format: bA,
      RGBA_PVRTC_4BPPV1_Format: wA,
      RGBA_S3TC_DXT1_Format: r0,
      RGBA_S3TC_DXT3_Format: i0,
      RGBA_S3TC_DXT5_Format: s0,
      RGB_ETC1_Format: Y3,
      RGB_ETC2_Format: CA,
      RGB_PVRTC_2BPPV1_Format: EA,
      RGB_PVRTC_4BPPV1_Format: MA,
      RGB_S3TC_DXT1_Format: n0,
      RGFormat: K3,
      RGIntegerFormat: GM,
      RawShaderMaterial: VF,
      Ray: Cf,
      Raycaster: BE,
      RectAreaLight: rO,
      RedFormat: kM,
      RedIntegerFormat: HM,
      ReinhardToneMapping: G3,
      RenderTarget: gF,
      RepeatWrapping: Fa,
      ReplaceStencilOp: dz,
      ReverseSubtractEquation: A3,
      RingGeometry: Xv,
      SIGNED_RED_GREEN_RGTC2_Format: jA,
      SIGNED_RED_RGTC1_Format: VA,
      SRGBColorSpace: Rt,
      Scene: Gd,
      ShaderChunk: Bt,
      ShaderLib: ds,
      ShaderMaterial: Qi,
      ShadowMaterial: zF,
      Shape: Vl,
      ShapeGeometry: Jv,
      ShapePath: U7,
      ShapeUtils: Ws,
      ShortType: j3,
      Skeleton: cp,
      SkeletonHelper: w7,
      SkinnedMesh: sE,
      Source: Ll,
      Sphere: Ci,
      SphereGeometry: pp,
      Spherical: fO,
      SphericalHarmonics3: iO,
      SplineCurve: dE,
      SpotLight: ME,
      SpotLightHelper: E7,
      Sprite: PF,
      SpriteMaterial: iE,
      SrcAlphaFactor: LM,
      SrcAlphaSaturateFactor: P3,
      SrcColorFactor: E3,
      StaticCopyUsage: Bz,
      StaticDrawUsage: Ud,
      StaticReadUsage: Tz,
      StereoCamera: qW,
      StreamCopyUsage: Lz,
      StreamDrawUsage: Cz,
      StreamReadUsage: Pz,
      StringKeyframeTrack: su,
      SubtractEquation: _3,
      SubtractiveBlending: xA,
      TOUCH: sz,
      TangentSpaceNormalMap: $a,
      TetrahedronGeometry: Kv,
      Texture: yn,
      TextureLoader: gp,
      TorusGeometry: Yv,
      TorusKnotGeometry: Qv,
      Triangle: Yr,
      TriangleFanDrawMode: k0,
      TriangleStripDrawMode: WM,
      TrianglesDrawMode: tF,
      TubeGeometry: Zv,
      TwoPassDoubleSide: az,
      UVMapping: Cv,
      Uint16BufferAttribute: YM,
      Uint32BufferAttribute: QM,
      Uint8BufferAttribute: g5,
      Uint8ClampedBufferAttribute: v5,
      Uniform: PE,
      UniformsGroup: y7,
      UniformsLib: Ge,
      UniformsUtils: ZM,
      UnsignedByteType: Vs,
      UnsignedInt248Type: ba,
      UnsignedIntType: So,
      UnsignedShort4444Type: NM,
      UnsignedShort5551Type: UM,
      UnsignedShortType: Rv,
      VSMShadowMap: cs,
      Vector2: Se,
      Vector3: U,
      Vector4: $t,
      VectorKeyframeTrack: vf,
      VideoTexture: sW,
      WebGL1Renderer: TF,
      WebGL3DRenderTarget: i5,
      WebGLArrayRenderTarget: r5,
      WebGLCoordinateSystem: ks,
      WebGLCubeRenderTarget: qM,
      WebGLMultipleRenderTargets: s5,
      WebGLRenderTarget: Ai,
      WebGLRenderer: rE,
      WebGLUtils: wF,
      WebGPUCoordinateSystem: kd,
      WireframeGeometry: GF,
      WrapAroundEnding: Nd,
      ZeroCurvatureEnding: Bl,
      ZeroFactor: S3,
      ZeroSlopeEnding: Il,
      ZeroStencilOp: hz,
      _SRGBAFormat: H0,
      sRGBEncoding: Ta
   }, Symbol.toStringTag, {
      value: "Module"
   }));
   var dO = {
         exports: {}
      },
      ou = {};
   /**
    * @license React
    * react-reconciler-constants.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   ou.ConcurrentRoot = 1;
   ou.ContinuousEventPriority = 4;
   ou.DefaultEventPriority = 16;
   ou.DiscreteEventPriority = 1;
   ou.IdleEventPriority = 536870912;
   ou.LegacyRoot = 0;
   dO.exports = ou;
   var kc = dO.exports;

   function H7(t) {
      let e;
      const n = new Set,
         r = (u, h) => {
            const d = typeof u == "function" ? u(e) : u;
            if (d !== e) {
               const p = e;
               e = h ? d : Object.assign({}, e, d), n.forEach(m => m(e, p))
            }
         },
         i = () => e,
         s = (u, h = i, d = Object.is) => {
            console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
            let p = h(e);

            function m() {
               const v = h(e);
               if (!d(p, v)) {
                  const _ = p;
                  u(p = v, _)
               }
            }
            return n.add(m), () => n.delete(m)
         },
         l = {
            setState: r,
            getState: i,
            subscribe: (u, h, d) => h || d ? s(u, h, d) : (n.add(u), () => n.delete(u)),
            destroy: () => n.clear()
         };
      return e = t(r, i, l), l
   }
   const G7 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
      f2 = G7 ? $.useEffect : $.useLayoutEffect;

   function pO(t) {
      const e = typeof t == "function" ? H7(t) : t,
         n = (r = e.getState, i = Object.is) => {
            const [, s] = $.useReducer(x => x + 1, 0), o = e.getState(), a = $.useRef(o), l = $.useRef(r), u = $.useRef(i), h = $.useRef(!1), d = $.useRef();
            d.current === void 0 && (d.current = r(o));
            let p, m = !1;
            (a.current !== o || l.current !== r || u.current !== i || h.current) && (p = r(o), m = !i(d.current, p)), f2(() => {
               m && (d.current = p), a.current = o, l.current = r, u.current = i, h.current = !1
            });
            const v = $.useRef(o);
            f2(() => {
               const x = () => {
                     try {
                        const S = e.getState(),
                           A = l.current(S);
                        u.current(d.current, A) || (a.current = S, d.current = A, s())
                     } catch {
                        h.current = !0, s()
                     }
                  },
                  g = e.subscribe(x);
               return e.getState() !== v.current && x(), g
            }, []);
            const _ = m ? p : d.current;
            return $.useDebugValue(_), _
         };
      return Object.assign(n, e), n[Symbol.iterator] = function () {
         console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
         const r = [n, e];
         return {
            next() {
               const i = r.length <= 0;
               return {
                  value: r.shift(),
                  done: i
               }
            }
         }
      }, n
   }
   var mO = {
         exports: {}
      },
      gO = {
         exports: {}
      },
      vO = {};
   /**
    * @license React
    * scheduler.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   (function (t) {
      function e(G, ne) {
         var Y = G.length;
         G.push(ne);
         e: for (; 0 < Y;) {
            var X = Y - 1 >>> 1,
               Q = G[X];
            if (0 < i(Q, ne)) G[X] = ne, G[Y] = Q, Y = X;
            else break e
         }
      }

      function n(G) {
         return G.length === 0 ? null : G[0]
      }

      function r(G) {
         if (G.length === 0) return null;
         var ne = G[0],
            Y = G.pop();
         if (Y !== ne) {
            G[0] = Y;
            e: for (var X = 0, Q = G.length, _e = Q >>> 1; X < _e;) {
               var Me = 2 * (X + 1) - 1,
                  we = G[Me],
                  Ee = Me + 1,
                  Ue = G[Ee];
               if (0 > i(we, Y)) Ee < Q && 0 > i(Ue, we) ? (G[X] = Ue, G[Ee] = Y, X = Ee) : (G[X] = we, G[Me] = Y, X = Me);
               else if (Ee < Q && 0 > i(Ue, Y)) G[X] = Ue, G[Ee] = Y, X = Ee;
               else break e
            }
         }
         return ne
      }

      function i(G, ne) {
         var Y = G.sortIndex - ne.sortIndex;
         return Y !== 0 ? Y : G.id - ne.id
      }
      if (typeof performance == "object" && typeof performance.now == "function") {
         var s = performance;
         t.unstable_now = function () {
            return s.now()
         }
      } else {
         var o = Date,
            a = o.now();
         t.unstable_now = function () {
            return o.now() - a
         }
      }
      var l = [],
         u = [],
         h = 1,
         d = null,
         p = 3,
         m = !1,
         v = !1,
         _ = !1,
         x = typeof setTimeout == "function" ? setTimeout : null,
         g = typeof clearTimeout == "function" ? clearTimeout : null,
         S = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

      function A(G) {
         for (var ne = n(u); ne !== null;) {
            if (ne.callback === null) r(u);
            else if (ne.startTime <= G) r(u), ne.sortIndex = ne.expirationTime, e(l, ne);
            else break;
            ne = n(u)
         }
      }

      function E(G) {
         if (_ = !1, A(G), !v)
            if (n(l) !== null) v = !0, se(C);
            else {
               var ne = n(u);
               ne !== null && oe(E, ne.startTime - G)
            }
      }

      function C(G, ne) {
         v = !1, _ && (_ = !1, g(D), D = -1), m = !0;
         var Y = p;
         try {
            for (A(ne), d = n(l); d !== null && (!(d.expirationTime > ne) || G && !N());) {
               var X = d.callback;
               if (typeof X == "function") {
                  d.callback = null, p = d.priorityLevel;
                  var Q = X(d.expirationTime <= ne);
                  ne = t.unstable_now(), typeof Q == "function" ? d.callback = Q : d === n(l) && r(l), A(ne)
               } else r(l);
               d = n(l)
            }
            if (d !== null) var _e = !0;
            else {
               var Me = n(u);
               Me !== null && oe(E, Me.startTime - ne), _e = !1
            }
            return _e
         } finally {
            d = null, p = Y, m = !1
         }
      }
      var R = !1,
         B = null,
         D = -1,
         T = 5,
         I = -1;

      function N() {
         return !(t.unstable_now() - I < T)
      }

      function q() {
         if (B !== null) {
            var G = t.unstable_now();
            I = G;
            var ne = !0;
            try {
               ne = B(!0, G)
            } finally {
               ne ? K() : (R = !1, B = null)
            }
         } else R = !1
      }
      var K;
      if (typeof S == "function") K = function () {
         S(q)
      };
      else if (typeof MessageChannel < "u") {
         var Z = new MessageChannel,
            te = Z.port2;
         Z.port1.onmessage = q, K = function () {
            te.postMessage(null)
         }
      } else K = function () {
         x(q, 0)
      };

      function se(G) {
         B = G, R || (R = !0, K())
      }

      function oe(G, ne) {
         D = x(function () {
            G(t.unstable_now())
         }, ne)
      }
      t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (G) {
         G.callback = null
      }, t.unstable_continueExecution = function () {
         v || m || (v = !0, se(C))
      }, t.unstable_forceFrameRate = function (G) {
         0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < G ? Math.floor(1e3 / G) : 5
      }, t.unstable_getCurrentPriorityLevel = function () {
         return p
      }, t.unstable_getFirstCallbackNode = function () {
         return n(l)
      }, t.unstable_next = function (G) {
         switch (p) {
            case 1:
            case 2:
            case 3:
               var ne = 3;
               break;
            default:
               ne = p
         }
         var Y = p;
         p = ne;
         try {
            return G()
         } finally {
            p = Y
         }
      }, t.unstable_pauseExecution = function () {}, t.unstable_requestPaint = function () {}, t.unstable_runWithPriority = function (G, ne) {
         switch (G) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
               break;
            default:
               G = 3
         }
         var Y = p;
         p = G;
         try {
            return ne()
         } finally {
            p = Y
         }
      }, t.unstable_scheduleCallback = function (G, ne, Y) {
         var X = t.unstable_now();
         switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? X + Y : X) : Y = X, G) {
            case 1:
               var Q = -1;
               break;
            case 2:
               Q = 250;
               break;
            case 5:
               Q = 1073741823;
               break;
            case 4:
               Q = 1e4;
               break;
            default:
               Q = 5e3
         }
         return Q = Y + Q, G = {
            id: h++,
            callback: ne,
            priorityLevel: G,
            startTime: Y,
            expirationTime: Q,
            sortIndex: -1
         }, Y > X ? (G.sortIndex = Y, e(u, G), n(l) === null && G === n(u) && (_ ? (g(D), D = -1) : _ = !0, oe(E, Y - X))) : (G.sortIndex = Q, e(l, G), v || m || (v = !0, se(C))), G
      }, t.unstable_shouldYield = N, t.unstable_wrapCallback = function (G) {
         var ne = p;
         return function () {
            var Y = p;
            p = ne;
            try {
               return G.apply(this, arguments)
            } finally {
               p = Y
            }
         }
      }
   })(vO);
   gO.exports = vO;
   var tS = gO.exports;
   /**
    * @license React
    * react-reconciler.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   var z7 = function (e) {
      var n = {},
         r = $,
         i = tS,
         s = Object.assign;

      function o(c) {
         for (var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, y = 1; y < arguments.length; y++) f += "&args[]=" + encodeURIComponent(arguments[y]);
         return "Minified React error #" + c + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
      }
      var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
         l = Symbol.for("react.element"),
         u = Symbol.for("react.portal"),
         h = Symbol.for("react.fragment"),
         d = Symbol.for("react.strict_mode"),
         p = Symbol.for("react.profiler"),
         m = Symbol.for("react.provider"),
         v = Symbol.for("react.context"),
         _ = Symbol.for("react.forward_ref"),
         x = Symbol.for("react.suspense"),
         g = Symbol.for("react.suspense_list"),
         S = Symbol.for("react.memo"),
         A = Symbol.for("react.lazy"),
         E = Symbol.for("react.offscreen"),
         C = Symbol.iterator;

      function R(c) {
         return c === null || typeof c != "object" ? null : (c = C && c[C] || c["@@iterator"], typeof c == "function" ? c : null)
      }

      function B(c) {
         if (c == null) return null;
         if (typeof c == "function") return c.displayName || c.name || null;
         if (typeof c == "string") return c;
         switch (c) {
            case h:
               return "Fragment";
            case u:
               return "Portal";
            case p:
               return "Profiler";
            case d:
               return "StrictMode";
            case x:
               return "Suspense";
            case g:
               return "SuspenseList"
         }
         if (typeof c == "object") switch (c.$$typeof) {
            case v:
               return (c.displayName || "Context") + ".Consumer";
            case m:
               return (c._context.displayName || "Context") + ".Provider";
            case _:
               var f = c.render;
               return c = c.displayName, c || (c = f.displayName || f.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
            case S:
               return f = c.displayName || null, f !== null ? f : B(c.type) || "Memo";
            case A:
               f = c._payload, c = c._init;
               try {
                  return B(c(f))
               } catch {}
         }
         return null
      }

      function D(c) {
         var f = c.type;
         switch (c.tag) {
            case 24:
               return "Cache";
            case 9:
               return (f.displayName || "Context") + ".Consumer";
            case 10:
               return (f._context.displayName || "Context") + ".Provider";
            case 18:
               return "DehydratedFragment";
            case 11:
               return c = f.render, c = c.displayName || c.name || "", f.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
            case 7:
               return "Fragment";
            case 5:
               return f;
            case 4:
               return "Portal";
            case 3:
               return "Root";
            case 6:
               return "Text";
            case 16:
               return B(f);
            case 8:
               return f === d ? "StrictMode" : "Mode";
            case 22:
               return "Offscreen";
            case 12:
               return "Profiler";
            case 21:
               return "Scope";
            case 13:
               return "Suspense";
            case 19:
               return "SuspenseList";
            case 25:
               return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
               if (typeof f == "function") return f.displayName || f.name || null;
               if (typeof f == "string") return f
         }
         return null
      }

      function T(c) {
         var f = c,
            y = c;
         if (c.alternate)
            for (; f.return;) f = f.return;
         else {
            c = f;
            do f = c, f.flags & 4098 && (y = f.return), c = f.return; while (c)
         }
         return f.tag === 3 ? y : null
      }

      function I(c) {
         if (T(c) !== c) throw Error(o(188))
      }

      function N(c) {
         var f = c.alternate;
         if (!f) {
            if (f = T(c), f === null) throw Error(o(188));
            return f !== c ? null : c
         }
         for (var y = c, M = f;;) {
            var w = y.return;
            if (w === null) break;
            var P = w.alternate;
            if (P === null) {
               if (M = w.return, M !== null) {
                  y = M;
                  continue
               }
               break
            }
            if (w.child === P.child) {
               for (P = w.child; P;) {
                  if (P === y) return I(w), c;
                  if (P === M) return I(w), f;
                  P = P.sibling
               }
               throw Error(o(188))
            }
            if (y.return !== M.return) y = w, M = P;
            else {
               for (var V = !1, re = w.child; re;) {
                  if (re === y) {
                     V = !0, y = w, M = P;
                     break
                  }
                  if (re === M) {
                     V = !0, M = w, y = P;
                     break
                  }
                  re = re.sibling
               }
               if (!V) {
                  for (re = P.child; re;) {
                     if (re === y) {
                        V = !0, y = P, M = w;
                        break
                     }
                     if (re === M) {
                        V = !0, M = P, y = w;
                        break
                     }
                     re = re.sibling
                  }
                  if (!V) throw Error(o(189))
               }
            }
            if (y.alternate !== M) throw Error(o(190))
         }
         if (y.tag !== 3) throw Error(o(188));
         return y.stateNode.current === y ? c : f
      }

      function q(c) {
         return c = N(c), c !== null ? K(c) : null
      }

      function K(c) {
         if (c.tag === 5 || c.tag === 6) return c;
         for (c = c.child; c !== null;) {
            var f = K(c);
            if (f !== null) return f;
            c = c.sibling
         }
         return null
      }

      function Z(c) {
         if (c.tag === 5 || c.tag === 6) return c;
         for (c = c.child; c !== null;) {
            if (c.tag !== 4) {
               var f = Z(c);
               if (f !== null) return f
            }
            c = c.sibling
         }
         return null
      }
      var te = Array.isArray,
         se = e.getPublicInstance,
         oe = e.getRootHostContext,
         G = e.getChildHostContext,
         ne = e.prepareForCommit,
         Y = e.resetAfterCommit,
         X = e.createInstance,
         Q = e.appendInitialChild,
         _e = e.finalizeInitialChildren,
         Me = e.prepareUpdate,
         we = e.shouldSetTextContent,
         Ee = e.createTextInstance,
         Ue = e.scheduleTimeout,
         Qe = e.cancelTimeout,
         Pt = e.noTimeout,
         kt = e.isPrimaryRenderer,
         $e = e.supportsMutation,
         J = e.supportsPersistence,
         Ce = e.supportsHydration,
         Ae = e.getInstanceFromNode,
         Ie = e.preparePortalMount,
         be = e.getCurrentEventPriority,
         lt = e.detachDeletedInstance,
         Je = e.supportsMicrotasks,
         qe = e.scheduleMicrotask,
         vt = e.supportsTestSelectors,
         Ot = e.findFiberRoot,
         un = e.getBoundingRect,
         j = e.getTextContent,
         O = e.isHiddenSubtree,
         ue = e.matchAccessibilityRole,
         Pe = e.setFocusIfFocusable,
         Te = e.setupIntersectionObserver,
         Be = e.appendChild,
         rt = e.appendChildToContainer,
         Le = e.commitTextUpdate,
         de = e.commitMount,
         ht = e.commitUpdate,
         st = e.insertBefore,
         Ke = e.insertInContainerBefore,
         et = e.removeChild,
         Ye = e.removeChildFromContainer,
         pt = e.resetTextContent,
         Mt = e.hideInstance,
         ee = e.hideTextInstance,
         fe = e.unhideInstance,
         he = e.unhideTextInstance,
         Fe = e.clearContainer,
         ze = e.cloneInstance,
         Ut = e.createContainerChildSet,
         sn = e.appendChildToContainerChildSet,
         xn = e.finalizeContainerChildren,
         si = e.replaceContainerChildren,
         en = e.cloneHiddenInstance,
         Br = e.cloneHiddenTextInstance,
         Kn = e.canHydrateInstance,
         vu = e.canHydrateTextInstance,
         yu = e.canHydrateSuspenseInstance,
         qs = e.isSuspenseInstancePending,
         Es = e.isSuspenseInstanceFallback,
         ws = e.registerSuspenseInstanceRetry,
         gr = e.getNextHydratableSibling,
         Lt = e.getFirstHydratableChild,
         xu = e.getFirstHydratableChildWithinContainer,
         zf = e.getFirstHydratableChildWithinSuspenseInstance,
         L = e.hydrateInstance,
         b = e.hydrateTextInstance,
         F = e.hydrateSuspenseInstance,
         H = e.getNextHydratableInstanceAfterSuspenseInstance,
         k = e.commitHydratedContainer,
         W = e.commitHydratedSuspenseInstance,
         ae = e.clearSuspenseBoundary,
         ce = e.clearSuspenseBoundaryFromContainer,
         ye = e.shouldDeleteUnhydratedTailInstances,
         ge = e.didNotMatchHydratedContainerTextInstance,
         xe = e.didNotMatchHydratedTextInstance,
         me;

      function Xe(c) {
         if (me === void 0) try {
            throw Error()
         } catch (y) {
            var f = y.stack.trim().match(/\n( *(at )?)/);
            me = f && f[1] || ""
         }
         return `
` + me + c
      }
      var Oe = !1;

      function He(c, f) {
         if (!c || Oe) return "";
         Oe = !0;
         var y = Error.prepareStackTrace;
         Error.prepareStackTrace = void 0;
         try {
            if (f)
               if (f = function () {
                     throw Error()
                  }, Object.defineProperty(f.prototype, "props", {
                     set: function () {
                        throw Error()
                     }
                  }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                     Reflect.construct(f, [])
                  } catch (De) {
                     var M = De
                  }
                  Reflect.construct(c, [], f)
               } else {
                  try {
                     f.call()
                  } catch (De) {
                     M = De
                  }
                  c.call(f.prototype)
               }
            else {
               try {
                  throw Error()
               } catch (De) {
                  M = De
               }
               c()
            }
         } catch (De) {
            if (De && M && typeof De.stack == "string") {
               for (var w = De.stack.split(`
`), P = M.stack.split(`
`), V = w.length - 1, re = P.length - 1; 1 <= V && 0 <= re && w[V] !== P[re];) re--;
               for (; 1 <= V && 0 <= re; V--, re--)
                  if (w[V] !== P[re]) {
                     if (V !== 1 || re !== 1)
                        do
                           if (V--, re--, 0 > re || w[V] !== P[re]) {
                              var ve = `
` + w[V].replace(" at new ", " at ");
                              return c.displayName && ve.includes("<anonymous>") && (ve = ve.replace("<anonymous>", c.displayName)), ve
                           } while (1 <= V && 0 <= re);
                     break
                  }
            }
         } finally {
            Oe = !1, Error.prepareStackTrace = y
         }
         return (c = c ? c.displayName || c.name : "") ? Xe(c) : ""
      }
      var ct = Object.prototype.hasOwnProperty,
         mt = [],
         dt = -1;

      function We(c) {
         return {
            current: c
         }
      }

      function xt(c) {
         0 > dt || (c.current = mt[dt], mt[dt] = null, dt--)
      }

      function it(c, f) {
         dt++, mt[dt] = c.current, c.current = f
      }
      var wt = {},
         tn = We(wt),
         At = We(!1),
         nn = wt;

      function Jt(c, f) {
         var y = c.type.contextTypes;
         if (!y) return wt;
         var M = c.stateNode;
         if (M && M.__reactInternalMemoizedUnmaskedChildContext === f) return M.__reactInternalMemoizedMaskedChildContext;
         var w = {},
            P;
         for (P in y) w[P] = f[P];
         return M && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = f, c.__reactInternalMemoizedMaskedChildContext = w), w
      }

      function on(c) {
         return c = c.childContextTypes, c != null
      }

      function Un() {
         xt(At), xt(tn)
      }

      function Et(c, f, y) {
         if (tn.current !== wt) throw Error(o(168));
         it(tn, f), it(At, y)
      }

      function wn(c, f, y) {
         var M = c.stateNode;
         if (f = f.childContextTypes, typeof M.getChildContext != "function") return y;
         M = M.getChildContext();
         for (var w in M)
            if (!(w in f)) throw Error(o(108, D(c) || "Unknown", w));
         return s({}, y, M)
      }

      function qt(c) {
         return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || wt, nn = tn.current, it(tn, c), it(At, At.current), !0
      }

      function Gt(c, f, y) {
         var M = c.stateNode;
         if (!M) throw Error(o(169));
         y ? (c = wn(c, f, nn), M.__reactInternalMemoizedMergedChildContext = c, xt(At), xt(tn), it(tn, c)) : xt(At), it(At, y)
      }
      var _n = Math.clz32 ? Math.clz32 : bs,
         eo = Math.log,
         Ir = Math.LN2;

      function bs(c) {
         return c >>>= 0, c === 0 ? 32 : 31 - (eo(c) / Ir | 0) | 0
      }
      var Ip = 64,
         Lp = 4194304;

      function Vf(c) {
         switch (c & -c) {
            case 1:
               return 1;
            case 2:
               return 2;
            case 4:
               return 4;
            case 8:
               return 8;
            case 16:
               return 16;
            case 32:
               return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
               return c & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
               return c & 130023424;
            case 134217728:
               return 134217728;
            case 268435456:
               return 268435456;
            case 536870912:
               return 536870912;
            case 1073741824:
               return 1073741824;
            default:
               return c
         }
      }

      function Dp(c, f) {
         var y = c.pendingLanes;
         if (y === 0) return 0;
         var M = 0,
            w = c.suspendedLanes,
            P = c.pingedLanes,
            V = y & 268435455;
         if (V !== 0) {
            var re = V & ~w;
            re !== 0 ? M = Vf(re) : (P &= V, P !== 0 && (M = Vf(P)))
         } else V = y & ~w, V !== 0 ? M = Vf(V) : P !== 0 && (M = Vf(P));
         if (M === 0) return 0;
         if (f !== 0 && f !== M && !(f & w) && (w = M & -M, P = f & -f, w >= P || w === 16 && (P & 4194240) !== 0)) return f;
         if (M & 4 && (M |= y & 16), f = c.entangledLanes, f !== 0)
            for (c = c.entanglements, f &= M; 0 < f;) y = 31 - _n(f), w = 1 << y, M |= c[y], f &= ~w;
         return M
      }

      function Wk(c, f) {
         switch (c) {
            case 1:
            case 2:
            case 4:
               return f + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
               return f + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
               return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
               return -1;
            default:
               return -1
         }
      }

      function jk(c, f) {
         for (var y = c.suspendedLanes, M = c.pingedLanes, w = c.expirationTimes, P = c.pendingLanes; 0 < P;) {
            var V = 31 - _n(P),
               re = 1 << V,
               ve = w[V];
            ve === -1 ? (!(re & y) || re & M) && (w[V] = Wk(re, f)) : ve <= f && (c.expiredLanes |= re), P &= ~re
         }
      }

      function by(c) {
         return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0
      }

      function Cy(c) {
         for (var f = [], y = 0; 31 > y; y++) f.push(c);
         return f
      }

      function Wf(c, f, y) {
         c.pendingLanes |= f, f !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, f = 31 - _n(f), c[f] = y
      }

      function $k(c, f) {
         var y = c.pendingLanes & ~f;
         c.pendingLanes = f, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= f, c.mutableReadLanes &= f, c.entangledLanes &= f, f = c.entanglements;
         var M = c.eventTimes;
         for (c = c.expirationTimes; 0 < y;) {
            var w = 31 - _n(y),
               P = 1 << w;
            f[w] = 0, M[w] = -1, c[w] = -1, y &= ~P
         }
      }

      function Ty(c, f) {
         var y = c.entangledLanes |= f;
         for (c = c.entanglements; y;) {
            var M = 31 - _n(y),
               w = 1 << M;
            w & f | c[M] & f && (c[M] |= f), y &= ~w
         }
      }
      var Kt = 0;

      function qw(c) {
         return c &= -c, 1 < c ? 4 < c ? c & 268435455 ? 16 : 536870912 : 4 : 1
      }
      var Ry = i.unstable_scheduleCallback,
         eb = i.unstable_cancelCallback,
         Xk = i.unstable_shouldYield,
         Jk = i.unstable_requestPaint,
         ir = i.unstable_now,
         Py = i.unstable_ImmediatePriority,
         Kk = i.unstable_UserBlockingPriority,
         By = i.unstable_NormalPriority,
         Yk = i.unstable_IdlePriority,
         Fp = null,
         Cs = null;

      function Qk(c) {
         if (Cs && typeof Cs.onCommitFiberRoot == "function") try {
            Cs.onCommitFiberRoot(Fp, c, void 0, (c.current.flags & 128) === 128)
         } catch {}
      }

      function Zk(c, f) {
         return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f
      }
      var Ts = typeof Object.is == "function" ? Object.is : Zk,
         to = null,
         Op = !1,
         Iy = !1;

      function tb(c) {
         to === null ? to = [c] : to.push(c)
      }

      function qk(c) {
         Op = !0, tb(c)
      }

      function Rs() {
         if (!Iy && to !== null) {
            Iy = !0;
            var c = 0,
               f = Kt;
            try {
               var y = to;
               for (Kt = 1; c < y.length; c++) {
                  var M = y[c];
                  do M = M(!0); while (M !== null)
               }
               to = null, Op = !1
            } catch (w) {
               throw to !== null && (to = to.slice(c + 1)), Ry(Py, Rs), w
            } finally {
               Kt = f, Iy = !1
            }
         }
         return null
      }
      var e4 = a.ReactCurrentBatchConfig;

      function Np(c, f) {
         if (Ts(c, f)) return !0;
         if (typeof c != "object" || c === null || typeof f != "object" || f === null) return !1;
         var y = Object.keys(c),
            M = Object.keys(f);
         if (y.length !== M.length) return !1;
         for (M = 0; M < y.length; M++) {
            var w = y[M];
            if (!ct.call(f, w) || !Ts(c[w], f[w])) return !1
         }
         return !0
      }

      function t4(c) {
         switch (c.tag) {
            case 5:
               return Xe(c.type);
            case 16:
               return Xe("Lazy");
            case 13:
               return Xe("Suspense");
            case 19:
               return Xe("SuspenseList");
            case 0:
            case 2:
            case 15:
               return c = He(c.type, !1), c;
            case 11:
               return c = He(c.type.render, !1), c;
            case 1:
               return c = He(c.type, !0), c;
            default:
               return ""
         }
      }

      function es(c, f) {
         if (c && c.defaultProps) {
            f = s({}, f), c = c.defaultProps;
            for (var y in c) f[y] === void 0 && (f[y] = c[y]);
            return f
         }
         return f
      }
      var Up = We(null),
         kp = null,
         _u = null,
         Ly = null;

      function Dy() {
         Ly = _u = kp = null
      }

      function nb(c, f, y) {
         kt ? (it(Up, f._currentValue), f._currentValue = y) : (it(Up, f._currentValue2), f._currentValue2 = y)
      }

      function Fy(c) {
         var f = Up.current;
         xt(Up), kt ? c._currentValue = f : c._currentValue2 = f
      }

      function Oy(c, f, y) {
         for (; c !== null;) {
            var M = c.alternate;
            if ((c.childLanes & f) !== f ? (c.childLanes |= f, M !== null && (M.childLanes |= f)) : M !== null && (M.childLanes & f) !== f && (M.childLanes |= f), c === y) break;
            c = c.return
         }
      }

      function Au(c, f) {
         kp = c, Ly = _u = null, c = c.dependencies, c !== null && c.firstContext !== null && (c.lanes & f && (li = !0), c.firstContext = null)
      }

      function Ti(c) {
         var f = kt ? c._currentValue : c._currentValue2;
         if (Ly !== c)
            if (c = {
                  context: c,
                  memoizedValue: f,
                  next: null
               }, _u === null) {
               if (kp === null) throw Error(o(308));
               _u = c, kp.dependencies = {
                  lanes: 0,
                  firstContext: c
               }
            } else _u = _u.next = c;
         return f
      }
      var Ps = null,
         Vo = !1;

      function Ny(c) {
         c.updateQueue = {
            baseState: c.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
               pending: null,
               interleaved: null,
               lanes: 0
            },
            effects: null
         }
      }

      function rb(c, f) {
         c = c.updateQueue, f.updateQueue === c && (f.updateQueue = {
            baseState: c.baseState,
            firstBaseUpdate: c.firstBaseUpdate,
            lastBaseUpdate: c.lastBaseUpdate,
            shared: c.shared,
            effects: c.effects
         })
      }

      function no(c, f) {
         return {
            eventTime: c,
            lane: f,
            tag: 0,
            payload: null,
            callback: null,
            next: null
         }
      }

      function Wo(c, f) {
         var y = c.updateQueue;
         y !== null && (y = y.shared, zn !== null && c.mode & 1 && !(Nt & 2) ? (c = y.interleaved, c === null ? (f.next = f, Ps === null ? Ps = [y] : Ps.push(y)) : (f.next = c.next, c.next = f), y.interleaved = f) : (c = y.pending, c === null ? f.next = f : (f.next = c.next, c.next = f), y.pending = f))
      }

      function Hp(c, f, y) {
         if (f = f.updateQueue, f !== null && (f = f.shared, (y & 4194240) !== 0)) {
            var M = f.lanes;
            M &= c.pendingLanes, y |= M, f.lanes = y, Ty(c, y)
         }
      }

      function ib(c, f) {
         var y = c.updateQueue,
            M = c.alternate;
         if (M !== null && (M = M.updateQueue, y === M)) {
            var w = null,
               P = null;
            if (y = y.firstBaseUpdate, y !== null) {
               do {
                  var V = {
                     eventTime: y.eventTime,
                     lane: y.lane,
                     tag: y.tag,
                     payload: y.payload,
                     callback: y.callback,
                     next: null
                  };
                  P === null ? w = P = V : P = P.next = V, y = y.next
               } while (y !== null);
               P === null ? w = P = f : P = P.next = f
            } else w = P = f;
            y = {
               baseState: M.baseState,
               firstBaseUpdate: w,
               lastBaseUpdate: P,
               shared: M.shared,
               effects: M.effects
            }, c.updateQueue = y;
            return
         }
         c = y.lastBaseUpdate, c === null ? y.firstBaseUpdate = f : c.next = f, y.lastBaseUpdate = f
      }

      function Gp(c, f, y, M) {
         var w = c.updateQueue;
         Vo = !1;
         var P = w.firstBaseUpdate,
            V = w.lastBaseUpdate,
            re = w.shared.pending;
         if (re !== null) {
            w.shared.pending = null;
            var ve = re,
               De = ve.next;
            ve.next = null, V === null ? P = De : V.next = De, V = ve;
            var tt = c.alternate;
            tt !== null && (tt = tt.updateQueue, re = tt.lastBaseUpdate, re !== V && (re === null ? tt.firstBaseUpdate = De : re.next = De, tt.lastBaseUpdate = ve))
         }
         if (P !== null) {
            var bt = w.baseState;
            V = 0, tt = De = ve = null, re = P;
            do {
               var gt = re.lane,
                  an = re.eventTime;
               if ((M & gt) === gt) {
                  tt !== null && (tt = tt.next = {
                     eventTime: an,
                     lane: 0,
                     tag: re.tag,
                     payload: re.payload,
                     callback: re.callback,
                     next: null
                  });
                  e: {
                     var ft = c,
                        _r = re;
                     switch (gt = f, an = y, _r.tag) {
                        case 1:
                           if (ft = _r.payload, typeof ft == "function") {
                              bt = ft.call(an, bt, gt);
                              break e
                           }
                           bt = ft;
                           break e;
                        case 3:
                           ft.flags = ft.flags & -65537 | 128;
                        case 0:
                           if (ft = _r.payload, gt = typeof ft == "function" ? ft.call(an, bt, gt) : ft, gt == null) break e;
                           bt = s({}, bt, gt);
                           break e;
                        case 2:
                           Vo = !0
                     }
                  }
                  re.callback !== null && re.lane !== 0 && (c.flags |= 64, gt = w.effects, gt === null ? w.effects = [re] : gt.push(re))
               } else an = {
                  eventTime: an,
                  lane: gt,
                  tag: re.tag,
                  payload: re.payload,
                  callback: re.callback,
                  next: null
               }, tt === null ? (De = tt = an, ve = bt) : tt = tt.next = an, V |= gt;
               if (re = re.next, re === null) {
                  if (re = w.shared.pending, re === null) break;
                  gt = re, re = gt.next, gt.next = null, w.lastBaseUpdate = gt, w.shared.pending = null
               }
            } while (1);
            if (tt === null && (ve = bt), w.baseState = ve, w.firstBaseUpdate = De, w.lastBaseUpdate = tt, f = w.shared.interleaved, f !== null) {
               w = f;
               do V |= w.lane, w = w.next; while (w !== f)
            } else P === null && (w.shared.lanes = 0);
            Pu |= V, c.lanes = V, c.memoizedState = bt
         }
      }

      function sb(c, f, y) {
         if (c = f.effects, f.effects = null, c !== null)
            for (f = 0; f < c.length; f++) {
               var M = c[f],
                  w = M.callback;
               if (w !== null) {
                  if (M.callback = null, M = y, typeof w != "function") throw Error(o(191, w));
                  w.call(M)
               }
            }
      }
      var ob = new r.Component().refs;

      function Uy(c, f, y, M) {
         f = c.memoizedState, y = y(M, f), y = y == null ? f : s({}, f, y), c.memoizedState = y, c.lanes === 0 && (c.updateQueue.baseState = y)
      }
      var zp = {
         isMounted: function (c) {
            return (c = c._reactInternals) ? T(c) === c : !1
         },
         enqueueSetState: function (c, f, y) {
            c = c._reactInternals;
            var M = Dr(),
               w = Xo(c),
               P = no(M, w);
            P.payload = f, y != null && (P.callback = y), Wo(c, P), f = Li(c, w, M), f !== null && Hp(f, c, w)
         },
         enqueueReplaceState: function (c, f, y) {
            c = c._reactInternals;
            var M = Dr(),
               w = Xo(c),
               P = no(M, w);
            P.tag = 1, P.payload = f, y != null && (P.callback = y), Wo(c, P), f = Li(c, w, M), f !== null && Hp(f, c, w)
         },
         enqueueForceUpdate: function (c, f) {
            c = c._reactInternals;
            var y = Dr(),
               M = Xo(c),
               w = no(y, M);
            w.tag = 2, f != null && (w.callback = f), Wo(c, w), f = Li(c, M, y), f !== null && Hp(f, c, M)
         }
      };

      function ab(c, f, y, M, w, P, V) {
         return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(M, P, V) : f.prototype && f.prototype.isPureReactComponent ? !Np(y, M) || !Np(w, P) : !0
      }

      function lb(c, f, y) {
         var M = !1,
            w = wt,
            P = f.contextType;
         return typeof P == "object" && P !== null ? P = Ti(P) : (w = on(f) ? nn : tn.current, M = f.contextTypes, P = (M = M != null) ? Jt(c, w) : wt), f = new f(y, P), c.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null, f.updater = zp, c.stateNode = f, f._reactInternals = c, M && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = w, c.__reactInternalMemoizedMaskedChildContext = P), f
      }

      function ub(c, f, y, M) {
         c = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(y, M), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(y, M), f.state !== c && zp.enqueueReplaceState(f, f.state, null)
      }

      function ky(c, f, y, M) {
         var w = c.stateNode;
         w.props = y, w.state = c.memoizedState, w.refs = ob, Ny(c);
         var P = f.contextType;
         typeof P == "object" && P !== null ? w.context = Ti(P) : (P = on(f) ? nn : tn.current, w.context = Jt(c, P)), w.state = c.memoizedState, P = f.getDerivedStateFromProps, typeof P == "function" && (Uy(c, f, P, y), w.state = c.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (f = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), f !== w.state && zp.enqueueReplaceState(w, w.state, null), Gp(c, y, w, M), w.state = c.memoizedState), typeof w.componentDidMount == "function" && (c.flags |= 4194308)
      }
      var Su = [],
         Mu = 0,
         Vp = null,
         Wp = 0,
         Ri = [],
         Pi = 0,
         Za = null,
         ro = 1,
         io = "";

      function qa(c, f) {
         Su[Mu++] = Wp, Su[Mu++] = Vp, Vp = c, Wp = f
      }

      function cb(c, f, y) {
         Ri[Pi++] = ro, Ri[Pi++] = io, Ri[Pi++] = Za, Za = c;
         var M = ro;
         c = io;
         var w = 32 - _n(M) - 1;
         M &= ~(1 << w), y += 1;
         var P = 32 - _n(f) + w;
         if (30 < P) {
            var V = w - w % 5;
            P = (M & (1 << V) - 1).toString(32), M >>= V, w -= V, ro = 1 << 32 - _n(f) + w | y << w | M, io = P + c
         } else ro = 1 << P | y << w | M, io = c
      }

      function Hy(c) {
         c.return !== null && (qa(c, 1), cb(c, 1, 0))
      }

      function Gy(c) {
         for (; c === Vp;) Vp = Su[--Mu], Su[Mu] = null, Wp = Su[--Mu], Su[Mu] = null;
         for (; c === Za;) Za = Ri[--Pi], Ri[Pi] = null, io = Ri[--Pi], Ri[Pi] = null, ro = Ri[--Pi], Ri[Pi] = null
      }
      var oi = null,
         ai = null,
         An = !1,
         jf = !1,
         ts = null;

      function fb(c, f) {
         var y = Di(5, null, null, 0);
         y.elementType = "DELETED", y.stateNode = f, y.return = c, f = c.deletions, f === null ? (c.deletions = [y], c.flags |= 16) : f.push(y)
      }

      function hb(c, f) {
         switch (c.tag) {
            case 5:
               return f = Kn(f, c.type, c.pendingProps), f !== null ? (c.stateNode = f, oi = c, ai = Lt(f), !0) : !1;
            case 6:
               return f = vu(f, c.pendingProps), f !== null ? (c.stateNode = f, oi = c, ai = null, !0) : !1;
            case 13:
               if (f = yu(f), f !== null) {
                  var y = Za !== null ? {
                     id: ro,
                     overflow: io
                  } : null;
                  return c.memoizedState = {
                     dehydrated: f,
                     treeContext: y,
                     retryLane: 1073741824
                  }, y = Di(18, null, null, 0), y.stateNode = f, y.return = c, c.child = y, oi = c, ai = null, !0
               }
               return !1;
            default:
               return !1
         }
      }

      function zy(c) {
         return (c.mode & 1) !== 0 && (c.flags & 128) === 0
      }

      function Vy(c) {
         if (An) {
            var f = ai;
            if (f) {
               var y = f;
               if (!hb(c, f)) {
                  if (zy(c)) throw Error(o(418));
                  f = gr(y);
                  var M = oi;
                  f && hb(c, f) ? fb(M, y) : (c.flags = c.flags & -4097 | 2, An = !1, oi = c)
               }
            } else {
               if (zy(c)) throw Error(o(418));
               c.flags = c.flags & -4097 | 2, An = !1, oi = c
            }
         }
      }

      function db(c) {
         for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13;) c = c.return;
         oi = c
      }

      function $f(c) {
         if (!Ce || c !== oi) return !1;
         if (!An) return db(c), An = !0, !1;
         if (c.tag !== 3 && (c.tag !== 5 || ye(c.type) && !we(c.type, c.memoizedProps))) {
            var f = ai;
            if (f) {
               if (zy(c)) {
                  for (c = ai; c;) c = gr(c);
                  throw Error(o(418))
               }
               for (; f;) fb(c, f), f = gr(f)
            }
         }
         if (db(c), c.tag === 13) {
            if (!Ce) throw Error(o(316));
            if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(o(317));
            ai = H(c)
         } else ai = oi ? gr(c.stateNode) : null;
         return !0
      }

      function Eu() {
         Ce && (ai = oi = null, jf = An = !1)
      }

      function Wy(c) {
         ts === null ? ts = [c] : ts.push(c)
      }

      function Xf(c, f, y) {
         if (c = y.ref, c !== null && typeof c != "function" && typeof c != "object") {
            if (y._owner) {
               if (y = y._owner, y) {
                  if (y.tag !== 1) throw Error(o(309));
                  var M = y.stateNode
               }
               if (!M) throw Error(o(147, c));
               var w = M,
                  P = "" + c;
               return f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === P ? f.ref : (f = function (V) {
                  var re = w.refs;
                  re === ob && (re = w.refs = {}), V === null ? delete re[P] : re[P] = V
               }, f._stringRef = P, f)
            }
            if (typeof c != "string") throw Error(o(284));
            if (!y._owner) throw Error(o(290, c))
         }
         return c
      }

      function jp(c, f) {
         throw c = Object.prototype.toString.call(f), Error(o(31, c === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : c))
      }

      function pb(c) {
         var f = c._init;
         return f(c._payload)
      }

      function mb(c) {
         function f(le, ie) {
            if (c) {
               var pe = le.deletions;
               pe === null ? (le.deletions = [ie], le.flags |= 16) : pe.push(ie)
            }
         }

         function y(le, ie) {
            if (!c) return null;
            for (; ie !== null;) f(le, ie), ie = ie.sibling;
            return null
         }

         function M(le, ie) {
            for (le = new Map; ie !== null;) ie.key !== null ? le.set(ie.key, ie) : le.set(ie.index, ie), ie = ie.sibling;
            return le
         }

         function w(le, ie) {
            return le = Ko(le, ie), le.index = 0, le.sibling = null, le
         }

         function P(le, ie, pe) {
            return le.index = pe, c ? (pe = le.alternate, pe !== null ? (pe = pe.index, pe < ie ? (le.flags |= 2, ie) : pe) : (le.flags |= 2, ie)) : (le.flags |= 1048576, ie)
         }

         function V(le) {
            return c && le.alternate === null && (le.flags |= 2), le
         }

         function re(le, ie, pe, je) {
            return ie === null || ie.tag !== 6 ? (ie = Cx(pe, le.mode, je), ie.return = le, ie) : (ie = w(ie, pe), ie.return = le, ie)
         }

         function ve(le, ie, pe, je) {
            var ut = pe.type;
            return ut === h ? tt(le, ie, pe.props.children, je, pe.key) : ie !== null && (ie.elementType === ut || typeof ut == "object" && ut !== null && ut.$$typeof === A && pb(ut) === ie.type) ? (je = w(ie, pe.props), je.ref = Xf(le, ie, pe), je.return = le, je) : (je = Sm(pe.type, pe.key, pe.props, null, le.mode, je), je.ref = Xf(le, ie, pe), je.return = le, je)
         }

         function De(le, ie, pe, je) {
            return ie === null || ie.tag !== 4 || ie.stateNode.containerInfo !== pe.containerInfo || ie.stateNode.implementation !== pe.implementation ? (ie = Tx(pe, le.mode, je), ie.return = le, ie) : (ie = w(ie, pe.children || []), ie.return = le, ie)
         }

         function tt(le, ie, pe, je, ut) {
            return ie === null || ie.tag !== 7 ? (ie = ol(pe, le.mode, je, ut), ie.return = le, ie) : (ie = w(ie, pe), ie.return = le, ie)
         }

         function bt(le, ie, pe) {
            if (typeof ie == "string" && ie !== "" || typeof ie == "number") return ie = Cx("" + ie, le.mode, pe), ie.return = le, ie;
            if (typeof ie == "object" && ie !== null) {
               switch (ie.$$typeof) {
                  case l:
                     return pe = Sm(ie.type, ie.key, ie.props, null, le.mode, pe), pe.ref = Xf(le, null, ie), pe.return = le, pe;
                  case u:
                     return ie = Tx(ie, le.mode, pe), ie.return = le, ie;
                  case A:
                     var je = ie._init;
                     return bt(le, je(ie._payload), pe)
               }
               if (te(ie) || R(ie)) return ie = ol(ie, le.mode, pe, null), ie.return = le, ie;
               jp(le, ie)
            }
            return null
         }

         function gt(le, ie, pe, je) {
            var ut = ie !== null ? ie.key : null;
            if (typeof pe == "string" && pe !== "" || typeof pe == "number") return ut !== null ? null : re(le, ie, "" + pe, je);
            if (typeof pe == "object" && pe !== null) {
               switch (pe.$$typeof) {
                  case l:
                     return pe.key === ut ? ve(le, ie, pe, je) : null;
                  case u:
                     return pe.key === ut ? De(le, ie, pe, je) : null;
                  case A:
                     return ut = pe._init, gt(le, ie, ut(pe._payload), je)
               }
               if (te(pe) || R(pe)) return ut !== null ? null : tt(le, ie, pe, je, null);
               jp(le, pe)
            }
            return null
         }

         function an(le, ie, pe, je, ut) {
            if (typeof je == "string" && je !== "" || typeof je == "number") return le = le.get(pe) || null, re(ie, le, "" + je, ut);
            if (typeof je == "object" && je !== null) {
               switch (je.$$typeof) {
                  case l:
                     return le = le.get(je.key === null ? pe : je.key) || null, ve(ie, le, je, ut);
                  case u:
                     return le = le.get(je.key === null ? pe : je.key) || null, De(ie, le, je, ut);
                  case A:
                     var Dt = je._init;
                     return an(le, ie, pe, Dt(je._payload), ut)
               }
               if (te(je) || R(je)) return le = le.get(pe) || null, tt(ie, le, je, ut, null);
               jp(ie, je)
            }
            return null
         }

         function ft(le, ie, pe, je) {
            for (var ut = null, Dt = null, Ct = ie, Yt = ie = 0, or = null; Ct !== null && Yt < pe.length; Yt++) {
               Ct.index > Yt ? (or = Ct, Ct = null) : or = Ct.sibling;
               var Qt = gt(le, Ct, pe[Yt], je);
               if (Qt === null) {
                  Ct === null && (Ct = or);
                  break
               }
               c && Ct && Qt.alternate === null && f(le, Ct), ie = P(Qt, ie, Yt), Dt === null ? ut = Qt : Dt.sibling = Qt, Dt = Qt, Ct = or
            }
            if (Yt === pe.length) return y(le, Ct), An && qa(le, Yt), ut;
            if (Ct === null) {
               for (; Yt < pe.length; Yt++) Ct = bt(le, pe[Yt], je), Ct !== null && (ie = P(Ct, ie, Yt), Dt === null ? ut = Ct : Dt.sibling = Ct, Dt = Ct);
               return An && qa(le, Yt), ut
            }
            for (Ct = M(le, Ct); Yt < pe.length; Yt++) or = an(Ct, le, Yt, pe[Yt], je), or !== null && (c && or.alternate !== null && Ct.delete(or.key === null ? Yt : or.key), ie = P(or, ie, Yt), Dt === null ? ut = or : Dt.sibling = or, Dt = or);
            return c && Ct.forEach(function (Yo) {
               return f(le, Yo)
            }), An && qa(le, Yt), ut
         }

         function _r(le, ie, pe, je) {
            var ut = R(pe);
            if (typeof ut != "function") throw Error(o(150));
            if (pe = ut.call(pe), pe == null) throw Error(o(151));
            for (var Dt = ut = null, Ct = ie, Yt = ie = 0, or = null, Qt = pe.next(); Ct !== null && !Qt.done; Yt++, Qt = pe.next()) {
               Ct.index > Yt ? (or = Ct, Ct = null) : or = Ct.sibling;
               var Yo = gt(le, Ct, Qt.value, je);
               if (Yo === null) {
                  Ct === null && (Ct = or);
                  break
               }
               c && Ct && Yo.alternate === null && f(le, Ct), ie = P(Yo, ie, Yt), Dt === null ? ut = Yo : Dt.sibling = Yo, Dt = Yo, Ct = or
            }
            if (Qt.done) return y(le, Ct), An && qa(le, Yt), ut;
            if (Ct === null) {
               for (; !Qt.done; Yt++, Qt = pe.next()) Qt = bt(le, Qt.value, je), Qt !== null && (ie = P(Qt, ie, Yt), Dt === null ? ut = Qt : Dt.sibling = Qt, Dt = Qt);
               return An && qa(le, Yt), ut
            }
            for (Ct = M(le, Ct); !Qt.done; Yt++, Qt = pe.next()) Qt = an(Ct, le, Yt, Qt.value, je), Qt !== null && (c && Qt.alternate !== null && Ct.delete(Qt.key === null ? Yt : Qt.key), ie = P(Qt, ie, Yt), Dt === null ? ut = Qt : Dt.sibling = Qt, Dt = Qt);
            return c && Ct.forEach(function (B4) {
               return f(le, B4)
            }), An && qa(le, Yt), ut
         }

         function Fi(le, ie, pe, je) {
            if (typeof pe == "object" && pe !== null && pe.type === h && pe.key === null && (pe = pe.props.children), typeof pe == "object" && pe !== null) {
               switch (pe.$$typeof) {
                  case l:
                     e: {
                        for (var ut = pe.key, Dt = ie; Dt !== null;) {
                           if (Dt.key === ut) {
                              if (ut = pe.type, ut === h) {
                                 if (Dt.tag === 7) {
                                    y(le, Dt.sibling), ie = w(Dt, pe.props.children), ie.return = le, le = ie;
                                    break e
                                 }
                              } else if (Dt.elementType === ut || typeof ut == "object" && ut !== null && ut.$$typeof === A && pb(ut) === Dt.type) {
                                 y(le, Dt.sibling), ie = w(Dt, pe.props), ie.ref = Xf(le, Dt, pe), ie.return = le, le = ie;
                                 break e
                              }
                              y(le, Dt);
                              break
                           } else f(le, Dt);
                           Dt = Dt.sibling
                        }
                        pe.type === h ? (ie = ol(pe.props.children, le.mode, je, pe.key), ie.return = le, le = ie) : (je = Sm(pe.type, pe.key, pe.props, null, le.mode, je), je.ref = Xf(le, ie, pe), je.return = le, le = je)
                     }
                     return V(le);
                  case u:
                     e: {
                        for (Dt = pe.key; ie !== null;) {
                           if (ie.key === Dt)
                              if (ie.tag === 4 && ie.stateNode.containerInfo === pe.containerInfo && ie.stateNode.implementation === pe.implementation) {
                                 y(le, ie.sibling), ie = w(ie, pe.children || []), ie.return = le, le = ie;
                                 break e
                              } else {
                                 y(le, ie);
                                 break
                              }
                           else f(le, ie);
                           ie = ie.sibling
                        }
                        ie = Tx(pe, le.mode, je),
                        ie.return = le,
                        le = ie
                     }
                     return V(le);
                  case A:
                     return Dt = pe._init, Fi(le, ie, Dt(pe._payload), je)
               }
               if (te(pe)) return ft(le, ie, pe, je);
               if (R(pe)) return _r(le, ie, pe, je);
               jp(le, pe)
            }
            return typeof pe == "string" && pe !== "" || typeof pe == "number" ? (pe = "" + pe, ie !== null && ie.tag === 6 ? (y(le, ie.sibling), ie = w(ie, pe), ie.return = le, le = ie) : (y(le, ie), ie = Cx(pe, le.mode, je), ie.return = le, le = ie), V(le)) : y(le, ie)
         }
         return Fi
      }
      var wu = mb(!0),
         gb = mb(!1),
         Jf = {},
         Bi = We(Jf),
         Kf = We(Jf),
         bu = We(Jf);

      function Bs(c) {
         if (c === Jf) throw Error(o(174));
         return c
      }

      function jy(c, f) {
         it(bu, f), it(Kf, c), it(Bi, Jf), c = oe(f), xt(Bi), it(Bi, c)
      }

      function Cu() {
         xt(Bi), xt(Kf), xt(bu)
      }

      function vb(c) {
         var f = Bs(bu.current),
            y = Bs(Bi.current);
         f = G(y, c.type, f), y !== f && (it(Kf, c), it(Bi, f))
      }

      function $y(c) {
         Kf.current === c && (xt(Bi), xt(Kf))
      }
      var bn = We(0);

      function $p(c) {
         for (var f = c; f !== null;) {
            if (f.tag === 13) {
               var y = f.memoizedState;
               if (y !== null && (y = y.dehydrated, y === null || qs(y) || Es(y))) return f
            } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
               if (f.flags & 128) return f
            } else if (f.child !== null) {
               f.child.return = f, f = f.child;
               continue
            }
            if (f === c) break;
            for (; f.sibling === null;) {
               if (f.return === null || f.return === c) return null;
               f = f.return
            }
            f.sibling.return = f.return, f = f.sibling
         }
         return null
      }
      var Xy = [];

      function Jy() {
         for (var c = 0; c < Xy.length; c++) {
            var f = Xy[c];
            kt ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null
         }
         Xy.length = 0
      }
      var Xp = a.ReactCurrentDispatcher,
         Ii = a.ReactCurrentBatchConfig,
         Tu = 0,
         In = null,
         vr = null,
         sr = null,
         Jp = !1,
         Yf = !1,
         Qf = 0,
         n4 = 0;

      function yr() {
         throw Error(o(321))
      }

      function Ky(c, f) {
         if (f === null) return !1;
         for (var y = 0; y < f.length && y < c.length; y++)
            if (!Ts(c[y], f[y])) return !1;
         return !0
      }

      function Yy(c, f, y, M, w, P) {
         if (Tu = P, In = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, Xp.current = c === null || c.memoizedState === null ? o4 : a4, c = y(M, w), Yf) {
            P = 0;
            do {
               if (Yf = !1, Qf = 0, 25 <= P) throw Error(o(301));
               P += 1, sr = vr = null, f.updateQueue = null, Xp.current = l4, c = y(M, w)
            } while (Yf)
         }
         if (Xp.current = qp, f = vr !== null && vr.next !== null, Tu = 0, sr = vr = In = null, Jp = !1, f) throw Error(o(300));
         return c
      }

      function Qy() {
         var c = Qf !== 0;
         return Qf = 0, c
      }

      function so() {
         var c = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
         };
         return sr === null ? In.memoizedState = sr = c : sr = sr.next = c, sr
      }

      function Is() {
         if (vr === null) {
            var c = In.alternate;
            c = c !== null ? c.memoizedState : null
         } else c = vr.next;
         var f = sr === null ? In.memoizedState : sr.next;
         if (f !== null) sr = f, vr = c;
         else {
            if (c === null) throw Error(o(310));
            vr = c, c = {
               memoizedState: vr.memoizedState,
               baseState: vr.baseState,
               baseQueue: vr.baseQueue,
               queue: vr.queue,
               next: null
            }, sr === null ? In.memoizedState = sr = c : sr = sr.next = c
         }
         return sr
      }

      function el(c, f) {
         return typeof f == "function" ? f(c) : f
      }

      function Kp(c) {
         var f = Is(),
            y = f.queue;
         if (y === null) throw Error(o(311));
         y.lastRenderedReducer = c;
         var M = vr,
            w = M.baseQueue,
            P = y.pending;
         if (P !== null) {
            if (w !== null) {
               var V = w.next;
               w.next = P.next, P.next = V
            }
            M.baseQueue = w = P, y.pending = null
         }
         if (w !== null) {
            P = w.next, M = M.baseState;
            var re = V = null,
               ve = null,
               De = P;
            do {
               var tt = De.lane;
               if ((Tu & tt) === tt) ve !== null && (ve = ve.next = {
                  lane: 0,
                  action: De.action,
                  hasEagerState: De.hasEagerState,
                  eagerState: De.eagerState,
                  next: null
               }), M = De.hasEagerState ? De.eagerState : c(M, De.action);
               else {
                  var bt = {
                     lane: tt,
                     action: De.action,
                     hasEagerState: De.hasEagerState,
                     eagerState: De.eagerState,
                     next: null
                  };
                  ve === null ? (re = ve = bt, V = M) : ve = ve.next = bt, In.lanes |= tt, Pu |= tt
               }
               De = De.next
            } while (De !== null && De !== P);
            ve === null ? V = M : ve.next = re, Ts(M, f.memoizedState) || (li = !0), f.memoizedState = M, f.baseState = V, f.baseQueue = ve, y.lastRenderedState = M
         }
         if (c = y.interleaved, c !== null) {
            w = c;
            do P = w.lane, In.lanes |= P, Pu |= P, w = w.next; while (w !== c)
         } else w === null && (y.lanes = 0);
         return [f.memoizedState, y.dispatch]
      }

      function Yp(c) {
         var f = Is(),
            y = f.queue;
         if (y === null) throw Error(o(311));
         y.lastRenderedReducer = c;
         var M = y.dispatch,
            w = y.pending,
            P = f.memoizedState;
         if (w !== null) {
            y.pending = null;
            var V = w = w.next;
            do P = c(P, V.action), V = V.next; while (V !== w);
            Ts(P, f.memoizedState) || (li = !0), f.memoizedState = P, f.baseQueue === null && (f.baseState = P), y.lastRenderedState = P
         }
         return [P, M]
      }

      function yb() {}

      function xb(c, f) {
         var y = In,
            M = Is(),
            w = f(),
            P = !Ts(M.memoizedState, w);
         if (P && (M.memoizedState = w, li = !0), M = M.queue, qf(Sb.bind(null, y, M, c), [c]), M.getSnapshot !== f || P || sr !== null && sr.memoizedState.tag & 1) {
            if (y.flags |= 2048, Zf(9, Ab.bind(null, y, M, w, f), void 0, null), zn === null) throw Error(o(349));
            Tu & 30 || _b(y, f, w)
         }
         return w
      }

      function _b(c, f, y) {
         c.flags |= 16384, c = {
            getSnapshot: f,
            value: y
         }, f = In.updateQueue, f === null ? (f = {
            lastEffect: null,
            stores: null
         }, In.updateQueue = f, f.stores = [c]) : (y = f.stores, y === null ? f.stores = [c] : y.push(c))
      }

      function Ab(c, f, y, M) {
         f.value = y, f.getSnapshot = M, Mb(f) && Li(c, 1, -1)
      }

      function Sb(c, f, y) {
         return y(function () {
            Mb(f) && Li(c, 1, -1)
         })
      }

      function Mb(c) {
         var f = c.getSnapshot;
         c = c.value;
         try {
            var y = f();
            return !Ts(c, y)
         } catch {
            return !0
         }
      }

      function Zy(c) {
         var f = so();
         return typeof c == "function" && (c = c()), f.memoizedState = f.baseState = c, c = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: el,
            lastRenderedState: c
         }, f.queue = c, c = c.dispatch = s4.bind(null, In, c), [f.memoizedState, c]
      }

      function Zf(c, f, y, M) {
         return c = {
            tag: c,
            create: f,
            destroy: y,
            deps: M,
            next: null
         }, f = In.updateQueue, f === null ? (f = {
            lastEffect: null,
            stores: null
         }, In.updateQueue = f, f.lastEffect = c.next = c) : (y = f.lastEffect, y === null ? f.lastEffect = c.next = c : (M = y.next, y.next = c, c.next = M, f.lastEffect = c)), c
      }

      function Eb() {
         return Is().memoizedState
      }

      function Qp(c, f, y, M) {
         var w = so();
         In.flags |= c, w.memoizedState = Zf(1 | f, y, void 0, M === void 0 ? null : M)
      }

      function Zp(c, f, y, M) {
         var w = Is();
         M = M === void 0 ? null : M;
         var P = void 0;
         if (vr !== null) {
            var V = vr.memoizedState;
            if (P = V.destroy, M !== null && Ky(M, V.deps)) {
               w.memoizedState = Zf(f, y, P, M);
               return
            }
         }
         In.flags |= c, w.memoizedState = Zf(1 | f, y, P, M)
      }

      function qy(c, f) {
         return Qp(8390656, 8, c, f)
      }

      function qf(c, f) {
         return Zp(2048, 8, c, f)
      }

      function wb(c, f) {
         return Zp(4, 2, c, f)
      }

      function bb(c, f) {
         return Zp(4, 4, c, f)
      }

      function Cb(c, f) {
         if (typeof f == "function") return c = c(), f(c),
            function () {
               f(null)
            };
         if (f != null) return c = c(), f.current = c,
            function () {
               f.current = null
            }
      }

      function Tb(c, f, y) {
         return y = y != null ? y.concat([c]) : null, Zp(4, 4, Cb.bind(null, f, c), y)
      }

      function ex() {}

      function Rb(c, f) {
         var y = Is();
         f = f === void 0 ? null : f;
         var M = y.memoizedState;
         return M !== null && f !== null && Ky(f, M[1]) ? M[0] : (y.memoizedState = [c, f], c)
      }

      function Pb(c, f) {
         var y = Is();
         f = f === void 0 ? null : f;
         var M = y.memoizedState;
         return M !== null && f !== null && Ky(f, M[1]) ? M[0] : (c = c(), y.memoizedState = [c, f], c)
      }

      function r4(c, f) {
         var y = Kt;
         Kt = y !== 0 && 4 > y ? y : 4, c(!0);
         var M = Ii.transition;
         Ii.transition = {};
         try {
            c(!1), f()
         } finally {
            Kt = y, Ii.transition = M
         }
      }

      function Bb() {
         return Is().memoizedState
      }

      function i4(c, f, y) {
         var M = Xo(c);
         y = {
            lane: M,
            action: y,
            hasEagerState: !1,
            eagerState: null,
            next: null
         }, Ib(c) ? Lb(f, y) : (Db(c, f, y), y = Dr(), c = Li(c, M, y), c !== null && Fb(c, f, M))
      }

      function s4(c, f, y) {
         var M = Xo(c),
            w = {
               lane: M,
               action: y,
               hasEagerState: !1,
               eagerState: null,
               next: null
            };
         if (Ib(c)) Lb(f, w);
         else {
            Db(c, f, w);
            var P = c.alternate;
            if (c.lanes === 0 && (P === null || P.lanes === 0) && (P = f.lastRenderedReducer, P !== null)) try {
               var V = f.lastRenderedState,
                  re = P(V, y);
               if (w.hasEagerState = !0, w.eagerState = re, Ts(re, V)) return
            } catch {} finally {}
            y = Dr(), c = Li(c, M, y), c !== null && Fb(c, f, M)
         }
      }

      function Ib(c) {
         var f = c.alternate;
         return c === In || f !== null && f === In
      }

      function Lb(c, f) {
         Yf = Jp = !0;
         var y = c.pending;
         y === null ? f.next = f : (f.next = y.next, y.next = f), c.pending = f
      }

      function Db(c, f, y) {
         zn !== null && c.mode & 1 && !(Nt & 2) ? (c = f.interleaved, c === null ? (y.next = y, Ps === null ? Ps = [f] : Ps.push(f)) : (y.next = c.next, c.next = y), f.interleaved = y) : (c = f.pending, c === null ? y.next = y : (y.next = c.next, c.next = y), f.pending = y)
      }

      function Fb(c, f, y) {
         if (y & 4194240) {
            var M = f.lanes;
            M &= c.pendingLanes, y |= M, f.lanes = y, Ty(c, y)
         }
      }
      var qp = {
            readContext: Ti,
            useCallback: yr,
            useContext: yr,
            useEffect: yr,
            useImperativeHandle: yr,
            useInsertionEffect: yr,
            useLayoutEffect: yr,
            useMemo: yr,
            useReducer: yr,
            useRef: yr,
            useState: yr,
            useDebugValue: yr,
            useDeferredValue: yr,
            useTransition: yr,
            useMutableSource: yr,
            useSyncExternalStore: yr,
            useId: yr,
            unstable_isNewReconciler: !1
         },
         o4 = {
            readContext: Ti,
            useCallback: function (c, f) {
               return so().memoizedState = [c, f === void 0 ? null : f], c
            },
            useContext: Ti,
            useEffect: qy,
            useImperativeHandle: function (c, f, y) {
               return y = y != null ? y.concat([c]) : null, Qp(4194308, 4, Cb.bind(null, f, c), y)
            },
            useLayoutEffect: function (c, f) {
               return Qp(4194308, 4, c, f)
            },
            useInsertionEffect: function (c, f) {
               return Qp(4, 2, c, f)
            },
            useMemo: function (c, f) {
               var y = so();
               return f = f === void 0 ? null : f, c = c(), y.memoizedState = [c, f], c
            },
            useReducer: function (c, f, y) {
               var M = so();
               return f = y !== void 0 ? y(f) : f, M.memoizedState = M.baseState = f, c = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: c,
                  lastRenderedState: f
               }, M.queue = c, c = c.dispatch = i4.bind(null, In, c), [M.memoizedState, c]
            },
            useRef: function (c) {
               var f = so();
               return c = {
                  current: c
               }, f.memoizedState = c
            },
            useState: Zy,
            useDebugValue: ex,
            useDeferredValue: function (c) {
               var f = Zy(c),
                  y = f[0],
                  M = f[1];
               return qy(function () {
                  var w = Ii.transition;
                  Ii.transition = {};
                  try {
                     M(c)
                  } finally {
                     Ii.transition = w
                  }
               }, [c]), y
            },
            useTransition: function () {
               var c = Zy(!1),
                  f = c[0];
               return c = r4.bind(null, c[1]), so().memoizedState = c, [f, c]
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (c, f, y) {
               var M = In,
                  w = so();
               if (An) {
                  if (y === void 0) throw Error(o(407));
                  y = y()
               } else {
                  if (y = f(), zn === null) throw Error(o(349));
                  Tu & 30 || _b(M, f, y)
               }
               w.memoizedState = y;
               var P = {
                  value: y,
                  getSnapshot: f
               };
               return w.queue = P, qy(Sb.bind(null, M, P, c), [c]), M.flags |= 2048, Zf(9, Ab.bind(null, M, P, y, f), void 0, null), y
            },
            useId: function () {
               var c = so(),
                  f = zn.identifierPrefix;
               if (An) {
                  var y = io,
                     M = ro;
                  y = (M & ~(1 << 32 - _n(M) - 1)).toString(32) + y, f = ":" + f + "R" + y, y = Qf++, 0 < y && (f += "H" + y.toString(32)), f += ":"
               } else y = n4++, f = ":" + f + "r" + y.toString(32) + ":";
               return c.memoizedState = f
            },
            unstable_isNewReconciler: !1
         },
         a4 = {
            readContext: Ti,
            useCallback: Rb,
            useContext: Ti,
            useEffect: qf,
            useImperativeHandle: Tb,
            useInsertionEffect: wb,
            useLayoutEffect: bb,
            useMemo: Pb,
            useReducer: Kp,
            useRef: Eb,
            useState: function () {
               return Kp(el)
            },
            useDebugValue: ex,
            useDeferredValue: function (c) {
               var f = Kp(el),
                  y = f[0],
                  M = f[1];
               return qf(function () {
                  var w = Ii.transition;
                  Ii.transition = {};
                  try {
                     M(c)
                  } finally {
                     Ii.transition = w
                  }
               }, [c]), y
            },
            useTransition: function () {
               var c = Kp(el)[0],
                  f = Is().memoizedState;
               return [c, f]
            },
            useMutableSource: yb,
            useSyncExternalStore: xb,
            useId: Bb,
            unstable_isNewReconciler: !1
         },
         l4 = {
            readContext: Ti,
            useCallback: Rb,
            useContext: Ti,
            useEffect: qf,
            useImperativeHandle: Tb,
            useInsertionEffect: wb,
            useLayoutEffect: bb,
            useMemo: Pb,
            useReducer: Yp,
            useRef: Eb,
            useState: function () {
               return Yp(el)
            },
            useDebugValue: ex,
            useDeferredValue: function (c) {
               var f = Yp(el),
                  y = f[0],
                  M = f[1];
               return qf(function () {
                  var w = Ii.transition;
                  Ii.transition = {};
                  try {
                     M(c)
                  } finally {
                     Ii.transition = w
                  }
               }, [c]), y
            },
            useTransition: function () {
               var c = Yp(el)[0],
                  f = Is().memoizedState;
               return [c, f]
            },
            useMutableSource: yb,
            useSyncExternalStore: xb,
            useId: Bb,
            unstable_isNewReconciler: !1
         };

      function tx(c, f) {
         try {
            var y = "",
               M = f;
            do y += t4(M), M = M.return; while (M);
            var w = y
         } catch (P) {
            w = `
Error generating stack: ` + P.message + `
` + P.stack
         }
         return {
            value: c,
            source: f,
            stack: w
         }
      }

      function nx(c, f) {
         try {
            console.error(f.value)
         } catch (y) {
            setTimeout(function () {
               throw y
            })
         }
      }
      var u4 = typeof WeakMap == "function" ? WeakMap : Map;

      function Ob(c, f, y) {
         y = no(-1, y), y.tag = 3, y.payload = {
            element: null
         };
         var M = f.value;
         return y.callback = function () {
            mm || (mm = !0, _x = M), nx(c, f)
         }, y
      }

      function Nb(c, f, y) {
         y = no(-1, y), y.tag = 3;
         var M = c.type.getDerivedStateFromError;
         if (typeof M == "function") {
            var w = f.value;
            y.payload = function () {
               return M(w)
            }, y.callback = function () {
               nx(c, f)
            }
         }
         var P = c.stateNode;
         return P !== null && typeof P.componentDidCatch == "function" && (y.callback = function () {
            nx(c, f), typeof M != "function" && (jo === null ? jo = new Set([this]) : jo.add(this));
            var V = f.stack;
            this.componentDidCatch(f.value, {
               componentStack: V !== null ? V : ""
            })
         }), y
      }

      function Ub(c, f, y) {
         var M = c.pingCache;
         if (M === null) {
            M = c.pingCache = new u4;
            var w = new Set;
            M.set(f, w)
         } else w = M.get(f), w === void 0 && (w = new Set, M.set(f, w));
         w.has(y) || (w.add(y), c = M4.bind(null, c, f, y), f.then(c, c))
      }

      function kb(c) {
         do {
            var f;
            if ((f = c.tag === 13) && (f = c.memoizedState, f = f !== null ? f.dehydrated !== null : !0), f) return c;
            c = c.return
         } while (c !== null);
         return null
      }

      function Hb(c, f, y, M, w) {
         return c.mode & 1 ? (c.flags |= 65536, c.lanes = w, c) : (c === f ? c.flags |= 65536 : (c.flags |= 128, y.flags |= 131072, y.flags &= -52805, y.tag === 1 && (y.alternate === null ? y.tag = 17 : (f = no(-1, 1), f.tag = 2, Wo(y, f))), y.lanes |= 1), c)
      }

      function Ls(c) {
         c.flags |= 4
      }

      function Gb(c, f) {
         if (c !== null && c.child === f.child) return !0;
         if (f.flags & 16) return !1;
         for (c = f.child; c !== null;) {
            if (c.flags & 12854 || c.subtreeFlags & 12854) return !1;
            c = c.sibling
         }
         return !0
      }
      var eh, th, em, tm;
      if ($e) eh = function (c, f) {
         for (var y = f.child; y !== null;) {
            if (y.tag === 5 || y.tag === 6) Q(c, y.stateNode);
            else if (y.tag !== 4 && y.child !== null) {
               y.child.return = y, y = y.child;
               continue
            }
            if (y === f) break;
            for (; y.sibling === null;) {
               if (y.return === null || y.return === f) return;
               y = y.return
            }
            y.sibling.return = y.return, y = y.sibling
         }
      }, th = function () {}, em = function (c, f, y, M, w) {
         if (c = c.memoizedProps, c !== M) {
            var P = f.stateNode,
               V = Bs(Bi.current);
            y = Me(P, y, c, M, w, V), (f.updateQueue = y) && Ls(f)
         }
      }, tm = function (c, f, y, M) {
         y !== M && Ls(f)
      };
      else if (J) {
         eh = function (c, f, y, M) {
            for (var w = f.child; w !== null;) {
               if (w.tag === 5) {
                  var P = w.stateNode;
                  y && M && (P = en(P, w.type, w.memoizedProps, w)), Q(c, P)
               } else if (w.tag === 6) P = w.stateNode, y && M && (P = Br(P, w.memoizedProps, w)), Q(c, P);
               else if (w.tag !== 4) {
                  if (w.tag === 22 && w.memoizedState !== null) P = w.child, P !== null && (P.return = w), eh(c, w, !0, !0);
                  else if (w.child !== null) {
                     w.child.return = w, w = w.child;
                     continue
                  }
               }
               if (w === f) break;
               for (; w.sibling === null;) {
                  if (w.return === null || w.return === f) return;
                  w = w.return
               }
               w.sibling.return = w.return, w = w.sibling
            }
         };
         var zb = function (c, f, y, M) {
            for (var w = f.child; w !== null;) {
               if (w.tag === 5) {
                  var P = w.stateNode;
                  y && M && (P = en(P, w.type, w.memoizedProps, w)), sn(c, P)
               } else if (w.tag === 6) P = w.stateNode, y && M && (P = Br(P, w.memoizedProps, w)), sn(c, P);
               else if (w.tag !== 4) {
                  if (w.tag === 22 && w.memoizedState !== null) P = w.child, P !== null && (P.return = w), zb(c, w, !0, !0);
                  else if (w.child !== null) {
                     w.child.return = w, w = w.child;
                     continue
                  }
               }
               if (w === f) break;
               for (; w.sibling === null;) {
                  if (w.return === null || w.return === f) return;
                  w = w.return
               }
               w.sibling.return = w.return, w = w.sibling
            }
         };
         th = function (c, f) {
            var y = f.stateNode;
            if (!Gb(c, f)) {
               c = y.containerInfo;
               var M = Ut(c);
               zb(M, f, !1, !1), y.pendingChildren = M, Ls(f), xn(c, M)
            }
         }, em = function (c, f, y, M, w) {
            var P = c.stateNode,
               V = c.memoizedProps;
            if ((c = Gb(c, f)) && V === M) f.stateNode = P;
            else {
               var re = f.stateNode,
                  ve = Bs(Bi.current),
                  De = null;
               V !== M && (De = Me(re, y, V, M, w, ve)), c && De === null ? f.stateNode = P : (P = ze(P, De, y, V, M, f, c, re), _e(P, y, M, w, ve) && Ls(f), f.stateNode = P, c ? Ls(f) : eh(P, f, !1, !1))
            }
         }, tm = function (c, f, y, M) {
            y !== M ? (c = Bs(bu.current), y = Bs(Bi.current), f.stateNode = Ee(M, c, y, f), Ls(f)) : f.stateNode = c.stateNode
         }
      } else th = function () {}, em = function () {}, tm = function () {};

      function nh(c, f) {
         if (!An) switch (c.tailMode) {
            case "hidden":
               f = c.tail;
               for (var y = null; f !== null;) f.alternate !== null && (y = f), f = f.sibling;
               y === null ? c.tail = null : y.sibling = null;
               break;
            case "collapsed":
               y = c.tail;
               for (var M = null; y !== null;) y.alternate !== null && (M = y), y = y.sibling;
               M === null ? f || c.tail === null ? c.tail = null : c.tail.sibling = null : M.sibling = null
         }
      }

      function xr(c) {
         var f = c.alternate !== null && c.alternate.child === c.child,
            y = 0,
            M = 0;
         if (f)
            for (var w = c.child; w !== null;) y |= w.lanes | w.childLanes, M |= w.subtreeFlags & 14680064, M |= w.flags & 14680064, w.return = c, w = w.sibling;
         else
            for (w = c.child; w !== null;) y |= w.lanes | w.childLanes, M |= w.subtreeFlags, M |= w.flags, w.return = c, w = w.sibling;
         return c.subtreeFlags |= M, c.childLanes = y, f
      }

      function c4(c, f, y) {
         var M = f.pendingProps;
         switch (Gy(f), f.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
               return xr(f), null;
            case 1:
               return on(f.type) && Un(), xr(f), null;
            case 3:
               return M = f.stateNode, Cu(), xt(At), xt(tn), Jy(), M.pendingContext && (M.context = M.pendingContext, M.pendingContext = null), (c === null || c.child === null) && ($f(f) ? Ls(f) : c === null || c.memoizedState.isDehydrated && !(f.flags & 256) || (f.flags |= 1024, ts !== null && (Mx(ts), ts = null))), th(c, f), xr(f), null;
            case 5:
               $y(f), y = Bs(bu.current);
               var w = f.type;
               if (c !== null && f.stateNode != null) em(c, f, w, M, y), c.ref !== f.ref && (f.flags |= 512, f.flags |= 2097152);
               else {
                  if (!M) {
                     if (f.stateNode === null) throw Error(o(166));
                     return xr(f), null
                  }
                  if (c = Bs(Bi.current), $f(f)) {
                     if (!Ce) throw Error(o(175));
                     c = L(f.stateNode, f.type, f.memoizedProps, y, c, f, !jf), f.updateQueue = c, c !== null && Ls(f)
                  } else {
                     var P = X(w, M, y, c, f);
                     eh(P, f, !1, !1), f.stateNode = P, _e(P, w, M, y, c) && Ls(f)
                  }
                  f.ref !== null && (f.flags |= 512, f.flags |= 2097152)
               }
               return xr(f), null;
            case 6:
               if (c && f.stateNode != null) tm(c, f, c.memoizedProps, M);
               else {
                  if (typeof M != "string" && f.stateNode === null) throw Error(o(166));
                  if (c = Bs(bu.current), y = Bs(Bi.current), $f(f)) {
                     if (!Ce) throw Error(o(176));
                     if (c = f.stateNode, M = f.memoizedProps, (y = b(c, M, f, !jf)) && (w = oi, w !== null)) switch (P = (w.mode & 1) !== 0, w.tag) {
                        case 3:
                           ge(w.stateNode.containerInfo, c, M, P);
                           break;
                        case 5:
                           xe(w.type, w.memoizedProps, w.stateNode, c, M, P)
                     }
                     y && Ls(f)
                  } else f.stateNode = Ee(M, c, y, f)
               }
               return xr(f), null;
            case 13:
               if (xt(bn), M = f.memoizedState, An && ai !== null && f.mode & 1 && !(f.flags & 128)) {
                  for (c = ai; c;) c = gr(c);
                  return Eu(), f.flags |= 98560, f
               }
               if (M !== null && M.dehydrated !== null) {
                  if (M = $f(f), c === null) {
                     if (!M) throw Error(o(318));
                     if (!Ce) throw Error(o(344));
                     if (c = f.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(o(317));
                     F(c, f)
                  } else Eu(), !(f.flags & 128) && (f.memoizedState = null), f.flags |= 4;
                  return xr(f), null
               }
               return ts !== null && (Mx(ts), ts = null), f.flags & 128 ? (f.lanes = y, f) : (M = M !== null, y = !1, c === null ? $f(f) : y = c.memoizedState !== null, M && !y && (f.child.flags |= 8192, f.mode & 1 && (c === null || bn.current & 1 ? Yn === 0 && (Yn = 3) : wx())), f.updateQueue !== null && (f.flags |= 4), xr(f), null);
            case 4:
               return Cu(), th(c, f), c === null && Ie(f.stateNode.containerInfo), xr(f), null;
            case 10:
               return Fy(f.type._context), xr(f), null;
            case 17:
               return on(f.type) && Un(), xr(f), null;
            case 19:
               if (xt(bn), w = f.memoizedState, w === null) return xr(f), null;
               if (M = (f.flags & 128) !== 0, P = w.rendering, P === null)
                  if (M) nh(w, !1);
                  else {
                     if (Yn !== 0 || c !== null && c.flags & 128)
                        for (c = f.child; c !== null;) {
                           if (P = $p(c), P !== null) {
                              for (f.flags |= 128, nh(w, !1), c = P.updateQueue, c !== null && (f.updateQueue = c, f.flags |= 4), f.subtreeFlags = 0, c = y, M = f.child; M !== null;) y = M, w = c, y.flags &= 14680066, P = y.alternate, P === null ? (y.childLanes = 0, y.lanes = w, y.child = null, y.subtreeFlags = 0, y.memoizedProps = null, y.memoizedState = null, y.updateQueue = null, y.dependencies = null, y.stateNode = null) : (y.childLanes = P.childLanes, y.lanes = P.lanes, y.child = P.child, y.subtreeFlags = 0, y.deletions = null, y.memoizedProps = P.memoizedProps, y.memoizedState = P.memoizedState, y.updateQueue = P.updateQueue, y.type = P.type, w = P.dependencies, y.dependencies = w === null ? null : {
                                 lanes: w.lanes,
                                 firstContext: w.firstContext
                              }), M = M.sibling;
                              return it(bn, bn.current & 1 | 2), f.child
                           }
                           c = c.sibling
                        }
                     w.tail !== null && ir() > xx && (f.flags |= 128, M = !0, nh(w, !1), f.lanes = 4194304)
                  }
               else {
                  if (!M)
                     if (c = $p(P), c !== null) {
                        if (f.flags |= 128, M = !0, c = c.updateQueue, c !== null && (f.updateQueue = c, f.flags |= 4), nh(w, !0), w.tail === null && w.tailMode === "hidden" && !P.alternate && !An) return xr(f), null
                     } else 2 * ir() - w.renderingStartTime > xx && y !== 1073741824 && (f.flags |= 128, M = !0, nh(w, !1), f.lanes = 4194304);
                  w.isBackwards ? (P.sibling = f.child, f.child = P) : (c = w.last, c !== null ? c.sibling = P : f.child = P, w.last = P)
               }
               return w.tail !== null ? (f = w.tail, w.rendering = f, w.tail = f.sibling, w.renderingStartTime = ir(), f.sibling = null, c = bn.current, it(bn, M ? c & 1 | 2 : c & 1), f) : (xr(f), null);
            case 22:
            case 23:
               return Ex(), M = f.memoizedState !== null, c !== null && c.memoizedState !== null !== M && (f.flags |= 8192), M && f.mode & 1 ? ui & 1073741824 && (xr(f), $e && f.subtreeFlags & 6 && (f.flags |= 8192)) : xr(f), null;
            case 24:
               return null;
            case 25:
               return null
         }
         throw Error(o(156, f.tag))
      }
      var f4 = a.ReactCurrentOwner,
         li = !1;

      function Lr(c, f, y, M) {
         f.child = c === null ? gb(f, null, y, M) : wu(f, c.child, y, M)
      }

      function Vb(c, f, y, M, w) {
         y = y.render;
         var P = f.ref;
         return Au(f, w), M = Yy(c, f, y, M, P, w), y = Qy(), c !== null && !li ? (f.updateQueue = c.updateQueue, f.flags &= -2053, c.lanes &= ~w, oo(c, f, w)) : (An && y && Hy(f), f.flags |= 1, Lr(c, f, M, w), f.child)
      }

      function Wb(c, f, y, M, w) {
         if (c === null) {
            var P = y.type;
            return typeof P == "function" && !bx(P) && P.defaultProps === void 0 && y.compare === null && y.defaultProps === void 0 ? (f.tag = 15, f.type = P, jb(c, f, P, M, w)) : (c = Sm(y.type, null, M, f, f.mode, w), c.ref = f.ref, c.return = f, f.child = c)
         }
         if (P = c.child, !(c.lanes & w)) {
            var V = P.memoizedProps;
            if (y = y.compare, y = y !== null ? y : Np, y(V, M) && c.ref === f.ref) return oo(c, f, w)
         }
         return f.flags |= 1, c = Ko(P, M), c.ref = f.ref, c.return = f, f.child = c
      }

      function jb(c, f, y, M, w) {
         if (c !== null && Np(c.memoizedProps, M) && c.ref === f.ref)
            if (li = !1, (c.lanes & w) !== 0) c.flags & 131072 && (li = !0);
            else return f.lanes = c.lanes, oo(c, f, w);
         return rx(c, f, y, M, w)
      }

      function $b(c, f, y) {
         var M = f.pendingProps,
            w = M.children,
            P = c !== null ? c.memoizedState : null;
         if (M.mode === "hidden")
            if (!(f.mode & 1)) f.memoizedState = {
               baseLanes: 0,
               cachePool: null
            }, it(Ru, ui), ui |= y;
            else if (y & 1073741824) f.memoizedState = {
            baseLanes: 0,
            cachePool: null
         }, M = P !== null ? P.baseLanes : y, it(Ru, ui), ui |= M;
         else return c = P !== null ? P.baseLanes | y : y, f.lanes = f.childLanes = 1073741824, f.memoizedState = {
            baseLanes: c,
            cachePool: null
         }, f.updateQueue = null, it(Ru, ui), ui |= c, null;
         else P !== null ? (M = P.baseLanes | y, f.memoizedState = null) : M = y, it(Ru, ui), ui |= M;
         return Lr(c, f, w, y), f.child
      }

      function Xb(c, f) {
         var y = f.ref;
         (c === null && y !== null || c !== null && c.ref !== y) && (f.flags |= 512, f.flags |= 2097152)
      }

      function rx(c, f, y, M, w) {
         var P = on(y) ? nn : tn.current;
         return P = Jt(f, P), Au(f, w), y = Yy(c, f, y, M, P, w), M = Qy(), c !== null && !li ? (f.updateQueue = c.updateQueue, f.flags &= -2053, c.lanes &= ~w, oo(c, f, w)) : (An && M && Hy(f), f.flags |= 1, Lr(c, f, y, w), f.child)
      }

      function Jb(c, f, y, M, w) {
         if (on(y)) {
            var P = !0;
            qt(f)
         } else P = !1;
         if (Au(f, w), f.stateNode === null) c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), lb(f, y, M), ky(f, y, M, w), M = !0;
         else if (c === null) {
            var V = f.stateNode,
               re = f.memoizedProps;
            V.props = re;
            var ve = V.context,
               De = y.contextType;
            typeof De == "object" && De !== null ? De = Ti(De) : (De = on(y) ? nn : tn.current, De = Jt(f, De));
            var tt = y.getDerivedStateFromProps,
               bt = typeof tt == "function" || typeof V.getSnapshotBeforeUpdate == "function";
            bt || typeof V.UNSAFE_componentWillReceiveProps != "function" && typeof V.componentWillReceiveProps != "function" || (re !== M || ve !== De) && ub(f, V, M, De), Vo = !1;
            var gt = f.memoizedState;
            V.state = gt, Gp(f, M, V, w), ve = f.memoizedState, re !== M || gt !== ve || At.current || Vo ? (typeof tt == "function" && (Uy(f, y, tt, M), ve = f.memoizedState), (re = Vo || ab(f, y, re, M, gt, ve, De)) ? (bt || typeof V.UNSAFE_componentWillMount != "function" && typeof V.componentWillMount != "function" || (typeof V.componentWillMount == "function" && V.componentWillMount(), typeof V.UNSAFE_componentWillMount == "function" && V.UNSAFE_componentWillMount()), typeof V.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof V.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = M, f.memoizedState = ve), V.props = M, V.state = ve, V.context = De, M = re) : (typeof V.componentDidMount == "function" && (f.flags |= 4194308), M = !1)
         } else {
            V = f.stateNode, rb(c, f), re = f.memoizedProps, De = f.type === f.elementType ? re : es(f.type, re), V.props = De, bt = f.pendingProps, gt = V.context, ve = y.contextType, typeof ve == "object" && ve !== null ? ve = Ti(ve) : (ve = on(y) ? nn : tn.current, ve = Jt(f, ve));
            var an = y.getDerivedStateFromProps;
            (tt = typeof an == "function" || typeof V.getSnapshotBeforeUpdate == "function") || typeof V.UNSAFE_componentWillReceiveProps != "function" && typeof V.componentWillReceiveProps != "function" || (re !== bt || gt !== ve) && ub(f, V, M, ve), Vo = !1, gt = f.memoizedState, V.state = gt, Gp(f, M, V, w);
            var ft = f.memoizedState;
            re !== bt || gt !== ft || At.current || Vo ? (typeof an == "function" && (Uy(f, y, an, M), ft = f.memoizedState), (De = Vo || ab(f, y, De, M, gt, ft, ve) || !1) ? (tt || typeof V.UNSAFE_componentWillUpdate != "function" && typeof V.componentWillUpdate != "function" || (typeof V.componentWillUpdate == "function" && V.componentWillUpdate(M, ft, ve), typeof V.UNSAFE_componentWillUpdate == "function" && V.UNSAFE_componentWillUpdate(M, ft, ve)), typeof V.componentDidUpdate == "function" && (f.flags |= 4), typeof V.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof V.componentDidUpdate != "function" || re === c.memoizedProps && gt === c.memoizedState || (f.flags |= 4), typeof V.getSnapshotBeforeUpdate != "function" || re === c.memoizedProps && gt === c.memoizedState || (f.flags |= 1024), f.memoizedProps = M, f.memoizedState = ft), V.props = M, V.state = ft, V.context = ve, M = De) : (typeof V.componentDidUpdate != "function" || re === c.memoizedProps && gt === c.memoizedState || (f.flags |= 4), typeof V.getSnapshotBeforeUpdate != "function" || re === c.memoizedProps && gt === c.memoizedState || (f.flags |= 1024), M = !1)
         }
         return ix(c, f, y, M, P, w)
      }

      function ix(c, f, y, M, w, P) {
         Xb(c, f);
         var V = (f.flags & 128) !== 0;
         if (!M && !V) return w && Gt(f, y, !1), oo(c, f, P);
         M = f.stateNode, f4.current = f;
         var re = V && typeof y.getDerivedStateFromError != "function" ? null : M.render();
         return f.flags |= 1, c !== null && V ? (f.child = wu(f, c.child, null, P), f.child = wu(f, null, re, P)) : Lr(c, f, re, P), f.memoizedState = M.state, w && Gt(f, y, !0), f.child
      }

      function Kb(c) {
         var f = c.stateNode;
         f.pendingContext ? Et(c, f.pendingContext, f.pendingContext !== f.context) : f.context && Et(c, f.context, !1), jy(c, f.containerInfo)
      }

      function Yb(c, f, y, M, w) {
         return Eu(), Wy(w), f.flags |= 256, Lr(c, f, y, M), f.child
      }
      var nm = {
         dehydrated: null,
         treeContext: null,
         retryLane: 0
      };

      function rm(c) {
         return {
            baseLanes: c,
            cachePool: null
         }
      }

      function Qb(c, f, y) {
         var M = f.pendingProps,
            w = bn.current,
            P = !1,
            V = (f.flags & 128) !== 0,
            re;
         if ((re = V) || (re = c !== null && c.memoizedState === null ? !1 : (w & 2) !== 0), re ? (P = !0, f.flags &= -129) : (c === null || c.memoizedState !== null) && (w |= 1), it(bn, w & 1), c === null) return Vy(f), c = f.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? (f.mode & 1 ? Es(c) ? f.lanes = 8 : f.lanes = 1073741824 : f.lanes = 1, null) : (w = M.children, c = M.fallback, P ? (M = f.mode, P = f.child, w = {
            mode: "hidden",
            children: w
         }, !(M & 1) && P !== null ? (P.childLanes = 0, P.pendingProps = w) : P = Mm(w, M, 0, null), c = ol(c, M, y, null), P.return = f, c.return = f, P.sibling = c, f.child = P, f.child.memoizedState = rm(y), f.memoizedState = nm, c) : sx(f, w));
         if (w = c.memoizedState, w !== null) {
            if (re = w.dehydrated, re !== null) {
               if (V) return f.flags & 256 ? (f.flags &= -257, im(c, f, y, Error(o(422)))) : f.memoizedState !== null ? (f.child = c.child, f.flags |= 128, null) : (P = M.fallback, w = f.mode, M = Mm({
                  mode: "visible",
                  children: M.children
               }, w, 0, null), P = ol(P, w, y, null), P.flags |= 2, M.return = f, P.return = f, M.sibling = P, f.child = M, f.mode & 1 && wu(f, c.child, null, y), f.child.memoizedState = rm(y), f.memoizedState = nm, P);
               if (!(f.mode & 1)) f = im(c, f, y, null);
               else if (Es(re)) f = im(c, f, y, Error(o(419)));
               else if (M = (y & c.childLanes) !== 0, li || M) {
                  if (M = zn, M !== null) {
                     switch (y & -y) {
                        case 4:
                           P = 2;
                           break;
                        case 16:
                           P = 8;
                           break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                           P = 32;
                           break;
                        case 536870912:
                           P = 268435456;
                           break;
                        default:
                           P = 0
                     }
                     M = P & (M.suspendedLanes | y) ? 0 : P, M !== 0 && M !== w.retryLane && (w.retryLane = M, Li(c, M, -1))
                  }
                  wx(), f = im(c, f, y, Error(o(421)))
               } else qs(re) ? (f.flags |= 128, f.child = c.child, f = E4.bind(null, c), ws(re, f), f = null) : (y = w.treeContext, Ce && (ai = zf(re), oi = f, An = !0, ts = null, jf = !1, y !== null && (Ri[Pi++] = ro, Ri[Pi++] = io, Ri[Pi++] = Za, ro = y.id, io = y.overflow, Za = f)), f = sx(f, f.pendingProps.children), f.flags |= 4096);
               return f
            }
            return P ? (M = qb(c, f, M.children, M.fallback, y), P = f.child, w = c.child.memoizedState, P.memoizedState = w === null ? rm(y) : {
               baseLanes: w.baseLanes | y,
               cachePool: null
            }, P.childLanes = c.childLanes & ~y, f.memoizedState = nm, M) : (y = Zb(c, f, M.children, y), f.memoizedState = null, y)
         }
         return P ? (M = qb(c, f, M.children, M.fallback, y), P = f.child, w = c.child.memoizedState, P.memoizedState = w === null ? rm(y) : {
            baseLanes: w.baseLanes | y,
            cachePool: null
         }, P.childLanes = c.childLanes & ~y, f.memoizedState = nm, M) : (y = Zb(c, f, M.children, y), f.memoizedState = null, y)
      }

      function sx(c, f) {
         return f = Mm({
            mode: "visible",
            children: f
         }, c.mode, 0, null), f.return = c, c.child = f
      }

      function Zb(c, f, y, M) {
         var w = c.child;
         return c = w.sibling, y = Ko(w, {
            mode: "visible",
            children: y
         }), !(f.mode & 1) && (y.lanes = M), y.return = f, y.sibling = null, c !== null && (M = f.deletions, M === null ? (f.deletions = [c], f.flags |= 16) : M.push(c)), f.child = y
      }

      function qb(c, f, y, M, w) {
         var P = f.mode;
         c = c.child;
         var V = c.sibling,
            re = {
               mode: "hidden",
               children: y
            };
         return !(P & 1) && f.child !== c ? (y = f.child, y.childLanes = 0, y.pendingProps = re, f.deletions = null) : (y = Ko(c, re), y.subtreeFlags = c.subtreeFlags & 14680064), V !== null ? M = Ko(V, M) : (M = ol(M, P, w, null), M.flags |= 2), M.return = f, y.return = f, y.sibling = M, f.child = y, M
      }

      function im(c, f, y, M) {
         return M !== null && Wy(M), wu(f, c.child, null, y), c = sx(f, f.pendingProps.children), c.flags |= 2, f.memoizedState = null, c
      }

      function eC(c, f, y) {
         c.lanes |= f;
         var M = c.alternate;
         M !== null && (M.lanes |= f), Oy(c.return, f, y)
      }

      function ox(c, f, y, M, w) {
         var P = c.memoizedState;
         P === null ? c.memoizedState = {
            isBackwards: f,
            rendering: null,
            renderingStartTime: 0,
            last: M,
            tail: y,
            tailMode: w
         } : (P.isBackwards = f, P.rendering = null, P.renderingStartTime = 0, P.last = M, P.tail = y, P.tailMode = w)
      }

      function tC(c, f, y) {
         var M = f.pendingProps,
            w = M.revealOrder,
            P = M.tail;
         if (Lr(c, f, M.children, y), M = bn.current, M & 2) M = M & 1 | 2, f.flags |= 128;
         else {
            if (c !== null && c.flags & 128) e: for (c = f.child; c !== null;) {
               if (c.tag === 13) c.memoizedState !== null && eC(c, y, f);
               else if (c.tag === 19) eC(c, y, f);
               else if (c.child !== null) {
                  c.child.return = c, c = c.child;
                  continue
               }
               if (c === f) break e;
               for (; c.sibling === null;) {
                  if (c.return === null || c.return === f) break e;
                  c = c.return
               }
               c.sibling.return = c.return, c = c.sibling
            }
            M &= 1
         }
         if (it(bn, M), !(f.mode & 1)) f.memoizedState = null;
         else switch (w) {
            case "forwards":
               for (y = f.child, w = null; y !== null;) c = y.alternate, c !== null && $p(c) === null && (w = y), y = y.sibling;
               y = w, y === null ? (w = f.child, f.child = null) : (w = y.sibling, y.sibling = null), ox(f, !1, w, y, P);
               break;
            case "backwards":
               for (y = null, w = f.child, f.child = null; w !== null;) {
                  if (c = w.alternate, c !== null && $p(c) === null) {
                     f.child = w;
                     break
                  }
                  c = w.sibling, w.sibling = y, y = w, w = c
               }
               ox(f, !0, y, null, P);
               break;
            case "together":
               ox(f, !1, null, null, void 0);
               break;
            default:
               f.memoizedState = null
         }
         return f.child
      }

      function oo(c, f, y) {
         if (c !== null && (f.dependencies = c.dependencies), Pu |= f.lanes, !(y & f.childLanes)) return null;
         if (c !== null && f.child !== c.child) throw Error(o(153));
         if (f.child !== null) {
            for (c = f.child, y = Ko(c, c.pendingProps), f.child = y, y.return = f; c.sibling !== null;) c = c.sibling, y = y.sibling = Ko(c, c.pendingProps), y.return = f;
            y.sibling = null
         }
         return f.child
      }

      function h4(c, f, y) {
         switch (f.tag) {
            case 3:
               Kb(f), Eu();
               break;
            case 5:
               vb(f);
               break;
            case 1:
               on(f.type) && qt(f);
               break;
            case 4:
               jy(f, f.stateNode.containerInfo);
               break;
            case 10:
               nb(f, f.type._context, f.memoizedProps.value);
               break;
            case 13:
               var M = f.memoizedState;
               if (M !== null) return M.dehydrated !== null ? (it(bn, bn.current & 1), f.flags |= 128, null) : y & f.child.childLanes ? Qb(c, f, y) : (it(bn, bn.current & 1), c = oo(c, f, y), c !== null ? c.sibling : null);
               it(bn, bn.current & 1);
               break;
            case 19:
               if (M = (y & f.childLanes) !== 0, c.flags & 128) {
                  if (M) return tC(c, f, y);
                  f.flags |= 128
               }
               var w = f.memoizedState;
               if (w !== null && (w.rendering = null, w.tail = null, w.lastEffect = null), it(bn, bn.current), M) break;
               return null;
            case 22:
            case 23:
               return f.lanes = 0, $b(c, f, y)
         }
         return oo(c, f, y)
      }

      function d4(c, f) {
         switch (Gy(f), f.tag) {
            case 1:
               return on(f.type) && Un(), c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null;
            case 3:
               return Cu(), xt(At), xt(tn), Jy(), c = f.flags, c & 65536 && !(c & 128) ? (f.flags = c & -65537 | 128, f) : null;
            case 5:
               return $y(f), null;
            case 13:
               if (xt(bn), c = f.memoizedState, c !== null && c.dehydrated !== null) {
                  if (f.alternate === null) throw Error(o(340));
                  Eu()
               }
               return c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null;
            case 19:
               return xt(bn), null;
            case 4:
               return Cu(), null;
            case 10:
               return Fy(f.type._context), null;
            case 22:
            case 23:
               return Ex(), null;
            case 24:
               return null;
            default:
               return null
         }
      }
      var sm = !1,
         tl = !1,
         p4 = typeof WeakSet == "function" ? WeakSet : Set,
         Ve = null;

      function om(c, f) {
         var y = c.ref;
         if (y !== null)
            if (typeof y == "function") try {
               y(null)
            } catch (M) {
               Xr(c, f, M)
            } else y.current = null
      }

      function ax(c, f, y) {
         try {
            y()
         } catch (M) {
            Xr(c, f, M)
         }
      }
      var nC = !1;

      function m4(c, f) {
         for (ne(c.containerInfo), Ve = f; Ve !== null;)
            if (c = Ve, f = c.child, (c.subtreeFlags & 1028) !== 0 && f !== null) f.return = c, Ve = f;
            else
               for (; Ve !== null;) {
                  c = Ve;
                  try {
                     var y = c.alternate;
                     if (c.flags & 1024) switch (c.tag) {
                        case 0:
                        case 11:
                        case 15:
                           break;
                        case 1:
                           if (y !== null) {
                              var M = y.memoizedProps,
                                 w = y.memoizedState,
                                 P = c.stateNode,
                                 V = P.getSnapshotBeforeUpdate(c.elementType === c.type ? M : es(c.type, M), w);
                              P.__reactInternalSnapshotBeforeUpdate = V
                           }
                           break;
                        case 3:
                           $e && Fe(c.stateNode.containerInfo);
                           break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                           break;
                        default:
                           throw Error(o(163))
                     }
                  } catch (re) {
                     Xr(c, c.return, re)
                  }
                  if (f = c.sibling, f !== null) {
                     f.return = c.return, Ve = f;
                     break
                  }
                  Ve = c.return
               }
         return y = nC, nC = !1, y
      }

      function nl(c, f, y) {
         var M = f.updateQueue;
         if (M = M !== null ? M.lastEffect : null, M !== null) {
            var w = M = M.next;
            do {
               if ((w.tag & c) === c) {
                  var P = w.destroy;
                  w.destroy = void 0, P !== void 0 && ax(f, y, P)
               }
               w = w.next
            } while (w !== M)
         }
      }

      function rh(c, f) {
         if (f = f.updateQueue, f = f !== null ? f.lastEffect : null, f !== null) {
            var y = f = f.next;
            do {
               if ((y.tag & c) === c) {
                  var M = y.create;
                  y.destroy = M()
               }
               y = y.next
            } while (y !== f)
         }
      }

      function lx(c) {
         var f = c.ref;
         if (f !== null) {
            var y = c.stateNode;
            switch (c.tag) {
               case 5:
                  c = se(y);
                  break;
               default:
                  c = y
            }
            typeof f == "function" ? f(c) : f.current = c
         }
      }

      function rC(c, f, y) {
         if (Cs && typeof Cs.onCommitFiberUnmount == "function") try {
            Cs.onCommitFiberUnmount(Fp, f)
         } catch {}
         switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
               if (c = f.updateQueue, c !== null && (c = c.lastEffect, c !== null)) {
                  var M = c = c.next;
                  do {
                     var w = M,
                        P = w.destroy;
                     w = w.tag, P !== void 0 && (w & 2 || w & 4) && ax(f, y, P), M = M.next
                  } while (M !== c)
               }
               break;
            case 1:
               if (om(f, y), c = f.stateNode, typeof c.componentWillUnmount == "function") try {
                  c.props = f.memoizedProps, c.state = f.memoizedState, c.componentWillUnmount()
               } catch (V) {
                  Xr(f, y, V)
               }
               break;
            case 5:
               om(f, y);
               break;
            case 4:
               $e ? uC(c, f, y) : J && J && (f = f.stateNode.containerInfo, y = Ut(f), si(f, y))
         }
      }

      function iC(c, f, y) {
         for (var M = f;;)
            if (rC(c, M, y), M.child === null || $e && M.tag === 4) {
               if (M === f) break;
               for (; M.sibling === null;) {
                  if (M.return === null || M.return === f) return;
                  M = M.return
               }
               M.sibling.return = M.return, M = M.sibling
            } else M.child.return = M, M = M.child
      }

      function sC(c) {
         var f = c.alternate;
         f !== null && (c.alternate = null, sC(f)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (f = c.stateNode, f !== null && lt(f)), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null
      }

      function oC(c) {
         return c.tag === 5 || c.tag === 3 || c.tag === 4
      }

      function aC(c) {
         e: for (;;) {
            for (; c.sibling === null;) {
               if (c.return === null || oC(c.return)) return null;
               c = c.return
            }
            for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18;) {
               if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
               c.child.return = c, c = c.child
            }
            if (!(c.flags & 2)) return c.stateNode
         }
      }

      function lC(c) {
         if ($e) {
            e: {
               for (var f = c.return; f !== null;) {
                  if (oC(f)) break e;
                  f = f.return
               }
               throw Error(o(160))
            }
            var y = f;
            switch (y.tag) {
               case 5:
                  f = y.stateNode, y.flags & 32 && (pt(f), y.flags &= -33), y = aC(c), cx(c, y, f);
                  break;
               case 3:
               case 4:
                  f = y.stateNode.containerInfo, y = aC(c), ux(c, y, f);
                  break;
               default:
                  throw Error(o(161))
            }
         }
      }

      function ux(c, f, y) {
         var M = c.tag;
         if (M === 5 || M === 6) c = c.stateNode, f ? Ke(y, c, f) : rt(y, c);
         else if (M !== 4 && (c = c.child, c !== null))
            for (ux(c, f, y), c = c.sibling; c !== null;) ux(c, f, y), c = c.sibling
      }

      function cx(c, f, y) {
         var M = c.tag;
         if (M === 5 || M === 6) c = c.stateNode, f ? st(y, c, f) : Be(y, c);
         else if (M !== 4 && (c = c.child, c !== null))
            for (cx(c, f, y), c = c.sibling; c !== null;) cx(c, f, y), c = c.sibling
      }

      function uC(c, f, y) {
         for (var M = f, w = !1, P, V;;) {
            if (!w) {
               w = M.return;
               e: for (;;) {
                  if (w === null) throw Error(o(160));
                  switch (P = w.stateNode, w.tag) {
                     case 5:
                        V = !1;
                        break e;
                     case 3:
                        P = P.containerInfo, V = !0;
                        break e;
                     case 4:
                        P = P.containerInfo, V = !0;
                        break e
                  }
                  w = w.return
               }
               w = !0
            }
            if (M.tag === 5 || M.tag === 6) iC(c, M, y), V ? Ye(P, M.stateNode) : et(P, M.stateNode);
            else if (M.tag === 18) V ? ce(P, M.stateNode) : ae(P, M.stateNode);
            else if (M.tag === 4) {
               if (M.child !== null) {
                  P = M.stateNode.containerInfo, V = !0, M.child.return = M, M = M.child;
                  continue
               }
            } else if (rC(c, M, y), M.child !== null) {
               M.child.return = M, M = M.child;
               continue
            }
            if (M === f) break;
            for (; M.sibling === null;) {
               if (M.return === null || M.return === f) return;
               M = M.return, M.tag === 4 && (w = !1)
            }
            M.sibling.return = M.return, M = M.sibling
         }
      }

      function fx(c, f) {
         if ($e) {
            switch (f.tag) {
               case 0:
               case 11:
               case 14:
               case 15:
                  nl(3, f, f.return), rh(3, f), nl(5, f, f.return);
                  return;
               case 1:
                  return;
               case 5:
                  var y = f.stateNode;
                  if (y != null) {
                     var M = f.memoizedProps;
                     c = c !== null ? c.memoizedProps : M;
                     var w = f.type,
                        P = f.updateQueue;
                     f.updateQueue = null, P !== null && ht(y, P, w, c, M, f)
                  }
                  return;
               case 6:
                  if (f.stateNode === null) throw Error(o(162));
                  y = f.memoizedProps, Le(f.stateNode, c !== null ? c.memoizedProps : y, y);
                  return;
               case 3:
                  Ce && c !== null && c.memoizedState.isDehydrated && k(f.stateNode.containerInfo);
                  return;
               case 12:
                  return;
               case 13:
                  am(f);
                  return;
               case 19:
                  am(f);
                  return;
               case 17:
                  return
            }
            throw Error(o(163))
         }
         switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
               nl(3, f, f.return), rh(3, f), nl(5, f, f.return);
               return;
            case 12:
               return;
            case 13:
               am(f);
               return;
            case 19:
               am(f);
               return;
            case 3:
               Ce && c !== null && c.memoizedState.isDehydrated && k(f.stateNode.containerInfo);
               break;
            case 22:
            case 23:
               return
         }
         e: if (J) {
            switch (f.tag) {
               case 1:
               case 5:
               case 6:
                  break e;
               case 3:
               case 4:
                  f = f.stateNode, si(f.containerInfo, f.pendingChildren);
                  break e
            }
            throw Error(o(163))
         }
      }

      function am(c) {
         var f = c.updateQueue;
         if (f !== null) {
            c.updateQueue = null;
            var y = c.stateNode;
            y === null && (y = c.stateNode = new p4), f.forEach(function (M) {
               var w = w4.bind(null, c, M);
               y.has(M) || (y.add(M), M.then(w, w))
            })
         }
      }

      function g4(c, f) {
         for (Ve = f; Ve !== null;) {
            f = Ve;
            var y = f.deletions;
            if (y !== null)
               for (var M = 0; M < y.length; M++) {
                  var w = y[M];
                  try {
                     var P = c;
                     $e ? uC(P, w, f) : iC(P, w, f);
                     var V = w.alternate;
                     V !== null && (V.return = null), w.return = null
                  } catch (ut) {
                     Xr(w, f, ut)
                  }
               }
            if (y = f.child, f.subtreeFlags & 12854 && y !== null) y.return = f, Ve = y;
            else
               for (; Ve !== null;) {
                  f = Ve;
                  try {
                     var re = f.flags;
                     if (re & 32 && $e && pt(f.stateNode), re & 512) {
                        var ve = f.alternate;
                        if (ve !== null) {
                           var De = ve.ref;
                           De !== null && (typeof De == "function" ? De(null) : De.current = null)
                        }
                     }
                     if (re & 8192) switch (f.tag) {
                        case 13:
                           if (f.memoizedState !== null) {
                              var tt = f.alternate;
                              (tt === null || tt.memoizedState === null) && (yx = ir())
                           }
                           break;
                        case 22:
                           var bt = f.memoizedState !== null,
                              gt = f.alternate,
                              an = gt !== null && gt.memoizedState !== null;
                           if (y = f, $e) {
                              e: if (M = y, w = bt, P = null, $e)
                                 for (var ft = M;;) {
                                    if (ft.tag === 5) {
                                       if (P === null) {
                                          P = ft;
                                          var _r = ft.stateNode;
                                          w ? Mt(_r) : fe(ft.stateNode, ft.memoizedProps)
                                       }
                                    } else if (ft.tag === 6) {
                                       if (P === null) {
                                          var Fi = ft.stateNode;
                                          w ? ee(Fi) : he(Fi, ft.memoizedProps)
                                       }
                                    } else if ((ft.tag !== 22 && ft.tag !== 23 || ft.memoizedState === null || ft === M) && ft.child !== null) {
                                       ft.child.return = ft, ft = ft.child;
                                       continue
                                    }
                                    if (ft === M) break;
                                    for (; ft.sibling === null;) {
                                       if (ft.return === null || ft.return === M) break e;
                                       P === ft && (P = null), ft = ft.return
                                    }
                                    P === ft && (P = null), ft.sibling.return = ft.return, ft = ft.sibling
                                 }
                           }
                           if (bt && !an && y.mode & 1) {
                              Ve = y;
                              for (var le = y.child; le !== null;) {
                                 for (y = Ve = le; Ve !== null;) {
                                    M = Ve;
                                    var ie = M.child;
                                    switch (M.tag) {
                                       case 0:
                                       case 11:
                                       case 14:
                                       case 15:
                                          nl(4, M, M.return);
                                          break;
                                       case 1:
                                          om(M, M.return);
                                          var pe = M.stateNode;
                                          if (typeof pe.componentWillUnmount == "function") {
                                             var je = M.return;
                                             try {
                                                pe.props = M.memoizedProps, pe.state = M.memoizedState, pe.componentWillUnmount()
                                             } catch (ut) {
                                                Xr(M, je, ut)
                                             }
                                          }
                                          break;
                                       case 5:
                                          om(M, M.return);
                                          break;
                                       case 22:
                                          if (M.memoizedState !== null) {
                                             hC(y);
                                             continue
                                          }
                                    }
                                    ie !== null ? (ie.return = M, Ve = ie) : hC(y)
                                 }
                                 le = le.sibling
                              }
                           }
                     }
                     switch (re & 4102) {
                        case 2:
                           lC(f), f.flags &= -3;
                           break;
                        case 6:
                           lC(f), f.flags &= -3, fx(f.alternate, f);
                           break;
                        case 4096:
                           f.flags &= -4097;
                           break;
                        case 4100:
                           f.flags &= -4097, fx(f.alternate, f);
                           break;
                        case 4:
                           fx(f.alternate, f)
                     }
                  } catch (ut) {
                     Xr(f, f.return, ut)
                  }
                  if (y = f.sibling, y !== null) {
                     y.return = f.return, Ve = y;
                     break
                  }
                  Ve = f.return
               }
         }
      }

      function v4(c, f, y) {
         Ve = c, cC(c)
      }

      function cC(c, f, y) {
         for (var M = (c.mode & 1) !== 0; Ve !== null;) {
            var w = Ve,
               P = w.child;
            if (w.tag === 22 && M) {
               var V = w.memoizedState !== null || sm;
               if (!V) {
                  var re = w.alternate,
                     ve = re !== null && re.memoizedState !== null || tl;
                  re = sm;
                  var De = tl;
                  if (sm = V, (tl = ve) && !De)
                     for (Ve = w; Ve !== null;) V = Ve, ve = V.child, V.tag === 22 && V.memoizedState !== null ? dC(w) : ve !== null ? (ve.return = V, Ve = ve) : dC(w);
                  for (; P !== null;) Ve = P, cC(P), P = P.sibling;
                  Ve = w, sm = re, tl = De
               }
               fC(c)
            } else w.subtreeFlags & 8772 && P !== null ? (P.return = w, Ve = P) : fC(c)
         }
      }

      function fC(c) {
         for (; Ve !== null;) {
            var f = Ve;
            if (f.flags & 8772) {
               var y = f.alternate;
               try {
                  if (f.flags & 8772) switch (f.tag) {
                     case 0:
                     case 11:
                     case 15:
                        tl || rh(5, f);
                        break;
                     case 1:
                        var M = f.stateNode;
                        if (f.flags & 4 && !tl)
                           if (y === null) M.componentDidMount();
                           else {
                              var w = f.elementType === f.type ? y.memoizedProps : es(f.type, y.memoizedProps);
                              M.componentDidUpdate(w, y.memoizedState, M.__reactInternalSnapshotBeforeUpdate)
                           } var P = f.updateQueue;
                        P !== null && sb(f, P, M);
                        break;
                     case 3:
                        var V = f.updateQueue;
                        if (V !== null) {
                           if (y = null, f.child !== null) switch (f.child.tag) {
                              case 5:
                                 y = se(f.child.stateNode);
                                 break;
                              case 1:
                                 y = f.child.stateNode
                           }
                           sb(f, V, y)
                        }
                        break;
                     case 5:
                        var re = f.stateNode;
                        y === null && f.flags & 4 && de(re, f.type, f.memoizedProps, f);
                        break;
                     case 6:
                        break;
                     case 4:
                        break;
                     case 12:
                        break;
                     case 13:
                        if (Ce && f.memoizedState === null) {
                           var ve = f.alternate;
                           if (ve !== null) {
                              var De = ve.memoizedState;
                              if (De !== null) {
                                 var tt = De.dehydrated;
                                 tt !== null && W(tt)
                              }
                           }
                        }
                        break;
                     case 19:
                     case 17:
                     case 21:
                     case 22:
                     case 23:
                        break;
                     default:
                        throw Error(o(163))
                  }
                  tl || f.flags & 512 && lx(f)
               } catch (bt) {
                  Xr(f, f.return, bt)
               }
            }
            if (f === c) {
               Ve = null;
               break
            }
            if (y = f.sibling, y !== null) {
               y.return = f.return, Ve = y;
               break
            }
            Ve = f.return
         }
      }

      function hC(c) {
         for (; Ve !== null;) {
            var f = Ve;
            if (f === c) {
               Ve = null;
               break
            }
            var y = f.sibling;
            if (y !== null) {
               y.return = f.return, Ve = y;
               break
            }
            Ve = f.return
         }
      }

      function dC(c) {
         for (; Ve !== null;) {
            var f = Ve;
            try {
               switch (f.tag) {
                  case 0:
                  case 11:
                  case 15:
                     var y = f.return;
                     try {
                        rh(4, f)
                     } catch (ve) {
                        Xr(f, y, ve)
                     }
                     break;
                  case 1:
                     var M = f.stateNode;
                     if (typeof M.componentDidMount == "function") {
                        var w = f.return;
                        try {
                           M.componentDidMount()
                        } catch (ve) {
                           Xr(f, w, ve)
                        }
                     }
                     var P = f.return;
                     try {
                        lx(f)
                     } catch (ve) {
                        Xr(f, P, ve)
                     }
                     break;
                  case 5:
                     var V = f.return;
                     try {
                        lx(f)
                     } catch (ve) {
                        Xr(f, V, ve)
                     }
               }
            } catch (ve) {
               Xr(f, f.return, ve)
            }
            if (f === c) {
               Ve = null;
               break
            }
            var re = f.sibling;
            if (re !== null) {
               re.return = f.return, Ve = re;
               break
            }
            Ve = f.return
         }
      }
      var lm = 0,
         um = 1,
         cm = 2,
         fm = 3,
         hm = 4;
      if (typeof Symbol == "function" && Symbol.for) {
         var ih = Symbol.for;
         lm = ih("selector.component"), um = ih("selector.has_pseudo_class"), cm = ih("selector.role"), fm = ih("selector.test_id"), hm = ih("selector.text")
      }

      function hx(c) {
         var f = Ae(c);
         if (f != null) {
            if (typeof f.memoizedProps["data-testname"] != "string") throw Error(o(364));
            return f
         }
         if (c = Ot(c), c === null) throw Error(o(362));
         return c.stateNode.current
      }

      function dx(c, f) {
         switch (f.$$typeof) {
            case lm:
               if (c.type === f.value) return !0;
               break;
            case um:
               e: {
                  f = f.value,
                  c = [c, 0];
                  for (var y = 0; y < c.length;) {
                     var M = c[y++],
                        w = c[y++],
                        P = f[w];
                     if (M.tag !== 5 || !O(M)) {
                        for (; P != null && dx(M, P);) w++, P = f[w];
                        if (w === f.length) {
                           f = !0;
                           break e
                        } else
                           for (M = M.child; M !== null;) c.push(M, w), M = M.sibling
                     }
                  }
                  f = !1
               }
               return f;
            case cm:
               if (c.tag === 5 && ue(c.stateNode, f.value)) return !0;
               break;
            case hm:
               if ((c.tag === 5 || c.tag === 6) && (c = j(c), c !== null && 0 <= c.indexOf(f.value))) return !0;
               break;
            case fm:
               if (c.tag === 5 && (c = c.memoizedProps["data-testname"], typeof c == "string" && c.toLowerCase() === f.value.toLowerCase())) return !0;
               break;
            default:
               throw Error(o(365))
         }
         return !1
      }

      function px(c) {
         switch (c.$$typeof) {
            case lm:
               return "<" + (B(c.value) || "Unknown") + ">";
            case um:
               return ":has(" + (px(c) || "") + ")";
            case cm:
               return '[role="' + c.value + '"]';
            case hm:
               return '"' + c.value + '"';
            case fm:
               return '[data-testname="' + c.value + '"]';
            default:
               throw Error(o(365))
         }
      }

      function pC(c, f) {
         var y = [];
         c = [c, 0];
         for (var M = 0; M < c.length;) {
            var w = c[M++],
               P = c[M++],
               V = f[P];
            if (w.tag !== 5 || !O(w)) {
               for (; V != null && dx(w, V);) P++, V = f[P];
               if (P === f.length) y.push(w);
               else
                  for (w = w.child; w !== null;) c.push(w, P), w = w.sibling
            }
         }
         return y
      }

      function mx(c, f) {
         if (!vt) throw Error(o(363));
         c = hx(c), c = pC(c, f), f = [], c = Array.from(c);
         for (var y = 0; y < c.length;) {
            var M = c[y++];
            if (M.tag === 5) O(M) || f.push(M.stateNode);
            else
               for (M = M.child; M !== null;) c.push(M), M = M.sibling
         }
         return f
      }
      var y4 = Math.ceil,
         dm = a.ReactCurrentDispatcher,
         gx = a.ReactCurrentOwner,
         kn = a.ReactCurrentBatchConfig,
         Nt = 0,
         zn = null,
         Vn = null,
         cr = 0,
         ui = 0,
         Ru = We(0),
         Yn = 0,
         sh = null,
         Pu = 0,
         pm = 0,
         vx = 0,
         oh = null,
         jr = null,
         yx = 0,
         xx = 1 / 0;

      function Bu() {
         xx = ir() + 500
      }
      var mm = !1,
         _x = null,
         jo = null,
         gm = !1,
         $o = null,
         vm = 0,
         ah = 0,
         Ax = null,
         ym = -1,
         xm = 0;

      function Dr() {
         return Nt & 6 ? ir() : ym !== -1 ? ym : ym = ir()
      }

      function Xo(c) {
         return c.mode & 1 ? Nt & 2 && cr !== 0 ? cr & -cr : e4.transition !== null ? (xm === 0 && (c = Ip, Ip <<= 1, !(Ip & 4194240) && (Ip = 64), xm = c), xm) : (c = Kt, c !== 0 ? c : be()) : 1
      }

      function Li(c, f, y) {
         if (50 < ah) throw ah = 0, Ax = null, Error(o(185));
         var M = _m(c, f);
         return M === null ? null : (Wf(M, f, y), (!(Nt & 2) || M !== zn) && (M === zn && (!(Nt & 2) && (pm |= f), Yn === 4 && Jo(M, cr)), $r(M, y), f === 1 && Nt === 0 && !(c.mode & 1) && (Bu(), Op && Rs())), M)
      }

      function _m(c, f) {
         c.lanes |= f;
         var y = c.alternate;
         for (y !== null && (y.lanes |= f), y = c, c = c.return; c !== null;) c.childLanes |= f, y = c.alternate, y !== null && (y.childLanes |= f), y = c, c = c.return;
         return y.tag === 3 ? y.stateNode : null
      }

      function $r(c, f) {
         var y = c.callbackNode;
         jk(c, f);
         var M = Dp(c, c === zn ? cr : 0);
         if (M === 0) y !== null && eb(y), c.callbackNode = null, c.callbackPriority = 0;
         else if (f = M & -M, c.callbackPriority !== f) {
            if (y != null && eb(y), f === 1) c.tag === 0 ? qk(gC.bind(null, c)) : tb(gC.bind(null, c)), Je ? qe(function () {
               Nt === 0 && Rs()
            }) : Ry(Py, Rs), y = null;
            else {
               switch (qw(M)) {
                  case 1:
                     y = Py;
                     break;
                  case 4:
                     y = Kk;
                     break;
                  case 16:
                     y = By;
                     break;
                  case 536870912:
                     y = Yk;
                     break;
                  default:
                     y = By
               }
               y = wC(y, mC.bind(null, c))
            }
            c.callbackPriority = f, c.callbackNode = y
         }
      }

      function mC(c, f) {
         if (ym = -1, xm = 0, Nt & 6) throw Error(o(327));
         var y = c.callbackNode;
         if (sl() && c.callbackNode !== y) return null;
         var M = Dp(c, c === zn ? cr : 0);
         if (M === 0) return null;
         if (M & 30 || M & c.expiredLanes || f) f = Am(c, M);
         else {
            f = M;
            var w = Nt;
            Nt |= 2;
            var P = xC();
            (zn !== c || cr !== f) && (Bu(), rl(c, f));
            do try {
               A4();
               break
            } catch (re) {
               yC(c, re)
            }
            while (1);
            Dy(), dm.current = P, Nt = w, Vn !== null ? f = 0 : (zn = null, cr = 0, f = Yn)
         }
         if (f !== 0) {
            if (f === 2 && (w = by(c), w !== 0 && (M = w, f = Sx(c, w))), f === 1) throw y = sh, rl(c, 0), Jo(c, M), $r(c, ir()), y;
            if (f === 6) Jo(c, M);
            else {
               if (w = c.current.alternate, !(M & 30) && !x4(w) && (f = Am(c, M), f === 2 && (P = by(c), P !== 0 && (M = P, f = Sx(c, P))), f === 1)) throw y = sh, rl(c, 0), Jo(c, M), $r(c, ir()), y;
               switch (c.finishedWork = w, c.finishedLanes = M, f) {
                  case 0:
                  case 1:
                     throw Error(o(345));
                  case 2:
                     il(c, jr);
                     break;
                  case 3:
                     if (Jo(c, M), (M & 130023424) === M && (f = yx + 500 - ir(), 10 < f)) {
                        if (Dp(c, 0) !== 0) break;
                        if (w = c.suspendedLanes, (w & M) !== M) {
                           Dr(), c.pingedLanes |= c.suspendedLanes & w;
                           break
                        }
                        c.timeoutHandle = Ue(il.bind(null, c, jr), f);
                        break
                     }
                     il(c, jr);
                     break;
                  case 4:
                     if (Jo(c, M), (M & 4194240) === M) break;
                     for (f = c.eventTimes, w = -1; 0 < M;) {
                        var V = 31 - _n(M);
                        P = 1 << V, V = f[V], V > w && (w = V), M &= ~P
                     }
                     if (M = w, M = ir() - M, M = (120 > M ? 120 : 480 > M ? 480 : 1080 > M ? 1080 : 1920 > M ? 1920 : 3e3 > M ? 3e3 : 4320 > M ? 4320 : 1960 * y4(M / 1960)) - M, 10 < M) {
                        c.timeoutHandle = Ue(il.bind(null, c, jr), M);
                        break
                     }
                     il(c, jr);
                     break;
                  case 5:
                     il(c, jr);
                     break;
                  default:
                     throw Error(o(329))
               }
            }
         }
         return $r(c, ir()), c.callbackNode === y ? mC.bind(null, c) : null
      }

      function Sx(c, f) {
         var y = oh;
         return c.current.memoizedState.isDehydrated && (rl(c, f).flags |= 256), c = Am(c, f), c !== 2 && (f = jr, jr = y, f !== null && Mx(f)), c
      }

      function Mx(c) {
         jr === null ? jr = c : jr.push.apply(jr, c)
      }

      function x4(c) {
         for (var f = c;;) {
            if (f.flags & 16384) {
               var y = f.updateQueue;
               if (y !== null && (y = y.stores, y !== null))
                  for (var M = 0; M < y.length; M++) {
                     var w = y[M],
                        P = w.getSnapshot;
                     w = w.value;
                     try {
                        if (!Ts(P(), w)) return !1
                     } catch {
                        return !1
                     }
                  }
            }
            if (y = f.child, f.subtreeFlags & 16384 && y !== null) y.return = f, f = y;
            else {
               if (f === c) break;
               for (; f.sibling === null;) {
                  if (f.return === null || f.return === c) return !0;
                  f = f.return
               }
               f.sibling.return = f.return, f = f.sibling
            }
         }
         return !0
      }

      function Jo(c, f) {
         for (f &= ~vx, f &= ~pm, c.suspendedLanes |= f, c.pingedLanes &= ~f, c = c.expirationTimes; 0 < f;) {
            var y = 31 - _n(f),
               M = 1 << y;
            c[y] = -1, f &= ~M
         }
      }

      function gC(c) {
         if (Nt & 6) throw Error(o(327));
         sl();
         var f = Dp(c, 0);
         if (!(f & 1)) return $r(c, ir()), null;
         var y = Am(c, f);
         if (c.tag !== 0 && y === 2) {
            var M = by(c);
            M !== 0 && (f = M, y = Sx(c, M))
         }
         if (y === 1) throw y = sh, rl(c, 0), Jo(c, f), $r(c, ir()), y;
         if (y === 6) throw Error(o(345));
         return c.finishedWork = c.current.alternate, c.finishedLanes = f, il(c, jr), $r(c, ir()), null
      }

      function vC(c) {
         $o !== null && $o.tag === 0 && !(Nt & 6) && sl();
         var f = Nt;
         Nt |= 1;
         var y = kn.transition,
            M = Kt;
         try {
            if (kn.transition = null, Kt = 1, c) return c()
         } finally {
            Kt = M, kn.transition = y, Nt = f, !(Nt & 6) && Rs()
         }
      }

      function Ex() {
         ui = Ru.current, xt(Ru)
      }

      function rl(c, f) {
         c.finishedWork = null, c.finishedLanes = 0;
         var y = c.timeoutHandle;
         if (y !== Pt && (c.timeoutHandle = Pt, Qe(y)), Vn !== null)
            for (y = Vn.return; y !== null;) {
               var M = y;
               switch (Gy(M), M.tag) {
                  case 1:
                     M = M.type.childContextTypes, M != null && Un();
                     break;
                  case 3:
                     Cu(), xt(At), xt(tn), Jy();
                     break;
                  case 5:
                     $y(M);
                     break;
                  case 4:
                     Cu();
                     break;
                  case 13:
                     xt(bn);
                     break;
                  case 19:
                     xt(bn);
                     break;
                  case 10:
                     Fy(M.type._context);
                     break;
                  case 22:
                  case 23:
                     Ex()
               }
               y = y.return
            }
         if (zn = c, Vn = c = Ko(c.current, null), cr = ui = f, Yn = 0, sh = null, vx = pm = Pu = 0, jr = oh = null, Ps !== null) {
            for (f = 0; f < Ps.length; f++)
               if (y = Ps[f], M = y.interleaved, M !== null) {
                  y.interleaved = null;
                  var w = M.next,
                     P = y.pending;
                  if (P !== null) {
                     var V = P.next;
                     P.next = w, M.next = V
                  }
                  y.pending = M
               } Ps = null
         }
         return c
      }

      function yC(c, f) {
         do {
            var y = Vn;
            try {
               if (Dy(), Xp.current = qp, Jp) {
                  for (var M = In.memoizedState; M !== null;) {
                     var w = M.queue;
                     w !== null && (w.pending = null), M = M.next
                  }
                  Jp = !1
               }
               if (Tu = 0, sr = vr = In = null, Yf = !1, Qf = 0, gx.current = null, y === null || y.return === null) {
                  Yn = 1, sh = f, Vn = null;
                  break
               }
               e: {
                  var P = c,
                     V = y.return,
                     re = y,
                     ve = f;
                  if (f = cr, re.flags |= 32768, ve !== null && typeof ve == "object" && typeof ve.then == "function") {
                     var De = ve,
                        tt = re,
                        bt = tt.tag;
                     if (!(tt.mode & 1) && (bt === 0 || bt === 11 || bt === 15)) {
                        var gt = tt.alternate;
                        gt ? (tt.updateQueue = gt.updateQueue, tt.memoizedState = gt.memoizedState, tt.lanes = gt.lanes) : (tt.updateQueue = null, tt.memoizedState = null)
                     }
                     var an = kb(V);
                     if (an !== null) {
                        an.flags &= -257, Hb(an, V, re, P, f), an.mode & 1 && Ub(P, De, f), f = an, ve = De;
                        var ft = f.updateQueue;
                        if (ft === null) {
                           var _r = new Set;
                           _r.add(ve), f.updateQueue = _r
                        } else ft.add(ve);
                        break e
                     } else {
                        if (!(f & 1)) {
                           Ub(P, De, f), wx();
                           break e
                        }
                        ve = Error(o(426))
                     }
                  } else if (An && re.mode & 1) {
                     var Fi = kb(V);
                     if (Fi !== null) {
                        !(Fi.flags & 65536) && (Fi.flags |= 256), Hb(Fi, V, re, P, f), Wy(ve);
                        break e
                     }
                  }
                  P = ve,
                  Yn !== 4 && (Yn = 2),
                  oh === null ? oh = [P] : oh.push(P),
                  ve = tx(ve, re),
                  re = V;do {
                     switch (re.tag) {
                        case 3:
                           re.flags |= 65536, f &= -f, re.lanes |= f;
                           var le = Ob(re, ve, f);
                           ib(re, le);
                           break e;
                        case 1:
                           P = ve;
                           var ie = re.type,
                              pe = re.stateNode;
                           if (!(re.flags & 128) && (typeof ie.getDerivedStateFromError == "function" || pe !== null && typeof pe.componentDidCatch == "function" && (jo === null || !jo.has(pe)))) {
                              re.flags |= 65536, f &= -f, re.lanes |= f;
                              var je = Nb(re, P, f);
                              ib(re, je);
                              break e
                           }
                     }
                     re = re.return
                  } while (re !== null)
               }
               AC(y)
            } catch (ut) {
               f = ut, Vn === y && y !== null && (Vn = y = y.return);
               continue
            }
            break
         } while (1)
      }

      function xC() {
         var c = dm.current;
         return dm.current = qp, c === null ? qp : c
      }

      function wx() {
         (Yn === 0 || Yn === 3 || Yn === 2) && (Yn = 4), zn === null || !(Pu & 268435455) && !(pm & 268435455) || Jo(zn, cr)
      }

      function Am(c, f) {
         var y = Nt;
         Nt |= 2;
         var M = xC();
         zn === c && cr === f || rl(c, f);
         do try {
            _4();
            break
         } catch (w) {
            yC(c, w)
         }
         while (1);
         if (Dy(), Nt = y, dm.current = M, Vn !== null) throw Error(o(261));
         return zn = null, cr = 0, Yn
      }

      function _4() {
         for (; Vn !== null;) _C(Vn)
      }

      function A4() {
         for (; Vn !== null && !Xk();) _C(Vn)
      }

      function _C(c) {
         var f = EC(c.alternate, c, ui);
         c.memoizedProps = c.pendingProps, f === null ? AC(c) : Vn = f, gx.current = null
      }

      function AC(c) {
         var f = c;
         do {
            var y = f.alternate;
            if (c = f.return, f.flags & 32768) {
               if (y = d4(y, f), y !== null) {
                  y.flags &= 32767, Vn = y;
                  return
               }
               if (c !== null) c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null;
               else {
                  Yn = 6, Vn = null;
                  return
               }
            } else if (y = c4(y, f, ui), y !== null) {
               Vn = y;
               return
            }
            if (f = f.sibling, f !== null) {
               Vn = f;
               return
            }
            Vn = f = c
         } while (f !== null);
         Yn === 0 && (Yn = 5)
      }

      function il(c, f) {
         var y = Kt,
            M = kn.transition;
         try {
            kn.transition = null, Kt = 1, S4(c, f, y)
         } finally {
            kn.transition = M, Kt = y
         }
         return null
      }

      function S4(c, f, y) {
         do sl(); while ($o !== null);
         if (Nt & 6) throw Error(o(327));
         var M = c.finishedWork,
            w = c.finishedLanes;
         if (M === null) return null;
         if (c.finishedWork = null, c.finishedLanes = 0, M === c.current) throw Error(o(177));
         c.callbackNode = null, c.callbackPriority = 0;
         var P = M.lanes | M.childLanes;
         if ($k(c, P), c === zn && (Vn = zn = null, cr = 0), !(M.subtreeFlags & 2064) && !(M.flags & 2064) || gm || (gm = !0, wC(By, function () {
               return sl(), null
            })), P = (M.flags & 15990) !== 0, M.subtreeFlags & 15990 || P) {
            P = kn.transition, kn.transition = null;
            var V = Kt;
            Kt = 1;
            var re = Nt;
            Nt |= 4, gx.current = null, m4(c, M), g4(c, M), Y(c.containerInfo), c.current = M, v4(M), Jk(), Nt = re, Kt = V, kn.transition = P
         } else c.current = M;
         if (gm && (gm = !1, $o = c, vm = w), P = c.pendingLanes, P === 0 && (jo = null), Qk(M.stateNode), $r(c, ir()), f !== null)
            for (y = c.onRecoverableError, M = 0; M < f.length; M++) y(f[M]);
         if (mm) throw mm = !1, c = _x, _x = null, c;
         return vm & 1 && c.tag !== 0 && sl(), P = c.pendingLanes, P & 1 ? c === Ax ? ah++ : (ah = 0, Ax = c) : ah = 0, Rs(), null
      }

      function sl() {
         if ($o !== null) {
            var c = qw(vm),
               f = kn.transition,
               y = Kt;
            try {
               if (kn.transition = null, Kt = 16 > c ? 16 : c, $o === null) var M = !1;
               else {
                  if (c = $o, $o = null, vm = 0, Nt & 6) throw Error(o(331));
                  var w = Nt;
                  for (Nt |= 4, Ve = c.current; Ve !== null;) {
                     var P = Ve,
                        V = P.child;
                     if (Ve.flags & 16) {
                        var re = P.deletions;
                        if (re !== null) {
                           for (var ve = 0; ve < re.length; ve++) {
                              var De = re[ve];
                              for (Ve = De; Ve !== null;) {
                                 var tt = Ve;
                                 switch (tt.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                       nl(8, tt, P)
                                 }
                                 var bt = tt.child;
                                 if (bt !== null) bt.return = tt, Ve = bt;
                                 else
                                    for (; Ve !== null;) {
                                       tt = Ve;
                                       var gt = tt.sibling,
                                          an = tt.return;
                                       if (sC(tt), tt === De) {
                                          Ve = null;
                                          break
                                       }
                                       if (gt !== null) {
                                          gt.return = an, Ve = gt;
                                          break
                                       }
                                       Ve = an
                                    }
                              }
                           }
                           var ft = P.alternate;
                           if (ft !== null) {
                              var _r = ft.child;
                              if (_r !== null) {
                                 ft.child = null;
                                 do {
                                    var Fi = _r.sibling;
                                    _r.sibling = null, _r = Fi
                                 } while (_r !== null)
                              }
                           }
                           Ve = P
                        }
                     }
                     if (P.subtreeFlags & 2064 && V !== null) V.return = P, Ve = V;
                     else e: for (; Ve !== null;) {
                        if (P = Ve, P.flags & 2048) switch (P.tag) {
                           case 0:
                           case 11:
                           case 15:
                              nl(9, P, P.return)
                        }
                        var le = P.sibling;
                        if (le !== null) {
                           le.return = P.return, Ve = le;
                           break e
                        }
                        Ve = P.return
                     }
                  }
                  var ie = c.current;
                  for (Ve = ie; Ve !== null;) {
                     V = Ve;
                     var pe = V.child;
                     if (V.subtreeFlags & 2064 && pe !== null) pe.return = V, Ve = pe;
                     else e: for (V = ie; Ve !== null;) {
                        if (re = Ve, re.flags & 2048) try {
                           switch (re.tag) {
                              case 0:
                              case 11:
                              case 15:
                                 rh(9, re)
                           }
                        } catch (ut) {
                           Xr(re, re.return, ut)
                        }
                        if (re === V) {
                           Ve = null;
                           break e
                        }
                        var je = re.sibling;
                        if (je !== null) {
                           je.return = re.return, Ve = je;
                           break e
                        }
                        Ve = re.return
                     }
                  }
                  if (Nt = w, Rs(), Cs && typeof Cs.onPostCommitFiberRoot == "function") try {
                     Cs.onPostCommitFiberRoot(Fp, c)
                  } catch {}
                  M = !0
               }
               return M
            } finally {
               Kt = y, kn.transition = f
            }
         }
         return !1
      }

      function SC(c, f, y) {
         f = tx(y, f), f = Ob(c, f, 1), Wo(c, f), f = Dr(), c = _m(c, 1), c !== null && (Wf(c, 1, f), $r(c, f))
      }

      function Xr(c, f, y) {
         if (c.tag === 3) SC(c, c, y);
         else
            for (; f !== null;) {
               if (f.tag === 3) {
                  SC(f, c, y);
                  break
               } else if (f.tag === 1) {
                  var M = f.stateNode;
                  if (typeof f.type.getDerivedStateFromError == "function" || typeof M.componentDidCatch == "function" && (jo === null || !jo.has(M))) {
                     c = tx(y, c), c = Nb(f, c, 1), Wo(f, c), c = Dr(), f = _m(f, 1), f !== null && (Wf(f, 1, c), $r(f, c));
                     break
                  }
               }
               f = f.return
            }
      }

      function M4(c, f, y) {
         var M = c.pingCache;
         M !== null && M.delete(f), f = Dr(), c.pingedLanes |= c.suspendedLanes & y, zn === c && (cr & y) === y && (Yn === 4 || Yn === 3 && (cr & 130023424) === cr && 500 > ir() - yx ? rl(c, 0) : vx |= y), $r(c, f)
      }

      function MC(c, f) {
         f === 0 && (c.mode & 1 ? (f = Lp, Lp <<= 1, !(Lp & 130023424) && (Lp = 4194304)) : f = 1);
         var y = Dr();
         c = _m(c, f), c !== null && (Wf(c, f, y), $r(c, y))
      }

      function E4(c) {
         var f = c.memoizedState,
            y = 0;
         f !== null && (y = f.retryLane), MC(c, y)
      }

      function w4(c, f) {
         var y = 0;
         switch (c.tag) {
            case 13:
               var M = c.stateNode,
                  w = c.memoizedState;
               w !== null && (y = w.retryLane);
               break;
            case 19:
               M = c.stateNode;
               break;
            default:
               throw Error(o(314))
         }
         M !== null && M.delete(f), MC(c, y)
      }
      var EC;
      EC = function (c, f, y) {
         if (c !== null)
            if (c.memoizedProps !== f.pendingProps || At.current) li = !0;
            else {
               if (!(c.lanes & y) && !(f.flags & 128)) return li = !1, h4(c, f, y);
               li = !!(c.flags & 131072)
            }
         else li = !1, An && f.flags & 1048576 && cb(f, Wp, f.index);
         switch (f.lanes = 0, f.tag) {
            case 2:
               var M = f.type;
               c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), c = f.pendingProps;
               var w = Jt(f, tn.current);
               Au(f, y), w = Yy(null, f, M, c, w, y);
               var P = Qy();
               return f.flags |= 1, typeof w == "object" && w !== null && typeof w.render == "function" && w.$$typeof === void 0 ? (f.tag = 1, f.memoizedState = null, f.updateQueue = null, on(M) ? (P = !0, qt(f)) : P = !1, f.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null, Ny(f), w.updater = zp, f.stateNode = w, w._reactInternals = f, ky(f, M, c, y), f = ix(null, f, M, !0, P, y)) : (f.tag = 0, An && P && Hy(f), Lr(null, f, w, y), f = f.child), f;
            case 16:
               M = f.elementType;
               e: {
                  switch (c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), c = f.pendingProps, w = M._init, M = w(M._payload), f.type = M, w = f.tag = C4(M), c = es(M, c), w) {
                     case 0:
                        f = rx(null, f, M, c, y);
                        break e;
                     case 1:
                        f = Jb(null, f, M, c, y);
                        break e;
                     case 11:
                        f = Vb(null, f, M, c, y);
                        break e;
                     case 14:
                        f = Wb(null, f, M, es(M.type, c), y);
                        break e
                  }
                  throw Error(o(306, M, ""))
               }
               return f;
            case 0:
               return M = f.type, w = f.pendingProps, w = f.elementType === M ? w : es(M, w), rx(c, f, M, w, y);
            case 1:
               return M = f.type, w = f.pendingProps, w = f.elementType === M ? w : es(M, w), Jb(c, f, M, w, y);
            case 3:
               e: {
                  if (Kb(f), c === null) throw Error(o(387));M = f.pendingProps,
                  P = f.memoizedState,
                  w = P.element,
                  rb(c, f),
                  Gp(f, M, null, y);
                  var V = f.memoizedState;
                  if (M = V.element, Ce && P.isDehydrated)
                     if (P = {
                           element: M,
                           isDehydrated: !1,
                           cache: V.cache,
                           transitions: V.transitions
                        }, f.updateQueue.baseState = P, f.memoizedState = P, f.flags & 256) {
                        w = Error(o(423)), f = Yb(c, f, M, y, w);
                        break e
                     } else if (M !== w) {
                     w = Error(o(424)), f = Yb(c, f, M, y, w);
                     break e
                  } else
                     for (Ce && (ai = xu(f.stateNode.containerInfo), oi = f, An = !0, ts = null, jf = !1), y = gb(f, null, M, y), f.child = y; y;) y.flags = y.flags & -3 | 4096, y = y.sibling;
                  else {
                     if (Eu(), M === w) {
                        f = oo(c, f, y);
                        break e
                     }
                     Lr(c, f, M, y)
                  }
                  f = f.child
               }
               return f;
            case 5:
               return vb(f), c === null && Vy(f), M = f.type, w = f.pendingProps, P = c !== null ? c.memoizedProps : null, V = w.children, we(M, w) ? V = null : P !== null && we(M, P) && (f.flags |= 32), Xb(c, f), Lr(c, f, V, y), f.child;
            case 6:
               return c === null && Vy(f), null;
            case 13:
               return Qb(c, f, y);
            case 4:
               return jy(f, f.stateNode.containerInfo), M = f.pendingProps, c === null ? f.child = wu(f, null, M, y) : Lr(c, f, M, y), f.child;
            case 11:
               return M = f.type, w = f.pendingProps, w = f.elementType === M ? w : es(M, w), Vb(c, f, M, w, y);
            case 7:
               return Lr(c, f, f.pendingProps, y), f.child;
            case 8:
               return Lr(c, f, f.pendingProps.children, y), f.child;
            case 12:
               return Lr(c, f, f.pendingProps.children, y), f.child;
            case 10:
               e: {
                  if (M = f.type._context, w = f.pendingProps, P = f.memoizedProps, V = w.value, nb(f, M, V), P !== null)
                     if (Ts(P.value, V)) {
                        if (P.children === w.children && !At.current) {
                           f = oo(c, f, y);
                           break e
                        }
                     } else
                        for (P = f.child, P !== null && (P.return = f); P !== null;) {
                           var re = P.dependencies;
                           if (re !== null) {
                              V = P.child;
                              for (var ve = re.firstContext; ve !== null;) {
                                 if (ve.context === M) {
                                    if (P.tag === 1) {
                                       ve = no(-1, y & -y), ve.tag = 2;
                                       var De = P.updateQueue;
                                       if (De !== null) {
                                          De = De.shared;
                                          var tt = De.pending;
                                          tt === null ? ve.next = ve : (ve.next = tt.next, tt.next = ve), De.pending = ve
                                       }
                                    }
                                    P.lanes |= y, ve = P.alternate, ve !== null && (ve.lanes |= y), Oy(P.return, y, f), re.lanes |= y;
                                    break
                                 }
                                 ve = ve.next
                              }
                           } else if (P.tag === 10) V = P.type === f.type ? null : P.child;
                           else if (P.tag === 18) {
                              if (V = P.return, V === null) throw Error(o(341));
                              V.lanes |= y, re = V.alternate, re !== null && (re.lanes |= y), Oy(V, y, f), V = P.sibling
                           } else V = P.child;
                           if (V !== null) V.return = P;
                           else
                              for (V = P; V !== null;) {
                                 if (V === f) {
                                    V = null;
                                    break
                                 }
                                 if (P = V.sibling, P !== null) {
                                    P.return = V.return, V = P;
                                    break
                                 }
                                 V = V.return
                              }
                           P = V
                        }
                  Lr(c, f, w.children, y),
                  f = f.child
               }
               return f;
            case 9:
               return w = f.type, M = f.pendingProps.children, Au(f, y), w = Ti(w), M = M(w), f.flags |= 1, Lr(c, f, M, y), f.child;
            case 14:
               return M = f.type, w = es(M, f.pendingProps), w = es(M.type, w), Wb(c, f, M, w, y);
            case 15:
               return jb(c, f, f.type, f.pendingProps, y);
            case 17:
               return M = f.type, w = f.pendingProps, w = f.elementType === M ? w : es(M, w), c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), f.tag = 1, on(M) ? (c = !0, qt(f)) : c = !1, Au(f, y), lb(f, M, w), ky(f, M, w, y), ix(null, f, M, !0, c, y);
            case 19:
               return tC(c, f, y);
            case 22:
               return $b(c, f, y)
         }
         throw Error(o(156, f.tag))
      };

      function wC(c, f) {
         return Ry(c, f)
      }

      function b4(c, f, y, M) {
         this.tag = c, this.key = y, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = M, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
      }

      function Di(c, f, y, M) {
         return new b4(c, f, y, M)
      }

      function bx(c) {
         return c = c.prototype, !(!c || !c.isReactComponent)
      }

      function C4(c) {
         if (typeof c == "function") return bx(c) ? 1 : 0;
         if (c != null) {
            if (c = c.$$typeof, c === _) return 11;
            if (c === S) return 14
         }
         return 2
      }

      function Ko(c, f) {
         var y = c.alternate;
         return y === null ? (y = Di(c.tag, f, c.key, c.mode), y.elementType = c.elementType, y.type = c.type, y.stateNode = c.stateNode, y.alternate = c, c.alternate = y) : (y.pendingProps = f, y.type = c.type, y.flags = 0, y.subtreeFlags = 0, y.deletions = null), y.flags = c.flags & 14680064, y.childLanes = c.childLanes, y.lanes = c.lanes, y.child = c.child, y.memoizedProps = c.memoizedProps, y.memoizedState = c.memoizedState, y.updateQueue = c.updateQueue, f = c.dependencies, y.dependencies = f === null ? null : {
            lanes: f.lanes,
            firstContext: f.firstContext
         }, y.sibling = c.sibling, y.index = c.index, y.ref = c.ref, y
      }

      function Sm(c, f, y, M, w, P) {
         var V = 2;
         if (M = c, typeof c == "function") bx(c) && (V = 1);
         else if (typeof c == "string") V = 5;
         else e: switch (c) {
            case h:
               return ol(y.children, w, P, f);
            case d:
               V = 8, w |= 8;
               break;
            case p:
               return c = Di(12, y, f, w | 2), c.elementType = p, c.lanes = P, c;
            case x:
               return c = Di(13, y, f, w), c.elementType = x, c.lanes = P, c;
            case g:
               return c = Di(19, y, f, w), c.elementType = g, c.lanes = P, c;
            case E:
               return Mm(y, w, P, f);
            default:
               if (typeof c == "object" && c !== null) switch (c.$$typeof) {
                  case m:
                     V = 10;
                     break e;
                  case v:
                     V = 9;
                     break e;
                  case _:
                     V = 11;
                     break e;
                  case S:
                     V = 14;
                     break e;
                  case A:
                     V = 16, M = null;
                     break e
               }
               throw Error(o(130, c == null ? c : typeof c, ""))
         }
         return f = Di(V, y, f, w), f.elementType = c, f.type = M, f.lanes = P, f
      }

      function ol(c, f, y, M) {
         return c = Di(7, c, M, f), c.lanes = y, c
      }

      function Mm(c, f, y, M) {
         return c = Di(22, c, M, f), c.elementType = E, c.lanes = y, c.stateNode = {}, c
      }

      function Cx(c, f, y) {
         return c = Di(6, c, null, f), c.lanes = y, c
      }

      function Tx(c, f, y) {
         return f = Di(4, c.children !== null ? c.children : [], c.key, f), f.lanes = y, f.stateNode = {
            containerInfo: c.containerInfo,
            pendingChildren: null,
            implementation: c.implementation
         }, f
      }

      function T4(c, f, y, M, w) {
         this.tag = f, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Pt, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Cy(0), this.expirationTimes = Cy(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Cy(0), this.identifierPrefix = M, this.onRecoverableError = w, Ce && (this.mutableSourceEagerHydrationData = null)
      }

      function bC(c, f, y, M, w, P, V, re, ve) {
         return c = new T4(c, f, y, re, ve), f === 1 ? (f = 1, P === !0 && (f |= 8)) : f = 0, P = Di(3, null, null, f), c.current = P, P.stateNode = c, P.memoizedState = {
            element: M,
            isDehydrated: y,
            cache: null,
            transitions: null
         }, Ny(P), c
      }

      function CC(c) {
         if (!c) return wt;
         c = c._reactInternals;
         e: {
            if (T(c) !== c || c.tag !== 1) throw Error(o(170));
            var f = c;do {
               switch (f.tag) {
                  case 3:
                     f = f.stateNode.context;
                     break e;
                  case 1:
                     if (on(f.type)) {
                        f = f.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                     }
               }
               f = f.return
            } while (f !== null);
            throw Error(o(171))
         }
         if (c.tag === 1) {
            var y = c.type;
            if (on(y)) return wn(c, y, f)
         }
         return f
      }

      function TC(c) {
         var f = c._reactInternals;
         if (f === void 0) throw typeof c.render == "function" ? Error(o(188)) : (c = Object.keys(c).join(","), Error(o(268, c)));
         return c = q(f), c === null ? null : c.stateNode
      }

      function RC(c, f) {
         if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
            var y = c.retryLane;
            c.retryLane = y !== 0 && y < f ? y : f
         }
      }

      function Rx(c, f) {
         RC(c, f), (c = c.alternate) && RC(c, f)
      }

      function R4(c) {
         return c = q(c), c === null ? null : c.stateNode
      }

      function P4() {
         return null
      }
      return n.attemptContinuousHydration = function (c) {
         if (c.tag === 13) {
            var f = Dr();
            Li(c, 134217728, f), Rx(c, 134217728)
         }
      }, n.attemptHydrationAtCurrentPriority = function (c) {
         if (c.tag === 13) {
            var f = Dr(),
               y = Xo(c);
            Li(c, y, f), Rx(c, y)
         }
      }, n.attemptSynchronousHydration = function (c) {
         switch (c.tag) {
            case 3:
               var f = c.stateNode;
               if (f.current.memoizedState.isDehydrated) {
                  var y = Vf(f.pendingLanes);
                  y !== 0 && (Ty(f, y | 1), $r(f, ir()), !(Nt & 6) && (Bu(), Rs()))
               }
               break;
            case 13:
               var M = Dr();
               vC(function () {
                  return Li(c, 1, M)
               }), Rx(c, 1)
         }
      }, n.batchedUpdates = function (c, f) {
         var y = Nt;
         Nt |= 1;
         try {
            return c(f)
         } finally {
            Nt = y, Nt === 0 && (Bu(), Op && Rs())
         }
      }, n.createComponentSelector = function (c) {
         return {
            $$typeof: lm,
            value: c
         }
      }, n.createContainer = function (c, f, y, M, w, P, V) {
         return bC(c, f, !1, null, y, M, w, P, V)
      }, n.createHasPseudoClassSelector = function (c) {
         return {
            $$typeof: um,
            value: c
         }
      }, n.createHydrationContainer = function (c, f, y, M, w, P, V, re, ve) {
         return c = bC(y, M, !0, c, w, P, V, re, ve), c.context = CC(null), y = c.current, M = Dr(), w = Xo(y), P = no(M, w), P.callback = f ?? null, Wo(y, P), c.current.lanes = w, Wf(c, w, M), $r(c, M), c
      }, n.createPortal = function (c, f, y) {
         var M = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
         return {
            $$typeof: u,
            key: M == null ? null : "" + M,
            children: c,
            containerInfo: f,
            implementation: y
         }
      }, n.createRoleSelector = function (c) {
         return {
            $$typeof: cm,
            value: c
         }
      }, n.createTestNameSelector = function (c) {
         return {
            $$typeof: fm,
            value: c
         }
      }, n.createTextSelector = function (c) {
         return {
            $$typeof: hm,
            value: c
         }
      }, n.deferredUpdates = function (c) {
         var f = Kt,
            y = kn.transition;
         try {
            return kn.transition = null, Kt = 16, c()
         } finally {
            Kt = f, kn.transition = y
         }
      }, n.discreteUpdates = function (c, f, y, M, w) {
         var P = Kt,
            V = kn.transition;
         try {
            return kn.transition = null, Kt = 1, c(f, y, M, w)
         } finally {
            Kt = P, kn.transition = V, Nt === 0 && Bu()
         }
      }, n.findAllNodes = mx, n.findBoundingRects = function (c, f) {
         if (!vt) throw Error(o(363));
         f = mx(c, f), c = [];
         for (var y = 0; y < f.length; y++) c.push(un(f[y]));
         for (f = c.length - 1; 0 < f; f--) {
            y = c[f];
            for (var M = y.x, w = M + y.width, P = y.y, V = P + y.height, re = f - 1; 0 <= re; re--)
               if (f !== re) {
                  var ve = c[re],
                     De = ve.x,
                     tt = De + ve.width,
                     bt = ve.y,
                     gt = bt + ve.height;
                  if (M >= De && P >= bt && w <= tt && V <= gt) {
                     c.splice(f, 1);
                     break
                  } else if (M !== De || y.width !== ve.width || gt < P || bt > V) {
                     if (!(P !== bt || y.height !== ve.height || tt < M || De > w)) {
                        De > M && (ve.width += De - M, ve.x = M), tt < w && (ve.width = w - De), c.splice(f, 1);
                        break
                     }
                  } else {
                     bt > P && (ve.height += bt - P, ve.y = P), gt < V && (ve.height = V - bt), c.splice(f, 1);
                     break
                  }
               }
         }
         return c
      }, n.findHostInstance = TC, n.findHostInstanceWithNoPortals = function (c) {
         return c = N(c), c = c !== null ? Z(c) : null, c === null ? null : c.stateNode
      }, n.findHostInstanceWithWarning = function (c) {
         return TC(c)
      }, n.flushControlled = function (c) {
         var f = Nt;
         Nt |= 1;
         var y = kn.transition,
            M = Kt;
         try {
            kn.transition = null, Kt = 1, c()
         } finally {
            Kt = M, kn.transition = y, Nt = f, Nt === 0 && (Bu(), Rs())
         }
      }, n.flushPassiveEffects = sl, n.flushSync = vC, n.focusWithin = function (c, f) {
         if (!vt) throw Error(o(363));
         for (c = hx(c), f = pC(c, f), f = Array.from(f), c = 0; c < f.length;) {
            var y = f[c++];
            if (!O(y)) {
               if (y.tag === 5 && Pe(y.stateNode)) return !0;
               for (y = y.child; y !== null;) f.push(y), y = y.sibling
            }
         }
         return !1
      }, n.getCurrentUpdatePriority = function () {
         return Kt
      }, n.getFindAllNodesFailureDescription = function (c, f) {
         if (!vt) throw Error(o(363));
         var y = 0,
            M = [];
         c = [hx(c), 0];
         for (var w = 0; w < c.length;) {
            var P = c[w++],
               V = c[w++],
               re = f[V];
            if ((P.tag !== 5 || !O(P)) && (dx(P, re) && (M.push(px(re)), V++, V > y && (y = V)), V < f.length))
               for (P = P.child; P !== null;) c.push(P, V), P = P.sibling
         }
         if (y < f.length) {
            for (c = []; y < f.length; y++) c.push(px(f[y]));
            return `findAllNodes was able to match part of the selector:
  ` + (M.join(" > ") + `

No matching component was found for:
  `) + c.join(" > ")
         }
         return null
      }, n.getPublicRootInstance = function (c) {
         if (c = c.current, !c.child) return null;
         switch (c.child.tag) {
            case 5:
               return se(c.child.stateNode);
            default:
               return c.child.stateNode
         }
      }, n.injectIntoDevTools = function (c) {
         if (c = {
               bundleType: c.bundleType,
               version: c.version,
               rendererPackageName: c.rendererPackageName,
               rendererConfig: c.rendererConfig,
               overrideHookState: null,
               overrideHookStateDeletePath: null,
               overrideHookStateRenamePath: null,
               overrideProps: null,
               overridePropsDeletePath: null,
               overridePropsRenamePath: null,
               setErrorHandler: null,
               setSuspenseHandler: null,
               scheduleUpdate: null,
               currentDispatcherRef: a.ReactCurrentDispatcher,
               findHostInstanceByFiber: R4,
               findFiberByHostInstance: c.findFiberByHostInstance || P4,
               findHostInstancesForRefresh: null,
               scheduleRefresh: null,
               scheduleRoot: null,
               setRefreshHandler: null,
               getCurrentFiber: null,
               reconcilerVersion: "18.0.0-fc46dba67-20220329"
            }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") c = !1;
         else {
            var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (f.isDisabled || !f.supportsFiber) c = !0;
            else {
               try {
                  Fp = f.inject(c), Cs = f
               } catch {}
               c = !!f.checkDCE
            }
         }
         return c
      }, n.isAlreadyRendering = function () {
         return !1
      }, n.observeVisibleRects = function (c, f, y, M) {
         if (!vt) throw Error(o(363));
         c = mx(c, f);
         var w = Te(c, y, M).disconnect;
         return {
            disconnect: function () {
               w()
            }
         }
      }, n.registerMutableSourceForHydration = function (c, f) {
         var y = f._getVersion;
         y = y(f._source), c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [f, y] : c.mutableSourceEagerHydrationData.push(f, y)
      }, n.runWithPriority = function (c, f) {
         var y = Kt;
         try {
            return Kt = c, f()
         } finally {
            Kt = y
         }
      }, n.shouldError = function () {
         return null
      }, n.shouldSuspend = function () {
         return !1
      }, n.updateContainer = function (c, f, y, M) {
         var w = f.current,
            P = Dr(),
            V = Xo(w);
         return y = CC(y), f.context === null ? f.context = y : f.pendingContext = y, f = no(P, V), f.payload = {
            element: c
         }, M = M === void 0 ? null : M, M !== null && (f.callback = M), Wo(w, f), c = Li(w, V, P), c !== null && Hp(c, w, V), V
      }, n
   };
   mO.exports = z7;
   var V7 = mO.exports;
   const W7 = qd(V7),
      j7 = t => typeof t == "object" && typeof t.then == "function",
      Ol = [];

   function yO(t, e, n = (r, i) => r === i) {
      if (t === e) return !0;
      if (!t || !e) return !1;
      const r = t.length;
      if (e.length !== r) return !1;
      for (let i = 0; i < r; i++)
         if (!n(t[i], e[i])) return !1;
      return !0
   }

   function xO(t, e = null, n = !1, r = {}) {
      e === null && (e = [t]);
      for (const s of Ol)
         if (yO(e, s.keys, s.equal)) {
            if (n) return;
            if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response")) return r.lifespan && r.lifespan > 0 && (s.timeout && clearTimeout(s.timeout), s.timeout = setTimeout(s.remove, r.lifespan)), s.response;
            if (!n) throw s.promise
         } const i = {
         keys: e,
         equal: r.equal,
         remove: () => {
            const s = Ol.indexOf(i);
            s !== -1 && Ol.splice(s, 1)
         },
         promise: (j7(t) ? t : t(...e)).then(s => {
            i.response = s, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan))
         }).catch(s => i.error = s)
      };
      if (Ol.push(i), !n) throw i.promise
   }
   const $7 = (t, e, n) => xO(t, e, !1, n),
      X7 = (t, e, n) => void xO(t, e, !0, n),
      J7 = t => {
         if (t === void 0 || t.length === 0) Ol.splice(0, Ol.length);
         else {
            const e = Ol.find(n => yO(t, n.keys, n.equal));
            e && e.remove()
         }
      },
      IE = {},
      LE = t => void Object.assign(IE, t);

   function K7(t, e) {
      function n(h, {
         args: d = [],
         attach: p,
         ...m
      }, v) {
         let _ = `${h[0].toUpperCase()}${h.slice(1)}`,
            x;
         if (h === "primitive") {
            if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
            const g = m.object;
            x = ic(g, {
               type: h,
               root: v,
               attach: p,
               primitive: !0
            })
         } else {
            const g = IE[_];
            if (!g) throw new Error(`R3F: ${_} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(d)) throw new Error("R3F: The args prop must be an array!");
            x = ic(new g(...d), {
               type: h,
               root: v,
               attach: p,
               memoizedProps: {
                  args: d
               }
            })
         }
         return x.__r3f.attach === void 0 && (x instanceof Tt ? x.__r3f.attach = "geometry" : x instanceof Jn && (x.__r3f.attach = "material")), _ !== "inject" && N_(x, m), x
      }

      function r(h, d) {
         let p = !1;
         if (d) {
            var m, v;
            (m = d.__r3f) != null && m.attach ? O_(h, d, d.__r3f.attach) : d.isObject3D && h.isObject3D && (h.add(d), p = !0), p || (v = h.__r3f) == null || v.objects.push(d), d.__r3f || ic(d, {}), d.__r3f.parent = h, rS(d), sc(d)
         }
      }

      function i(h, d, p) {
         let m = !1;
         if (d) {
            var v, _;
            if ((v = d.__r3f) != null && v.attach) O_(h, d, d.__r3f.attach);
            else if (d.isObject3D && h.isObject3D) {
               d.parent = h, d.dispatchEvent({
                  type: "added"
               });
               const x = h.children.filter(S => S !== d),
                  g = x.indexOf(p);
               h.children = [...x.slice(0, g), d, ...x.slice(g)], m = !0
            }
            m || (_ = h.__r3f) == null || _.objects.push(d), d.__r3f || ic(d, {}), d.__r3f.parent = h, rS(d), sc(d)
         }
      }

      function s(h, d, p = !1) {
         h && [...h].forEach(m => o(d, m, p))
      }

      function o(h, d, p) {
         if (d) {
            var m, v, _;
            if (d.__r3f && (d.__r3f.parent = null), (m = h.__r3f) != null && m.objects && (h.__r3f.objects = h.__r3f.objects.filter(E => E !== d)), (v = d.__r3f) != null && v.attach) g2(h, d, d.__r3f.attach);
            else if (d.isObject3D && h.isObject3D) {
               var x;
               h.remove(d), (x = d.__r3f) != null && x.root && nj(d.__r3f.root, d)
            }
            const S = (_ = d.__r3f) == null ? void 0 : _.primitive,
               A = p === void 0 ? d.dispose !== null && !S : p;
            if (!S) {
               var g;
               s((g = d.__r3f) == null ? void 0 : g.objects, d, A), s(d.children, d, A)
            }
            delete d.__r3f, A && d.dispose && d.type !== "Scene" && tS.unstable_scheduleCallback(tS.unstable_IdlePriority, () => {
               try {
                  d.dispose()
               } catch {}
            }), sc(h)
         }
      }

      function a(h, d, p, m) {
         var v;
         const _ = (v = h.__r3f) == null ? void 0 : v.parent;
         if (!_) return;
         const x = n(d, p, h.__r3f.root);
         if (h.children) {
            for (const g of h.children) g.__r3f && r(x, g);
            h.children = h.children.filter(g => !g.__r3f)
         }
         h.__r3f.objects.forEach(g => r(x, g)), h.__r3f.objects = [], h.__r3f.autoRemovedBeforeAppend || o(_, h), x.parent && (x.__r3f.autoRemovedBeforeAppend = !0), r(_, x), x.raycast && x.__r3f.eventCount && x.__r3f.root.getState().internal.interaction.push(x), [m, m.alternate].forEach(g => {
            g !== null && (g.stateNode = x, g.ref && (typeof g.ref == "function" ? g.ref(x) : g.ref.current = x))
         })
      }
      const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
      return {
         reconciler: W7({
            createInstance: n,
            removeChild: o,
            appendChild: r,
            appendInitialChild: r,
            insertBefore: i,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (h, d) => {
               if (!d) return;
               const p = h.getState().scene;
               p.__r3f && (p.__r3f.root = h, r(p, d))
            },
            removeChildFromContainer: (h, d) => {
               d && o(h.getState().scene, d)
            },
            insertInContainerBefore: (h, d, p) => {
               if (!d || !p) return;
               const m = h.getState().scene;
               m.__r3f && i(m, d, p)
            },
            getRootHostContext: () => null,
            getChildHostContext: h => h,
            finalizeInitialChildren(h) {
               var d;
               return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers
            },
            prepareUpdate(h, d, p, m) {
               var v;
               if (((v = h == null ? void 0 : h.__r3f) != null ? v : {}).primitive && m.object && m.object !== h) return [!0]; {
                  const {
                     args: x = [],
                     children: g,
                     ...S
                  } = m, {
                     args: A = [],
                     children: E,
                     ...C
                  } = p;
                  if (!Array.isArray(x)) throw new Error("R3F: the args prop must be an array!");
                  if (x.some((B, D) => B !== A[D])) return [!0];
                  const R = bO(h, S, C, !0);
                  return R.changes.length ? [!1, R] : null
               }
            },
            commitUpdate(h, [d, p], m, v, _, x) {
               d ? a(h, m, _, x) : N_(h, p)
            },
            commitMount(h, d, p, m) {
               var v;
               const _ = (v = h.__r3f) != null ? v : {};
               h.raycast && _.handlers && _.eventCount && h.__r3f.root.getState().internal.interaction.push(h)
            },
            getPublicInstance: h => h,
            prepareForCommit: () => null,
            preparePortalMount: h => ic(h.getState().scene),
            resetAfterCommit: () => {},
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance(h) {
               var d;
               const {
                  attach: p,
                  parent: m
               } = (d = h.__r3f) != null ? d : {};
               p && m && g2(m, h, p), h.isObject3D && (h.visible = !1), sc(h)
            },
            unhideInstance(h, d) {
               var p;
               const {
                  attach: m,
                  parent: v
               } = (p = h.__r3f) != null ? p : {};
               m && v && O_(v, h, m), (h.isObject3D && d.visible == null || d.visible) && (h.visible = !0), sc(h)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: () => e ? e() : kc.DefaultEventPriority,
            beforeActiveInstanceBlur: () => {},
            afterActiveInstanceBlur: () => {},
            detachDeletedInstance: () => {},
            now: typeof performance < "u" && mn.fun(performance.now) ? performance.now : mn.fun(Date.now) ? Date.now : () => 0,
            scheduleTimeout: mn.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: mn.fun(clearTimeout) ? clearTimeout : void 0
         }),
         applyProps: N_
      }
   }
   var h2, d2;
   const F_ = t => "colorSpace" in t || "outputColorSpace" in t,
      _O = () => {
         var t;
         return (t = IE.ColorManagement) != null ? t : null
      },
      AO = t => t && t.isOrthographicCamera,
      Y7 = t => t && t.hasOwnProperty("current"),
      vp = typeof window < "u" && ((h2 = window.document) != null && h2.createElement || ((d2 = window.navigator) == null ? void 0 : d2.product) === "ReactNative") ? $.useLayoutEffect : $.useEffect;

   function SO(t) {
      const e = $.useRef(t);
      return vp(() => void(e.current = t), [t]), e
   }

   function Q7({
      set: t
   }) {
      return vp(() => (t(new Promise(() => null)), () => t(!1)), [t]), null
   }
   class MO extends $.Component {
      constructor(...e) {
         super(...e), this.state = {
            error: !1
         }
      }
      componentDidCatch(e) {
         this.props.set(e)
      }
      render() {
         return this.state.error ? null : this.props.children
      }
   }
   MO.getDerivedStateFromError = () => ({
      error: !0
   });
   const EO = "__default",
      p2 = new Map,
      Z7 = t => t && !!t.memoized && !!t.changes;

   function wO(t) {
      var e;
      const n = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
      return Array.isArray(t) ? Math.min(Math.max(t[0], n), t[1]) : t
   }
   const bh = t => {
         var e;
         return (e = t.__r3f) == null ? void 0 : e.root.getState()
      },
      mn = {
         obj: t => t === Object(t) && !mn.arr(t) && typeof t != "function",
         fun: t => typeof t == "function",
         str: t => typeof t == "string",
         num: t => typeof t == "number",
         boo: t => typeof t == "boolean",
         und: t => t === void 0,
         arr: t => Array.isArray(t),
         equ(t, e, {
            arrays: n = "shallow",
            objects: r = "reference",
            strict: i = !0
         } = {}) {
            if (typeof t != typeof e || !!t != !!e) return !1;
            if (mn.str(t) || mn.num(t)) return t === e;
            const s = mn.obj(t);
            if (s && r === "reference") return t === e;
            const o = mn.arr(t);
            if (o && n === "reference") return t === e;
            if ((o || s) && t === e) return !0;
            let a;
            for (a in t)
               if (!(a in e)) return !1;
            if (s && n === "shallow" && r === "shallow") {
               for (a in i ? e : t)
                  if (!mn.equ(t[a], e[a], {
                        strict: i,
                        objects: "reference"
                     })) return !1
            } else
               for (a in i ? e : t)
                  if (t[a] !== e[a]) return !1;
            if (mn.und(a)) {
               if (o && t.length === 0 && e.length === 0 || s && Object.keys(t).length === 0 && Object.keys(e).length === 0) return !0;
               if (t !== e) return !1
            }
            return !0
         }
      };

   function q7(t) {
      const e = {
         nodes: {},
         materials: {}
      };
      return t && t.traverse(n => {
         n.name && (e.nodes[n.name] = n), n.material && !e.materials[n.material.name] && (e.materials[n.material.name] = n.material)
      }), e
   }

   function ej(t) {
      t.dispose && t.type !== "Scene" && t.dispose();
      for (const e in t) e.dispose == null || e.dispose(), delete t[e]
   }

   function ic(t, e) {
      const n = t;
      return n.__r3f = {
         type: "",
         root: null,
         previousAttach: null,
         memoizedProps: {},
         eventCount: 0,
         handlers: {},
         objects: [],
         parent: null,
         ...e
      }, t
   }

   function nS(t, e) {
      let n = t;
      if (e.includes("-")) {
         const r = e.split("-"),
            i = r.pop();
         return n = r.reduce((s, o) => s[o], t), {
            target: n,
            key: i
         }
      } else return {
         target: n,
         key: e
      }
   }
   const m2 = /-\d+$/;

   function O_(t, e, n) {
      if (mn.str(n)) {
         if (m2.test(n)) {
            const s = n.replace(m2, ""),
               {
                  target: o,
                  key: a
               } = nS(t, s);
            Array.isArray(o[a]) || (o[a] = [])
         }
         const {
            target: r,
            key: i
         } = nS(t, n);
         e.__r3f.previousAttach = r[i], r[i] = e
      } else e.__r3f.previousAttach = n(t, e)
   }

   function g2(t, e, n) {
      var r, i;
      if (mn.str(n)) {
         const {
            target: s,
            key: o
         } = nS(t, n), a = e.__r3f.previousAttach;
         a === void 0 ? delete s[o] : s[o] = a
      } else(r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(t, e);
      (i = e.__r3f) == null || delete i.previousAttach
   }

   function bO(t, {
      children: e,
      key: n,
      ref: r,
      ...i
   }, {
      children: s,
      key: o,
      ref: a,
      ...l
   } = {}, u = !1) {
      var h;
      const d = (h = t == null ? void 0 : t.__r3f) != null ? h : {},
         p = Object.entries(i),
         m = [];
      if (u) {
         const _ = Object.keys(l);
         for (let x = 0; x < _.length; x++) i.hasOwnProperty(_[x]) || p.unshift([_[x], EO + "remove"])
      }
      p.forEach(([_, x]) => {
         var g;
         if ((g = t.__r3f) != null && g.primitive && _ === "object" || mn.equ(x, l[_])) return;
         if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(_)) return m.push([_, x, !0, []]);
         let S = [];
         _.includes("-") && (S = _.split("-")), m.push([_, x, !1, S]);
         for (const A in i) {
            const E = i[A];
            A.startsWith(`${_}-`) && m.push([A, E, !1, A.split("-")])
         }
      });
      const v = {
         ...i
      };
      return d.memoizedProps && d.memoizedProps.args && (v.args = d.memoizedProps.args), d.memoizedProps && d.memoizedProps.attach && (v.attach = d.memoizedProps.attach), {
         memoized: v,
         changes: m
      }
   }

   function N_(t, e) {
      var n, r, i;
      const s = (n = t.__r3f) != null ? n : {},
         o = s.root,
         a = (r = o == null || o.getState == null ? void 0 : o.getState()) != null ? r : {},
         {
            memoized: l,
            changes: u
         } = Z7(e) ? e : bO(t, e),
         h = s.eventCount;
      t.__r3f && (t.__r3f.memoizedProps = l);
      for (let p = 0; p < u.length; p++) {
         let [m, v, _, x] = u[p];
         if (F_(t)) {
            const E = "srgb",
               C = "srgb-linear";
            m === "encoding" ? (m = "colorSpace", v = v === 3001 ? E : C) : m === "outputEncoding" && (m = "outputColorSpace", v = v === 3001 ? E : C)
         }
         let g = t,
            S = g[m];
         if (x.length && (S = x.reduce((A, E) => A[E], t), !(S && S.set))) {
            const [A, ...E] = x.reverse();
            g = E.reverse().reduce((C, R) => C[R], t), m = A
         }
         if (v === EO + "remove")
            if (g.constructor) {
               let A = p2.get(g.constructor);
               A || (A = new g.constructor, p2.set(g.constructor, A)), v = A[m]
            } else v = 0;
         if (_) v ? s.handlers[m] = v : delete s.handlers[m], s.eventCount = Object.keys(s.handlers).length;
         else if (S && S.set && (S.copy || S instanceof zl)) {
            if (Array.isArray(v)) S.fromArray ? S.fromArray(v) : S.set(...v);
            else if (S.copy && v && v.constructor && S.constructor === v.constructor) S.copy(v);
            else if (v !== void 0) {
               const A = S instanceof ke;
               !A && S.setScalar ? S.setScalar(v) : S instanceof zl && v instanceof zl ? S.mask = v.mask : S.set(v), !_O() && !a.linear && A && S.convertSRGBToLinear()
            }
         } else if (g[m] = v, g[m] instanceof yn && g[m].format === Hr && g[m].type === Vs) {
            const A = g[m];
            F_(A) && F_(a.gl) ? A.colorSpace = a.gl.outputColorSpace : A.encoding = a.gl.outputEncoding
         }
         sc(t)
      }
      if (s.parent && a.internal && t.raycast && h !== s.eventCount) {
         const p = a.internal.interaction.indexOf(t);
         p > -1 && a.internal.interaction.splice(p, 1), s.eventCount && a.internal.interaction.push(t)
      }
      return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (i = t.__r3f) != null && i.parent && rS(t), t
   }

   function sc(t) {
      var e, n;
      const r = (e = t.__r3f) == null || (n = e.root) == null || n.getState == null ? void 0 : n.getState();
      r && r.internal.frames === 0 && r.invalidate()
   }

   function rS(t) {
      t.onUpdate == null || t.onUpdate(t)
   }

   function CO(t, e) {
      t.manual || (AO(t) ? (t.left = e.width / -2, t.right = e.width / 2, t.top = e.height / 2, t.bottom = e.height / -2) : t.aspect = e.width / e.height, t.updateProjectionMatrix(), t.updateMatrixWorld())
   }

   function Rg(t) {
      return (t.eventObject || t.object).uuid + "/" + t.index + t.instanceId
   }

   function tj() {
      var t;
      const e = typeof self < "u" && self || typeof window < "u" && window;
      if (!e) return kc.DefaultEventPriority;
      switch ((t = e.event) == null ? void 0 : t.type) {
         case "click":
         case "contextmenu":
         case "dblclick":
         case "pointercancel":
         case "pointerdown":
         case "pointerup":
            return kc.DiscreteEventPriority;
         case "pointermove":
         case "pointerout":
         case "pointerover":
         case "pointerenter":
         case "pointerleave":
         case "wheel":
            return kc.ContinuousEventPriority;
         default:
            return kc.DefaultEventPriority
      }
   }

   function TO(t, e, n, r) {
      const i = n.get(e);
      i && (n.delete(e), n.size === 0 && (t.delete(r), i.target.releasePointerCapture(r)))
   }

   function nj(t, e) {
      const {
         internal: n
      } = t.getState();
      n.interaction = n.interaction.filter(r => r !== e), n.initialHits = n.initialHits.filter(r => r !== e), n.hovered.forEach((r, i) => {
         (r.eventObject === e || r.object === e) && n.hovered.delete(i)
      }), n.capturedMap.forEach((r, i) => {
         TO(n.capturedMap, e, r, i)
      })
   }

   function rj(t) {
      function e(l) {
         const {
            internal: u
         } = t.getState(), h = l.offsetX - u.initialClick[0], d = l.offsetY - u.initialClick[1];
         return Math.round(Math.sqrt(h * h + d * d))
      }

      function n(l) {
         return l.filter(u => ["Move", "Over", "Enter", "Out", "Leave"].some(h => {
            var d;
            return (d = u.__r3f) == null ? void 0 : d.handlers["onPointer" + h]
         }))
      }

      function r(l, u) {
         const h = t.getState(),
            d = new Set,
            p = [],
            m = u ? u(h.internal.interaction) : h.internal.interaction;
         for (let g = 0; g < m.length; g++) {
            const S = bh(m[g]);
            S && (S.raycaster.camera = void 0)
         }
         h.previousRoot || h.events.compute == null || h.events.compute(l, h);

         function v(g) {
            const S = bh(g);
            if (!S || !S.events.enabled || S.raycaster.camera === null) return [];
            if (S.raycaster.camera === void 0) {
               var A;
               S.events.compute == null || S.events.compute(l, S, (A = S.previousRoot) == null ? void 0 : A.getState()), S.raycaster.camera === void 0 && (S.raycaster.camera = null)
            }
            return S.raycaster.camera ? S.raycaster.intersectObject(g, !0) : []
         }
         let _ = m.flatMap(v).sort((g, S) => {
            const A = bh(g.object),
               E = bh(S.object);
            return !A || !E ? g.distance - S.distance : E.events.priority - A.events.priority || g.distance - S.distance
         }).filter(g => {
            const S = Rg(g);
            return d.has(S) ? !1 : (d.add(S), !0)
         });
         h.events.filter && (_ = h.events.filter(_, h));
         for (const g of _) {
            let S = g.object;
            for (; S;) {
               var x;
               (x = S.__r3f) != null && x.eventCount && p.push({
                  ...g,
                  eventObject: S
               }), S = S.parent
            }
         }
         if ("pointerId" in l && h.internal.capturedMap.has(l.pointerId))
            for (let g of h.internal.capturedMap.get(l.pointerId).values()) d.has(Rg(g.intersection)) || p.push(g.intersection);
         return p
      }

      function i(l, u, h, d) {
         const p = t.getState();
         if (l.length) {
            const m = {
               stopped: !1
            };
            for (const v of l) {
               const _ = bh(v.object) || p,
                  {
                     raycaster: x,
                     pointer: g,
                     camera: S,
                     internal: A
                  } = _,
                  E = new U(g.x, g.y, 0).unproject(S),
                  C = I => {
                     var N, q;
                     return (N = (q = A.capturedMap.get(I)) == null ? void 0 : q.has(v.eventObject)) != null ? N : !1
                  },
                  R = I => {
                     const N = {
                        intersection: v,
                        target: u.target
                     };
                     A.capturedMap.has(I) ? A.capturedMap.get(I).set(v.eventObject, N) : A.capturedMap.set(I, new Map([
                        [v.eventObject, N]
                     ])), u.target.setPointerCapture(I)
                  },
                  B = I => {
                     const N = A.capturedMap.get(I);
                     N && TO(A.capturedMap, v.eventObject, N, I)
                  };
               let D = {};
               for (let I in u) {
                  let N = u[I];
                  typeof N != "function" && (D[I] = N)
               }
               let T = {
                  ...v,
                  ...D,
                  pointer: g,
                  intersections: l,
                  stopped: m.stopped,
                  delta: h,
                  unprojectedPoint: E,
                  ray: x.ray,
                  camera: S,
                  stopPropagation() {
                     const I = "pointerId" in u && A.capturedMap.get(u.pointerId);
                     if ((!I || I.has(v.eventObject)) && (T.stopped = m.stopped = !0, A.hovered.size && Array.from(A.hovered.values()).find(N => N.eventObject === v.eventObject))) {
                        const N = l.slice(0, l.indexOf(v));
                        s([...N, v])
                     }
                  },
                  target: {
                     hasPointerCapture: C,
                     setPointerCapture: R,
                     releasePointerCapture: B
                  },
                  currentTarget: {
                     hasPointerCapture: C,
                     setPointerCapture: R,
                     releasePointerCapture: B
                  },
                  nativeEvent: u
               };
               if (d(T), m.stopped === !0) break
            }
         }
         return l
      }

      function s(l) {
         const {
            internal: u
         } = t.getState();
         for (const h of u.hovered.values())
            if (!l.length || !l.find(d => d.object === h.object && d.index === h.index && d.instanceId === h.instanceId)) {
               const p = h.eventObject.__r3f,
                  m = p == null ? void 0 : p.handlers;
               if (u.hovered.delete(Rg(h)), p != null && p.eventCount) {
                  const v = {
                     ...h,
                     intersections: l
                  };
                  m.onPointerOut == null || m.onPointerOut(v), m.onPointerLeave == null || m.onPointerLeave(v)
               }
            }
      }

      function o(l, u) {
         for (let h = 0; h < u.length; h++) {
            const d = u[h].__r3f;
            d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(l)
         }
      }

      function a(l) {
         switch (l) {
            case "onPointerLeave":
            case "onPointerCancel":
               return () => s([]);
            case "onLostPointerCapture":
               return u => {
                  const {
                     internal: h
                  } = t.getState();
                  "pointerId" in u && h.capturedMap.has(u.pointerId) && requestAnimationFrame(() => {
                     h.capturedMap.has(u.pointerId) && (h.capturedMap.delete(u.pointerId), s([]))
                  })
               }
         }
         return function (h) {
            const {
               onPointerMissed: d,
               internal: p
            } = t.getState();
            p.lastEvent.current = h;
            const m = l === "onPointerMove",
               v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
               x = r(h, m ? n : void 0),
               g = v ? e(h) : 0;
            l === "onPointerDown" && (p.initialClick = [h.offsetX, h.offsetY], p.initialHits = x.map(A => A.eventObject)), v && !x.length && g <= 2 && (o(h, p.interaction), d && d(h)), m && s(x);

            function S(A) {
               const E = A.eventObject,
                  C = E.__r3f,
                  R = C == null ? void 0 : C.handlers;
               if (C != null && C.eventCount)
                  if (m) {
                     if (R.onPointerOver || R.onPointerEnter || R.onPointerOut || R.onPointerLeave) {
                        const B = Rg(A),
                           D = p.hovered.get(B);
                        D ? D.stopped && A.stopPropagation() : (p.hovered.set(B, A), R.onPointerOver == null || R.onPointerOver(A), R.onPointerEnter == null || R.onPointerEnter(A))
                     }
                     R.onPointerMove == null || R.onPointerMove(A)
                  } else {
                     const B = R[l];
                     B ? (!v || p.initialHits.includes(E)) && (o(h, p.interaction.filter(D => !p.initialHits.includes(D))), B(A)) : v && p.initialHits.includes(E) && o(h, p.interaction.filter(D => !p.initialHits.includes(D)))
                  }
            }
            i(x, h, g, S)
         }
      }
      return {
         handlePointer: a
      }
   }
   const ij = ["set", "get", "setSize", "setFrameloop", "setDpr", "events", "invalidate", "advance", "size", "viewport"],
      RO = t => !!(t != null && t.render),
      DE = $.createContext(null),
      sj = (t, e) => {
         const n = pO((a, l) => {
               const u = new U,
                  h = new U,
                  d = new U;

               function p(g = l().camera, S = h, A = l().size) {
                  const {
                     width: E,
                     height: C,
                     top: R,
                     left: B
                  } = A, D = E / C;
                  S instanceof U ? d.copy(S) : d.set(...S);
                  const T = g.getWorldPosition(u).distanceTo(d);
                  if (AO(g)) return {
                     width: E / g.zoom,
                     height: C / g.zoom,
                     top: R,
                     left: B,
                     factor: 1,
                     distance: T,
                     aspect: D
                  }; {
                     const I = g.fov * Math.PI / 180,
                        N = 2 * Math.tan(I / 2) * T,
                        q = N * (E / C);
                     return {
                        width: q,
                        height: N,
                        top: R,
                        left: B,
                        factor: E / q,
                        distance: T,
                        aspect: D
                     }
                  }
               }
               let m;
               const v = g => a(S => ({
                     performance: {
                        ...S.performance,
                        current: g
                     }
                  })),
                  _ = new Se;
               return {
                  set: a,
                  get: l,
                  gl: null,
                  camera: null,
                  raycaster: null,
                  events: {
                     priority: 1,
                     enabled: !0,
                     connected: !1
                  },
                  xr: null,
                  scene: null,
                  invalidate: (g = 1) => t(l(), g),
                  advance: (g, S) => e(g, S, l()),
                  legacy: !1,
                  linear: !1,
                  flat: !1,
                  controls: null,
                  clock: new CE,
                  pointer: _,
                  mouse: _,
                  frameloop: "always",
                  onPointerMissed: void 0,
                  performance: {
                     current: 1,
                     min: .5,
                     max: 1,
                     debounce: 200,
                     regress: () => {
                        const g = l();
                        m && clearTimeout(m), g.performance.current !== g.performance.min && v(g.performance.min), m = setTimeout(() => v(l().performance.max), g.performance.debounce)
                     }
                  },
                  size: {
                     width: 0,
                     height: 0,
                     top: 0,
                     left: 0,
                     updateStyle: !1
                  },
                  viewport: {
                     initialDpr: 0,
                     dpr: 0,
                     width: 0,
                     height: 0,
                     top: 0,
                     left: 0,
                     aspect: 0,
                     distance: 0,
                     factor: 0,
                     getCurrentViewport: p
                  },
                  setEvents: g => a(S => ({
                     ...S,
                     events: {
                        ...S.events,
                        ...g
                     }
                  })),
                  setSize: (g, S, A, E, C) => {
                     const R = l().camera,
                        B = {
                           width: g,
                           height: S,
                           top: E || 0,
                           left: C || 0,
                           updateStyle: A
                        };
                     a(D => ({
                        size: B,
                        viewport: {
                           ...D.viewport,
                           ...p(R, h, B)
                        }
                     }))
                  },
                  setDpr: g => a(S => {
                     const A = wO(g);
                     return {
                        viewport: {
                           ...S.viewport,
                           dpr: A,
                           initialDpr: S.viewport.initialDpr || A
                        }
                     }
                  }),
                  setFrameloop: (g = "always") => {
                     const S = l().clock;
                     S.stop(), S.elapsedTime = 0, g !== "never" && (S.start(), S.elapsedTime = 0), a(() => ({
                        frameloop: g
                     }))
                  },
                  previousRoot: void 0,
                  internal: {
                     active: !1,
                     priority: 0,
                     frames: 0,
                     lastEvent: $.createRef(),
                     interaction: [],
                     hovered: new Map,
                     subscribers: [],
                     initialClick: [0, 0],
                     initialHits: [],
                     capturedMap: new Map,
                     subscribe: (g, S, A) => {
                        const E = l().internal;
                        return E.priority = E.priority + (S > 0 ? 1 : 0), E.subscribers.push({
                           ref: g,
                           priority: S,
                           store: A
                        }), E.subscribers = E.subscribers.sort((C, R) => C.priority - R.priority), () => {
                           const C = l().internal;
                           C != null && C.subscribers && (C.priority = C.priority - (S > 0 ? 1 : 0), C.subscribers = C.subscribers.filter(R => R.ref !== g))
                        }
                     }
                  }
               }
            }),
            r = n.getState();
         let i = r.size,
            s = r.viewport.dpr,
            o = r.camera;
         return n.subscribe(() => {
            const {
               camera: a,
               size: l,
               viewport: u,
               gl: h,
               set: d
            } = n.getState();
            if (l !== i || u.dpr !== s) {
               var p;
               i = l, s = u.dpr, CO(a, l), h.setPixelRatio(u.dpr);
               const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && h.domElement instanceof HTMLCanvasElement;
               h.setSize(l.width, l.height, m)
            }
            a !== o && (o = a, d(m => ({
               viewport: {
                  ...m.viewport,
                  ...m.viewport.getCurrentViewport(a)
               }
            })))
         }), n.subscribe(a => t(a)), n
      };
   let Pg, oj = new Set,
      aj = new Set,
      lj = new Set;

   function U_(t, e) {
      if (t.size)
         for (const {
               callback: n
            } of t.values()) n(e)
   }

   function Ch(t, e) {
      switch (t) {
         case "before":
            return U_(oj, e);
         case "after":
            return U_(aj, e);
         case "tail":
            return U_(lj, e)
      }
   }
   let k_, H_;

   function G_(t, e, n) {
      let r = e.clock.getDelta();
      for (e.frameloop === "never" && typeof t == "number" && (r = t - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = t), k_ = e.internal.subscribers, Pg = 0; Pg < k_.length; Pg++) H_ = k_[Pg], H_.ref.current(H_.store.getState(), r, n);
      return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames
   }

   function uj(t) {
      let e = !1,
         n, r, i;

      function s(l) {
         r = requestAnimationFrame(s), e = !0, n = 0, Ch("before", l);
         for (const h of t.values()) {
            var u;
            i = h.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((u = i.gl.xr) != null && u.isPresenting) && (n += G_(l, i))
         }
         if (Ch("after", l), n === 0) return Ch("tail", l), e = !1, cancelAnimationFrame(r)
      }

      function o(l, u = 1) {
         var h;
         if (!l) return t.forEach(d => o(d.store.getState()), u);
         (h = l.gl.xr) != null && h.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + u), e || (e = !0, requestAnimationFrame(s)))
      }

      function a(l, u = !0, h, d) {
         if (u && Ch("before", l), h) G_(l, h, d);
         else
            for (const p of t.values()) G_(l, p.store.getState());
         u && Ch("after", l)
      }
      return {
         loop: s,
         invalidate: o,
         advance: a
      }
   }

   function FE() {
      const t = $.useContext(DE);
      if (!t) throw new Error("R3F: Hooks can only be used within the Canvas component!");
      return t
   }

   function Eo(t = n => n, e) {
      return FE()(t, e)
   }

   function ty(t, e = 0) {
      const n = FE(),
         r = n.getState().internal.subscribe,
         i = SO(t);
      return vp(() => r(i, e, n), [e, r, n]), null
   }

   function PO(t, e) {
      return function (n, ...r) {
         const i = new n;
         return t && t(i), Promise.all(r.map(s => new Promise((o, a) => i.load(s, l => {
            l.scene && Object.assign(l, q7(l.scene)), o(l)
         }, e, l => a(new Error(`Could not load ${s}: ${l.message}`))))))
      }
   }

   function ko(t, e, n, r) {
      const i = Array.isArray(e) ? e : [e],
         s = $7(PO(n, r), [t, ...i], {
            equal: mn.equ
         });
      return Array.isArray(e) ? s : s[0]
   }
   ko.preload = function (t, e, n) {
      const r = Array.isArray(e) ? e : [e];
      return X7(PO(n), [t, ...r])
   };
   ko.clear = function (t, e) {
      const n = Array.isArray(e) ? e : [e];
      return J7([t, ...n])
   };
   const xf = new Map,
      {
         invalidate: v2,
         advance: y2
      } = uj(xf),
      {
         reconciler: Xd,
         applyProps: Ns
      } = K7(xf, tj),
      tc = {
         objects: "shallow",
         strict: !1
      },
      cj = (t, e) => {
         const n = typeof t == "function" ? t(e) : t;
         return RO(n) ? n : new rE({
            powerPreference: "high-performance",
            canvas: e,
            antialias: !0,
            alpha: !0,
            ...t
         })
      };

   function fj(t, e) {
      if (e) return e;
      if (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && t.parentElement) {
         const {
            width: n,
            height: r,
            top: i,
            left: s
         } = t.parentElement.getBoundingClientRect();
         return {
            width: n,
            height: r,
            top: i,
            left: s
         }
      } else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas) return {
         width: t.width,
         height: t.height,
         top: 0,
         left: 0
      };
      return {
         width: 0,
         height: 0,
         top: 0,
         left: 0
      }
   }

   function hj(t) {
      const e = xf.get(t),
         n = e == null ? void 0 : e.fiber,
         r = e == null ? void 0 : e.store;
      e && console.warn("R3F.createRoot should only be called once!");
      const i = typeof reportError == "function" ? reportError : console.error,
         s = r || sj(v2, y2),
         o = n || Xd.createContainer(s, kc.ConcurrentRoot, null, !1, null, "", i, null);
      e || xf.set(t, {
         fiber: o,
         store: s
      });
      let a, l = !1,
         u;
      return {
         configure(h = {}) {
            let {
               gl: d,
               size: p,
               scene: m,
               events: v,
               onCreated: _,
               shadows: x = !1,
               linear: g = !1,
               flat: S = !1,
               legacy: A = !1,
               orthographic: E = !1,
               frameloop: C = "always",
               dpr: R = [1, 2],
               performance: B,
               raycaster: D,
               camera: T,
               onPointerMissed: I
            } = h, N = s.getState(), q = N.gl;
            N.gl || N.set({
               gl: q = cj(d, t)
            });
            let K = N.raycaster;
            K || N.set({
               raycaster: K = new BE
            });
            const {
               params: Z,
               ...te
            } = D || {};
            if (mn.equ(te, K, tc) || Ns(K, {
                  ...te
               }), mn.equ(Z, K.params, tc) || Ns(K, {
                  params: {
                     ...K.params,
                     ...Z
                  }
               }), !N.camera || N.camera === u && !mn.equ(u, T, tc)) {
               u = T;
               const Q = T instanceof op,
                  _e = Q ? T : E ? new Tf(0, 0, 0, 0, .1, 1e3) : new Zn(75, 0, .1, 1e3);
               Q || (_e.position.z = 5, T && Ns(_e, T), !N.camera && !(T != null && T.rotation) && _e.lookAt(0, 0, 0)), N.set({
                  camera: _e
               })
            }
            if (!N.scene) {
               let Q;
               m instanceof Gd ? Q = m : (Q = new Gd, m && Ns(Q, m)), N.set({
                  scene: ic(Q)
               })
            }
            if (!N.xr) {
               var se;
               const Q = (we, Ee) => {
                     const Ue = s.getState();
                     Ue.frameloop !== "never" && y2(we, !0, Ue, Ee)
                  },
                  _e = () => {
                     const we = s.getState();
                     we.gl.xr.enabled = we.gl.xr.isPresenting, we.gl.xr.setAnimationLoop(we.gl.xr.isPresenting ? Q : null), we.gl.xr.isPresenting || v2(we)
                  },
                  Me = {
                     connect() {
                        const we = s.getState().gl;
                        we.xr.addEventListener("sessionstart", _e), we.xr.addEventListener("sessionend", _e)
                     },
                     disconnect() {
                        const we = s.getState().gl;
                        we.xr.removeEventListener("sessionstart", _e), we.xr.removeEventListener("sessionend", _e)
                     }
                  };
               typeof ((se = q.xr) == null ? void 0 : se.addEventListener) == "function" && Me.connect(), N.set({
                  xr: Me
               })
            }
            if (q.shadowMap) {
               const Q = q.shadowMap.enabled,
                  _e = q.shadowMap.type;
               if (q.shadowMap.enabled = !!x, mn.boo(x)) q.shadowMap.type = od;
               else if (mn.str(x)) {
                  var oe;
                  const Me = {
                     basic: y3,
                     percentage: bv,
                     soft: od,
                     variance: cs
                  };
                  q.shadowMap.type = (oe = Me[x]) != null ? oe : od
               } else mn.obj(x) && Object.assign(q.shadowMap, x);
               (Q !== q.shadowMap.enabled || _e !== q.shadowMap.type) && (q.shadowMap.needsUpdate = !0)
            }
            const G = _O();
            G && ("enabled" in G ? G.enabled = !A : "legacyMode" in G && (G.legacyMode = A)), Ns(q, {
               outputEncoding: g ? 3e3 : 3001,
               toneMapping: S ? zs : FM
            }), N.legacy !== A && N.set(() => ({
               legacy: A
            })), N.linear !== g && N.set(() => ({
               linear: g
            })), N.flat !== S && N.set(() => ({
               flat: S
            })), d && !mn.fun(d) && !RO(d) && !mn.equ(d, q, tc) && Ns(q, d), v && !N.events.handlers && N.set({
               events: v(s)
            });
            const X = fj(t, p);
            return mn.equ(X, N.size, tc) || N.setSize(X.width, X.height, X.updateStyle, X.top, X.left), R && N.viewport.dpr !== wO(R) && N.setDpr(R), N.frameloop !== C && N.setFrameloop(C), N.onPointerMissed || N.set({
               onPointerMissed: I
            }), B && !mn.equ(B, N.performance, tc) && N.set(Q => ({
               performance: {
                  ...Q.performance,
                  ...B
               }
            })), a = _, l = !0, this
         },
         render(h) {
            return l || this.configure(), Xd.updateContainer($.createElement(dj, {
               store: s,
               children: h,
               onCreated: a,
               rootElement: t
            }), o, null, () => {}), s
         },
         unmount() {
            BO(t)
         }
      }
   }

   function dj({
      store: t,
      children: e,
      onCreated: n,
      rootElement: r
   }) {
      return vp(() => {
         const i = t.getState();
         i.set(s => ({
            internal: {
               ...s.internal,
               active: !0
            }
         })), n && n(i), t.getState().events.connected || i.events.connect == null || i.events.connect(r)
      }, []), $.createElement(DE.Provider, {
         value: t
      }, e)
   }

   function BO(t, e) {
      const n = xf.get(t),
         r = n == null ? void 0 : n.fiber;
      if (r) {
         const i = n == null ? void 0 : n.store.getState();
         i && (i.internal.active = !1), Xd.updateContainer(null, r, null, () => {
            i && setTimeout(() => {
               try {
                  var s, o, a, l;
                  i.events.disconnect == null || i.events.disconnect(), (s = i.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = i.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = i.gl) != null && l.xr && i.xr.disconnect(), ej(i), xf.delete(t), e && e(t)
               } catch {}
            }, 500)
         })
      }
   }

   function pj(t, e, n) {
      return $.createElement(mj, {
         key: e.uuid,
         children: t,
         container: e,
         state: n
      })
   }

   function mj({
      state: t = {},
      children: e,
      container: n
   }) {
      const {
         events: r,
         size: i,
         ...s
      } = t, o = FE(), [a] = $.useState(() => new BE), [l] = $.useState(() => new Se), u = $.useCallback((d, p) => {
         const m = {
            ...d
         };
         Object.keys(d).forEach(_ => {
            (ij.includes(_) || d[_] !== p[_] && p[_]) && delete m[_]
         });
         let v;
         if (p && i) {
            const _ = p.camera;
            v = d.viewport.getCurrentViewport(_, new U, i), _ !== d.camera && CO(_, i)
         }
         return {
            ...m,
            scene: n,
            raycaster: a,
            pointer: l,
            mouse: l,
            previousRoot: o,
            events: {
               ...d.events,
               ...p == null ? void 0 : p.events,
               ...r
            },
            size: {
               ...d.size,
               ...i
            },
            viewport: {
               ...d.viewport,
               ...v
            },
            ...s
         }
      }, [t]), [h] = $.useState(() => {
         const d = o.getState();
         return pO((m, v) => ({
            ...d,
            scene: n,
            raycaster: a,
            pointer: l,
            mouse: l,
            previousRoot: o,
            events: {
               ...d.events,
               ...r
            },
            size: {
               ...d.size,
               ...i
            },
            ...s,
            set: m,
            get: v,
            setEvents: _ => m(x => ({
               ...x,
               events: {
                  ...x.events,
                  ..._
               }
            }))
         }))
      });
      return $.useEffect(() => {
         const d = o.subscribe(p => h.setState(m => u(p, m)));
         return () => {
            d(), h.destroy()
         }
      }, []), $.useEffect(() => {
         h.setState(d => u(o.getState(), d))
      }, [u]), $.createElement($.Fragment, null, Xd.createPortal($.createElement(DE.Provider, {
         value: h
      }, e), h, null))
   }
   Xd.injectIntoDevTools({
      bundleType: 0,
      rendererPackageName: "@react-three/fiber",
      version: $.version
   });

   function Ua() {
      return Ua = Object.assign ? Object.assign.bind() : function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      }, Ua.apply(this, arguments)
   }

   function iS(t, e, n) {
      var r, i, s, o, a;
      e == null && (e = 100);

      function l() {
         var h = Date.now() - o;
         h < e && h >= 0 ? r = setTimeout(l, e - h) : (r = null, n || (a = t.apply(s, i), s = i = null))
      }
      var u = function () {
         s = this, i = arguments, o = Date.now();
         var h = n && !r;
         return r || (r = setTimeout(l, e)), h && (a = t.apply(s, i), s = i = null), a
      };
      return u.clear = function () {
         r && (clearTimeout(r), r = null)
      }, u.flush = function () {
         r && (a = t.apply(s, i), s = i = null, clearTimeout(r), r = null)
      }, u
   }
   iS.debounce = iS;
   var gj = iS;
   const x2 = qd(gj);

   function vj(t) {
      let {
         debounce: e,
         scroll: n,
         polyfill: r,
         offsetSize: i
      } = t === void 0 ? {
         debounce: 0,
         scroll: !1,
         offsetSize: !1
      } : t;
      const s = r || (typeof window > "u" ? class {} : window.ResizeObserver);
      if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
      const [o, a] = $.useState({
         left: 0,
         top: 0,
         width: 0,
         height: 0,
         bottom: 0,
         right: 0,
         x: 0,
         y: 0
      }), l = $.useRef({
         element: null,
         scrollContainers: null,
         resizeObserver: null,
         lastBounds: o
      }), u = e ? typeof e == "number" ? e : e.scroll : null, h = e ? typeof e == "number" ? e : e.resize : null, d = $.useRef(!1);
      $.useEffect(() => (d.current = !0, () => void(d.current = !1)));
      const [p, m, v] = $.useMemo(() => {
         const S = () => {
            if (!l.current.element) return;
            const {
               left: A,
               top: E,
               width: C,
               height: R,
               bottom: B,
               right: D,
               x: T,
               y: I
            } = l.current.element.getBoundingClientRect(), N = {
               left: A,
               top: E,
               width: C,
               height: R,
               bottom: B,
               right: D,
               x: T,
               y: I
            };
            l.current.element instanceof HTMLElement && i && (N.height = l.current.element.offsetHeight, N.width = l.current.element.offsetWidth), Object.freeze(N), d.current && !Aj(l.current.lastBounds, N) && a(l.current.lastBounds = N)
         };
         return [S, h ? x2(S, h) : S, u ? x2(S, u) : S]
      }, [a, i, u, h]);

      function _() {
         l.current.scrollContainers && (l.current.scrollContainers.forEach(S => S.removeEventListener("scroll", v, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null)
      }

      function x() {
         l.current.element && (l.current.resizeObserver = new s(v), l.current.resizeObserver.observe(l.current.element), n && l.current.scrollContainers && l.current.scrollContainers.forEach(S => S.addEventListener("scroll", v, {
            capture: !0,
            passive: !0
         })))
      }
      const g = S => {
         !S || S === l.current.element || (_(), l.current.element = S, l.current.scrollContainers = IO(S), x())
      };
      return xj(v, !!n), yj(m), $.useEffect(() => {
         _(), x()
      }, [n, v, m]), $.useEffect(() => _, []), [g, o, p]
   }

   function yj(t) {
      $.useEffect(() => {
         const e = t;
         return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e)
      }, [t])
   }

   function xj(t, e) {
      $.useEffect(() => {
         if (e) {
            const n = t;
            return window.addEventListener("scroll", n, {
               capture: !0,
               passive: !0
            }), () => void window.removeEventListener("scroll", n, !0)
         }
      }, [t, e])
   }

   function IO(t) {
      const e = [];
      if (!t || t === document.body) return e;
      const {
         overflow: n,
         overflowX: r,
         overflowY: i
      } = window.getComputedStyle(t);
      return [n, r, i].some(s => s === "auto" || s === "scroll") && e.push(t), [...e, ...IO(t.parentElement)]
   }
   const _j = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
      Aj = (t, e) => _j.every(n => t[n] === e[n]);
   var Sj = Object.defineProperty,
      Mj = Object.defineProperties,
      Ej = Object.getOwnPropertyDescriptors,
      _2 = Object.getOwnPropertySymbols,
      wj = Object.prototype.hasOwnProperty,
      bj = Object.prototype.propertyIsEnumerable,
      A2 = (t, e, n) => e in t ? Sj(t, e, {
         enumerable: !0,
         configurable: !0,
         writable: !0,
         value: n
      }) : t[e] = n,
      S2 = (t, e) => {
         for (var n in e || (e = {})) wj.call(e, n) && A2(t, n, e[n]);
         if (_2)
            for (var n of _2(e)) bj.call(e, n) && A2(t, n, e[n]);
         return t
      },
      Cj = (t, e) => Mj(t, Ej(e));

   function LO(t, e, n) {
      if (!t) return;
      if (n(t) === !0) return t;
      let r = e ? t.return : t.child;
      for (; r;) {
         const i = LO(r, e, n);
         if (i) return i;
         r = e ? null : r.sibling
      }
   }

   function DO(t) {
      try {
         return Object.defineProperties(t, {
            _currentRenderer: {
               get() {
                  return null
               },
               set() {}
            },
            _currentRenderer2: {
               get() {
                  return null
               },
               set() {}
            }
         })
      } catch {
         return t
      }
   }
   const OE = DO($.createContext(null));
   class FO extends $.Component {
      render() {
         return $.createElement(OE.Provider, {
            value: this._reactInternals
         }, this.props.children)
      }
   }
   const {
      ReactCurrentOwner: M2,
      ReactCurrentDispatcher: E2
   } = $.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

   function Tj() {
      const t = $.useContext(OE);
      if (t === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
      const e = $.useId();
      return $.useMemo(() => {
         for (const r of [M2 == null ? void 0 : M2.current, t, t == null ? void 0 : t.alternate]) {
            if (!r) continue;
            const i = LO(r, !1, s => {
               let o = s.memoizedState;
               for (; o;) {
                  if (o.memoizedState === e) return !0;
                  o = o.next
               }
            });
            if (i) return i
         }
      }, [t, e])
   }

   function Rj() {
      var t, e;
      const n = Tj(),
         [r] = $.useState(() => new Map);
      r.clear();
      let i = n;
      for (; i;) {
         const s = (t = i.type) == null ? void 0 : t._context;
         s && s !== OE && !r.has(s) && r.set(s, (e = E2 == null ? void 0 : E2.current) == null ? void 0 : e.readContext(DO(s))), i = i.return
      }
      return r
   }

   function Pj() {
      const t = Rj();
      return $.useMemo(() => Array.from(t.keys()).reduce((e, n) => r => $.createElement(e, null, $.createElement(n.Provider, Cj(S2({}, r), {
         value: t.get(n)
      }))), e => $.createElement(FO, S2({}, e))), [t])
   }
   const z_ = {
      onClick: ["click", !1],
      onContextMenu: ["contextmenu", !1],
      onDoubleClick: ["dblclick", !1],
      onWheel: ["wheel", !0],
      onPointerDown: ["pointerdown", !0],
      onPointerUp: ["pointerup", !0],
      onPointerLeave: ["pointerleave", !0],
      onPointerMove: ["pointermove", !0],
      onPointerCancel: ["pointercancel", !0],
      onLostPointerCapture: ["lostpointercapture", !0]
   };

   function Bj(t) {
      const {
         handlePointer: e
      } = rj(t);
      return {
         priority: 1,
         enabled: !0,
         compute(n, r, i) {
            r.pointer.set(n.offsetX / r.size.width * 2 - 1, -(n.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera)
         },
         connected: void 0,
         handlers: Object.keys(z_).reduce((n, r) => ({
            ...n,
            [r]: e(r)
         }), {}),
         update: () => {
            var n;
            const {
               events: r,
               internal: i
            } = t.getState();
            (n = i.lastEvent) != null && n.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current)
         },
         connect: n => {
            var r;
            const {
               set: i,
               events: s
            } = t.getState();
            s.disconnect == null || s.disconnect(), i(o => ({
               events: {
                  ...o.events,
                  connected: n
               }
            })), Object.entries((r = s.handlers) != null ? r : []).forEach(([o, a]) => {
               const [l, u] = z_[o];
               n.addEventListener(l, a, {
                  passive: u
               })
            })
         },
         disconnect: () => {
            const {
               set: n,
               events: r
            } = t.getState();
            if (r.connected) {
               var i;
               Object.entries((i = r.handlers) != null ? i : []).forEach(([s, o]) => {
                  if (r && r.connected instanceof HTMLElement) {
                     const [a] = z_[s];
                     r.connected.removeEventListener(a, o)
                  }
               }), n(s => ({
                  events: {
                     ...s.events,
                     connected: void 0
                  }
               }))
            }
         }
      }
   }
   const Ij = $.forwardRef(function ({
         children: e,
         fallback: n,
         resize: r,
         style: i,
         gl: s,
         events: o = Bj,
         eventSource: a,
         eventPrefix: l,
         shadows: u,
         linear: h,
         flat: d,
         legacy: p,
         orthographic: m,
         frameloop: v,
         dpr: _,
         performance: x,
         raycaster: g,
         camera: S,
         scene: A,
         onPointerMissed: E,
         onCreated: C,
         ...R
      }, B) {
         $.useMemo(() => LE(k7), []);
         const D = Pj(),
            [T, I] = vj({
               scroll: !0,
               debounce: {
                  scroll: 50,
                  resize: 0
               },
               ...r
            }),
            N = $.useRef(null),
            q = $.useRef(null);
         $.useImperativeHandle(B, () => N.current);
         const K = SO(E),
            [Z, te] = $.useState(!1),
            [se, oe] = $.useState(!1);
         if (Z) throw Z;
         if (se) throw se;
         const G = $.useRef(null);
         vp(() => {
            const Y = N.current;
            I.width > 0 && I.height > 0 && Y && (G.current || (G.current = hj(Y)), G.current.configure({
               gl: s,
               events: o,
               shadows: u,
               linear: h,
               flat: d,
               legacy: p,
               orthographic: m,
               frameloop: v,
               dpr: _,
               performance: x,
               raycaster: g,
               camera: S,
               scene: A,
               size: I,
               onPointerMissed: (...X) => K.current == null ? void 0 : K.current(...X),
               onCreated: X => {
                  X.events.connect == null || X.events.connect(a ? Y7(a) ? a.current : a : q.current), l && X.setEvents({
                     compute: (Q, _e) => {
                        const Me = Q[l + "X"],
                           we = Q[l + "Y"];
                        _e.pointer.set(Me / _e.size.width * 2 - 1, -(we / _e.size.height) * 2 + 1), _e.raycaster.setFromCamera(_e.pointer, _e.camera)
                     }
                  }), C == null || C(X)
               }
            }), G.current.render($.createElement(D, null, $.createElement(MO, {
               set: oe
            }, $.createElement($.Suspense, {
               fallback: $.createElement(Q7, {
                  set: te
               })
            }, e)))))
         }), $.useEffect(() => {
            const Y = N.current;
            if (Y) return () => BO(Y)
         }, []);
         const ne = a ? "none" : "auto";
         return $.createElement("div", Ua({
            ref: q,
            style: {
               position: "relative",
               width: "100%",
               height: "100%",
               overflow: "hidden",
               pointerEvents: ne,
               ...i
            }
         }, R), $.createElement("div", {
            ref: T,
            style: {
               width: "100%",
               height: "100%"
            }
         }, $.createElement("canvas", {
            ref: N,
            style: {
               display: "block"
            }
         }, n)))
      }),
      Lj = $.forwardRef(function (e, n) {
         return $.createElement(FO, null, $.createElement(Ij, Ua({}, e, {
            ref: n
         })))
      });

   function w2(t, e) {
      if (e === tF) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), t;
      if (e === k0 || e === WM) {
         let n = t.getIndex();
         if (n === null) {
            const o = [],
               a = t.getAttribute("position");
            if (a !== void 0) {
               for (let l = 0; l < a.count; l++) o.push(l);
               t.setIndex(o), n = t.getIndex()
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t
         }
         const r = n.count - 2,
            i = [];
         if (n)
            if (e === k0)
               for (let o = 1; o <= r; o++) i.push(n.getX(0)), i.push(n.getX(o)), i.push(n.getX(o + 1));
            else
               for (let o = 0; o < r; o++) o % 2 === 0 ? (i.push(n.getX(o)), i.push(n.getX(o + 1)), i.push(n.getX(o + 2))) : (i.push(n.getX(o + 2)), i.push(n.getX(o + 1)), i.push(n.getX(o)));
         i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
         const s = t.clone();
         return s.setIndex(i), s.clearGroups(), s
      } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), t
   }
   var ji = Uint8Array,
      va = Uint16Array,
      sS = Uint32Array,
      OO = new ji([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
      NO = new ji([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
      Dj = new ji([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
      UO = function (t, e) {
         for (var n = new va(31), r = 0; r < 31; ++r) n[r] = e += 1 << t[r - 1];
         for (var i = new sS(n[30]), r = 1; r < 30; ++r)
            for (var s = n[r]; s < n[r + 1]; ++s) i[s] = s - n[r] << 5 | r;
         return [n, i]
      },
      kO = UO(OO, 2),
      HO = kO[0],
      Fj = kO[1];
   HO[28] = 258, Fj[258] = 28;
   var Oj = UO(NO, 0),
      Nj = Oj[0],
      oS = new va(32768);
   for (var gn = 0; gn < 32768; ++gn) {
      var ra = (gn & 43690) >>> 1 | (gn & 21845) << 1;
      ra = (ra & 52428) >>> 2 | (ra & 13107) << 2, ra = (ra & 61680) >>> 4 | (ra & 3855) << 4, oS[gn] = ((ra & 65280) >>> 8 | (ra & 255) << 8) >>> 1
   }
   var fd = function (t, e, n) {
         for (var r = t.length, i = 0, s = new va(e); i < r; ++i) ++s[t[i] - 1];
         var o = new va(e);
         for (i = 0; i < e; ++i) o[i] = o[i - 1] + s[i - 1] << 1;
         var a;
         if (n) {
            a = new va(1 << e);
            var l = 15 - e;
            for (i = 0; i < r; ++i)
               if (t[i])
                  for (var u = i << 4 | t[i], h = e - t[i], d = o[t[i] - 1]++ << h, p = d | (1 << h) - 1; d <= p; ++d) a[oS[d] >>> l] = u
         } else
            for (a = new va(r), i = 0; i < r; ++i) t[i] && (a[i] = oS[o[t[i] - 1]++] >>> 15 - t[i]);
         return a
      },
      yp = new ji(288);
   for (var gn = 0; gn < 144; ++gn) yp[gn] = 8;
   for (var gn = 144; gn < 256; ++gn) yp[gn] = 9;
   for (var gn = 256; gn < 280; ++gn) yp[gn] = 7;
   for (var gn = 280; gn < 288; ++gn) yp[gn] = 8;
   var GO = new ji(32);
   for (var gn = 0; gn < 32; ++gn) GO[gn] = 5;
   var Uj = fd(yp, 9, 1),
      kj = fd(GO, 5, 1),
      V_ = function (t) {
         for (var e = t[0], n = 1; n < t.length; ++n) t[n] > e && (e = t[n]);
         return e
      },
      os = function (t, e, n) {
         var r = e / 8 | 0;
         return (t[r] | t[r + 1] << 8) >> (e & 7) & n
      },
      W_ = function (t, e) {
         var n = e / 8 | 0;
         return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (e & 7)
      },
      Hj = function (t) {
         return (t / 8 | 0) + (t & 7 && 1)
      },
      Gj = function (t, e, n) {
         (e == null || e < 0) && (e = 0), (n == null || n > t.length) && (n = t.length);
         var r = new(t instanceof va ? va : t instanceof sS ? sS : ji)(n - e);
         return r.set(t.subarray(e, n)), r
      },
      zj = function (t, e, n) {
         var r = t.length;
         if (!r || n && !n.l && r < 5) return e || new ji(0);
         var i = !e || n,
            s = !n || n.i;
         n || (n = {}), e || (e = new ji(r * 3));
         var o = function (Ee) {
               var Ue = e.length;
               if (Ee > Ue) {
                  var Qe = new ji(Math.max(Ue * 2, Ee));
                  Qe.set(e), e = Qe
               }
            },
            a = n.f || 0,
            l = n.p || 0,
            u = n.b || 0,
            h = n.l,
            d = n.d,
            p = n.m,
            m = n.n,
            v = r * 8;
         do {
            if (!h) {
               n.f = a = os(t, l, 1);
               var _ = os(t, l + 1, 3);
               if (l += 3, _)
                  if (_ == 1) h = Uj, d = kj, p = 9, m = 5;
                  else if (_ == 2) {
                  var A = os(t, l, 31) + 257,
                     E = os(t, l + 10, 15) + 4,
                     C = A + os(t, l + 5, 31) + 1;
                  l += 14;
                  for (var R = new ji(C), B = new ji(19), D = 0; D < E; ++D) B[Dj[D]] = os(t, l + D * 3, 7);
                  l += E * 3;
                  for (var T = V_(B), I = (1 << T) - 1, N = fd(B, T, 1), D = 0; D < C;) {
                     var q = N[os(t, l, I)];
                     l += q & 15;
                     var x = q >>> 4;
                     if (x < 16) R[D++] = x;
                     else {
                        var K = 0,
                           Z = 0;
                        for (x == 16 ? (Z = 3 + os(t, l, 3), l += 2, K = R[D - 1]) : x == 17 ? (Z = 3 + os(t, l, 7), l += 3) : x == 18 && (Z = 11 + os(t, l, 127), l += 7); Z--;) R[D++] = K
                     }
                  }
                  var te = R.subarray(0, A),
                     se = R.subarray(A);
                  p = V_(te), m = V_(se), h = fd(te, p, 1), d = fd(se, m, 1)
               } else throw "invalid block type";
               else {
                  var x = Hj(l) + 4,
                     g = t[x - 4] | t[x - 3] << 8,
                     S = x + g;
                  if (S > r) {
                     if (s) throw "unexpected EOF";
                     break
                  }
                  i && o(u + g), e.set(t.subarray(x, S), u), n.b = u += g, n.p = l = S * 8;
                  continue
               }
               if (l > v) {
                  if (s) throw "unexpected EOF";
                  break
               }
            }
            i && o(u + 131072);
            for (var oe = (1 << p) - 1, G = (1 << m) - 1, ne = l;; ne = l) {
               var K = h[W_(t, l) & oe],
                  Y = K >>> 4;
               if (l += K & 15, l > v) {
                  if (s) throw "unexpected EOF";
                  break
               }
               if (!K) throw "invalid length/literal";
               if (Y < 256) e[u++] = Y;
               else if (Y == 256) {
                  ne = l, h = null;
                  break
               } else {
                  var X = Y - 254;
                  if (Y > 264) {
                     var D = Y - 257,
                        Q = OO[D];
                     X = os(t, l, (1 << Q) - 1) + HO[D], l += Q
                  }
                  var _e = d[W_(t, l) & G],
                     Me = _e >>> 4;
                  if (!_e) throw "invalid distance";
                  l += _e & 15;
                  var se = Nj[Me];
                  if (Me > 3) {
                     var Q = NO[Me];
                     se += W_(t, l) & (1 << Q) - 1, l += Q
                  }
                  if (l > v) {
                     if (s) throw "unexpected EOF";
                     break
                  }
                  i && o(u + 131072);
                  for (var we = u + X; u < we; u += 4) e[u] = e[u - se], e[u + 1] = e[u + 1 - se], e[u + 2] = e[u + 2 - se], e[u + 3] = e[u + 3 - se];
                  u = we
               }
            }
            n.l = h, n.p = ne, n.b = u, h && (a = 1, n.m = p, n.d = d, n.n = m)
         } while (!a);
         return u == e.length ? e : Gj(e, 0, u)
      },
      Vj = new ji(0),
      Wj = function (t) {
         if ((t[0] & 15) != 8 || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31) throw "invalid zlib data";
         if (t[1] & 32) throw "invalid zlib data: preset dictionaries not supported"
      };

   function Bg(t, e) {
      return zj((Wj(t), t.subarray(2, -4)), e)
   }
   var jj = typeof TextDecoder < "u" && new TextDecoder,
      $j = 0;
   try {
      jj.decode(Vj, {
         stream: !0
      }), $j = 1
   } catch {}
   const Xj = t => t && t.isCubeTexture;
   class Jj extends Xn {
      constructor(e, n) {
         var r, i;
         const s = Xj(e),
            a = ((i = s ? (r = e.image[0]) == null ? void 0 : r.width : e.image.width) != null ? i : 1024) / 4,
            l = Math.floor(Math.log2(a)),
            u = Math.pow(2, l),
            h = 3 * Math.max(u, 16 * 7),
            d = 4 * u,
            p = [s ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1/h}`, `#define CUBEUV_TEXEL_HEIGHT ${1/d}`, `#define CUBEUV_MAX_MIP ${l}.0`],
            m = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
            v = p.join(`
`) + `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${parseInt(nu.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,
            _ = {
               map: {
                  value: e
               },
               height: {
                  value: (n == null ? void 0 : n.height) || 15
               },
               radius: {
                  value: (n == null ? void 0 : n.radius) || 100
               }
            },
            x = new hp(1, 16),
            g = new Qi({
               uniforms: _,
               fragmentShader: v,
               vertexShader: m,
               side: Wi
            });
         super(x, g)
      }
      set radius(e) {
         this.material.uniforms.radius.value = e
      }
      get radius() {
         return this.material.uniforms.radius.value
      }
      set height(e) {
         this.material.uniforms.height.value = e
      }
      get height() {
         return this.material.uniforms.height.value
      }
   }
   class NE extends Pr {
      constructor(e) {
         super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (n) {
            return new qj(n)
         }), this.register(function (n) {
            return new a$(n)
         }), this.register(function (n) {
            return new l$(n)
         }), this.register(function (n) {
            return new u$(n)
         }), this.register(function (n) {
            return new t$(n)
         }), this.register(function (n) {
            return new n$(n)
         }), this.register(function (n) {
            return new r$(n)
         }), this.register(function (n) {
            return new i$(n)
         }), this.register(function (n) {
            return new Zj(n)
         }), this.register(function (n) {
            return new s$(n)
         }), this.register(function (n) {
            return new e$(n)
         }), this.register(function (n) {
            return new o$(n)
         }), this.register(function (n) {
            return new Yj(n)
         }), this.register(function (n) {
            return new c$(n)
         }), this.register(function (n) {
            return new f$(n)
         })
      }
      load(e, n, r, i) {
         const s = this;
         let o;
         this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = js.extractUrlBase(e), this.manager.itemStart(e);
         const a = function (u) {
               i ? i(u) : console.error(u), s.manager.itemError(e), s.manager.itemEnd(e)
            },
            l = new Si(this.manager);
         l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (u) {
            try {
               s.parse(u, o, function (h) {
                  n(h), s.manager.itemEnd(e)
               }, a)
            } catch (h) {
               a(h)
            }
         }, r, a)
      }
      setDRACOLoader(e) {
         return this.dracoLoader = e, this
      }
      setDDSLoader() {
         throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
      }
      setKTX2Loader(e) {
         return this.ktx2Loader = e, this
      }
      setMeshoptDecoder(e) {
         return this.meshoptDecoder = e, this
      }
      register(e) {
         return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
      }
      unregister(e) {
         return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
      }
      parse(e, n, r, i) {
         let s;
         const o = {},
            a = {};
         if (typeof e == "string") s = JSON.parse(e);
         else if (e instanceof ArrayBuffer)
            if (js.decodeText(new Uint8Array(e.slice(0, 4))) === zO) {
               try {
                  o[Vt.KHR_BINARY_GLTF] = new h$(e)
               } catch (h) {
                  i && i(h);
                  return
               }
               s = JSON.parse(o[Vt.KHR_BINARY_GLTF].content)
            } else s = JSON.parse(js.decodeText(new Uint8Array(e)));
         else s = e;
         if (s.asset === void 0 || s.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
         }
         const l = new w$(s, {
            path: n || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
         });
         l.fileLoader.setRequestHeader(this.requestHeader);
         for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const h = this.pluginCallbacks[u](l);
            a[h.name] = h, o[h.name] = !0
         }
         if (s.extensionsUsed)
            for (let u = 0; u < s.extensionsUsed.length; ++u) {
               const h = s.extensionsUsed[u],
                  d = s.extensionsRequired || [];
               switch (h) {
                  case Vt.KHR_MATERIALS_UNLIT:
                     o[h] = new Qj;
                     break;
                  case Vt.KHR_DRACO_MESH_COMPRESSION:
                     o[h] = new d$(s, this.dracoLoader);
                     break;
                  case Vt.KHR_TEXTURE_TRANSFORM:
                     o[h] = new p$;
                     break;
                  case Vt.KHR_MESH_QUANTIZATION:
                     o[h] = new m$;
                     break;
                  default:
                     d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
               }
            }
         l.setExtensions(o), l.setPlugins(a), l.parse(r, i)
      }
      parseAsync(e, n) {
         const r = this;
         return new Promise(function (i, s) {
            r.parse(e, n, i, s)
         })
      }
   }

   function Kj() {
      let t = {};
      return {
         get: function (e) {
            return t[e]
         },
         add: function (e, n) {
            t[e] = n
         },
         remove: function (e) {
            delete t[e]
         },
         removeAll: function () {
            t = {}
         }
      }
   }
   const Vt = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_IOR: "KHR_materials_ior",
      KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
      KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
      KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_MATERIALS_VOLUME: "KHR_materials_volume",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_TEXTURE_AVIF: "EXT_texture_avif",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
   };
   class Yj {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
         }
      }
      _markDefs() {
         const e = this.parser,
            n = this.parser.json.nodes || [];
         for (let r = 0, i = n.length; r < i; r++) {
            const s = n[r];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
         }
      }
      _loadLight(e) {
         const n = this.parser,
            r = "light:" + e;
         let i = n.cache.get(r);
         if (i) return i;
         const s = n.json,
            l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
         let u;
         const h = new ke(16777215);
         l.color !== void 0 && h.fromArray(l.color);
         const d = l.range !== void 0 ? l.range : 0;
         switch (l.type) {
            case "directional":
               u = new wE(h), u.target.position.set(0, 0, -1), u.add(u.target);
               break;
            case "point":
               u = new EE(h), u.distance = d;
               break;
            case "spot":
               u = new ME(h), u.distance = d, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, u.angle = l.spot.outerConeAngle, u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, u.target.position.set(0, 0, -1), u.add(u.target);
               break;
            default:
               throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
         }
         return u.position.set(0, 0, 0), u.decay = 2, ua(u, l), l.intensity !== void 0 && (u.intensity = l.intensity), u.name = n.createUniqueName(l.name || "light_" + e), i = Promise.resolve(u), n.cache.add(r, i), i
      }
      getDependency(e, n) {
         if (e === "light") return this._loadLight(n)
      }
      createNodeAttachment(e) {
         const n = this,
            r = this.parser,
            s = r.json.nodes[e],
            a = (s.extensions && s.extensions[this.name] || {}).light;
         return a === void 0 ? null : this._loadLight(a).then(function (l) {
            return r._getNodeRef(n.cache, a, l)
         })
      }
   }
   class Qj {
      constructor() {
         this.name = Vt.KHR_MATERIALS_UNLIT
      }
      getMaterialType() {
         return mi
      }
      extendParams(e, n, r) {
         const i = [];
         e.color = new ke(1, 1, 1), e.opacity = 1;
         const s = n.pbrMetallicRoughness;
         if (s) {
            if (Array.isArray(s.baseColorFactor)) {
               const o = s.baseColorFactor;
               e.color.fromArray(o), e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(r.assignTexture(e, "map", s.baseColorTexture, 3001))
         }
         return Promise.all(i)
      }
   }
   class Zj {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_EMISSIVE_STRENGTH
      }
      extendMaterialParams(e, n) {
         const i = this.parser.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = i.extensions[this.name].emissiveStrength;
         return s !== void 0 && (n.emissiveIntensity = s), Promise.resolve()
      }
   }
   class qj {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_CLEARCOAT
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const r = this.parser,
            i = r.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = [],
            o = i.extensions[this.name];
         if (o.clearcoatFactor !== void 0 && (n.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(r.assignTexture(n, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (n.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(n, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(n, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            n.clearcoatNormalScale = new Se(a, a)
         }
         return Promise.all(s)
      }
   }
   class e$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_IRIDESCENCE
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const r = this.parser,
            i = r.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = [],
            o = i.extensions[this.name];
         return o.iridescenceFactor !== void 0 && (n.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(r.assignTexture(n, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (n.iridescenceIOR = o.iridescenceIor), n.iridescenceThicknessRange === void 0 && (n.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (n.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (n.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(n, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s)
      }
   }
   class t$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_SHEEN
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const r = this.parser,
            i = r.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = [];
         n.sheenColor = new ke(0, 0, 0), n.sheenRoughness = 0, n.sheen = 1;
         const o = i.extensions[this.name];
         return o.sheenColorFactor !== void 0 && n.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (n.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(r.assignTexture(n, "sheenColorMap", o.sheenColorTexture, 3001)), o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(n, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s)
      }
   }
   class n$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_TRANSMISSION
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const r = this.parser,
            i = r.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = [],
            o = i.extensions[this.name];
         return o.transmissionFactor !== void 0 && (n.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(r.assignTexture(n, "transmissionMap", o.transmissionTexture)), Promise.all(s)
      }
   }
   class r$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_VOLUME
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const r = this.parser,
            i = r.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = [],
            o = i.extensions[this.name];
         n.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(r.assignTexture(n, "thicknessMap", o.thicknessTexture)), n.attenuationDistance = o.attenuationDistance || 1 / 0;
         const a = o.attenuationColor || [1, 1, 1];
         return n.attenuationColor = new ke(a[0], a[1], a[2]), Promise.all(s)
      }
   }
   class i$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_IOR
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const i = this.parser.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = i.extensions[this.name];
         return n.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
      }
   }
   class s$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_SPECULAR
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const r = this.parser,
            i = r.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = [],
            o = i.extensions[this.name];
         n.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(r.assignTexture(n, "specularIntensityMap", o.specularTexture));
         const a = o.specularColorFactor || [1, 1, 1];
         return n.specularColor = new ke(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && s.push(r.assignTexture(n, "specularColorMap", o.specularColorTexture, 3001)), Promise.all(s)
      }
   }
   class o$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_MATERIALS_ANISOTROPY
      }
      getMaterialType(e) {
         const r = this.parser.json.materials[e];
         return !r.extensions || !r.extensions[this.name] ? null : Qs
      }
      extendMaterialParams(e, n) {
         const r = this.parser,
            i = r.json.materials[e];
         if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
         const s = [],
            o = i.extensions[this.name];
         return o.anisotropyStrength !== void 0 && (n.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (n.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(r.assignTexture(n, "anisotropyMap", o.anisotropyTexture)), Promise.all(s)
      }
   }
   class a$ {
      constructor(e) {
         this.parser = e, this.name = Vt.KHR_TEXTURE_BASISU
      }
      loadTexture(e) {
         const n = this.parser,
            r = n.json,
            i = r.textures[e];
         if (!i.extensions || !i.extensions[this.name]) return null;
         const s = i.extensions[this.name],
            o = n.options.ktx2Loader;
         if (!o) {
            if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
         }
         return n.loadTextureImage(e, s.source, o)
      }
   }
   class l$ {
      constructor(e) {
         this.parser = e, this.name = Vt.EXT_TEXTURE_WEBP, this.isSupported = null
      }
      loadTexture(e) {
         const n = this.name,
            r = this.parser,
            i = r.json,
            s = i.textures[e];
         if (!s.extensions || !s.extensions[n]) return null;
         const o = s.extensions[n],
            a = i.images[o.source];
         let l = r.textureLoader;
         if (a.uri) {
            const u = r.options.manager.getHandler(a.uri);
            u !== null && (l = u)
         }
         return this.detectSupport().then(function (u) {
            if (u) return r.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(n) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return r.loadTexture(e)
         })
      }
      detectSupport() {
         return this.isSupported || (this.isSupported = new Promise(function (e) {
            const n = new Image;
            n.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", n.onload = n.onerror = function () {
               e(n.height === 1)
            }
         })), this.isSupported
      }
   }
   class u$ {
      constructor(e) {
         this.parser = e, this.name = Vt.EXT_TEXTURE_AVIF, this.isSupported = null
      }
      loadTexture(e) {
         const n = this.name,
            r = this.parser,
            i = r.json,
            s = i.textures[e];
         if (!s.extensions || !s.extensions[n]) return null;
         const o = s.extensions[n],
            a = i.images[o.source];
         let l = r.textureLoader;
         if (a.uri) {
            const u = r.options.manager.getHandler(a.uri);
            u !== null && (l = u)
         }
         return this.detectSupport().then(function (u) {
            if (u) return r.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(n) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return r.loadTexture(e)
         })
      }
      detectSupport() {
         return this.isSupported || (this.isSupported = new Promise(function (e) {
            const n = new Image;
            n.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", n.onload = n.onerror = function () {
               e(n.height === 1)
            }
         })), this.isSupported
      }
   }
   class c$ {
      constructor(e) {
         this.name = Vt.EXT_MESHOPT_COMPRESSION, this.parser = e
      }
      loadBufferView(e) {
         const n = this.parser.json,
            r = n.bufferViews[e];
         if (r.extensions && r.extensions[this.name]) {
            const i = r.extensions[this.name],
               s = this.parser.getDependency("buffer", i.buffer),
               o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
               if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
               return null
            }
            return s.then(function (a) {
               const l = i.byteOffset || 0,
                  u = i.byteLength || 0,
                  h = i.count,
                  d = i.byteStride,
                  p = new Uint8Array(a, l, u);
               return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, d, p, i.mode, i.filter).then(function (m) {
                  return m.buffer
               }) : o.ready.then(function () {
                  const m = new ArrayBuffer(h * d);
                  return o.decodeGltfBuffer(new Uint8Array(m), h, d, p, i.mode, i.filter), m
               })
            })
         } else return null
      }
   }
   class f$ {
      constructor(e) {
         this.name = Vt.EXT_MESH_GPU_INSTANCING, this.parser = e
      }
      createNodeMesh(e) {
         const n = this.parser.json,
            r = n.nodes[e];
         if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0) return null;
         const i = n.meshes[r.mesh];
         for (const u of i.primitives)
            if (u.mode !== Hi.TRIANGLES && u.mode !== Hi.TRIANGLE_STRIP && u.mode !== Hi.TRIANGLE_FAN && u.mode !== void 0) return null;
         const o = r.extensions[this.name].attributes,
            a = [],
            l = {};
         for (const u in o) a.push(this.parser.getDependency("accessor", o[u]).then(h => (l[u] = h, l[u])));
         return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then(u => {
            const h = u.pop(),
               d = h.isGroup ? h.children : [h],
               p = u[0].count,
               m = [];
            for (const v of d) {
               const _ = new yt,
                  x = new U,
                  g = new tr,
                  S = new U(1, 1, 1),
                  A = new oE(v.geometry, v.material, p);
               for (let E = 0; E < p; E++) l.TRANSLATION && x.fromBufferAttribute(l.TRANSLATION, E), l.ROTATION && g.fromBufferAttribute(l.ROTATION, E), l.SCALE && S.fromBufferAttribute(l.SCALE, E), A.setMatrixAt(E, _.compose(x, g, S));
               for (const E in l) E !== "TRANSLATION" && E !== "ROTATION" && E !== "SCALE" && v.geometry.setAttribute(E, l[E]);
               Wt.prototype.copy.call(A, v), this.parser.assignFinalMaterial(A), m.push(A)
            }
            return h.isGroup ? (h.clear(), h.add(...m), h) : m[0]
         }))
      }
   }
   const zO = "glTF",
      Th = 12,
      b2 = {
         JSON: 1313821514,
         BIN: 5130562
      };
   class h$ {
      constructor(e) {
         this.name = Vt.KHR_BINARY_GLTF, this.content = null, this.body = null;
         const n = new DataView(e, 0, Th);
         if (this.header = {
               magic: js.decodeText(new Uint8Array(e.slice(0, 4))),
               version: n.getUint32(4, !0),
               length: n.getUint32(8, !0)
            }, this.header.magic !== zO) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
         if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
         const r = this.header.length - Th,
            i = new DataView(e, Th);
         let s = 0;
         for (; s < r;) {
            const o = i.getUint32(s, !0);
            s += 4;
            const a = i.getUint32(s, !0);
            if (s += 4, a === b2.JSON) {
               const l = new Uint8Array(e, Th + s, o);
               this.content = js.decodeText(l)
            } else if (a === b2.BIN) {
               const l = Th + s;
               this.body = e.slice(l, l + o)
            }
            s += o
         }
         if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
      }
   }
   class d$ {
      constructor(e, n) {
         if (!n) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
         this.name = Vt.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = n, this.dracoLoader.preload()
      }
      decodePrimitive(e, n) {
         const r = this.json,
            i = this.dracoLoader,
            s = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            u = {};
         for (const h in o) {
            const d = aS[h] || h.toLowerCase();
            a[d] = o[h]
         }
         for (const h in e.attributes) {
            const d = aS[h] || h.toLowerCase();
            if (o[h] !== void 0) {
               const p = r.accessors[e.attributes[h]],
                  m = ef[p.componentType];
               u[d] = m.name, l[d] = p.normalized === !0
            }
         }
         return n.getDependency("bufferView", s).then(function (h) {
            return new Promise(function (d) {
               i.decodeDracoFile(h, function (p) {
                  for (const m in p.attributes) {
                     const v = p.attributes[m],
                        _ = l[m];
                     _ !== void 0 && (v.normalized = _)
                  }
                  d(p)
               }, a, u)
            })
         })
      }
   }
   class p$ {
      constructor() {
         this.name = Vt.KHR_TEXTURE_TRANSFORM
      }
      extendTexture(e, n) {
         return (n.texCoord === void 0 || n.texCoord === e.channel) && n.offset === void 0 && n.rotation === void 0 && n.scale === void 0 || (e = e.clone(), n.texCoord !== void 0 && (e.channel = n.texCoord), n.offset !== void 0 && e.offset.fromArray(n.offset), n.rotation !== void 0 && (e.rotation = n.rotation), n.scale !== void 0 && e.repeat.fromArray(n.scale), e.needsUpdate = !0), e
      }
   }
   class m$ {
      constructor() {
         this.name = Vt.KHR_MESH_QUANTIZATION
      }
   }
   class VO extends Bf {
      constructor(e, n, r, i) {
         super(e, n, r, i)
      }
      copySampleValue_(e) {
         const n = this.resultBuffer,
            r = this.sampleValues,
            i = this.valueSize,
            s = e * i * 3 + i;
         for (let o = 0; o !== i; o++) n[o] = r[s + o];
         return n
      }
      interpolate_(e, n, r, i) {
         const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = a * 2,
            u = a * 3,
            h = i - n,
            d = (r - n) / h,
            p = d * d,
            m = p * d,
            v = e * u,
            _ = v - u,
            x = -2 * m + 3 * p,
            g = m - p,
            S = 1 - x,
            A = g - p + d;
         for (let E = 0; E !== a; E++) {
            const C = o[_ + E + a],
               R = o[_ + E + l] * h,
               B = o[v + E + a],
               D = o[v + E] * h;
            s[E] = S * C + A * R + x * B + g * D
         }
         return s
      }
   }
   const g$ = new tr;
   class v$ extends VO {
      interpolate_(e, n, r, i) {
         const s = super.interpolate_(e, n, r, i);
         return g$.fromArray(s).normalize().toArray(s), s
      }
   }
   const Hi = {
         FLOAT: 5126,
         FLOAT_MAT3: 35675,
         FLOAT_MAT4: 35676,
         FLOAT_VEC2: 35664,
         FLOAT_VEC3: 35665,
         FLOAT_VEC4: 35666,
         LINEAR: 9729,
         REPEAT: 10497,
         SAMPLER_2D: 35678,
         POINTS: 0,
         LINES: 1,
         LINE_LOOP: 2,
         LINE_STRIP: 3,
         TRIANGLES: 4,
         TRIANGLE_STRIP: 5,
         TRIANGLE_FAN: 6,
         UNSIGNED_BYTE: 5121,
         UNSIGNED_SHORT: 5123
      },
      ef = {
         5120: Int8Array,
         5121: Uint8Array,
         5122: Int16Array,
         5123: Uint16Array,
         5125: Uint32Array,
         5126: Float32Array
      },
      C2 = {
         9728: Fn,
         9729: ln,
         9984: Od,
         9985: Tv,
         9986: Yc,
         9987: Ys
      },
      T2 = {
         33071: hr,
         33648: ff,
         10497: Fa
      },
      j_ = {
         SCALAR: 1,
         VEC2: 2,
         VEC3: 3,
         VEC4: 4,
         MAT2: 4,
         MAT3: 9,
         MAT4: 16
      },
      aS = {
         POSITION: "position",
         NORMAL: "normal",
         TANGENT: "tangent",
         ...nu.replace(/\D+/g, "") >= 152 ? {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3"
         } : {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2"
         },
         COLOR_0: "color",
         WEIGHTS_0: "skinWeight",
         JOINTS_0: "skinIndex"
      },
      ia = {
         scale: "scale",
         translation: "position",
         rotation: "quaternion",
         weights: "morphTargetInfluences"
      },
      y$ = {
         CUBICSPLINE: void 0,
         LINEAR: Yl,
         STEP: hf
      },
      $_ = {
         OPAQUE: "OPAQUE",
         MASK: "MASK",
         BLEND: "BLEND"
      };

   function x$(t) {
      return t.DefaultMaterial === void 0 && (t.DefaultMaterial = new mp({
         color: 16777215,
         emissive: 0,
         metalness: 1,
         roughness: 1,
         transparent: !1,
         depthTest: !0,
         side: Js
      })), t.DefaultMaterial
   }

   function gl(t, e, n) {
      for (const r in n.extensions) t[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = n.extensions[r])
   }

   function ua(t, e) {
      e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
   }

   function _$(t, e, n) {
      let r = !1,
         i = !1,
         s = !1;
      for (let u = 0, h = e.length; u < h; u++) {
         const d = e[u];
         if (d.POSITION !== void 0 && (r = !0), d.NORMAL !== void 0 && (i = !0), d.COLOR_0 !== void 0 && (s = !0), r && i && s) break
      }
      if (!r && !i && !s) return Promise.resolve(t);
      const o = [],
         a = [],
         l = [];
      for (let u = 0, h = e.length; u < h; u++) {
         const d = e[u];
         if (r) {
            const p = d.POSITION !== void 0 ? n.getDependency("accessor", d.POSITION) : t.attributes.position;
            o.push(p)
         }
         if (i) {
            const p = d.NORMAL !== void 0 ? n.getDependency("accessor", d.NORMAL) : t.attributes.normal;
            a.push(p)
         }
         if (s) {
            const p = d.COLOR_0 !== void 0 ? n.getDependency("accessor", d.COLOR_0) : t.attributes.color;
            l.push(p)
         }
      }
      return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (u) {
         const h = u[0],
            d = u[1],
            p = u[2];
         return r && (t.morphAttributes.position = h), i && (t.morphAttributes.normal = d), s && (t.morphAttributes.color = p), t.morphTargetsRelative = !0, t
      })
   }

   function A$(t, e) {
      if (t.updateMorphTargets(), e.weights !== void 0)
         for (let n = 0, r = e.weights.length; n < r; n++) t.morphTargetInfluences[n] = e.weights[n];
      if (e.extras && Array.isArray(e.extras.targetNames)) {
         const n = e.extras.targetNames;
         if (t.morphTargetInfluences.length === n.length) {
            t.morphTargetDictionary = {};
            for (let r = 0, i = n.length; r < i; r++) t.morphTargetDictionary[n[r]] = r
         } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
      }
   }

   function S$(t) {
      let e;
      const n = t.extensions && t.extensions[Vt.KHR_DRACO_MESH_COMPRESSION];
      if (n ? e = "draco:" + n.bufferView + ":" + n.indices + ":" + X_(n.attributes) : e = t.indices + ":" + X_(t.attributes) + ":" + t.mode, t.targets !== void 0)
         for (let r = 0, i = t.targets.length; r < i; r++) e += ":" + X_(t.targets[r]);
      return e
   }

   function X_(t) {
      let e = "";
      const n = Object.keys(t).sort();
      for (let r = 0, i = n.length; r < i; r++) e += n[r] + ":" + t[n[r]] + ";";
      return e
   }

   function lS(t) {
      switch (t) {
         case Int8Array:
            return 1 / 127;
         case Uint8Array:
            return 1 / 255;
         case Int16Array:
            return 1 / 32767;
         case Uint16Array:
            return 1 / 65535;
         default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
      }
   }

   function M$(t) {
      return t.search(/\.jpe?g($|\?)/i) > 0 || t.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || t.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
   }
   const E$ = new yt;
   class w$ {
      constructor(e = {}, n = {}) {
         this.json = e, this.extensions = {}, this.plugins = {}, this.options = n, this.cache = new Kj, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
         }, this.cameraCache = {
            refs: {},
            uses: {}
         }, this.lightCache = {
            refs: {},
            uses: {}
         }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
         let r = !1,
            i = !1,
            s = -1;
         typeof navigator < "u" && typeof navigator.userAgent < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || i && s < 98 ? this.textureLoader = new gp(this.options.manager) : this.textureLoader = new aO(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Si(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
      }
      setExtensions(e) {
         this.extensions = e
      }
      setPlugins(e) {
         this.plugins = e
      }
      parse(e, n) {
         const r = this,
            i = this.json,
            s = this.extensions;
         this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (o) {
            return o._markDefs && o._markDefs()
         }), Promise.all(this._invokeAll(function (o) {
            return o.beforeRoot && o.beforeRoot()
         })).then(function () {
            return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")])
         }).then(function (o) {
            const a = {
               scene: o[0][i.scene || 0],
               scenes: o[0],
               animations: o[1],
               cameras: o[2],
               asset: i.asset,
               parser: r,
               userData: {}
            };
            gl(s, a, i), ua(a, i), Promise.all(r._invokeAll(function (l) {
               return l.afterRoot && l.afterRoot(a)
            })).then(function () {
               e(a)
            })
         }).catch(n)
      }
      _markDefs() {
         const e = this.json.nodes || [],
            n = this.json.skins || [],
            r = this.json.meshes || [];
         for (let i = 0, s = n.length; i < s; i++) {
            const o = n[i].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0
         }
         for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
         }
      }
      _addNodeRef(e, n) {
         n !== void 0 && (e.refs[n] === void 0 && (e.refs[n] = e.uses[n] = 0), e.refs[n]++)
      }
      _getNodeRef(e, n, r) {
         if (e.refs[n] <= 1) return r;
         const i = r.clone(),
            s = (o, a) => {
               const l = this.associations.get(o);
               l != null && this.associations.set(a, l);
               for (const [u, h] of o.children.entries()) s(h, a.children[u])
            };
         return s(r, i), i.name += "_instance_" + e.uses[n]++, i
      }
      _invokeOne(e) {
         const n = Object.values(this.plugins);
         n.push(this);
         for (let r = 0; r < n.length; r++) {
            const i = e(n[r]);
            if (i) return i
         }
         return null
      }
      _invokeAll(e) {
         const n = Object.values(this.plugins);
         n.unshift(this);
         const r = [];
         for (let i = 0; i < n.length; i++) {
            const s = e(n[i]);
            s && r.push(s)
         }
         return r
      }
      getDependency(e, n) {
         const r = e + ":" + n;
         let i = this.cache.get(r);
         if (!i) {
            switch (e) {
               case "scene":
                  i = this.loadScene(n);
                  break;
               case "node":
                  i = this._invokeOne(function (s) {
                     return s.loadNode && s.loadNode(n)
                  });
                  break;
               case "mesh":
                  i = this._invokeOne(function (s) {
                     return s.loadMesh && s.loadMesh(n)
                  });
                  break;
               case "accessor":
                  i = this.loadAccessor(n);
                  break;
               case "bufferView":
                  i = this._invokeOne(function (s) {
                     return s.loadBufferView && s.loadBufferView(n)
                  });
                  break;
               case "buffer":
                  i = this.loadBuffer(n);
                  break;
               case "material":
                  i = this._invokeOne(function (s) {
                     return s.loadMaterial && s.loadMaterial(n)
                  });
                  break;
               case "texture":
                  i = this._invokeOne(function (s) {
                     return s.loadTexture && s.loadTexture(n)
                  });
                  break;
               case "skin":
                  i = this.loadSkin(n);
                  break;
               case "animation":
                  i = this._invokeOne(function (s) {
                     return s.loadAnimation && s.loadAnimation(n)
                  });
                  break;
               case "camera":
                  i = this.loadCamera(n);
                  break;
               default:
                  if (i = this._invokeOne(function (s) {
                        return s != this && s.getDependency && s.getDependency(e, n)
                     }), !i) throw new Error("Unknown type: " + e);
                  break
            }
            this.cache.add(r, i)
         }
         return i
      }
      getDependencies(e) {
         let n = this.cache.get(e);
         if (!n) {
            const r = this,
               i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            n = Promise.all(i.map(function (s, o) {
               return r.getDependency(e, o)
            })), this.cache.add(e, n)
         }
         return n
      }
      loadBuffer(e) {
         const n = this.json.buffers[e],
            r = this.fileLoader;
         if (n.type && n.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + n.type + " buffer type is not supported.");
         if (n.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Vt.KHR_BINARY_GLTF].body);
         const i = this.options;
         return new Promise(function (s, o) {
            r.load(js.resolveURL(n.uri, i.path), s, void 0, function () {
               o(new Error('THREE.GLTFLoader: Failed to load buffer "' + n.uri + '".'))
            })
         })
      }
      loadBufferView(e) {
         const n = this.json.bufferViews[e];
         return this.getDependency("buffer", n.buffer).then(function (r) {
            const i = n.byteLength || 0,
               s = n.byteOffset || 0;
            return r.slice(s, s + i)
         })
      }
      loadAccessor(e) {
         const n = this,
            r = this.json,
            i = this.json.accessors[e];
         if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = j_[i.type],
               a = ef[i.componentType],
               l = i.normalized === !0,
               u = new a(i.count * o);
            return Promise.resolve(new Zt(u, o, l))
         }
         const s = [];
         return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function (o) {
            const a = o[0],
               l = j_[i.type],
               u = ef[i.componentType],
               h = u.BYTES_PER_ELEMENT,
               d = h * l,
               p = i.byteOffset || 0,
               m = i.bufferView !== void 0 ? r.bufferViews[i.bufferView].byteStride : void 0,
               v = i.normalized === !0;
            let _, x;
            if (m && m !== d) {
               const g = Math.floor(p / m),
                  S = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + g + ":" + i.count;
               let A = n.cache.get(S);
               A || (_ = new u(a, g * m, i.count * m / h), A = new up(_, m / h), n.cache.add(S, A)), x = new Oa(A, l, p % m / h, v)
            } else a === null ? _ = new u(i.count * l) : _ = new u(a, p, i.count * l), x = new Zt(_, l, v);
            if (i.sparse !== void 0) {
               const g = j_.SCALAR,
                  S = ef[i.sparse.indices.componentType],
                  A = i.sparse.indices.byteOffset || 0,
                  E = i.sparse.values.byteOffset || 0,
                  C = new S(o[1], A, i.sparse.count * g),
                  R = new u(o[2], E, i.sparse.count * l);
               a !== null && (x = new Zt(x.array.slice(), x.itemSize, x.normalized));
               for (let B = 0, D = C.length; B < D; B++) {
                  const T = C[B];
                  if (x.setX(T, R[B * l]), l >= 2 && x.setY(T, R[B * l + 1]), l >= 3 && x.setZ(T, R[B * l + 2]), l >= 4 && x.setW(T, R[B * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
               }
            }
            return x
         })
      }
      loadTexture(e) {
         const n = this.json,
            r = this.options,
            s = n.textures[e].source,
            o = n.images[s];
         let a = this.textureLoader;
         if (o.uri) {
            const l = r.manager.getHandler(o.uri);
            l !== null && (a = l)
         }
         return this.loadTextureImage(e, s, a)
      }
      loadTextureImage(e, n, r) {
         const i = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[n],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
         if (this.textureCache[l]) return this.textureCache[l];
         const u = this.loadImageSource(n, r).then(function (h) {
            h.flipY = !1, h.name = o.name || a.name || "", h.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (h.name = a.uri);
            const p = (s.samplers || {})[o.sampler] || {};
            return h.magFilter = C2[p.magFilter] || ln, h.minFilter = C2[p.minFilter] || Ys, h.wrapS = T2[p.wrapS] || Fa, h.wrapT = T2[p.wrapT] || Fa, i.associations.set(h, {
               textures: e
            }), h
         }).catch(function () {
            return null
         });
         return this.textureCache[l] = u, u
      }
      loadImageSource(e, n) {
         const r = this,
            i = this.json,
            s = this.options;
         if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(d => d.clone());
         const o = i.images[e],
            a = self.URL || self.webkitURL;
         let l = o.uri || "",
            u = !1;
         if (o.bufferView !== void 0) l = r.getDependency("bufferView", o.bufferView).then(function (d) {
            u = !0;
            const p = new Blob([d], {
               type: o.mimeType
            });
            return l = a.createObjectURL(p), l
         });
         else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
         const h = Promise.resolve(l).then(function (d) {
            return new Promise(function (p, m) {
               let v = p;
               n.isImageBitmapLoader === !0 && (v = function (_) {
                  const x = new yn(_);
                  x.needsUpdate = !0, p(x)
               }), n.load(js.resolveURL(d, s.path), v, void 0, m)
            })
         }).then(function (d) {
            return u === !0 && a.revokeObjectURL(l), d.userData.mimeType = o.mimeType || M$(o.uri), d
         }).catch(function (d) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), d
         });
         return this.sourceCache[e] = h, h
      }
      assignTexture(e, n, r, i) {
         const s = this;
         return this.getDependency("texture", r.index).then(function (o) {
            if (!o) return null;
            if (r.texCoord !== void 0 && r.texCoord > 0 && (o = o.clone(), o.channel = r.texCoord), s.extensions[Vt.KHR_TEXTURE_TRANSFORM]) {
               const a = r.extensions !== void 0 ? r.extensions[Vt.KHR_TEXTURE_TRANSFORM] : void 0;
               if (a) {
                  const l = s.associations.get(o);
                  o = s.extensions[Vt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l)
               }
            }
            return i !== void 0 && ("colorSpace" in o ? o.colorSpace = i === 3001 ? "srgb" : "srgb-linear" : o.encoding = i), e[n] = o, o
         })
      }
      assignFinalMaterial(e) {
         const n = e.geometry;
         let r = e.material;
         const i = n.attributes.tangent === void 0,
            s = n.attributes.color !== void 0,
            o = n.attributes.normal === void 0;
         if (e.isPoints) {
            const a = "PointsMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new Nv, Jn.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, l.sizeAttenuation = !1, this.cache.add(a, l)), r = l
         } else if (e.isLine) {
            const a = "LineBasicMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new Rr, Jn.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, this.cache.add(a, l)), r = l
         }
         if (i || s || o) {
            let a = "ClonedMaterial:" + r.uuid + ":";
            i && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = r.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(r))), r = l
         }
         e.material = r
      }
      getMaterialType() {
         return mp
      }
      loadMaterial(e) {
         const n = this,
            r = this.json,
            i = this.extensions,
            s = r.materials[e];
         let o;
         const a = {},
            l = s.extensions || {},
            u = [];
         if (l[Vt.KHR_MATERIALS_UNLIT]) {
            const d = i[Vt.KHR_MATERIALS_UNLIT];
            o = d.getMaterialType(), u.push(d.extendParams(a, s, n))
         } else {
            const d = s.pbrMetallicRoughness || {};
            if (a.color = new ke(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) {
               const p = d.baseColorFactor;
               a.color.fromArray(p), a.opacity = p[3]
            }
            d.baseColorTexture !== void 0 && u.push(n.assignTexture(a, "map", d.baseColorTexture, 3001)), a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (u.push(n.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), u.push(n.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), o = this._invokeOne(function (p) {
               return p.getMaterialType && p.getMaterialType(e)
            }), u.push(Promise.all(this._invokeAll(function (p) {
               return p.extendMaterialParams && p.extendMaterialParams(e, a)
            })))
         }
         s.doubleSided === !0 && (a.side = Wi);
         const h = s.alphaMode || $_.OPAQUE;
         if (h === $_.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, h === $_.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== mi && (u.push(n.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new Se(1, 1), s.normalTexture.scale !== void 0)) {
            const d = s.normalTexture.scale;
            a.normalScale.set(d, d)
         }
         return s.occlusionTexture !== void 0 && o !== mi && (u.push(n.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== mi && (a.emissive = new ke().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && o !== mi && u.push(n.assignTexture(a, "emissiveMap", s.emissiveTexture, 3001)), Promise.all(u).then(function () {
            const d = new o(a);
            return s.name && (d.name = s.name), ua(d, s), n.associations.set(d, {
               materials: e
            }), s.extensions && gl(i, d, s), d
         })
      }
      createUniqueName(e) {
         const n = jt.sanitizeNodeName(e || "");
         return n in this.nodeNamesUsed ? n + "_" + ++this.nodeNamesUsed[n] : (this.nodeNamesUsed[n] = 0, n)
      }
      loadGeometries(e) {
         const n = this,
            r = this.extensions,
            i = this.primitiveCache;

         function s(a) {
            return r[Vt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, n).then(function (l) {
               return R2(l, a, n)
            })
         }
         const o = [];
         for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a],
               h = S$(u),
               d = i[h];
            if (d) o.push(d.promise);
            else {
               let p;
               u.extensions && u.extensions[Vt.KHR_DRACO_MESH_COMPRESSION] ? p = s(u) : p = R2(new Tt, u, n), i[h] = {
                  primitive: u,
                  promise: p
               }, o.push(p)
            }
         }
         return Promise.all(o)
      }
      loadMesh(e) {
         const n = this,
            r = this.json,
            i = this.extensions,
            s = r.meshes[e],
            o = s.primitives,
            a = [];
         for (let l = 0, u = o.length; l < u; l++) {
            const h = o[l].material === void 0 ? x$(this.cache) : this.getDependency("material", o[l].material);
            a.push(h)
         }
         return a.push(n.loadGeometries(o)), Promise.all(a).then(function (l) {
            const u = l.slice(0, l.length - 1),
               h = l[l.length - 1],
               d = [];
            for (let m = 0, v = h.length; m < v; m++) {
               const _ = h[m],
                  x = o[m];
               let g;
               const S = u[m];
               if (x.mode === Hi.TRIANGLES || x.mode === Hi.TRIANGLE_STRIP || x.mode === Hi.TRIANGLE_FAN || x.mode === void 0) g = s.isSkinnedMesh === !0 ? new sE(_, S) : new Xn(_, S), g.isSkinnedMesh === !0 && g.normalizeSkinWeights(), x.mode === Hi.TRIANGLE_STRIP ? g.geometry = w2(g.geometry, WM) : x.mode === Hi.TRIANGLE_FAN && (g.geometry = w2(g.geometry, k0));
               else if (x.mode === Hi.LINES) g = new xs(_, S);
               else if (x.mode === Hi.LINE_STRIP) g = new Fo(_, S);
               else if (x.mode === Hi.LINE_LOOP) g = new aE(_, S);
               else if (x.mode === Hi.POINTS) g = new lE(_, S);
               else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode);
               Object.keys(g.geometry.morphAttributes).length > 0 && A$(g, s), g.name = n.createUniqueName(s.name || "mesh_" + e), ua(g, s), x.extensions && gl(i, g, x), n.assignFinalMaterial(g), d.push(g)
            }
            for (let m = 0, v = d.length; m < v; m++) n.associations.set(d[m], {
               meshes: e,
               primitives: m
            });
            if (d.length === 1) return s.extensions && gl(i, d[0], s), d[0];
            const p = new Mo;
            s.extensions && gl(i, p, s), n.associations.set(p, {
               meshes: e
            });
            for (let m = 0, v = d.length; m < v; m++) p.add(d[m]);
            return p
         })
      }
      loadCamera(e) {
         let n;
         const r = this.json.cameras[e],
            i = r[r.type];
         if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
         }
         return r.type === "perspective" ? n = new Zn(Qc.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : r.type === "orthographic" && (n = new Tf(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), r.name && (n.name = this.createUniqueName(r.name)), ua(n, r), Promise.resolve(n)
      }
      loadSkin(e) {
         const n = this.json.skins[e],
            r = [];
         for (let i = 0, s = n.joints.length; i < s; i++) r.push(this._loadNodeShallow(n.joints[i]));
         return n.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", n.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function (i) {
            const s = i.pop(),
               o = i,
               a = [],
               l = [];
            for (let u = 0, h = o.length; u < h; u++) {
               const d = o[u];
               if (d) {
                  a.push(d);
                  const p = new yt;
                  s !== null && p.fromArray(s.array, u * 16), l.push(p)
               } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', n.joints[u])
            }
            return new cp(a, l)
         })
      }
      loadAnimation(e) {
         const r = this.json.animations[e],
            i = r.name ? r.name : "animation_" + e,
            s = [],
            o = [],
            a = [],
            l = [],
            u = [];
         for (let h = 0, d = r.channels.length; h < d; h++) {
            const p = r.channels[h],
               m = r.samplers[p.sampler],
               v = p.target,
               _ = v.node,
               x = r.parameters !== void 0 ? r.parameters[m.input] : m.input,
               g = r.parameters !== void 0 ? r.parameters[m.output] : m.output;
            v.node !== void 0 && (s.push(this.getDependency("node", _)), o.push(this.getDependency("accessor", x)), a.push(this.getDependency("accessor", g)), l.push(m), u.push(v))
         }
         return Promise.all([Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(u)]).then(function (h) {
            const d = h[0],
               p = h[1],
               m = h[2],
               v = h[3],
               _ = h[4],
               x = [];
            for (let g = 0, S = d.length; g < S; g++) {
               const A = d[g],
                  E = p[g],
                  C = m[g],
                  R = v[g],
                  B = _[g];
               if (A === void 0) continue;
               A.updateMatrix();
               let D;
               switch (ia[B.path]) {
                  case ia.weights:
                     D = gf;
                     break;
                  case ia.rotation:
                     D = Na;
                     break;
                  case ia.position:
                  case ia.scale:
                  default:
                     D = vf;
                     break
               }
               const T = A.name ? A.name : A.uuid,
                  I = R.interpolation !== void 0 ? y$[R.interpolation] : Yl,
                  N = [];
               ia[B.path] === ia.weights ? A.traverse(function (K) {
                  K.morphTargetInfluences && N.push(K.name ? K.name : K.uuid)
               }) : N.push(T);
               let q = C.array;
               if (C.normalized) {
                  const K = lS(q.constructor),
                     Z = new Float32Array(q.length);
                  for (let te = 0, se = q.length; te < se; te++) Z[te] = q[te] * K;
                  q = Z
               }
               for (let K = 0, Z = N.length; K < Z; K++) {
                  const te = new D(N[K] + "." + ia[B.path], E.array, q, I);
                  R.interpolation === "CUBICSPLINE" && (te.createInterpolant = function (oe) {
                     const G = this instanceof Na ? v$ : VO;
                     return new G(this.times, this.values, this.getValueSize() / 3, oe)
                  }, te.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), x.push(te)
               }
            }
            return new yf(i, void 0, x)
         })
      }
      createNodeMesh(e) {
         const n = this.json,
            r = this,
            i = n.nodes[e];
         return i.mesh === void 0 ? null : r.getDependency("mesh", i.mesh).then(function (s) {
            const o = r._getNodeRef(r.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function (a) {
               if (a.isMesh)
                  for (let l = 0, u = i.weights.length; l < u; l++) a.morphTargetInfluences[l] = i.weights[l]
            }), o
         })
      }
      loadNode(e) {
         const n = this.json,
            r = this,
            i = n.nodes[e],
            s = r._loadNodeShallow(e),
            o = [],
            a = i.children || [];
         for (let u = 0, h = a.length; u < h; u++) o.push(r.getDependency("node", a[u]));
         const l = i.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", i.skin);
         return Promise.all([s, Promise.all(o), l]).then(function (u) {
            const h = u[0],
               d = u[1],
               p = u[2];
            p !== null && h.traverse(function (m) {
               m.isSkinnedMesh && m.bind(p, E$)
            });
            for (let m = 0, v = d.length; m < v; m++) h.add(d[m]);
            return h
         })
      }
      _loadNodeShallow(e) {
         const n = this.json,
            r = this.extensions,
            i = this;
         if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
         const s = n.nodes[e],
            o = s.name ? i.createUniqueName(s.name) : "",
            a = [],
            l = i._invokeOne(function (u) {
               return u.createNodeMesh && u.createNodeMesh(e)
            });
         return l && a.push(l), s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function (u) {
            return i._getNodeRef(i.cameraCache, s.camera, u)
         })), i._invokeAll(function (u) {
            return u.createNodeAttachment && u.createNodeAttachment(e)
         }).forEach(function (u) {
            a.push(u)
         }), this.nodeCache[e] = Promise.all(a).then(function (u) {
            let h;
            if (s.isBone === !0 ? h = new Ov : u.length > 1 ? h = new Mo : u.length === 1 ? h = u[0] : h = new Wt, h !== u[0])
               for (let d = 0, p = u.length; d < p; d++) h.add(u[d]);
            if (s.name && (h.userData.name = s.name, h.name = o), ua(h, s), s.extensions && gl(r, h, s), s.matrix !== void 0) {
               const d = new yt;
               d.fromArray(s.matrix), h.applyMatrix4(d)
            } else s.translation !== void 0 && h.position.fromArray(s.translation), s.rotation !== void 0 && h.quaternion.fromArray(s.rotation), s.scale !== void 0 && h.scale.fromArray(s.scale);
            return i.associations.has(h) || i.associations.set(h, {}), i.associations.get(h).nodes = e, h
         }), this.nodeCache[e]
      }
      loadScene(e) {
         const n = this.extensions,
            r = this.json.scenes[e],
            i = this,
            s = new Mo;
         r.name && (s.name = i.createUniqueName(r.name)), ua(s, r), r.extensions && gl(n, s, r);
         const o = r.nodes || [],
            a = [];
         for (let l = 0, u = o.length; l < u; l++) a.push(i.getDependency("node", o[l]));
         return Promise.all(a).then(function (l) {
            for (let h = 0, d = l.length; h < d; h++) s.add(l[h]);
            const u = h => {
               const d = new Map;
               for (const [p, m] of i.associations)(p instanceof Jn || p instanceof yn) && d.set(p, m);
               return h.traverse(p => {
                  const m = i.associations.get(p);
                  m != null && d.set(p, m)
               }), d
            };
            return i.associations = u(s), s
         })
      }
   }

   function b$(t, e, n) {
      const r = e.attributes,
         i = new qi;
      if (r.POSITION !== void 0) {
         const a = n.json.accessors[r.POSITION],
            l = a.min,
            u = a.max;
         if (l !== void 0 && u !== void 0) {
            if (i.set(new U(l[0], l[1], l[2]), new U(u[0], u[1], u[2])), a.normalized) {
               const h = lS(ef[a.componentType]);
               i.min.multiplyScalar(h), i.max.multiplyScalar(h)
            }
         } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
         }
      } else return;
      const s = e.targets;
      if (s !== void 0) {
         const a = new U,
            l = new U;
         for (let u = 0, h = s.length; u < h; u++) {
            const d = s[u];
            if (d.POSITION !== void 0) {
               const p = n.json.accessors[d.POSITION],
                  m = p.min,
                  v = p.max;
               if (m !== void 0 && v !== void 0) {
                  if (l.setX(Math.max(Math.abs(m[0]), Math.abs(v[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(v[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(v[2]))), p.normalized) {
                     const _ = lS(ef[p.componentType]);
                     l.multiplyScalar(_)
                  }
                  a.max(l)
               } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
         }
         i.expandByVector(a)
      }
      t.boundingBox = i;
      const o = new Ci;
      i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, t.boundingSphere = o
   }

   function R2(t, e, n) {
      const r = e.attributes,
         i = [];

      function s(o, a) {
         return n.getDependency("accessor", o).then(function (l) {
            t.setAttribute(a, l)
         })
      }
      for (const o in r) {
         const a = aS[o] || o.toLowerCase();
         a in t.attributes || i.push(s(r[o], a))
      }
      if (e.indices !== void 0 && !t.index) {
         const o = n.getDependency("accessor", e.indices).then(function (a) {
            t.setIndex(a)
         });
         i.push(o)
      }
      return ua(t, e), b$(t, e, n), Promise.all(i).then(function () {
         return e.targets !== void 0 ? _$(t, e.targets, n) : t
      })
   }
   class C$ extends Tt {
      constructor(e, n, r, i) {
         super();
         const s = [],
            o = [],
            a = [],
            l = new U,
            u = new yt;
         u.makeRotationFromEuler(r), u.setPosition(n);
         const h = new yt;
         h.copy(u).invert(), d(), this.setAttribute("position", new nt(s, 3)), this.setAttribute("normal", new nt(o, 3)), this.setAttribute("uv", new nt(a, 2));

         function d() {
            let _, x = [];
            const g = new U,
               S = new U;
            if (e.geometry.isGeometry === !0) {
               console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");
               return
            }
            const A = e.geometry,
               E = A.attributes.position,
               C = A.attributes.normal;
            if (A.index !== null) {
               const R = A.index;
               for (_ = 0; _ < R.count; _++) g.fromBufferAttribute(E, R.getX(_)), S.fromBufferAttribute(C, R.getX(_)), p(x, g, S)
            } else
               for (_ = 0; _ < E.count; _++) g.fromBufferAttribute(E, _), S.fromBufferAttribute(C, _), p(x, g, S);
            for (x = m(x, l.set(1, 0, 0)), x = m(x, l.set(-1, 0, 0)), x = m(x, l.set(0, 1, 0)), x = m(x, l.set(0, -1, 0)), x = m(x, l.set(0, 0, 1)), x = m(x, l.set(0, 0, -1)), _ = 0; _ < x.length; _++) {
               const R = x[_];
               a.push(.5 + R.position.x / i.x, .5 + R.position.y / i.y), R.position.applyMatrix4(u), s.push(R.position.x, R.position.y, R.position.z), o.push(R.normal.x, R.normal.y, R.normal.z)
            }
         }

         function p(_, x, g) {
            x.applyMatrix4(e.matrixWorld), x.applyMatrix4(h), g.transformDirection(e.matrixWorld), _.push(new P2(x.clone(), g.clone()))
         }

         function m(_, x) {
            const g = [],
               S = .5 * Math.abs(i.dot(x));
            for (let A = 0; A < _.length; A += 3) {
               let E, C, R, B = 0,
                  D, T, I, N;
               const q = _[A + 0].position.dot(x) - S,
                  K = _[A + 1].position.dot(x) - S,
                  Z = _[A + 2].position.dot(x) - S;
               switch (E = q > 0, C = K > 0, R = Z > 0, B = (E ? 1 : 0) + (C ? 1 : 0) + (R ? 1 : 0), B) {
                  case 0: {
                     g.push(_[A]), g.push(_[A + 1]), g.push(_[A + 2]);
                     break
                  }
                  case 1: {
                     if (E && (D = _[A + 1], T = _[A + 2], I = v(_[A], D, x, S), N = v(_[A], T, x, S)), C) {
                        D = _[A], T = _[A + 2], I = v(_[A + 1], D, x, S), N = v(_[A + 1], T, x, S), g.push(I), g.push(T.clone()), g.push(D.clone()), g.push(T.clone()), g.push(I.clone()), g.push(N);
                        break
                     }
                     R && (D = _[A], T = _[A + 1], I = v(_[A + 2], D, x, S), N = v(_[A + 2], T, x, S)), g.push(D.clone()), g.push(T.clone()), g.push(I), g.push(N), g.push(I.clone()), g.push(T.clone());
                     break
                  }
                  case 2: {
                     E || (D = _[A].clone(), T = v(D, _[A + 1], x, S), I = v(D, _[A + 2], x, S), g.push(D), g.push(T), g.push(I)), C || (D = _[A + 1].clone(), T = v(D, _[A + 2], x, S), I = v(D, _[A], x, S), g.push(D), g.push(T), g.push(I)), R || (D = _[A + 2].clone(), T = v(D, _[A], x, S), I = v(D, _[A + 1], x, S), g.push(D), g.push(T), g.push(I));
                     break
                  }
               }
            }
            return g
         }

         function v(_, x, g, S) {
            const A = _.position.dot(g) - S,
               E = x.position.dot(g) - S,
               C = A / (A - E);
            return new P2(new U(_.position.x + C * (x.position.x - _.position.x), _.position.y + C * (x.position.y - _.position.y), _.position.z + C * (x.position.z - _.position.z)), new U(_.normal.x + C * (x.normal.x - _.normal.x), _.normal.y + C * (x.normal.y - _.normal.y), _.normal.z + C * (x.normal.z - _.normal.z)))
         }
      }
   }
   class P2 {
      constructor(e, n) {
         this.position = e, this.normal = n
      }
      clone() {
         return new this.constructor(this.position.clone(), this.normal.clone())
      }
   }
   var T$ = Object.prototype;

   function R$(t) {
      var e = t && t.constructor,
         n = typeof e == "function" && e.prototype || T$;
      return t === n
   }
   var UE = R$;

   function P$(t, e) {
      return function (n) {
         return t(e(n))
      }
   }
   var WO = P$,
      B$ = WO,
      I$ = B$(Object.keys, Object),
      L$ = I$,
      D$ = UE,
      F$ = L$,
      O$ = Object.prototype,
      N$ = O$.hasOwnProperty;

   function U$(t) {
      if (!D$(t)) return F$(t);
      var e = [];
      for (var n in Object(t)) N$.call(t, n) && n != "constructor" && e.push(n);
      return e
   }
   var k$ = U$,
      H$ = typeof Em == "object" && Em && Em.Object === Object && Em,
      jO = H$,
      G$ = jO,
      z$ = typeof self == "object" && self && self.Object === Object && self,
      V$ = G$ || z$ || Function("return this")(),
      Zs = V$,
      W$ = Zs,
      j$ = W$.Symbol,
      xp = j$,
      B2 = xp,
      $O = Object.prototype,
      $$ = $O.hasOwnProperty,
      X$ = $O.toString,
      Rh = B2 ? B2.toStringTag : void 0;

   function J$(t) {
      var e = $$.call(t, Rh),
         n = t[Rh];
      try {
         t[Rh] = void 0;
         var r = !0
      } catch {}
      var i = X$.call(t);
      return r && (e ? t[Rh] = n : delete t[Rh]), i
   }
   var K$ = J$,
      Y$ = Object.prototype,
      Q$ = Y$.toString;

   function Z$(t) {
      return Q$.call(t)
   }
   var q$ = Z$,
      I2 = xp,
      eX = K$,
      tX = q$,
      nX = "[object Null]",
      rX = "[object Undefined]",
      L2 = I2 ? I2.toStringTag : void 0;

   function iX(t) {
      return t == null ? t === void 0 ? rX : nX : L2 && L2 in Object(t) ? eX(t) : tX(t)
   }
   var au = iX;

   function sX(t) {
      var e = typeof t;
      return t != null && (e == "object" || e == "function")
   }
   var If = sX,
      oX = au,
      aX = If,
      lX = "[object AsyncFunction]",
      uX = "[object Function]",
      cX = "[object GeneratorFunction]",
      fX = "[object Proxy]";

   function hX(t) {
      if (!aX(t)) return !1;
      var e = oX(t);
      return e == uX || e == cX || e == lX || e == fX
   }
   var XO = hX,
      dX = Zs,
      pX = dX["__core-js_shared__"],
      mX = pX,
      J_ = mX,
      D2 = function () {
         var t = /[^.]+$/.exec(J_ && J_.keys && J_.keys.IE_PROTO || "");
         return t ? "Symbol(src)_1." + t : ""
      }();

   function gX(t) {
      return !!D2 && D2 in t
   }
   var vX = gX,
      yX = Function.prototype,
      xX = yX.toString;

   function _X(t) {
      if (t != null) {
         try {
            return xX.call(t)
         } catch {}
         try {
            return t + ""
         } catch {}
      }
      return ""
   }
   var JO = _X,
      AX = XO,
      SX = vX,
      MX = If,
      EX = JO,
      wX = /[\\^$.*+?()[\]{}|]/g,
      bX = /^\[object .+?Constructor\]$/,
      CX = Function.prototype,
      TX = Object.prototype,
      RX = CX.toString,
      PX = TX.hasOwnProperty,
      BX = RegExp("^" + RX.call(PX).replace(wX, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

   function IX(t) {
      if (!MX(t) || SX(t)) return !1;
      var e = AX(t) ? BX : bX;
      return e.test(EX(t))
   }
   var LX = IX;

   function DX(t, e) {
      return t == null ? void 0 : t[e]
   }
   var FX = DX,
      OX = LX,
      NX = FX;

   function UX(t, e) {
      var n = NX(t, e);
      return OX(n) ? n : void 0
   }
   var lu = UX,
      kX = lu,
      HX = Zs,
      GX = kX(HX, "DataView"),
      zX = GX,
      VX = lu,
      WX = Zs,
      jX = VX(WX, "Map"),
      kE = jX,
      $X = lu,
      XX = Zs,
      JX = $X(XX, "Promise"),
      KX = JX,
      YX = lu,
      QX = Zs,
      ZX = YX(QX, "Set"),
      qX = ZX,
      eJ = lu,
      tJ = Zs,
      nJ = eJ(tJ, "WeakMap"),
      rJ = nJ,
      uS = zX,
      cS = kE,
      fS = KX,
      hS = qX,
      dS = rJ,
      KO = au,
      Lf = JO,
      F2 = "[object Map]",
      iJ = "[object Object]",
      O2 = "[object Promise]",
      N2 = "[object Set]",
      U2 = "[object WeakMap]",
      k2 = "[object DataView]",
      sJ = Lf(uS),
      oJ = Lf(cS),
      aJ = Lf(fS),
      lJ = Lf(hS),
      uJ = Lf(dS),
      Sl = KO;
   (uS && Sl(new uS(new ArrayBuffer(1))) != k2 || cS && Sl(new cS) != F2 || fS && Sl(fS.resolve()) != O2 || hS && Sl(new hS) != N2 || dS && Sl(new dS) != U2) && (Sl = function (t) {
      var e = KO(t),
         n = e == iJ ? t.constructor : void 0,
         r = n ? Lf(n) : "";
      if (r) switch (r) {
         case sJ:
            return k2;
         case oJ:
            return F2;
         case aJ:
            return O2;
         case lJ:
            return N2;
         case uJ:
            return U2
      }
      return e
   });
   var ny = Sl;

   function cJ(t) {
      return t != null && typeof t == "object"
   }
   var Ho = cJ,
      fJ = au,
      hJ = Ho,
      dJ = "[object Arguments]";

   function pJ(t) {
      return hJ(t) && fJ(t) == dJ
   }
   var mJ = pJ,
      H2 = mJ,
      gJ = Ho,
      YO = Object.prototype,
      vJ = YO.hasOwnProperty,
      yJ = YO.propertyIsEnumerable,
      xJ = H2(function () {
         return arguments
      }()) ? H2 : function (t) {
         return gJ(t) && vJ.call(t, "callee") && !yJ.call(t, "callee")
      },
      QO = xJ,
      _J = Array.isArray,
      Ss = _J,
      AJ = 9007199254740991;

   function SJ(t) {
      return typeof t == "number" && t > -1 && t % 1 == 0 && t <= AJ
   }
   var HE = SJ,
      MJ = XO,
      EJ = HE;

   function wJ(t) {
      return t != null && EJ(t.length) && !MJ(t)
   }
   var ry = wJ,
      z0 = {
         exports: {}
      };

   function bJ() {
      return !1
   }
   var CJ = bJ;
   z0.exports;
   (function (t, e) {
      var n = Zs,
         r = CJ,
         i = e && !e.nodeType && e,
         s = i && !0 && t && !t.nodeType && t,
         o = s && s.exports === i,
         a = o ? n.Buffer : void 0,
         l = a ? a.isBuffer : void 0,
         u = l || r;
      t.exports = u
   })(z0, z0.exports);
   var GE = z0.exports,
      TJ = au,
      RJ = HE,
      PJ = Ho,
      BJ = "[object Arguments]",
      IJ = "[object Array]",
      LJ = "[object Boolean]",
      DJ = "[object Date]",
      FJ = "[object Error]",
      OJ = "[object Function]",
      NJ = "[object Map]",
      UJ = "[object Number]",
      kJ = "[object Object]",
      HJ = "[object RegExp]",
      GJ = "[object Set]",
      zJ = "[object String]",
      VJ = "[object WeakMap]",
      WJ = "[object ArrayBuffer]",
      jJ = "[object DataView]",
      $J = "[object Float32Array]",
      XJ = "[object Float64Array]",
      JJ = "[object Int8Array]",
      KJ = "[object Int16Array]",
      YJ = "[object Int32Array]",
      QJ = "[object Uint8Array]",
      ZJ = "[object Uint8ClampedArray]",
      qJ = "[object Uint16Array]",
      eK = "[object Uint32Array]",
      dn = {};
   dn[$J] = dn[XJ] = dn[JJ] = dn[KJ] = dn[YJ] = dn[QJ] = dn[ZJ] = dn[qJ] = dn[eK] = !0;
   dn[BJ] = dn[IJ] = dn[WJ] = dn[LJ] = dn[jJ] = dn[DJ] = dn[FJ] = dn[OJ] = dn[NJ] = dn[UJ] = dn[kJ] = dn[HJ] = dn[GJ] = dn[zJ] = dn[VJ] = !1;

   function tK(t) {
      return PJ(t) && RJ(t.length) && !!dn[TJ(t)]
   }
   var nK = tK;

   function rK(t) {
      return function (e) {
         return t(e)
      }
   }
   var zE = rK,
      V0 = {
         exports: {}
      };
   V0.exports;
   (function (t, e) {
      var n = jO,
         r = e && !e.nodeType && e,
         i = r && !0 && t && !t.nodeType && t,
         s = i && i.exports === r,
         o = s && n.process,
         a = function () {
            try {
               var l = i && i.require && i.require("util").types;
               return l || o && o.binding && o.binding("util")
            } catch {}
         }();
      t.exports = a
   })(V0, V0.exports);
   var VE = V0.exports,
      iK = nK,
      sK = zE,
      G2 = VE,
      z2 = G2 && G2.isTypedArray,
      oK = z2 ? sK(z2) : iK,
      ZO = oK;

   function aK(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r;) i[n] = e(t[n], n, t);
      return i
   }
   var qO = aK;

   function lK() {
      this.__data__ = [], this.size = 0
   }
   var uK = lK;

   function cK(t, e) {
      return t === e || t !== t && e !== e
   }
   var WE = cK,
      fK = WE;

   function hK(t, e) {
      for (var n = t.length; n--;)
         if (fK(t[n][0], e)) return n;
      return -1
   }
   var iy = hK,
      dK = iy,
      pK = Array.prototype,
      mK = pK.splice;

   function gK(t) {
      var e = this.__data__,
         n = dK(e, t);
      if (n < 0) return !1;
      var r = e.length - 1;
      return n == r ? e.pop() : mK.call(e, n, 1), --this.size, !0
   }
   var vK = gK,
      yK = iy;

   function xK(t) {
      var e = this.__data__,
         n = yK(e, t);
      return n < 0 ? void 0 : e[n][1]
   }
   var _K = xK,
      AK = iy;

   function SK(t) {
      return AK(this.__data__, t) > -1
   }
   var MK = SK,
      EK = iy;

   function wK(t, e) {
      var n = this.__data__,
         r = EK(n, t);
      return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
   }
   var bK = wK,
      CK = uK,
      TK = vK,
      RK = _K,
      PK = MK,
      BK = bK;

   function Df(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.clear(); ++e < n;) {
         var r = t[e];
         this.set(r[0], r[1])
      }
   }
   Df.prototype.clear = CK;
   Df.prototype.delete = TK;
   Df.prototype.get = RK;
   Df.prototype.has = PK;
   Df.prototype.set = BK;
   var sy = Df,
      IK = sy;

   function LK() {
      this.__data__ = new IK, this.size = 0
   }
   var DK = LK;

   function FK(t) {
      var e = this.__data__,
         n = e.delete(t);
      return this.size = e.size, n
   }
   var OK = FK;

   function NK(t) {
      return this.__data__.get(t)
   }
   var UK = NK;

   function kK(t) {
      return this.__data__.has(t)
   }
   var HK = kK,
      GK = lu,
      zK = GK(Object, "create"),
      oy = zK,
      V2 = oy;

   function VK() {
      this.__data__ = V2 ? V2(null) : {}, this.size = 0
   }
   var WK = VK;

   function jK(t) {
      var e = this.has(t) && delete this.__data__[t];
      return this.size -= e ? 1 : 0, e
   }
   var $K = jK,
      XK = oy,
      JK = "__lodash_hash_undefined__",
      KK = Object.prototype,
      YK = KK.hasOwnProperty;

   function QK(t) {
      var e = this.__data__;
      if (XK) {
         var n = e[t];
         return n === JK ? void 0 : n
      }
      return YK.call(e, t) ? e[t] : void 0
   }
   var ZK = QK,
      qK = oy,
      eY = Object.prototype,
      tY = eY.hasOwnProperty;

   function nY(t) {
      var e = this.__data__;
      return qK ? e[t] !== void 0 : tY.call(e, t)
   }
   var rY = nY,
      iY = oy,
      sY = "__lodash_hash_undefined__";

   function oY(t, e) {
      var n = this.__data__;
      return this.size += this.has(t) ? 0 : 1, n[t] = iY && e === void 0 ? sY : e, this
   }
   var aY = oY,
      lY = WK,
      uY = $K,
      cY = ZK,
      fY = rY,
      hY = aY;

   function Ff(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.clear(); ++e < n;) {
         var r = t[e];
         this.set(r[0], r[1])
      }
   }
   Ff.prototype.clear = lY;
   Ff.prototype.delete = uY;
   Ff.prototype.get = cY;
   Ff.prototype.has = fY;
   Ff.prototype.set = hY;
   var dY = Ff,
      W2 = dY,
      pY = sy,
      mY = kE;

   function gY() {
      this.size = 0, this.__data__ = {
         hash: new W2,
         map: new(mY || pY),
         string: new W2
      }
   }
   var vY = gY;

   function yY(t) {
      var e = typeof t;
      return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
   }
   var xY = yY,
      _Y = xY;

   function AY(t, e) {
      var n = t.__data__;
      return _Y(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
   }
   var ay = AY,
      SY = ay;

   function MY(t) {
      var e = SY(this, t).delete(t);
      return this.size -= e ? 1 : 0, e
   }
   var EY = MY,
      wY = ay;

   function bY(t) {
      return wY(this, t).get(t)
   }
   var CY = bY,
      TY = ay;

   function RY(t) {
      return TY(this, t).has(t)
   }
   var PY = RY,
      BY = ay;

   function IY(t, e) {
      var n = BY(this, t),
         r = n.size;
      return n.set(t, e), this.size += n.size == r ? 0 : 1, this
   }
   var LY = IY,
      DY = vY,
      FY = EY,
      OY = CY,
      NY = PY,
      UY = LY;

   function Of(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.clear(); ++e < n;) {
         var r = t[e];
         this.set(r[0], r[1])
      }
   }
   Of.prototype.clear = DY;
   Of.prototype.delete = FY;
   Of.prototype.get = OY;
   Of.prototype.has = NY;
   Of.prototype.set = UY;
   var jE = Of,
      kY = sy,
      HY = kE,
      GY = jE,
      zY = 200;

   function VY(t, e) {
      var n = this.__data__;
      if (n instanceof kY) {
         var r = n.__data__;
         if (!HY || r.length < zY - 1) return r.push([t, e]), this.size = ++n.size, this;
         n = this.__data__ = new GY(r)
      }
      return n.set(t, e), this.size = n.size, this
   }
   var WY = VY,
      jY = sy,
      $Y = DK,
      XY = OK,
      JY = UK,
      KY = HK,
      YY = WY;

   function Nf(t) {
      var e = this.__data__ = new jY(t);
      this.size = e.size
   }
   Nf.prototype.clear = $Y;
   Nf.prototype.delete = XY;
   Nf.prototype.get = JY;
   Nf.prototype.has = KY;
   Nf.prototype.set = YY;
   var $E = Nf,
      QY = "__lodash_hash_undefined__";

   function ZY(t) {
      return this.__data__.set(t, QY), this
   }
   var qY = ZY;

   function eQ(t) {
      return this.__data__.has(t)
   }
   var tQ = eQ,
      nQ = jE,
      rQ = qY,
      iQ = tQ;

   function W0(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.__data__ = new nQ; ++e < n;) this.add(t[e])
   }
   W0.prototype.add = W0.prototype.push = rQ;
   W0.prototype.has = iQ;
   var sQ = W0;

   function oQ(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length; ++n < r;)
         if (e(t[n], n, t)) return !0;
      return !1
   }
   var aQ = oQ;

   function lQ(t, e) {
      return t.has(e)
   }
   var uQ = lQ,
      cQ = sQ,
      fQ = aQ,
      hQ = uQ,
      dQ = 1,
      pQ = 2;

   function mQ(t, e, n, r, i, s) {
      var o = n & dQ,
         a = t.length,
         l = e.length;
      if (a != l && !(o && l > a)) return !1;
      var u = s.get(t),
         h = s.get(e);
      if (u && h) return u == e && h == t;
      var d = -1,
         p = !0,
         m = n & pQ ? new cQ : void 0;
      for (s.set(t, e), s.set(e, t); ++d < a;) {
         var v = t[d],
            _ = e[d];
         if (r) var x = o ? r(_, v, d, e, t, s) : r(v, _, d, t, e, s);
         if (x !== void 0) {
            if (x) continue;
            p = !1;
            break
         }
         if (m) {
            if (!fQ(e, function (g, S) {
                  if (!hQ(m, S) && (v === g || i(v, g, n, r, s))) return m.push(S)
               })) {
               p = !1;
               break
            }
         } else if (!(v === _ || i(v, _, n, r, s))) {
            p = !1;
            break
         }
      }
      return s.delete(t), s.delete(e), p
   }
   var eN = mQ,
      gQ = Zs,
      vQ = gQ.Uint8Array,
      tN = vQ;

   function yQ(t) {
      var e = -1,
         n = Array(t.size);
      return t.forEach(function (r, i) {
         n[++e] = [i, r]
      }), n
   }
   var xQ = yQ;

   function _Q(t) {
      var e = -1,
         n = Array(t.size);
      return t.forEach(function (r) {
         n[++e] = r
      }), n
   }
   var AQ = _Q,
      j2 = xp,
      $2 = tN,
      SQ = WE,
      MQ = eN,
      EQ = xQ,
      wQ = AQ,
      bQ = 1,
      CQ = 2,
      TQ = "[object Boolean]",
      RQ = "[object Date]",
      PQ = "[object Error]",
      BQ = "[object Map]",
      IQ = "[object Number]",
      LQ = "[object RegExp]",
      DQ = "[object Set]",
      FQ = "[object String]",
      OQ = "[object Symbol]",
      NQ = "[object ArrayBuffer]",
      UQ = "[object DataView]",
      X2 = j2 ? j2.prototype : void 0,
      K_ = X2 ? X2.valueOf : void 0;

   function kQ(t, e, n, r, i, s, o) {
      switch (n) {
         case UQ:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
            t = t.buffer, e = e.buffer;
         case NQ:
            return !(t.byteLength != e.byteLength || !s(new $2(t), new $2(e)));
         case TQ:
         case RQ:
         case IQ:
            return SQ(+t, +e);
         case PQ:
            return t.name == e.name && t.message == e.message;
         case LQ:
         case FQ:
            return t == e + "";
         case BQ:
            var a = EQ;
         case DQ:
            var l = r & bQ;
            if (a || (a = wQ), t.size != e.size && !l) return !1;
            var u = o.get(t);
            if (u) return u == e;
            r |= CQ, o.set(t, e);
            var h = MQ(a(t), a(e), r, i, s, o);
            return o.delete(t), h;
         case OQ:
            if (K_) return K_.call(t) == K_.call(e)
      }
      return !1
   }
   var HQ = kQ;

   function GQ(t, e) {
      for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
      return t
   }
   var nN = GQ,
      zQ = nN,
      VQ = Ss;

   function WQ(t, e, n) {
      var r = e(t);
      return VQ(t) ? r : zQ(r, n(t))
   }
   var rN = WQ;

   function jQ(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r;) {
         var o = t[n];
         e(o, n, t) && (s[i++] = o)
      }
      return s
   }
   var $Q = jQ;

   function XQ() {
      return []
   }
   var iN = XQ,
      JQ = $Q,
      KQ = iN,
      YQ = Object.prototype,
      QQ = YQ.propertyIsEnumerable,
      J2 = Object.getOwnPropertySymbols,
      ZQ = J2 ? function (t) {
         return t == null ? [] : (t = Object(t), JQ(J2(t), function (e) {
            return QQ.call(t, e)
         }))
      } : KQ,
      XE = ZQ;

   function qQ(t, e) {
      for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
      return r
   }
   var eZ = qQ,
      tZ = 9007199254740991,
      nZ = /^(?:0|[1-9]\d*)$/;

   function rZ(t, e) {
      var n = typeof t;
      return e = e ?? tZ, !!e && (n == "number" || n != "symbol" && nZ.test(t)) && t > -1 && t % 1 == 0 && t < e
   }
   var sN = rZ,
      iZ = eZ,
      sZ = QO,
      oZ = Ss,
      aZ = GE,
      lZ = sN,
      uZ = ZO,
      cZ = Object.prototype,
      fZ = cZ.hasOwnProperty;

   function hZ(t, e) {
      var n = oZ(t),
         r = !n && sZ(t),
         i = !n && !r && aZ(t),
         s = !n && !r && !i && uZ(t),
         o = n || r || i || s,
         a = o ? iZ(t.length, String) : [],
         l = a.length;
      for (var u in t)(e || fZ.call(t, u)) && !(o && (u == "length" || i && (u == "offset" || u == "parent") || s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || lZ(u, l))) && a.push(u);
      return a
   }
   var oN = hZ,
      dZ = oN,
      pZ = k$,
      mZ = ry;

   function gZ(t) {
      return mZ(t) ? dZ(t) : pZ(t)
   }
   var _p = gZ,
      vZ = rN,
      yZ = XE,
      xZ = _p;

   function _Z(t) {
      return vZ(t, xZ, yZ)
   }
   var aN = _Z,
      K2 = aN,
      AZ = 1,
      SZ = Object.prototype,
      MZ = SZ.hasOwnProperty;

   function EZ(t, e, n, r, i, s) {
      var o = n & AZ,
         a = K2(t),
         l = a.length,
         u = K2(e),
         h = u.length;
      if (l != h && !o) return !1;
      for (var d = l; d--;) {
         var p = a[d];
         if (!(o ? p in e : MZ.call(e, p))) return !1
      }
      var m = s.get(t),
         v = s.get(e);
      if (m && v) return m == e && v == t;
      var _ = !0;
      s.set(t, e), s.set(e, t);
      for (var x = o; ++d < l;) {
         p = a[d];
         var g = t[p],
            S = e[p];
         if (r) var A = o ? r(S, g, p, e, t, s) : r(g, S, p, t, e, s);
         if (!(A === void 0 ? g === S || i(g, S, n, r, s) : A)) {
            _ = !1;
            break
         }
         x || (x = p == "constructor")
      }
      if (_ && !x) {
         var E = t.constructor,
            C = e.constructor;
         E != C && "constructor" in t && "constructor" in e && !(typeof E == "function" && E instanceof E && typeof C == "function" && C instanceof C) && (_ = !1)
      }
      return s.delete(t), s.delete(e), _
   }
   var wZ = EZ,
      Y_ = $E,
      bZ = eN,
      CZ = HQ,
      TZ = wZ,
      Y2 = ny,
      Q2 = Ss,
      Z2 = GE,
      RZ = ZO,
      PZ = 1,
      q2 = "[object Arguments]",
      eP = "[object Array]",
      Ig = "[object Object]",
      BZ = Object.prototype,
      tP = BZ.hasOwnProperty;

   function IZ(t, e, n, r, i, s) {
      var o = Q2(t),
         a = Q2(e),
         l = o ? eP : Y2(t),
         u = a ? eP : Y2(e);
      l = l == q2 ? Ig : l, u = u == q2 ? Ig : u;
      var h = l == Ig,
         d = u == Ig,
         p = l == u;
      if (p && Z2(t)) {
         if (!Z2(e)) return !1;
         o = !0, h = !1
      }
      if (p && !h) return s || (s = new Y_), o || RZ(t) ? bZ(t, e, n, r, i, s) : CZ(t, e, l, n, r, i, s);
      if (!(n & PZ)) {
         var m = h && tP.call(t, "__wrapped__"),
            v = d && tP.call(e, "__wrapped__");
         if (m || v) {
            var _ = m ? t.value() : t,
               x = v ? e.value() : e;
            return s || (s = new Y_), i(_, x, n, r, s)
         }
      }
      return p ? (s || (s = new Y_), TZ(t, e, n, r, i, s)) : !1
   }
   var LZ = IZ,
      DZ = LZ,
      nP = Ho;

   function lN(t, e, n, r, i) {
      return t === e ? !0 : t == null || e == null || !nP(t) && !nP(e) ? t !== t && e !== e : DZ(t, e, n, r, lN, i)
   }
   var uN = lN,
      FZ = $E,
      OZ = uN,
      NZ = 1,
      UZ = 2;

   function kZ(t, e, n, r) {
      var i = n.length,
         s = i,
         o = !r;
      if (t == null) return !s;
      for (t = Object(t); i--;) {
         var a = n[i];
         if (o && a[2] ? a[1] !== t[a[0]] : !(a[0] in t)) return !1
      }
      for (; ++i < s;) {
         a = n[i];
         var l = a[0],
            u = t[l],
            h = a[1];
         if (o && a[2]) {
            if (u === void 0 && !(l in t)) return !1
         } else {
            var d = new FZ;
            if (r) var p = r(u, h, l, t, e, d);
            if (!(p === void 0 ? OZ(h, u, NZ | UZ, r, d) : p)) return !1
         }
      }
      return !0
   }
   var HZ = kZ,
      GZ = If;

   function zZ(t) {
      return t === t && !GZ(t)
   }
   var cN = zZ,
      VZ = cN,
      WZ = _p;

   function jZ(t) {
      for (var e = WZ(t), n = e.length; n--;) {
         var r = e[n],
            i = t[r];
         e[n] = [r, i, VZ(i)]
      }
      return e
   }
   var $Z = jZ;

   function XZ(t, e) {
      return function (n) {
         return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n))
      }
   }
   var fN = XZ,
      JZ = HZ,
      KZ = $Z,
      YZ = fN;

   function QZ(t) {
      var e = KZ(t);
      return e.length == 1 && e[0][2] ? YZ(e[0][0], e[0][1]) : function (n) {
         return n === t || JZ(n, t, e)
      }
   }
   var ZZ = QZ,
      qZ = au,
      eq = Ho,
      tq = "[object Symbol]";

   function nq(t) {
      return typeof t == "symbol" || eq(t) && qZ(t) == tq
   }
   var JE = nq,
      rq = Ss,
      iq = JE,
      sq = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      oq = /^\w*$/;

   function aq(t, e) {
      if (rq(t)) return !1;
      var n = typeof t;
      return n == "number" || n == "symbol" || n == "boolean" || t == null || iq(t) ? !0 : oq.test(t) || !sq.test(t) || e != null && t in Object(e)
   }
   var KE = aq,
      hN = jE,
      lq = "Expected a function";

   function YE(t, e) {
      if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(lq);
      var n = function () {
         var r = arguments,
            i = e ? e.apply(this, r) : r[0],
            s = n.cache;
         if (s.has(i)) return s.get(i);
         var o = t.apply(this, r);
         return n.cache = s.set(i, o) || s, o
      };
      return n.cache = new(YE.Cache || hN), n
   }
   YE.Cache = hN;
   var uq = YE,
      cq = uq,
      fq = 500;

   function hq(t) {
      var e = cq(t, function (r) {
            return n.size === fq && n.clear(), r
         }),
         n = e.cache;
      return e
   }
   var dq = hq,
      pq = dq,
      mq = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      gq = /\\(\\)?/g,
      vq = pq(function (t) {
         var e = [];
         return t.charCodeAt(0) === 46 && e.push(""), t.replace(mq, function (n, r, i, s) {
            e.push(i ? s.replace(gq, "$1") : r || n)
         }), e
      }),
      yq = vq,
      rP = xp,
      xq = qO,
      _q = Ss,
      Aq = JE,
      Sq = 1 / 0,
      iP = rP ? rP.prototype : void 0,
      sP = iP ? iP.toString : void 0;

   function dN(t) {
      if (typeof t == "string") return t;
      if (_q(t)) return xq(t, dN) + "";
      if (Aq(t)) return sP ? sP.call(t) : "";
      var e = t + "";
      return e == "0" && 1 / t == -Sq ? "-0" : e
   }
   var Mq = dN,
      Eq = Mq;

   function wq(t) {
      return t == null ? "" : Eq(t)
   }
   var bq = wq,
      Cq = Ss,
      Tq = KE,
      Rq = yq,
      Pq = bq;

   function Bq(t, e) {
      return Cq(t) ? t : Tq(t, e) ? [t] : Rq(Pq(t))
   }
   var pN = Bq,
      Iq = JE,
      Lq = 1 / 0;

   function Dq(t) {
      if (typeof t == "string" || Iq(t)) return t;
      var e = t + "";
      return e == "0" && 1 / t == -Lq ? "-0" : e
   }
   var ly = Dq,
      Fq = pN,
      Oq = ly;

   function Nq(t, e) {
      e = Fq(e, t);
      for (var n = 0, r = e.length; t != null && n < r;) t = t[Oq(e[n++])];
      return n && n == r ? t : void 0
   }
   var mN = Nq,
      Uq = mN;

   function kq(t, e, n) {
      var r = t == null ? void 0 : Uq(t, e);
      return r === void 0 ? n : r
   }
   var Hq = kq;

   function Gq(t, e) {
      return t != null && e in Object(t)
   }
   var zq = Gq,
      Vq = pN,
      Wq = QO,
      jq = Ss,
      $q = sN,
      Xq = HE,
      Jq = ly;

   function Kq(t, e, n) {
      e = Vq(e, t);
      for (var r = -1, i = e.length, s = !1; ++r < i;) {
         var o = Jq(e[r]);
         if (!(s = t != null && n(t, o))) break;
         t = t[o]
      }
      return s || ++r != i ? s : (i = t == null ? 0 : t.length, !!i && Xq(i) && $q(o, i) && (jq(t) || Wq(t)))
   }
   var Yq = Kq,
      Qq = zq,
      Zq = Yq;

   function qq(t, e) {
      return t != null && Zq(t, e, Qq)
   }
   var eee = qq,
      tee = uN,
      nee = Hq,
      ree = eee,
      iee = KE,
      see = cN,
      oee = fN,
      aee = ly,
      lee = 1,
      uee = 2;

   function cee(t, e) {
      return iee(t) && see(e) ? oee(aee(t), e) : function (n) {
         var r = nee(n, t);
         return r === void 0 && r === e ? ree(n, t) : tee(e, r, lee | uee)
      }
   }
   var fee = cee;

   function hee(t) {
      return t
   }
   var gN = hee;

   function dee(t) {
      return function (e) {
         return e == null ? void 0 : e[t]
      }
   }
   var pee = dee,
      mee = mN;

   function gee(t) {
      return function (e) {
         return mee(e, t)
      }
   }
   var vee = gee,
      yee = pee,
      xee = vee,
      _ee = KE,
      Aee = ly;

   function See(t) {
      return _ee(t) ? yee(Aee(t)) : xee(t)
   }
   var Mee = See,
      Eee = ZZ,
      wee = fee,
      bee = gN,
      Cee = Ss,
      Tee = Mee;

   function Ree(t) {
      return typeof t == "function" ? t : t == null ? bee : typeof t == "object" ? Cee(t) ? wee(t[0], t[1]) : Eee(t) : Tee(t)
   }
   var Pee = Ree;

   function Bee(t) {
      return function (e, n, r) {
         for (var i = -1, s = Object(e), o = r(e), a = o.length; a--;) {
            var l = o[t ? a : ++i];
            if (n(s[l], l, s) === !1) break
         }
         return e
      }
   }
   var Iee = Bee,
      Lee = Iee,
      Dee = Lee(),
      Fee = Dee,
      Oee = Fee,
      Nee = _p;

   function Uee(t, e) {
      return t && Oee(t, e, Nee)
   }
   var vN = Uee,
      kee = ry;

   function Hee(t, e) {
      return function (n, r) {
         if (n == null) return n;
         if (!kee(n)) return t(n, r);
         for (var i = n.length, s = e ? i : -1, o = Object(n);
            (e ? s-- : ++s < i) && r(o[s], s, o) !== !1;);
         return n
      }
   }
   var Gee = Hee,
      zee = vN,
      Vee = Gee,
      Wee = Vee(zee),
      jee = Wee,
      $ee = jee,
      Xee = ry;

   function Jee(t, e) {
      var n = -1,
         r = Xee(t) ? Array(t.length) : [];
      return $ee(t, function (i, s, o) {
         r[++n] = e(i, s, o)
      }), r
   }
   var Kee = Jee,
      Yee = qO,
      Qee = Pee,
      Zee = Kee,
      qee = Ss;

   function ete(t, e) {
      var n = qee(t) ? Yee : Zee;
      return n(t, Qee(e))
   }
   var tte = ete;

   function nte(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1;);
      return t
   }
   var rte = nte,
      ite = gN;

   function ste(t) {
      return typeof t == "function" ? t : ite
   }
   var ote = ste,
      ate = lu,
      lte = function () {
         try {
            var t = ate(Object, "defineProperty");
            return t({}, "", {}), t
         } catch {}
      }(),
      ute = lte,
      oP = ute;

   function cte(t, e, n) {
      e == "__proto__" && oP ? oP(t, e, {
         configurable: !0,
         enumerable: !0,
         value: n,
         writable: !0
      }) : t[e] = n
   }
   var yN = cte,
      fte = yN,
      hte = WE,
      dte = Object.prototype,
      pte = dte.hasOwnProperty;

   function mte(t, e, n) {
      var r = t[e];
      (!(pte.call(t, e) && hte(r, n)) || n === void 0 && !(e in t)) && fte(t, e, n)
   }
   var xN = mte,
      gte = xN,
      vte = yN;

   function yte(t, e, n, r) {
      var i = !n;
      n || (n = {});
      for (var s = -1, o = e.length; ++s < o;) {
         var a = e[s],
            l = r ? r(n[a], t[a], a, n, t) : void 0;
         l === void 0 && (l = t[a]), i ? vte(n, a, l) : gte(n, a, l)
      }
      return n
   }
   var uy = yte,
      xte = uy,
      _te = _p;

   function Ate(t, e) {
      return t && xte(e, _te(e), t)
   }
   var Ste = Ate;

   function Mte(t) {
      var e = [];
      if (t != null)
         for (var n in Object(t)) e.push(n);
      return e
   }
   var Ete = Mte,
      wte = If,
      bte = UE,
      Cte = Ete,
      Tte = Object.prototype,
      Rte = Tte.hasOwnProperty;

   function Pte(t) {
      if (!wte(t)) return Cte(t);
      var e = bte(t),
         n = [];
      for (var r in t) r == "constructor" && (e || !Rte.call(t, r)) || n.push(r);
      return n
   }
   var Bte = Pte,
      Ite = oN,
      Lte = Bte,
      Dte = ry;

   function Fte(t) {
      return Dte(t) ? Ite(t, !0) : Lte(t)
   }
   var QE = Fte,
      Ote = uy,
      Nte = QE;

   function Ute(t, e) {
      return t && Ote(e, Nte(e), t)
   }
   var kte = Ute,
      j0 = {
         exports: {}
      };
   j0.exports;
   (function (t, e) {
      var n = Zs,
         r = e && !e.nodeType && e,
         i = r && !0 && t && !t.nodeType && t,
         s = i && i.exports === r,
         o = s ? n.Buffer : void 0,
         a = o ? o.allocUnsafe : void 0;

      function l(u, h) {
         if (h) return u.slice();
         var d = u.length,
            p = a ? a(d) : new u.constructor(d);
         return u.copy(p), p
      }
      t.exports = l
   })(j0, j0.exports);
   var Hte = j0.exports;

   function Gte(t, e) {
      var n = -1,
         r = t.length;
      for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
      return e
   }
   var zte = Gte,
      Vte = uy,
      Wte = XE;

   function jte(t, e) {
      return Vte(t, Wte(t), e)
   }
   var $te = jte,
      Xte = WO,
      Jte = Xte(Object.getPrototypeOf, Object),
      ZE = Jte,
      Kte = nN,
      Yte = ZE,
      Qte = XE,
      Zte = iN,
      qte = Object.getOwnPropertySymbols,
      ene = qte ? function (t) {
         for (var e = []; t;) Kte(e, Qte(t)), t = Yte(t);
         return e
      } : Zte,
      _N = ene,
      tne = uy,
      nne = _N;

   function rne(t, e) {
      return tne(t, nne(t), e)
   }
   var ine = rne,
      sne = rN,
      one = _N,
      ane = QE;

   function lne(t) {
      return sne(t, ane, one)
   }
   var une = lne,
      cne = Object.prototype,
      fne = cne.hasOwnProperty;

   function hne(t) {
      var e = t.length,
         n = new t.constructor(e);
      return e && typeof t[0] == "string" && fne.call(t, "index") && (n.index = t.index, n.input = t.input), n
   }
   var dne = hne,
      aP = tN;

   function pne(t) {
      var e = new t.constructor(t.byteLength);
      return new aP(e).set(new aP(t)), e
   }
   var qE = pne,
      mne = qE;

   function gne(t, e) {
      var n = e ? mne(t.buffer) : t.buffer;
      return new t.constructor(n, t.byteOffset, t.byteLength)
   }
   var vne = gne,
      yne = /\w*$/;

   function xne(t) {
      var e = new t.constructor(t.source, yne.exec(t));
      return e.lastIndex = t.lastIndex, e
   }
   var _ne = xne,
      lP = xp,
      uP = lP ? lP.prototype : void 0,
      cP = uP ? uP.valueOf : void 0;

   function Ane(t) {
      return cP ? Object(cP.call(t)) : {}
   }
   var Sne = Ane,
      Mne = qE;

   function Ene(t, e) {
      var n = e ? Mne(t.buffer) : t.buffer;
      return new t.constructor(n, t.byteOffset, t.length)
   }
   var wne = Ene,
      bne = qE,
      Cne = vne,
      Tne = _ne,
      Rne = Sne,
      Pne = wne,
      Bne = "[object Boolean]",
      Ine = "[object Date]",
      Lne = "[object Map]",
      Dne = "[object Number]",
      Fne = "[object RegExp]",
      One = "[object Set]",
      Nne = "[object String]",
      Une = "[object Symbol]",
      kne = "[object ArrayBuffer]",
      Hne = "[object DataView]",
      Gne = "[object Float32Array]",
      zne = "[object Float64Array]",
      Vne = "[object Int8Array]",
      Wne = "[object Int16Array]",
      jne = "[object Int32Array]",
      $ne = "[object Uint8Array]",
      Xne = "[object Uint8ClampedArray]",
      Jne = "[object Uint16Array]",
      Kne = "[object Uint32Array]";

   function Yne(t, e, n) {
      var r = t.constructor;
      switch (e) {
         case kne:
            return bne(t);
         case Bne:
         case Ine:
            return new r(+t);
         case Hne:
            return Cne(t, n);
         case Gne:
         case zne:
         case Vne:
         case Wne:
         case jne:
         case $ne:
         case Xne:
         case Jne:
         case Kne:
            return Pne(t, n);
         case Lne:
            return new r;
         case Dne:
         case Nne:
            return new r(t);
         case Fne:
            return Tne(t);
         case One:
            return new r;
         case Une:
            return Rne(t)
      }
   }
   var Qne = Yne,
      Zne = If,
      fP = Object.create,
      qne = function () {
         function t() {}
         return function (e) {
            if (!Zne(e)) return {};
            if (fP) return fP(e);
            t.prototype = e;
            var n = new t;
            return t.prototype = void 0, n
         }
      }(),
      ere = qne,
      tre = ere,
      nre = ZE,
      rre = UE;

   function ire(t) {
      return typeof t.constructor == "function" && !rre(t) ? tre(nre(t)) : {}
   }
   var sre = ire,
      ore = ny,
      are = Ho,
      lre = "[object Map]";

   function ure(t) {
      return are(t) && ore(t) == lre
   }
   var cre = ure,
      fre = cre,
      hre = zE,
      hP = VE,
      dP = hP && hP.isMap,
      dre = dP ? hre(dP) : fre,
      pre = dre,
      mre = ny,
      gre = Ho,
      vre = "[object Set]";

   function yre(t) {
      return gre(t) && mre(t) == vre
   }
   var xre = yre,
      _re = xre,
      Are = zE,
      pP = VE,
      mP = pP && pP.isSet,
      Sre = mP ? Are(mP) : _re,
      Mre = Sre,
      Ere = $E,
      wre = rte,
      bre = xN,
      Cre = Ste,
      Tre = kte,
      Rre = Hte,
      Pre = zte,
      Bre = $te,
      Ire = ine,
      Lre = aN,
      Dre = une,
      Fre = ny,
      Ore = dne,
      Nre = Qne,
      Ure = sre,
      kre = Ss,
      Hre = GE,
      Gre = pre,
      zre = If,
      Vre = Mre,
      Wre = _p,
      jre = QE,
      $re = 1,
      Xre = 2,
      Jre = 4,
      AN = "[object Arguments]",
      Kre = "[object Array]",
      Yre = "[object Boolean]",
      Qre = "[object Date]",
      Zre = "[object Error]",
      SN = "[object Function]",
      qre = "[object GeneratorFunction]",
      eie = "[object Map]",
      tie = "[object Number]",
      MN = "[object Object]",
      nie = "[object RegExp]",
      rie = "[object Set]",
      iie = "[object String]",
      sie = "[object Symbol]",
      oie = "[object WeakMap]",
      aie = "[object ArrayBuffer]",
      lie = "[object DataView]",
      uie = "[object Float32Array]",
      cie = "[object Float64Array]",
      fie = "[object Int8Array]",
      hie = "[object Int16Array]",
      die = "[object Int32Array]",
      pie = "[object Uint8Array]",
      mie = "[object Uint8ClampedArray]",
      gie = "[object Uint16Array]",
      vie = "[object Uint32Array]",
      cn = {};
   cn[AN] = cn[Kre] = cn[aie] = cn[lie] = cn[Yre] = cn[Qre] = cn[uie] = cn[cie] = cn[fie] = cn[hie] = cn[die] = cn[eie] = cn[tie] = cn[MN] = cn[nie] = cn[rie] = cn[iie] = cn[sie] = cn[pie] = cn[mie] = cn[gie] = cn[vie] = !0;
   cn[Zre] = cn[SN] = cn[oie] = !1;

   function c0(t, e, n, r, i, s) {
      var o, a = e & $re,
         l = e & Xre,
         u = e & Jre;
      if (n && (o = i ? n(t, r, i, s) : n(t)), o !== void 0) return o;
      if (!zre(t)) return t;
      var h = kre(t);
      if (h) {
         if (o = Ore(t), !a) return Pre(t, o)
      } else {
         var d = Fre(t),
            p = d == SN || d == qre;
         if (Hre(t)) return Rre(t, a);
         if (d == MN || d == AN || p && !i) {
            if (o = l || p ? {} : Ure(t), !a) return l ? Ire(t, Tre(o, t)) : Bre(t, Cre(o, t))
         } else {
            if (!cn[d]) return i ? t : {};
            o = Nre(t, d, a)
         }
      }
      s || (s = new Ere);
      var m = s.get(t);
      if (m) return m;
      s.set(t, o), Vre(t) ? t.forEach(function (x) {
         o.add(c0(x, e, n, x, t, s))
      }) : Gre(t) && t.forEach(function (x, g) {
         o.set(g, c0(x, e, n, g, t, s))
      });
      var v = u ? l ? Dre : Lre : l ? jre : Wre,
         _ = h ? void 0 : v(t);
      return wre(_ || t, function (x, g) {
         _ && (g = x, x = t[g]), bre(o, g, c0(x, e, n, g, t, s))
      }), o
   }
   var yie = c0,
      xie = au,
      _ie = Ss,
      Aie = Ho,
      Sie = "[object String]";

   function Mie(t) {
      return typeof t == "string" || !_ie(t) && Aie(t) && xie(t) == Sie
   }
   var Eie = Mie;
   class wie extends AE {
      constructor(e) {
         super(e), this.type = Cr
      }
      parse(e) {
         const a = function (A, E) {
               switch (A) {
                  case 1:
                     console.error("THREE.RGBELoader Read Error: " + (E || ""));
                     break;
                  case 2:
                     console.error("THREE.RGBELoader Write Error: " + (E || ""));
                     break;
                  case 3:
                     console.error("THREE.RGBELoader Bad File Format: " + (E || ""));
                     break;
                  default:
                  case 4:
                     console.error("THREE.RGBELoader: Error: " + (E || ""))
               }
               return -1
            },
            d = `
`,
            p = function (A, E, C) {
               E = E || 1024;
               let B = A.pos,
                  D = -1,
                  T = 0,
                  I = "",
                  N = String.fromCharCode.apply(null, new Uint16Array(A.subarray(B, B + 128)));
               for (; 0 > (D = N.indexOf(d)) && T < E && B < A.byteLength;) I += N, T += N.length, B += 128, N += String.fromCharCode.apply(null, new Uint16Array(A.subarray(B, B + 128)));
               return -1 < D ? (C !== !1 && (A.pos += T + D + 1), I + N.slice(0, D)) : !1
            },
            m = function (A) {
               const E = /^#\?(\S+)/,
                  C = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                  R = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                  B = /^\s*FORMAT=(\S+)\s*$/,
                  D = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                  T = {
                     valid: 0,
                     string: "",
                     comments: "",
                     programtype: "RGBE",
                     format: "",
                     gamma: 1,
                     exposure: 1,
                     width: 0,
                     height: 0
                  };
               let I, N;
               if (A.pos >= A.byteLength || !(I = p(A))) return a(1, "no header found");
               if (!(N = I.match(E))) return a(3, "bad initial token");
               for (T.valid |= 1, T.programtype = N[1], T.string += I + `
`; I = p(A), I !== !1;) {
                  if (T.string += I + `
`, I.charAt(0) === "#") {
                     T.comments += I + `
`;
                     continue
                  }
                  if ((N = I.match(C)) && (T.gamma = parseFloat(N[1])), (N = I.match(R)) && (T.exposure = parseFloat(N[1])), (N = I.match(B)) && (T.valid |= 2, T.format = N[1]), (N = I.match(D)) && (T.valid |= 4, T.height = parseInt(N[1], 10), T.width = parseInt(N[2], 10)), T.valid & 2 && T.valid & 4) break
               }
               return T.valid & 2 ? T.valid & 4 ? T : a(3, "missing image size specifier") : a(3, "missing format specifier")
            },
            v = function (A, E, C) {
               const R = E;
               if (R < 8 || R > 32767 || A[0] !== 2 || A[1] !== 2 || A[2] & 128) return new Uint8Array(A);
               if (R !== (A[2] << 8 | A[3])) return a(3, "wrong scanline width");
               const B = new Uint8Array(4 * E * C);
               if (!B.length) return a(4, "unable to allocate buffer space");
               let D = 0,
                  T = 0;
               const I = 4 * R,
                  N = new Uint8Array(4),
                  q = new Uint8Array(I);
               let K = C;
               for (; K > 0 && T < A.byteLength;) {
                  if (T + 4 > A.byteLength) return a(1);
                  if (N[0] = A[T++], N[1] = A[T++], N[2] = A[T++], N[3] = A[T++], N[0] != 2 || N[1] != 2 || (N[2] << 8 | N[3]) != R) return a(3, "bad rgbe scanline format");
                  let Z = 0,
                     te;
                  for (; Z < I && T < A.byteLength;) {
                     te = A[T++];
                     const oe = te > 128;
                     if (oe && (te -= 128), te === 0 || Z + te > I) return a(3, "bad scanline data");
                     if (oe) {
                        const G = A[T++];
                        for (let ne = 0; ne < te; ne++) q[Z++] = G
                     } else q.set(A.subarray(T, T + te), Z), Z += te, T += te
                  }
                  const se = R;
                  for (let oe = 0; oe < se; oe++) {
                     let G = 0;
                     B[D] = q[oe + G], G += R, B[D + 1] = q[oe + G], G += R, B[D + 2] = q[oe + G], G += R, B[D + 3] = q[oe + G], D += 4
                  }
                  K--
               }
               return B
            },
            _ = function (A, E, C, R) {
               const B = A[E + 3],
                  D = Math.pow(2, B - 128) / 255;
               C[R + 0] = A[E + 0] * D, C[R + 1] = A[E + 1] * D, C[R + 2] = A[E + 2] * D, C[R + 3] = 1
            },
            x = function (A, E, C, R) {
               const B = A[E + 3],
                  D = Math.pow(2, B - 128) / 255;
               C[R + 0] = Dl.toHalfFloat(Math.min(A[E + 0] * D, 65504)), C[R + 1] = Dl.toHalfFloat(Math.min(A[E + 1] * D, 65504)), C[R + 2] = Dl.toHalfFloat(Math.min(A[E + 2] * D, 65504)), C[R + 3] = Dl.toHalfFloat(1)
            },
            g = new Uint8Array(e);
         g.pos = 0;
         const S = m(g);
         if (S !== -1) {
            const A = S.width,
               E = S.height,
               C = v(g.subarray(g.pos), A, E);
            if (C !== -1) {
               let R, B, D;
               switch (this.type) {
                  case dr:
                     D = C.length / 4;
                     const T = new Float32Array(D * 4);
                     for (let N = 0; N < D; N++) _(C, N * 4, T, N * 4);
                     R = T, B = dr;
                     break;
                  case Cr:
                     D = C.length / 4;
                     const I = new Uint16Array(D * 4);
                     for (let N = 0; N < D; N++) x(C, N * 4, I, N * 4);
                     R = I, B = Cr;
                     break;
                  default:
                     console.error("THREE.RGBELoader: unsupported type: ", this.type);
                     break
               }
               return {
                  width: A,
                  height: E,
                  data: R,
                  header: S.string,
                  gamma: S.gamma,
                  exposure: S.exposure,
                  type: B
               }
            }
         }
         return null
      }
      setDataType(e) {
         return this.type = e, this
      }
      load(e, n, r, i) {
         function s(o, a) {
            switch (o.type) {
               case dr:
               case Cr:
                  "colorSpace" in o ? o.colorSpace = "srgb-linear" : o.encoding = 3e3, o.minFilter = ln, o.magFilter = ln, o.generateMipmaps = !1, o.flipY = !0;
                  break
            }
            n && n(o, a)
         }
         return super.load(e, s, r, i)
      }
   }
   const Ph = "colorSpace" in new yn;
   class bie extends AE {
      constructor(e) {
         super(e), this.type = Cr
      }
      parse(e) {
         const T = Math.pow(2.7182818, 2.2);

         function I(L, b) {
            for (var F = 0, H = 0; H < 65536; ++H)(H == 0 || L[H >> 3] & 1 << (H & 7)) && (b[F++] = H);
            for (var k = F - 1; F < 65536;) b[F++] = 0;
            return k
         }

         function N(L) {
            for (var b = 0; b < 16384; b++) L[b] = {}, L[b].len = 0, L[b].lit = 0, L[b].p = null
         }
         const q = {
            l: 0,
            c: 0,
            lc: 0
         };

         function K(L, b, F, H, k) {
            for (; F < L;) b = b << 8 | et(H, k), F += 8;
            F -= L, q.l = b >> F & (1 << L) - 1, q.c = b, q.lc = F
         }
         const Z = new Array(59);

         function te(L) {
            for (var b = 0; b <= 58; ++b) Z[b] = 0;
            for (var b = 0; b < 65537; ++b) Z[L[b]] += 1;
            for (var F = 0, b = 58; b > 0; --b) {
               var H = F + Z[b] >> 1;
               Z[b] = F, F = H
            }
            for (var b = 0; b < 65537; ++b) {
               var k = L[b];
               k > 0 && (L[b] = k | Z[k]++ << 6)
            }
         }

         function se(L, b, F, H, k, W, ae) {
            for (var ce = F, ye = 0, ge = 0; k <= W; k++) {
               if (ce.value - F.value > H) return !1;
               K(6, ye, ge, L, ce);
               var xe = q.l;
               if (ye = q.c, ge = q.lc, ae[k] = xe, xe == 63) {
                  if (ce.value - F.value > H) throw "Something wrong with hufUnpackEncTable";
                  K(8, ye, ge, L, ce);
                  var me = q.l + 6;
                  if (ye = q.c, ge = q.lc, k + me > W + 1) throw "Something wrong with hufUnpackEncTable";
                  for (; me--;) ae[k++] = 0;
                  k--
               } else if (xe >= 59) {
                  var me = xe - 59 + 2;
                  if (k + me > W + 1) throw "Something wrong with hufUnpackEncTable";
                  for (; me--;) ae[k++] = 0;
                  k--
               }
            }
            te(ae)
         }

         function oe(L) {
            return L & 63
         }

         function G(L) {
            return L >> 6
         }

         function ne(L, b, F, H) {
            for (; b <= F; b++) {
               var k = G(L[b]),
                  W = oe(L[b]);
               if (k >> W) throw "Invalid table entry";
               if (W > 14) {
                  var ae = H[k >> W - 14];
                  if (ae.len) throw "Invalid table entry";
                  if (ae.lit++, ae.p) {
                     var ce = ae.p;
                     ae.p = new Array(ae.lit);
                     for (var ye = 0; ye < ae.lit - 1; ++ye) ae.p[ye] = ce[ye]
                  } else ae.p = new Array(1);
                  ae.p[ae.lit - 1] = b
               } else if (W)
                  for (var ge = 0, ye = 1 << 14 - W; ye > 0; ye--) {
                     var ae = H[(k << 14 - W) + ge];
                     if (ae.len || ae.p) throw "Invalid table entry";
                     ae.len = W, ae.lit = b, ge++
                  }
            }
            return !0
         }
         const Y = {
            c: 0,
            lc: 0
         };

         function X(L, b, F, H) {
            L = L << 8 | et(F, H), b += 8, Y.c = L, Y.lc = b
         }
         const Q = {
            c: 0,
            lc: 0
         };

         function _e(L, b, F, H, k, W, ae, ce, ye, ge) {
            if (L == b) {
               H < 8 && (X(F, H, k, ae), F = Y.c, H = Y.lc), H -= 8;
               var xe = F >> H,
                  xe = new Uint8Array([xe])[0];
               if (ye.value + xe > ge) return !1;
               for (var me = ce[ye.value - 1]; xe-- > 0;) ce[ye.value++] = me
            } else if (ye.value < ge) ce[ye.value++] = L;
            else return !1;
            Q.c = F, Q.lc = H
         }

         function Me(L) {
            return L & 65535
         }

         function we(L) {
            var b = Me(L);
            return b > 32767 ? b - 65536 : b
         }
         const Ee = {
            a: 0,
            b: 0
         };

         function Ue(L, b) {
            var F = we(L),
               H = we(b),
               k = H,
               W = F + (k & 1) + (k >> 1),
               ae = W,
               ce = W - k;
            Ee.a = ae, Ee.b = ce
         }

         function Qe(L, b) {
            var F = Me(L),
               H = Me(b),
               k = F - (H >> 1) & 65535,
               W = H + k - 32768 & 65535;
            Ee.a = W, Ee.b = k
         }

         function Pt(L, b, F, H, k, W, ae) {
            for (var ce = ae < 16384, ye = F > k ? k : F, ge = 1, xe; ge <= ye;) ge <<= 1;
            for (ge >>= 1, xe = ge, ge >>= 1; ge >= 1;) {
               for (var me = 0, Xe = me + W * (k - xe), Oe = W * ge, He = W * xe, ct = H * ge, mt = H * xe, dt, We, xt, it; me <= Xe; me += He) {
                  for (var wt = me, tn = me + H * (F - xe); wt <= tn; wt += mt) {
                     var At = wt + ct,
                        nn = wt + Oe,
                        Jt = nn + ct;
                     ce ? (Ue(L[wt + b], L[nn + b]), dt = Ee.a, xt = Ee.b, Ue(L[At + b], L[Jt + b]), We = Ee.a, it = Ee.b, Ue(dt, We), L[wt + b] = Ee.a, L[At + b] = Ee.b, Ue(xt, it), L[nn + b] = Ee.a, L[Jt + b] = Ee.b) : (Qe(L[wt + b], L[nn + b]), dt = Ee.a, xt = Ee.b, Qe(L[At + b], L[Jt + b]), We = Ee.a, it = Ee.b, Qe(dt, We), L[wt + b] = Ee.a, L[At + b] = Ee.b, Qe(xt, it), L[nn + b] = Ee.a, L[Jt + b] = Ee.b)
                  }
                  if (F & ge) {
                     var nn = wt + Oe;
                     ce ? Ue(L[wt + b], L[nn + b]) : Qe(L[wt + b], L[nn + b]), dt = Ee.a, L[nn + b] = Ee.b, L[wt + b] = dt
                  }
               }
               if (k & ge)
                  for (var wt = me, tn = me + H * (F - xe); wt <= tn; wt += mt) {
                     var At = wt + ct;
                     ce ? Ue(L[wt + b], L[At + b]) : Qe(L[wt + b], L[At + b]), dt = Ee.a, L[At + b] = Ee.b, L[wt + b] = dt
                  }
               xe = ge, ge >>= 1
            }
            return me
         }

         function kt(L, b, F, H, k, W, ae, ce, ye, ge) {
            for (var xe = 0, me = 0, Xe = ce, Oe = Math.trunc(k.value + (W + 7) / 8); k.value < Oe;)
               for (X(xe, me, F, k), xe = Y.c, me = Y.lc; me >= 14;) {
                  var He = xe >> me - 14 & 16383,
                     ct = b[He];
                  if (ct.len) me -= ct.len, _e(ct.lit, ae, xe, me, F, H, k, ye, ge, Xe), xe = Q.c, me = Q.lc;
                  else {
                     if (!ct.p) throw "hufDecode issues";
                     var mt;
                     for (mt = 0; mt < ct.lit; mt++) {
                        for (var dt = oe(L[ct.p[mt]]); me < dt && k.value < Oe;) X(xe, me, F, k), xe = Y.c, me = Y.lc;
                        if (me >= dt && G(L[ct.p[mt]]) == (xe >> me - dt & (1 << dt) - 1)) {
                           me -= dt, _e(ct.p[mt], ae, xe, me, F, H, k, ye, ge, Xe), xe = Q.c, me = Q.lc;
                           break
                        }
                     }
                     if (mt == ct.lit) throw "hufDecode issues"
                  }
               }
            var We = 8 - W & 7;
            for (xe >>= We, me -= We; me > 0;) {
               var ct = b[xe << 14 - me & 16383];
               if (ct.len) me -= ct.len, _e(ct.lit, ae, xe, me, F, H, k, ye, ge, Xe), xe = Q.c, me = Q.lc;
               else throw "hufDecode issues"
            }
            return !0
         }

         function $e(L, b, F, H, k, W) {
            var ae = {
                  value: 0
               },
               ce = F.value,
               ye = Ke(b, F),
               ge = Ke(b, F);
            F.value += 4;
            var xe = Ke(b, F);
            if (F.value += 4, ye < 0 || ye >= 65537 || ge < 0 || ge >= 65537) throw "Something wrong with HUF_ENCSIZE";
            var me = new Array(65537),
               Xe = new Array(16384);
            N(Xe);
            var Oe = H - (F.value - ce);
            if (se(L, b, F, Oe, ye, ge, me), xe > 8 * (H - (F.value - ce))) throw "Something wrong with hufUncompress";
            ne(me, ye, ge, Xe), kt(me, Xe, L, b, F, xe, ge, W, k, ae)
         }

         function J(L, b, F) {
            for (var H = 0; H < F; ++H) b[H] = L[b[H]]
         }

         function Ce(L) {
            for (var b = 1; b < L.length; b++) {
               var F = L[b - 1] + L[b] - 128;
               L[b] = F
            }
         }

         function Ae(L, b) {
            for (var F = 0, H = Math.floor((L.length + 1) / 2), k = 0, W = L.length - 1; !(k > W || (b[k++] = L[F++], k > W));) b[k++] = L[H++]
         }

         function Ie(L) {
            for (var b = L.byteLength, F = new Array, H = 0, k = new DataView(L); b > 0;) {
               var W = k.getInt8(H++);
               if (W < 0) {
                  var ae = -W;
                  b -= ae + 1;
                  for (var ce = 0; ce < ae; ce++) F.push(k.getUint8(H++))
               } else {
                  var ae = W;
                  b -= 2;
                  for (var ye = k.getUint8(H++), ce = 0; ce < ae + 1; ce++) F.push(ye)
               }
            }
            return F
         }

         function be(L, b, F, H, k, W) {
            var At = new DataView(W.buffer),
               ae = F[L.idx[0]].width,
               ce = F[L.idx[0]].height,
               ye = 3,
               ge = Math.floor(ae / 8),
               xe = Math.ceil(ae / 8),
               me = Math.ceil(ce / 8),
               Xe = ae - (xe - 1) * 8,
               Oe = ce - (me - 1) * 8,
               He = {
                  value: 0
               },
               ct = new Array(ye),
               mt = new Array(ye),
               dt = new Array(ye),
               We = new Array(ye),
               xt = new Array(ye);
            for (let Et = 0; Et < ye; ++Et) xt[Et] = b[L.idx[Et]], ct[Et] = Et < 1 ? 0 : ct[Et - 1] + xe * me, mt[Et] = new Float32Array(64), dt[Et] = new Uint16Array(64), We[Et] = new Uint16Array(xe * 64);
            for (let Et = 0; Et < me; ++Et) {
               var it = 8;
               Et == me - 1 && (it = Oe);
               var wt = 8;
               for (let qt = 0; qt < xe; ++qt) {
                  qt == xe - 1 && (wt = Xe);
                  for (let Gt = 0; Gt < ye; ++Gt) dt[Gt].fill(0), dt[Gt][0] = k[ct[Gt]++], lt(He, H, dt[Gt]), Je(dt[Gt], mt[Gt]), qe(mt[Gt]);
                  vt(mt);
                  for (let Gt = 0; Gt < ye; ++Gt) Ot(mt[Gt], We[Gt], qt * 64)
               }
               let wn = 0;
               for (let qt = 0; qt < ye; ++qt) {
                  const Gt = F[L.idx[qt]].type;
                  for (let _n = 8 * Et; _n < 8 * Et + it; ++_n) {
                     wn = xt[qt][_n];
                     for (let eo = 0; eo < ge; ++eo) {
                        const Ir = eo * 64 + (_n & 7) * 8;
                        At.setUint16(wn + 0 * 2 * Gt, We[qt][Ir + 0], !0), At.setUint16(wn + 1 * 2 * Gt, We[qt][Ir + 1], !0), At.setUint16(wn + 2 * 2 * Gt, We[qt][Ir + 2], !0), At.setUint16(wn + 3 * 2 * Gt, We[qt][Ir + 3], !0), At.setUint16(wn + 4 * 2 * Gt, We[qt][Ir + 4], !0), At.setUint16(wn + 5 * 2 * Gt, We[qt][Ir + 5], !0), At.setUint16(wn + 6 * 2 * Gt, We[qt][Ir + 6], !0), At.setUint16(wn + 7 * 2 * Gt, We[qt][Ir + 7], !0), wn += 8 * 2 * Gt
                     }
                  }
                  if (ge != xe)
                     for (let _n = 8 * Et; _n < 8 * Et + it; ++_n) {
                        const eo = xt[qt][_n] + 8 * ge * 2 * Gt,
                           Ir = ge * 64 + (_n & 7) * 8;
                        for (let bs = 0; bs < wt; ++bs) At.setUint16(eo + bs * 2 * Gt, We[qt][Ir + bs], !0)
                     }
               }
            }
            for (var tn = new Uint16Array(ae), At = new DataView(W.buffer), nn = 0; nn < ye; ++nn) {
               F[L.idx[nn]].decoded = !0;
               var Jt = F[L.idx[nn]].type;
               if (F[nn].type == 2)
                  for (var on = 0; on < ce; ++on) {
                     const Et = xt[nn][on];
                     for (var Un = 0; Un < ae; ++Un) tn[Un] = At.getUint16(Et + Un * 2 * Jt, !0);
                     for (var Un = 0; Un < ae; ++Un) At.setFloat32(Et + Un * 2 * Jt, fe(tn[Un]), !0)
                  }
            }
         }

         function lt(L, b, F) {
            for (var H, k = 1; k < 64;) H = b[L.value], H == 65280 ? k = 64 : H >> 8 == 255 ? k += H & 255 : (F[k] = H, k++), L.value++
         }

         function Je(L, b) {
            b[0] = fe(L[0]), b[1] = fe(L[1]), b[2] = fe(L[5]), b[3] = fe(L[6]), b[4] = fe(L[14]), b[5] = fe(L[15]), b[6] = fe(L[27]), b[7] = fe(L[28]), b[8] = fe(L[2]), b[9] = fe(L[4]), b[10] = fe(L[7]), b[11] = fe(L[13]), b[12] = fe(L[16]), b[13] = fe(L[26]), b[14] = fe(L[29]), b[15] = fe(L[42]), b[16] = fe(L[3]), b[17] = fe(L[8]), b[18] = fe(L[12]), b[19] = fe(L[17]), b[20] = fe(L[25]), b[21] = fe(L[30]), b[22] = fe(L[41]), b[23] = fe(L[43]), b[24] = fe(L[9]), b[25] = fe(L[11]), b[26] = fe(L[18]), b[27] = fe(L[24]), b[28] = fe(L[31]), b[29] = fe(L[40]), b[30] = fe(L[44]), b[31] = fe(L[53]), b[32] = fe(L[10]), b[33] = fe(L[19]), b[34] = fe(L[23]), b[35] = fe(L[32]), b[36] = fe(L[39]), b[37] = fe(L[45]), b[38] = fe(L[52]), b[39] = fe(L[54]), b[40] = fe(L[20]), b[41] = fe(L[22]), b[42] = fe(L[33]), b[43] = fe(L[38]), b[44] = fe(L[46]), b[45] = fe(L[51]), b[46] = fe(L[55]), b[47] = fe(L[60]), b[48] = fe(L[21]), b[49] = fe(L[34]), b[50] = fe(L[37]), b[51] = fe(L[47]), b[52] = fe(L[50]), b[53] = fe(L[56]), b[54] = fe(L[59]), b[55] = fe(L[61]), b[56] = fe(L[35]), b[57] = fe(L[36]), b[58] = fe(L[48]), b[59] = fe(L[49]), b[60] = fe(L[57]), b[61] = fe(L[58]), b[62] = fe(L[62]), b[63] = fe(L[63])
         }

         function qe(L) {
            const b = .5 * Math.cos(.7853975),
               F = .5 * Math.cos(3.14159 / 16),
               H = .5 * Math.cos(3.14159 / 8),
               k = .5 * Math.cos(3 * 3.14159 / 16),
               W = .5 * Math.cos(5 * 3.14159 / 16),
               ae = .5 * Math.cos(3 * 3.14159 / 8),
               ce = .5 * Math.cos(7 * 3.14159 / 16);
            for (var ye = new Array(4), ge = new Array(4), xe = new Array(4), me = new Array(4), Xe = 0; Xe < 8; ++Xe) {
               var Oe = Xe * 8;
               ye[0] = H * L[Oe + 2], ye[1] = ae * L[Oe + 2], ye[2] = H * L[Oe + 6], ye[3] = ae * L[Oe + 6], ge[0] = F * L[Oe + 1] + k * L[Oe + 3] + W * L[Oe + 5] + ce * L[Oe + 7], ge[1] = k * L[Oe + 1] - ce * L[Oe + 3] - F * L[Oe + 5] - W * L[Oe + 7], ge[2] = W * L[Oe + 1] - F * L[Oe + 3] + ce * L[Oe + 5] + k * L[Oe + 7], ge[3] = ce * L[Oe + 1] - W * L[Oe + 3] + k * L[Oe + 5] - F * L[Oe + 7], xe[0] = b * (L[Oe + 0] + L[Oe + 4]), xe[3] = b * (L[Oe + 0] - L[Oe + 4]), xe[1] = ye[0] + ye[3], xe[2] = ye[1] - ye[2], me[0] = xe[0] + xe[1], me[1] = xe[3] + xe[2], me[2] = xe[3] - xe[2], me[3] = xe[0] - xe[1], L[Oe + 0] = me[0] + ge[0], L[Oe + 1] = me[1] + ge[1], L[Oe + 2] = me[2] + ge[2], L[Oe + 3] = me[3] + ge[3], L[Oe + 4] = me[3] - ge[3], L[Oe + 5] = me[2] - ge[2], L[Oe + 6] = me[1] - ge[1], L[Oe + 7] = me[0] - ge[0]
            }
            for (var He = 0; He < 8; ++He) ye[0] = H * L[16 + He], ye[1] = ae * L[16 + He], ye[2] = H * L[48 + He], ye[3] = ae * L[48 + He], ge[0] = F * L[8 + He] + k * L[24 + He] + W * L[40 + He] + ce * L[56 + He], ge[1] = k * L[8 + He] - ce * L[24 + He] - F * L[40 + He] - W * L[56 + He], ge[2] = W * L[8 + He] - F * L[24 + He] + ce * L[40 + He] + k * L[56 + He], ge[3] = ce * L[8 + He] - W * L[24 + He] + k * L[40 + He] - F * L[56 + He], xe[0] = b * (L[He] + L[32 + He]), xe[3] = b * (L[He] - L[32 + He]), xe[1] = ye[0] + ye[3], xe[2] = ye[1] - ye[2], me[0] = xe[0] + xe[1], me[1] = xe[3] + xe[2], me[2] = xe[3] - xe[2], me[3] = xe[0] - xe[1], L[0 + He] = me[0] + ge[0], L[8 + He] = me[1] + ge[1], L[16 + He] = me[2] + ge[2], L[24 + He] = me[3] + ge[3], L[32 + He] = me[3] - ge[3], L[40 + He] = me[2] - ge[2], L[48 + He] = me[1] - ge[1], L[56 + He] = me[0] - ge[0]
         }

         function vt(L) {
            for (var b = 0; b < 64; ++b) {
               var F = L[0][b],
                  H = L[1][b],
                  k = L[2][b];
               L[0][b] = F + 1.5747 * k, L[1][b] = F - .1873 * H - .4682 * k, L[2][b] = F + 1.8556 * H
            }
         }

         function Ot(L, b, F) {
            for (var H = 0; H < 64; ++H) b[F + H] = Dl.toHalfFloat(un(L[H]))
         }

         function un(L) {
            return L <= 1 ? Math.sign(L) * Math.pow(Math.abs(L), 2.2) : Math.sign(L) * Math.pow(T, Math.abs(L) - 1)
         }

         function j(L) {
            return new DataView(L.array.buffer, L.offset.value, L.size)
         }

         function O(L) {
            var b = L.viewer.buffer.slice(L.offset.value, L.offset.value + L.size),
               F = new Uint8Array(Ie(b)),
               H = new Uint8Array(F.length);
            return Ce(F), Ae(F, H), new DataView(H.buffer)
         }

         function ue(L) {
            var b = L.array.slice(L.offset.value, L.offset.value + L.size),
               F = Bg(b),
               H = new Uint8Array(F.length);
            return Ce(F), Ae(F, H), new DataView(H.buffer)
         }

         function Pe(L) {
            for (var b = L.viewer, F = {
                  value: L.offset.value
               }, H = new Uint16Array(L.width * L.scanlineBlockSize * (L.channels * L.type)), k = new Uint8Array(8192), W = 0, ae = new Array(L.channels), ce = 0; ce < L.channels; ce++) ae[ce] = {}, ae[ce].start = W, ae[ce].end = ae[ce].start, ae[ce].nx = L.width, ae[ce].ny = L.lines, ae[ce].size = L.type, W += ae[ce].nx * ae[ce].ny * ae[ce].size;
            var ye = he(b, F),
               ge = he(b, F);
            if (ge >= 8192) throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
            if (ye <= ge)
               for (var ce = 0; ce < ge - ye + 1; ce++) k[ce + ye] = Ye(b, F);
            var xe = new Uint16Array(65536),
               me = I(k, xe),
               Xe = Ke(b, F);
            $e(L.array, b, F, Xe, H, W);
            for (var ce = 0; ce < L.channels; ++ce)
               for (var Oe = ae[ce], He = 0; He < ae[ce].size; ++He) Pt(H, Oe.start + He, Oe.nx, Oe.size, Oe.ny, Oe.nx * Oe.size, me);
            J(xe, H, W);
            for (var ct = 0, mt = new Uint8Array(H.buffer.byteLength), dt = 0; dt < L.lines; dt++)
               for (var We = 0; We < L.channels; We++) {
                  var Oe = ae[We],
                     xt = Oe.nx * Oe.size,
                     it = new Uint8Array(H.buffer, Oe.end * 2, xt * 2);
                  mt.set(it, ct), ct += xt * 2, Oe.end += xt
               }
            return new DataView(mt.buffer)
         }

         function Te(L) {
            var b = L.array.slice(L.offset.value, L.offset.value + L.size),
               F = Bg(b);
            const H = L.lines * L.channels * L.width,
               k = L.type == 1 ? new Uint16Array(H) : new Uint32Array(H);
            let W = 0,
               ae = 0;
            const ce = new Array(4);
            for (let ye = 0; ye < L.lines; ye++)
               for (let ge = 0; ge < L.channels; ge++) {
                  let xe = 0;
                  switch (L.type) {
                     case 1:
                        ce[0] = W, ce[1] = ce[0] + L.width, W = ce[1] + L.width;
                        for (let me = 0; me < L.width; ++me) {
                           const Xe = F[ce[0]++] << 8 | F[ce[1]++];
                           xe += Xe, k[ae] = xe, ae++
                        }
                        break;
                     case 2:
                        ce[0] = W, ce[1] = ce[0] + L.width, ce[2] = ce[1] + L.width, W = ce[2] + L.width;
                        for (let me = 0; me < L.width; ++me) {
                           const Xe = F[ce[0]++] << 24 | F[ce[1]++] << 16 | F[ce[2]++] << 8;
                           xe += Xe, k[ae] = xe, ae++
                        }
                        break
                  }
               }
            return new DataView(k.buffer)
         }

         function Be(L) {
            var b = L.viewer,
               F = {
                  value: L.offset.value
               },
               H = new Uint8Array(L.width * L.lines * (L.channels * L.type * 2)),
               k = {
                  version: pt(b, F),
                  unknownUncompressedSize: pt(b, F),
                  unknownCompressedSize: pt(b, F),
                  acCompressedSize: pt(b, F),
                  dcCompressedSize: pt(b, F),
                  rleCompressedSize: pt(b, F),
                  rleUncompressedSize: pt(b, F),
                  rleRawSize: pt(b, F),
                  totalAcUncompressedCount: pt(b, F),
                  totalDcUncompressedCount: pt(b, F),
                  acCompression: pt(b, F)
               };
            if (k.version < 2) throw "EXRLoader.parse: " + gr.compression + " version " + k.version + " is unsupported";
            for (var W = new Array, ae = he(b, F) - 2; ae > 0;) {
               var ce = rt(b.buffer, F),
                  ye = Ye(b, F),
                  ge = ye >> 2 & 3,
                  xe = (ye >> 4) - 1,
                  me = new Int8Array([xe])[0],
                  Xe = Ye(b, F);
               W.push({
                  name: ce,
                  index: me,
                  type: Xe,
                  compression: ge
               }), ae -= ce.length + 3
            }
            for (var Oe = gr.channels, He = new Array(L.channels), ct = 0; ct < L.channels; ++ct) {
               var mt = He[ct] = {},
                  dt = Oe[ct];
               mt.name = dt.name, mt.compression = 0, mt.decoded = !1, mt.type = dt.pixelType, mt.pLinear = dt.pLinear, mt.width = L.width, mt.height = L.lines
            }
            for (var We = {
                  idx: new Array(3)
               }, xt = 0; xt < L.channels; ++xt)
               for (var mt = He[xt], ct = 0; ct < W.length; ++ct) {
                  var it = W[ct];
                  mt.name == it.name && (mt.compression = it.compression, it.index >= 0 && (We.idx[it.index] = xt), mt.offset = xt)
               }
            if (k.acCompressedSize > 0) switch (k.acCompression) {
               case 0:
                  var At = new Uint16Array(k.totalAcUncompressedCount);
                  $e(L.array, b, F, k.acCompressedSize, At, k.totalAcUncompressedCount);
                  break;
               case 1:
                  var wt = L.array.slice(F.value, F.value + k.totalAcUncompressedCount),
                     tn = Bg(wt),
                     At = new Uint16Array(tn.buffer);
                  F.value += k.totalAcUncompressedCount;
                  break
            }
            if (k.dcCompressedSize > 0) {
               var nn = {
                     array: L.array,
                     offset: F,
                     size: k.dcCompressedSize
                  },
                  Jt = new Uint16Array(ue(nn).buffer);
               F.value += k.dcCompressedSize
            }
            if (k.rleRawSize > 0) {
               var wt = L.array.slice(F.value, F.value + k.rleCompressedSize),
                  tn = Bg(wt),
                  on = Ie(tn.buffer);
               F.value += k.rleCompressedSize
            }
            for (var Un = 0, Et = new Array(He.length), ct = 0; ct < Et.length; ++ct) Et[ct] = new Array;
            for (var wn = 0; wn < L.lines; ++wn)
               for (var qt = 0; qt < He.length; ++qt) Et[qt].push(Un), Un += He[qt].width * L.type * 2;
            be(We, Et, He, At, Jt, H);
            for (var ct = 0; ct < He.length; ++ct) {
               var mt = He[ct];
               if (!mt.decoded) switch (mt.compression) {
                  case 2:
                     for (var Gt = 0, _n = 0, wn = 0; wn < L.lines; ++wn) {
                        for (var eo = Et[ct][Gt], Ir = 0; Ir < mt.width; ++Ir) {
                           for (var bs = 0; bs < 2 * mt.type; ++bs) H[eo++] = on[_n + bs * mt.width * mt.height];
                           _n++
                        }
                        Gt++
                     }
                     break;
                  case 1:
                  default:
                     throw "EXRLoader.parse: unsupported channel compression"
               }
            }
            return new DataView(H.buffer)
         }

         function rt(L, b) {
            for (var F = new Uint8Array(L), H = 0; F[b.value + H] != 0;) H += 1;
            var k = new TextDecoder().decode(F.slice(b.value, b.value + H));
            return b.value = b.value + H + 1, k
         }

         function Le(L, b, F) {
            var H = new TextDecoder().decode(new Uint8Array(L).slice(b.value, b.value + F));
            return b.value = b.value + F, H
         }

         function de(L, b) {
            var F = st(L, b),
               H = Ke(L, b);
            return [F, H]
         }

         function ht(L, b) {
            var F = Ke(L, b),
               H = Ke(L, b);
            return [F, H]
         }

         function st(L, b) {
            var F = L.getInt32(b.value, !0);
            return b.value = b.value + 4, F
         }

         function Ke(L, b) {
            var F = L.getUint32(b.value, !0);
            return b.value = b.value + 4, F
         }

         function et(L, b) {
            var F = L[b.value];
            return b.value = b.value + 1, F
         }

         function Ye(L, b) {
            var F = L.getUint8(b.value);
            return b.value = b.value + 1, F
         }
         const pt = function (L, b) {
            let F;
            return "getBigInt64" in DataView.prototype ? F = Number(L.getBigInt64(b.value, !0)) : F = L.getUint32(b.value + 4, !0) + Number(L.getUint32(b.value, !0) << 32), b.value += 8, F
         };

         function Mt(L, b) {
            var F = L.getFloat32(b.value, !0);
            return b.value += 4, F
         }

         function ee(L, b) {
            return Dl.toHalfFloat(Mt(L, b))
         }

         function fe(L) {
            var b = (L & 31744) >> 10,
               F = L & 1023;
            return (L >> 15 ? -1 : 1) * (b ? b === 31 ? F ? NaN : 1 / 0 : Math.pow(2, b - 15) * (1 + F / 1024) : 6103515625e-14 * (F / 1024))
         }

         function he(L, b) {
            var F = L.getUint16(b.value, !0);
            return b.value += 2, F
         }

         function Fe(L, b) {
            return fe(he(L, b))
         }

         function ze(L, b, F, H) {
            for (var k = F.value, W = []; F.value < k + H - 1;) {
               var ae = rt(b, F),
                  ce = st(L, F),
                  ye = Ye(L, F);
               F.value += 3;
               var ge = st(L, F),
                  xe = st(L, F);
               W.push({
                  name: ae,
                  pixelType: ce,
                  pLinear: ye,
                  xSampling: ge,
                  ySampling: xe
               })
            }
            return F.value += 1, W
         }

         function Ut(L, b) {
            var F = Mt(L, b),
               H = Mt(L, b),
               k = Mt(L, b),
               W = Mt(L, b),
               ae = Mt(L, b),
               ce = Mt(L, b),
               ye = Mt(L, b),
               ge = Mt(L, b);
            return {
               redX: F,
               redY: H,
               greenX: k,
               greenY: W,
               blueX: ae,
               blueY: ce,
               whiteX: ye,
               whiteY: ge
            }
         }

         function sn(L, b) {
            var F = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"],
               H = Ye(L, b);
            return F[H]
         }

         function xn(L, b) {
            var F = Ke(L, b),
               H = Ke(L, b),
               k = Ke(L, b),
               W = Ke(L, b);
            return {
               xMin: F,
               yMin: H,
               xMax: k,
               yMax: W
            }
         }

         function si(L, b) {
            var F = ["INCREASING_Y"],
               H = Ye(L, b);
            return F[H]
         }

         function en(L, b) {
            var F = Mt(L, b),
               H = Mt(L, b);
            return [F, H]
         }

         function Br(L, b) {
            var F = Mt(L, b),
               H = Mt(L, b),
               k = Mt(L, b);
            return [F, H, k]
         }

         function Kn(L, b, F, H, k) {
            if (H === "string" || H === "stringvector" || H === "iccProfile") return Le(b, F, k);
            if (H === "chlist") return ze(L, b, F, k);
            if (H === "chromaticities") return Ut(L, F);
            if (H === "compression") return sn(L, F);
            if (H === "box2i") return xn(L, F);
            if (H === "lineOrder") return si(L, F);
            if (H === "float") return Mt(L, F);
            if (H === "v2f") return en(L, F);
            if (H === "v3f") return Br(L, F);
            if (H === "int") return st(L, F);
            if (H === "rational") return de(L, F);
            if (H === "timecode") return ht(L, F);
            if (H === "preview") return F.value += k, "skipped";
            F.value += k
         }

         function vu(L, b, F) {
            const H = {};
            if (L.getUint32(0, !0) != 20000630) throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
            H.version = L.getUint8(4);
            const k = L.getUint8(5);
            H.spec = {
               singleTile: !!(k & 2),
               longName: !!(k & 4),
               deepFormat: !!(k & 8),
               multiPart: !!(k & 16)
            }, F.value = 8;
            for (var W = !0; W;) {
               var ae = rt(b, F);
               if (ae == 0) W = !1;
               else {
                  var ce = rt(b, F),
                     ye = Ke(L, F),
                     ge = Kn(L, b, F, ce, ye);
                  ge === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${ce}'.`) : H[ae] = ge
               }
            }
            if (k != 0) throw console.error("EXRHeader:", H), "THREE.EXRLoader: provided file is currently unsupported.";
            return H
         }

         function yu(L, b, F, H, k) {
            const W = {
               size: 0,
               viewer: b,
               array: F,
               offset: H,
               width: L.dataWindow.xMax - L.dataWindow.xMin + 1,
               height: L.dataWindow.yMax - L.dataWindow.yMin + 1,
               channels: L.channels.length,
               bytesPerLine: null,
               lines: null,
               inputSize: null,
               type: L.channels[0].pixelType,
               uncompress: null,
               getter: null,
               format: null,
               [Ph ? "colorSpace" : "encoding"]: null
            };
            switch (L.compression) {
               case "NO_COMPRESSION":
                  W.lines = 1, W.uncompress = j;
                  break;
               case "RLE_COMPRESSION":
                  W.lines = 1, W.uncompress = O;
                  break;
               case "ZIPS_COMPRESSION":
                  W.lines = 1, W.uncompress = ue;
                  break;
               case "ZIP_COMPRESSION":
                  W.lines = 16, W.uncompress = ue;
                  break;
               case "PIZ_COMPRESSION":
                  W.lines = 32, W.uncompress = Pe;
                  break;
               case "PXR24_COMPRESSION":
                  W.lines = 16, W.uncompress = Te;
                  break;
               case "DWAA_COMPRESSION":
                  W.lines = 32, W.uncompress = Be;
                  break;
               case "DWAB_COMPRESSION":
                  W.lines = 256, W.uncompress = Be;
                  break;
               default:
                  throw "EXRLoader.parse: " + L.compression + " is unsupported"
            }
            if (W.scanlineBlockSize = W.lines, W.type == 1) switch (k) {
               case dr:
                  W.getter = Fe, W.inputSize = 2;
                  break;
               case Cr:
                  W.getter = he, W.inputSize = 2;
                  break
            } else if (W.type == 2) switch (k) {
               case dr:
                  W.getter = Mt, W.inputSize = 4;
                  break;
               case Cr:
                  W.getter = ee, W.inputSize = 4
            } else throw "EXRLoader.parse: unsupported pixelType " + W.type + " for " + L.compression + ".";
            W.blockCount = (L.dataWindow.yMax + 1) / W.scanlineBlockSize;
            for (var ae = 0; ae < W.blockCount; ae++) pt(b, H);
            W.outputChannels = W.channels == 3 ? 4 : W.channels;
            const ce = W.width * W.height * W.outputChannels;
            switch (k) {
               case dr:
                  W.byteArray = new Float32Array(ce), W.channels < W.outputChannels && W.byteArray.fill(1, 0, ce);
                  break;
               case Cr:
                  W.byteArray = new Uint16Array(ce), W.channels < W.outputChannels && W.byteArray.fill(15360, 0, ce);
                  break;
               default:
                  console.error("THREE.EXRLoader: unsupported type: ", k);
                  break
            }
            return W.bytesPerLine = W.width * W.inputSize * W.channels, W.outputChannels == 4 ? W.format = Hr : W.format = kM, Ph ? W.colorSpace = "srgb-linear" : W.encoding = 3e3, W
         }
         const qs = new DataView(e),
            Es = new Uint8Array(e),
            ws = {
               value: 0
            },
            gr = vu(qs, e, ws),
            Lt = yu(gr, qs, Es, ws, this.type),
            xu = {
               value: 0
            },
            zf = {
               R: 0,
               G: 1,
               B: 2,
               A: 3,
               Y: 0
            };
         for (let L = 0; L < Lt.height / Lt.scanlineBlockSize; L++) {
            const b = Ke(qs, ws);
            Lt.size = Ke(qs, ws), Lt.lines = b + Lt.scanlineBlockSize > Lt.height ? Lt.height - b : Lt.scanlineBlockSize;
            const H = Lt.size < Lt.lines * Lt.bytesPerLine ? Lt.uncompress(Lt) : j(Lt);
            ws.value += Lt.size;
            for (let k = 0; k < Lt.scanlineBlockSize; k++) {
               const W = k + L * Lt.scanlineBlockSize;
               if (W >= Lt.height) break;
               for (let ae = 0; ae < Lt.channels; ae++) {
                  const ce = zf[gr.channels[ae].name];
                  for (let ye = 0; ye < Lt.width; ye++) {
                     xu.value = (k * (Lt.channels * Lt.width) + ae * Lt.width + ye) * Lt.inputSize;
                     const ge = (Lt.height - 1 - W) * (Lt.width * Lt.outputChannels) + ye * Lt.outputChannels + ce;
                     Lt.byteArray[ge] = Lt.getter(H, xu)
                  }
               }
            }
         }
         return {
            header: gr,
            width: Lt.width,
            height: Lt.height,
            data: Lt.byteArray,
            format: Lt.format,
            [Ph ? "colorSpace" : "encoding"]: Lt[Ph ? "colorSpace" : "encoding"],
            type: this.type
         }
      }
      setDataType(e) {
         return this.type = e, this
      }
      load(e, n, r, i) {
         function s(o, a) {
            Ph ? o.colorSpace = a.colorSpace : o.encoding = a.encoding, o.minFilter = ln, o.magFilter = ln, o.generateMipmaps = !1, o.flipY = !1, n && n(o, a)
         }
         return super.load(e, s, r, i)
      }
   }
   const Q_ = new WeakMap;
   class Cie extends Pr {
      constructor(e) {
         super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
         }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
         }
      }
      setDecoderPath(e) {
         return this.decoderPath = e, this
      }
      setDecoderConfig(e) {
         return this.decoderConfig = e, this
      }
      setWorkerLimit(e) {
         return this.workerLimit = e, this
      }
      load(e, n, r, i) {
         const s = new Si(this.manager);
         s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => {
            const a = {
               attributeIDs: this.defaultAttributeIDs,
               attributeTypes: this.defaultAttributeTypes,
               useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(n).catch(i)
         }, r, i)
      }
      decodeDracoFile(e, n, r, i) {
         const s = {
            attributeIDs: r || this.defaultAttributeIDs,
            attributeTypes: i || this.defaultAttributeTypes,
            useUniqueIDs: !!r
         };
         this.decodeGeometry(e, s).then(n)
      }
      decodeGeometry(e, n) {
         for (const l in n.attributeTypes) {
            const u = n.attributeTypes[l];
            u.BYTES_PER_ELEMENT !== void 0 && (n.attributeTypes[l] = u.name)
         }
         const r = JSON.stringify(n);
         if (Q_.has(e)) {
            const l = Q_.get(e);
            if (l.key === r) return l.promise;
            if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
         }
         let i;
         const s = this.workerNextTaskID++,
            o = e.byteLength,
            a = this._getWorker(s, o).then(l => (i = l, new Promise((u, h) => {
               i._callbacks[s] = {
                  resolve: u,
                  reject: h
               }, i.postMessage({
                  type: "decode",
                  id: s,
                  taskConfig: n,
                  buffer: e
               }, [e])
            }))).then(l => this._createGeometry(l.geometry));
         return a.catch(() => !0).then(() => {
            i && s && this._releaseTask(i, s)
         }), Q_.set(e, {
            key: r,
            promise: a
         }), a
      }
      _createGeometry(e) {
         const n = new Tt;
         e.index && n.setIndex(new Zt(e.index.array, 1));
         for (let r = 0; r < e.attributes.length; r++) {
            const i = e.attributes[r],
               s = i.name,
               o = i.array,
               a = i.itemSize;
            n.setAttribute(s, new Zt(o, a))
         }
         return n
      }
      _loadLibrary(e, n) {
         const r = new Si(this.manager);
         return r.setPath(this.decoderPath), r.setResponseType(n), r.setWithCredentials(this.withCredentials), new Promise((i, s) => {
            r.load(e, i, void 0, s)
         })
      }
      preload() {
         return this._initDecoder(), this
      }
      _initDecoder() {
         if (this.decoderPending) return this.decoderPending;
         const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
            n = [];
         return e ? n.push(this._loadLibrary("draco_decoder.js", "text")) : (n.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), n.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(n).then(r => {
            const i = r[0];
            e || (this.decoderConfig.wasmBinary = r[1]);
            const s = Tie.toString(),
               o = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
         }), this.decoderPending
      }
      _getWorker(e, n) {
         return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
               const i = new Worker(this.workerSourceURL);
               i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
                  type: "init",
                  decoderConfig: this.decoderConfig
               }), i.onmessage = function (s) {
                  const o = s.data;
                  switch (o.type) {
                     case "decode":
                        i._callbacks[o.id].resolve(o);
                        break;
                     case "error":
                        i._callbacks[o.id].reject(o);
                        break;
                     default:
                        console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                  }
               }, this.workerPool.push(i)
            } else this.workerPool.sort(function (i, s) {
               return i._taskLoad > s._taskLoad ? -1 : 1
            });
            const r = this.workerPool[this.workerPool.length - 1];
            return r._taskCosts[e] = n, r._taskLoad += n, r
         })
      }
      _releaseTask(e, n) {
         e._taskLoad -= e._taskCosts[n], delete e._callbacks[n], delete e._taskCosts[n]
      }
      debug() {
         console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
      }
      dispose() {
         for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
         return this.workerPool.length = 0, this
      }
   }

   function Tie() {
      let t, e;
      onmessage = function (o) {
         const a = o.data;
         switch (a.type) {
            case "init":
               t = a.decoderConfig, e = new Promise(function (h) {
                  t.onModuleLoaded = function (d) {
                     h({
                        draco: d
                     })
                  }, DracoDecoderModule(t)
               });
               break;
            case "decode":
               const l = a.buffer,
                  u = a.taskConfig;
               e.then(h => {
                  const d = h.draco,
                     p = new d.Decoder,
                     m = new d.DecoderBuffer;
                  m.Init(new Int8Array(l), l.byteLength);
                  try {
                     const v = n(d, p, m, u),
                        _ = v.attributes.map(x => x.array.buffer);
                     v.index && _.push(v.index.array.buffer), self.postMessage({
                        type: "decode",
                        id: a.id,
                        geometry: v
                     }, _)
                  } catch (v) {
                     console.error(v), self.postMessage({
                        type: "error",
                        id: a.id,
                        error: v.message
                     })
                  } finally {
                     d.destroy(m), d.destroy(p)
                  }
               });
               break
         }
      };

      function n(o, a, l, u) {
         const h = u.attributeIDs,
            d = u.attributeTypes;
         let p, m;
         const v = a.GetEncodedGeometryType(l);
         if (v === o.TRIANGULAR_MESH) p = new o.Mesh, m = a.DecodeBufferToMesh(l, p);
         else if (v === o.POINT_CLOUD) p = new o.PointCloud, m = a.DecodeBufferToPointCloud(l, p);
         else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
         if (!m.ok() || p.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
         const _ = {
            index: null,
            attributes: []
         };
         for (const x in h) {
            const g = self[d[x]];
            let S, A;
            if (u.useUniqueIDs) A = h[x], S = a.GetAttributeByUniqueId(p, A);
            else {
               if (A = a.GetAttributeId(p, o[h[x]]), A === -1) continue;
               S = a.GetAttribute(p, A)
            }
            _.attributes.push(i(o, a, p, x, g, S))
         }
         return v === o.TRIANGULAR_MESH && (_.index = r(o, a, p)), o.destroy(p), _
      }

      function r(o, a, l) {
         const h = l.num_faces() * 3,
            d = h * 4,
            p = o._malloc(d);
         a.GetTrianglesUInt32Array(l, d, p);
         const m = new Uint32Array(o.HEAPF32.buffer, p, h).slice();
         return o._free(p), {
            array: m,
            itemSize: 1
         }
      }

      function i(o, a, l, u, h, d) {
         const p = d.num_components(),
            v = l.num_points() * p,
            _ = v * h.BYTES_PER_ELEMENT,
            x = s(o, h),
            g = o._malloc(_);
         a.GetAttributeDataArrayForAllPoints(l, d, x, _, g);
         const S = new h(o.HEAPF32.buffer, g, v).slice();
         return o._free(g), {
            name: u,
            array: S,
            itemSize: p
         }
      }

      function s(o, a) {
         switch (a) {
            case Float32Array:
               return o.DT_FLOAT32;
            case Int8Array:
               return o.DT_INT8;
            case Int16Array:
               return o.DT_INT16;
            case Int32Array:
               return o.DT_INT32;
            case Uint8Array:
               return o.DT_UINT8;
            case Uint16Array:
               return o.DT_UINT16;
            case Uint32Array:
               return o.DT_UINT32
         }
      }
   }
   let Lg;
   const Z_ = () => {
      if (Lg) return Lg;
      const t = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
         e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
         n = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
         r = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
      if (typeof WebAssembly != "object") return {
         supported: !1
      };
      let i = t;
      WebAssembly.validate(n) && (i = e);
      let s;
      const o = WebAssembly.instantiate(a(i), {}).then(d => {
         s = d.instance, s.exports.__wasm_call_ctors()
      });

      function a(d) {
         const p = new Uint8Array(d.length);
         for (let v = 0; v < d.length; ++v) {
            const _ = d.charCodeAt(v);
            p[v] = _ > 96 ? _ - 71 : _ > 64 ? _ - 65 : _ > 47 ? _ + 4 : _ > 46 ? 63 : 62
         }
         let m = 0;
         for (let v = 0; v < d.length; ++v) p[m++] = p[v] < 60 ? r[p[v]] : (p[v] - 60) * 64 + p[++v];
         return p.buffer.slice(0, m)
      }

      function l(d, p, m, v, _, x) {
         const g = s.exports.sbrk,
            S = m + 3 & -4,
            A = g(S * v),
            E = g(_.length),
            C = new Uint8Array(s.exports.memory.buffer);
         C.set(_, E);
         const R = d(A, m, v, E, _.length);
         if (R === 0 && x && x(A, S, v), p.set(C.subarray(A, A + m * v)), g(A - g(0)), R !== 0) throw new Error(`Malformed buffer data: ${R}`)
      }
      const u = {
            0: "",
            1: "meshopt_decodeFilterOct",
            2: "meshopt_decodeFilterQuat",
            3: "meshopt_decodeFilterExp",
            NONE: "",
            OCTAHEDRAL: "meshopt_decodeFilterOct",
            QUATERNION: "meshopt_decodeFilterQuat",
            EXPONENTIAL: "meshopt_decodeFilterExp"
         },
         h = {
            0: "meshopt_decodeVertexBuffer",
            1: "meshopt_decodeIndexBuffer",
            2: "meshopt_decodeIndexSequence",
            ATTRIBUTES: "meshopt_decodeVertexBuffer",
            TRIANGLES: "meshopt_decodeIndexBuffer",
            INDICES: "meshopt_decodeIndexSequence"
         };
      return Lg = {
         ready: o,
         supported: !0,
         decodeVertexBuffer(d, p, m, v, _) {
            l(s.exports.meshopt_decodeVertexBuffer, d, p, m, v, s.exports[u[_]])
         },
         decodeIndexBuffer(d, p, m, v) {
            l(s.exports.meshopt_decodeIndexBuffer, d, p, m, v)
         },
         decodeIndexSequence(d, p, m, v) {
            l(s.exports.meshopt_decodeIndexSequence, d, p, m, v)
         },
         decodeGltfBuffer(d, p, m, v, _, x) {
            l(s.exports[h[_]], d, p, m, v, s.exports[u[x]])
         }
      }, Lg
   };

   function EN(t, e, n, r) {
      const i = class extends Qi {
         constructor(o = {}) {
            const a = Object.entries(t);
            super({
               uniforms: a.reduce((l, [u, h]) => {
                  const d = ZM.clone({
                     [u]: {
                        value: h
                     }
                  });
                  return {
                     ...l,
                     ...d
                  }
               }, {}),
               vertexShader: e,
               fragmentShader: n
            }), this.key = "", a.forEach(([l]) => Object.defineProperty(this, l, {
               get: () => this.uniforms[l].value,
               set: u => this.uniforms[l].value = u
            })), Object.assign(this, o), r && r(this)
         }
      };
      return i.key = Qc.generateUUID(), i
   }
   const gP = t => t === Object(t) && !Array.isArray(t) && typeof t != "function";

   function $0(t, e) {
      const n = Eo(i => i.gl),
         r = ko(gp, gP(t) ? Object.values(t) : t);
      if ($.useLayoutEffect(() => {
            e == null || e(r)
         }, [e]), $.useEffect(() => {
            (Array.isArray(r) ? r : [r]).forEach(n.initTexture)
         }, [n, r]), gP(t)) {
         const i = Object.keys(t),
            s = {};
         return i.forEach(o => Object.assign(s, {
            [o]: r[i.indexOf(o)]
         })), s
      } else return r
   }
   $0.preload = t => ko.preload(gp, t);
   $0.clear = t => ko.clear(gp, t);

   function Rie(t) {
      return Array.isArray(t)
   }

   function q_(t = [0, 0, 0]) {
      return Rie(t) ? t : t instanceof U || t instanceof Xa ? [t.x, t.y, t.z] : [t, t, t]
   }
   const vP = $.forwardRef(function ({
      debug: e,
      depthTest: n = !1,
      polygonOffsetFactor: r = -10,
      map: i,
      mesh: s,
      children: o,
      position: a,
      rotation: l,
      scale: u,
      ...h
   }, d) {
      const p = $.useRef(null);
      $.useImperativeHandle(d, () => p.current);
      const m = $.useRef(null);
      return $.useLayoutEffect(() => {
         const v = (s == null ? void 0 : s.current) || p.current.parent,
            _ = p.current;
         if (!(v instanceof Xn)) throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');
         const x = {
            position: new U,
            rotation: new Xa,
            scale: new U(1, 1, 1)
         };
         if (v) {
            Ns(x, {
               position: a,
               scale: u
            });
            const g = v.matrixWorld.clone();
            if (v.matrixWorld.identity(), !l || typeof l == "number") {
               const S = new Wt;
               S.position.copy(x.position), S.lookAt(v.position), typeof l == "number" && S.rotateZ(l), Ns(x, {
                  rotation: S.rotation
               })
            } else Ns(x, {
               rotation: l
            });
            return _.geometry = new C$(v, x.position, x.rotation, x.scale), m.current && (Ns(m.current, x), m.current.traverse(S => S.raycast = () => null)), v.matrixWorld = g, () => {
               _.geometry.dispose()
            }
         }
      }, [s, ...q_(a), ...q_(u), ...q_(l)]), $.createElement("mesh", Ua({
         ref: p,
         "material-transparent": !0,
         "material-polygonOffset": !0,
         "material-polygonOffsetFactor": r,
         "material-depthTest": n,
         "material-map": i
      }, h), o, e && $.createElement("mesh", {
         ref: m
      }, $.createElement("boxGeometry", null), $.createElement("meshNormalMaterial", {
         wireframe: !0
      }), $.createElement("axesHelper", null)))
   });
   let Dg = null;

   function wN(t, e, n) {
      return r => {
         n && n(r), t && (Dg || (Dg = new Cie), Dg.setDecoderPath(typeof t == "string" ? t : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"), r.setDRACOLoader(Dg)), e && r.setMeshoptDecoder(typeof Z_ == "function" ? Z_() : Z_)
      }
   }

   function ew(t, e = !0, n = !0, r) {
      return ko(NE, t, wN(e, n, r))
   }
   ew.preload = (t, e = !0, n = !0, r) => ko.preload(NE, t, wN(e, n, r));
   ew.clear = t => ko.clear(NE, t);
   const Pie = $.forwardRef(function ({
         children: e,
         disable: n,
         disableX: r,
         disableY: i,
         disableZ: s,
         left: o,
         right: a,
         top: l,
         bottom: u,
         front: h,
         back: d,
         onCentered: p,
         precise: m = !0,
         cacheKey: v = 0,
         ..._
      }, x) {
         const g = $.useRef(null),
            S = $.useRef(null),
            A = $.useRef(null);
         return $.useLayoutEffect(() => {
            S.current.matrixWorld.identity();
            const E = new qi().setFromObject(A.current, m),
               C = new U,
               R = new Ci,
               B = E.max.x - E.min.x,
               D = E.max.y - E.min.y,
               T = E.max.z - E.min.z;
            E.getCenter(C), E.getBoundingSphere(R);
            const I = l ? D / 2 : u ? -D / 2 : 0,
               N = o ? -B / 2 : a ? B / 2 : 0,
               q = h ? T / 2 : d ? -T / 2 : 0;
            S.current.position.set(n || r ? 0 : -C.x + N, n || i ? 0 : -C.y + I, n || s ? 0 : -C.z + q), typeof p < "u" && p({
               parent: g.current.parent,
               container: g.current,
               width: B,
               height: D,
               depth: T,
               boundingBox: E,
               boundingSphere: R,
               center: C,
               verticalAlignment: I,
               horizontalAlignment: N,
               depthAlignment: q
            })
         }, [v, p, l, o, h, n, r, i, s, m, a, u, d]), $.useImperativeHandle(x, () => g.current, []), $.createElement("group", Ua({
            ref: g
         }, _), $.createElement("group", {
            ref: S
         }, $.createElement("group", {
            ref: A
         }, e)))
      }),
      Bie = EN({}, "void main() { }", "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }"),
      e1 = {
         apartment: "lebombo_1k.hdr",
         city: "potsdamer_platz_1k.hdr",
         dawn: "kiara_1_dawn_1k.hdr",
         forest: "forest_slope_1k.hdr",
         lobby: "st_fagans_interior_1k.hdr",
         night: "dikhololo_night_1k.hdr",
         park: "rooitou_park_1k.hdr",
         studio: "studio_small_03_1k.hdr",
         sunset: "venice_sunset_1k.hdr",
         warehouse: "empty_warehouse_01_1k.hdr"
      },
      Iie = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
      yP = t => Array.isArray(t);

   function bN({
      files: t = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
      path: e = "",
      preset: n = void 0,
      encoding: r = void 0,
      extensions: i
   } = {}) {
      var s, o, a;
      let l = null,
         u = !1,
         h;
      if (n) {
         if (!(n in e1)) throw new Error("Preset must be one of: " + Object.keys(e1).join(", "));
         t = e1[n], e = Iie
      }
      if (u = yP(t), h = yP(t) ? "cube" : t.startsWith("data:application/exr") ? "exr" : t.startsWith("data:application/hdr") ? "hdr" : (s = t.split(".").pop()) == null || (o = s.split("?")) == null || (a = o.shift()) == null ? void 0 : a.toLowerCase(), l = u ? eO : h === "hdr" ? wie : h === "exr" ? bie : null, !l) throw new Error("useEnvironment: Unrecognized file extension: " + t);
      const d = ko(l, u ? [t] : t, _ => {
            _.setPath == null || _.setPath(e), i && i(_)
         }),
         p = u ? d[0] : d;
      p.mapping = u ? Ks : cf;
      const m = 3001,
         v = 3e3;
      return "colorSpace" in p ? p.colorSpace = r ?? u ? "srgb" : "srgb-linear" : p.encoding = r ?? u ? m : v, p
   }
   const Lie = t => t.current && t.current.isScene,
      Die = t => Lie(t) ? t.current : t;

   function tw(t, e, n, r, i = 0) {
      const s = Die(e || n),
         o = s.background,
         a = s.environment,
         l = s.backgroundBlurriness || 0;
      return t !== "only" && (s.environment = r), t && (s.background = r), t && s.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = i), () => {
         t !== "only" && (s.environment = a), t && (s.background = o), t && s.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = l)
      }
   }

   function nw({
      scene: t,
      background: e = !1,
      blur: n,
      map: r
   }) {
      const i = Eo(s => s.scene);
      return $.useLayoutEffect(() => {
         if (r) return tw(e, t, i, r, n)
      }, [i, t, r, e, n]), null
   }

   function CN({
      background: t = !1,
      scene: e,
      blur: n,
      ...r
   }) {
      const i = bN(r),
         s = Eo(o => o.scene);
      return $.useLayoutEffect(() => tw(t, e, s, i, n), [i, t, e, s, n]), null
   }

   function Fie({
      children: t,
      near: e = 1,
      far: n = 1e3,
      resolution: r = 256,
      frames: i = 1,
      map: s,
      background: o = !1,
      blur: a,
      scene: l,
      files: u,
      path: h,
      preset: d = void 0,
      extensions: p
   }) {
      const m = Eo(A => A.gl),
         v = Eo(A => A.scene),
         _ = $.useRef(null),
         [x] = $.useState(() => new Gd),
         g = $.useMemo(() => {
            const A = new qM(r);
            return A.texture.type = Cr, A
         }, [r]);
      $.useLayoutEffect(() => (i === 1 && _.current.update(m, x), tw(o, l, v, g.texture, a)), [t, x, g.texture, l, v, o, i, m]);
      let S = 1;
      return ty(() => {
         (i === 1 / 0 || S < i) && (_.current.update(m, x), S++)
      }), $.createElement($.Fragment, null, pj($.createElement($.Fragment, null, t, $.createElement("cubeCamera", {
         ref: _,
         args: [e, n, g]
      }), u || d ? $.createElement(CN, {
         background: !0,
         files: u,
         preset: d,
         path: h,
         extensions: p
      }) : s ? $.createElement(nw, {
         background: !0,
         map: s,
         extensions: p
      }) : null), x))
   }

   function Oie(t) {
      var e, n, r, i;
      const s = bN(t),
         o = t.map || s;
      $.useMemo(() => LE({
         GroundProjectedEnvImpl: Jj
      }), []);
      const a = $.useMemo(() => [o], [o]),
         l = (e = t.ground) == null ? void 0 : e.height,
         u = (n = t.ground) == null ? void 0 : n.radius,
         h = (r = (i = t.ground) == null ? void 0 : i.scale) !== null && r !== void 0 ? r : 1e3;
      return $.createElement($.Fragment, null, $.createElement(nw, Ua({}, t, {
         map: o
      })), $.createElement("groundProjectedEnvImpl", {
         args: a,
         scale: h,
         height: l,
         radius: u
      }))
   }

   function Nie(t) {
      return t.ground ? $.createElement(Oie, t) : t.map ? $.createElement(nw, t) : t.children ? $.createElement(Fie, t) : $.createElement(CN, t)
   }

   function Uie(t) {
      return t.isLight
   }

   function kie(t) {
      return !!t.geometry
   }
   const TN = $.createContext(null),
      Hie = EN({
         color: new ke,
         blend: 2,
         alphaTest: .75,
         opacity: 0,
         map: null
      }, `varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
     vUv = uv;
   }`, `varying vec2 vUv;
   uniform sampler2D map;
   uniform vec3 color;
   uniform float opacity;
   uniform float alphaTest;
   uniform float blend;
   void main() {
     vec4 sampledDiffuseColor = texture2D(map, vUv);
     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);
     #include <tonemapping_fragment>
     #include <${parseInt(nu.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
   }`),
      Gie = $.forwardRef(({
         children: t,
         temporal: e,
         frames: n = 40,
         limit: r = 1 / 0,
         blend: i = 20,
         scale: s = 10,
         opacity: o = 1,
         alphaTest: a = .75,
         color: l = "black",
         colorBlend: u = 2,
         resolution: h = 1024,
         toneMapped: d = !0,
         ...p
      }, m) => {
         LE({
            SoftShadowMaterial: Hie
         });
         const v = Eo(R => R.gl),
            _ = Eo(R => R.scene),
            x = Eo(R => R.camera),
            g = Eo(R => R.invalidate),
            S = $.useRef(null),
            A = $.useRef(null),
            [E] = $.useState(() => new zie(v, _, h));
         $.useLayoutEffect(() => {
            E.configure(S.current)
         }, []);
         const C = $.useMemo(() => ({
            lights: new Map,
            temporal: !!e,
            frames: Math.max(2, n),
            blend: Math.max(2, n === 1 / 0 ? i : n),
            count: 0,
            getMesh: () => S.current,
            reset: () => {
               E.clear();
               const R = S.current.material;
               R.opacity = 0, R.alphaTest = 0, C.count = 0
            },
            update: (R = 1) => {
               const B = S.current.material;
               C.temporal ? (B.opacity = Math.min(o, B.opacity + o / C.blend), B.alphaTest = Math.min(a, B.alphaTest + a / C.blend)) : (B.opacity = o, B.alphaTest = a), A.current.visible = !0, E.prepare();
               for (let D = 0; D < R; D++) C.lights.forEach(T => T.update()), E.update(x, C.blend);
               A.current.visible = !1, E.finish()
            }
         }), [E, x, _, e, n, i, o, a]);
         return $.useLayoutEffect(() => {
            C.reset(), !C.temporal && C.frames !== 1 / 0 && C.update(C.blend)
         }), $.useImperativeHandle(m, () => C, [C]), ty(() => {
            (C.temporal || C.frames === 1 / 0) && C.count < C.frames && C.count < r && (g(), C.update(), C.count++)
         }), $.createElement("group", p, $.createElement("group", {
            traverse: () => null,
            ref: A
         }, $.createElement(TN.Provider, {
            value: C
         }, t)), $.createElement("mesh", {
            receiveShadow: !0,
            ref: S,
            scale: s,
            rotation: [-Math.PI / 2, 0, 0]
         }, $.createElement("planeGeometry", null), $.createElement("softShadowMaterial", {
            transparent: !0,
            depthWrite: !1,
            toneMapped: d,
            color: l,
            blend: u,
            map: E.progressiveLightMap2.texture
         })))
      }),
      xP = $.forwardRef(({
         castShadow: t = !0,
         bias: e = .001,
         mapSize: n = 512,
         size: r = 5,
         near: i = .5,
         far: s = 500,
         frames: o = 1,
         position: a = [0, 0, 0],
         radius: l = 1,
         amount: u = 8,
         intensity: h = 1,
         ambient: d = .5,
         ...p
      }, m) => {
         const v = $.useRef(null),
            _ = new U(...a).length(),
            x = $.useContext(TN),
            g = $.useCallback(() => {
               let A;
               if (v.current)
                  for (let E = 0; E < v.current.children.length; E++)
                     if (A = v.current.children[E], Math.random() > d) A.position.set(a[0] + Qc.randFloatSpread(l), a[1] + Qc.randFloatSpread(l), a[2] + Qc.randFloatSpread(l));
                     else {
                        let C = Math.acos(2 * Math.random() - 1) - Math.PI / 2,
                           R = 2 * Math.PI * Math.random();
                        A.position.set(Math.cos(C) * Math.cos(R) * _, Math.abs(Math.cos(C) * Math.sin(R) * _), Math.sin(C) * _)
                     }
            }, [l, d, _, ...a]),
            S = $.useMemo(() => ({
               update: g
            }), [g]);
         return $.useImperativeHandle(m, () => S, [S]), $.useLayoutEffect(() => {
            const A = v.current;
            return x && x.lights.set(A.uuid, S), () => void x.lights.delete(A.uuid)
         }, [x, S]), $.createElement("group", Ua({
            ref: v
         }, p), Array.from({
            length: u
         }, (A, E) => $.createElement("directionalLight", {
            key: E,
            castShadow: t,
            "shadow-bias": e,
            "shadow-mapSize": [n, n],
            intensity: h / u
         }, $.createElement("orthographicCamera", {
            attach: "shadow-camera",
            args: [-r, r, r, -r, i, s]
         }))))
      });
   class zie {
      constructor(e, n, r = 1024) {
         this.renderer = e, this.res = r, this.scene = n, this.buffer1Active = !1, this.lights = [], this.meshes = [], this.object = null, this.clearColor = new ke, this.clearAlpha = 0;
         const i = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? Cr : dr;
         this.progressiveLightMap1 = new Ai(this.res, this.res, {
            type: i
         }), this.progressiveLightMap2 = new Ai(this.res, this.res, {
            type: i
         }), this.discardMat = new Bie, this.targetMat = new mE({
            fog: !1
         }), this.previousShadowMap = {
            value: this.progressiveLightMap1.texture
         }, this.averagingWindow = {
            value: 100
         }, this.targetMat.onBeforeCompile = s => {
            s.vertexShader = `varying vec2 vUv;
` + s.vertexShader.slice(0, -1) + "vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";
            const o = s.fragmentShader.indexOf("void main() {");
            s.fragmentShader = `varying vec2 vUv;
` + s.fragmentShader.slice(0, o) + `uniform sampler2D previousShadowMap;
    uniform float averagingWindow;
` + s.fragmentShader.slice(o - 1, -1) + `
vec3 texelOld = texture2D(previousShadowMap, vUv).rgb;
        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);
      }`, s.uniforms.previousShadowMap = this.previousShadowMap, s.uniforms.averagingWindow = this.averagingWindow
         }
      }
      clear() {
         this.renderer.getClearColor(this.clearColor), this.clearAlpha = this.renderer.getClearAlpha(), this.renderer.setClearColor("black", 1), this.renderer.setRenderTarget(this.progressiveLightMap1), this.renderer.clear(), this.renderer.setRenderTarget(this.progressiveLightMap2), this.renderer.clear(), this.renderer.setRenderTarget(null), this.renderer.setClearColor(this.clearColor, this.clearAlpha), this.lights = [], this.meshes = [], this.scene.traverse(e => {
            kie(e) ? this.meshes.push({
               object: e,
               material: e.material
            }) : Uie(e) && this.lights.push({
               object: e,
               intensity: e.intensity
            })
         })
      }
      prepare() {
         this.lights.forEach(e => e.object.intensity = 0), this.meshes.forEach(e => e.object.material = this.discardMat)
      }
      finish() {
         this.lights.forEach(e => e.object.intensity = e.intensity), this.meshes.forEach(e => e.object.material = e.material)
      }
      configure(e) {
         this.object = e
      }
      update(e, n = 100) {
         if (!this.object) return;
         this.averagingWindow.value = n, this.object.material = this.targetMat;
         const r = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2,
            i = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1,
            s = this.scene.background;
         this.scene.background = null, this.renderer.setRenderTarget(r), this.previousShadowMap.value = i.texture, this.buffer1Active = !this.buffer1Active, this.renderer.render(this.scene, e), this.renderer.setRenderTarget(null), this.scene.background = s
      }
   }
   var RN = {
         exports: {}
      },
      Vie = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
      Wie = Vie,
      jie = Wie;

   function PN() {}

   function BN() {}
   BN.resetWarningCache = PN;
   var $ie = function () {
      function t(r, i, s, o, a, l) {
         if (l !== jie) {
            var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw u.name = "Invariant Violation", u
         }
      }
      t.isRequired = t;

      function e() {
         return t
      }
      var n = {
         array: t,
         bigint: t,
         bool: t,
         func: t,
         number: t,
         object: t,
         string: t,
         symbol: t,
         any: t,
         arrayOf: e,
         element: t,
         elementType: t,
         instanceOf: e,
         node: t,
         objectOf: e,
         oneOf: e,
         oneOfType: e,
         shape: e,
         exact: e,
         checkPropTypes: BN,
         resetWarningCache: PN
      };
      return n.PropTypes = n, n
   };
   RN.exports = $ie();
   var Xie = RN.exports;
   const Ne = qd(Xie);

   function hd(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
         value: n,
         enumerable: !0,
         configurable: !0,
         writable: !0
      }) : t[e] = n, t
   }

   function pS(t, e) {
      (e == null || e > t.length) && (e = t.length);
      for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
      return r
   }

   function Jie(t, e) {
      if (t) {
         if (typeof t == "string") return pS(t, e);
         var n = Object.prototype.toString.call(t).slice(8, -1);
         if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
         if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return pS(t, e)
      }
   }

   function Kie(t) {
      if (Array.isArray(t)) return pS(t)
   }

   function Yie(t) {
      if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t)
   }

   function Qie() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
   }

   function Zie(t) {
      return Kie(t) || Yie(t) || Jie(t) || Qie()
   }
   new Se;
   new Se;

   function qie(t, e, n) {
      return Math.max(e, Math.min(n, t))
   }

   function ese(t, e) {
      return qie(t - Math.floor(t / e) * e, 0, e)
   }

   function tse(t, e) {
      var n = ese(e - t, Math.PI * 2);
      return n > Math.PI && (n -= Math.PI * 2), n
   }

   function IN(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }
   var Ni = function t(e, n, r) {
         var i = this;
         IN(this, t), hd(this, "dot2", function (s, o) {
            return i.x * s + i.y * o
         }), hd(this, "dot3", function (s, o, a) {
            return i.x * s + i.y * o + i.z * a
         }), this.x = e, this.y = n, this.z = r
      },
      nse = [new Ni(1, 1, 0), new Ni(-1, 1, 0), new Ni(1, -1, 0), new Ni(-1, -1, 0), new Ni(1, 0, 1), new Ni(-1, 0, 1), new Ni(1, 0, -1), new Ni(-1, 0, -1), new Ni(0, 1, 1), new Ni(0, -1, 1), new Ni(0, 1, -1), new Ni(0, -1, -1)],
      _P = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180],
      AP = new Array(512),
      SP = new Array(512),
      rse = function (e) {
         e > 0 && e < 1 && (e *= 65536), e = Math.floor(e), e < 256 && (e |= e << 8);
         for (var n = 0; n < 256; n++) {
            var r;
            n & 1 ? r = _P[n] ^ e & 255 : r = _P[n] ^ e >> 8 & 255, AP[n] = AP[n + 256] = r, SP[n] = SP[n + 256] = nse[r % 12]
         }
      };
   rse(0);

   function ise(t) {
      if (typeof t == "number") t = Math.abs(t);
      else if (typeof t == "string") {
         var e = t;
         t = 0;
         for (var n = 0; n < e.length; n++) t = (t + (n + 1) * (e.charCodeAt(n) % 96)) % 2147483647
      }
      return t === 0 && (t = 311), t
   }

   function MP(t) {
      var e = ise(t);
      return function () {
         var n = e * 48271 % 2147483647;
         return e = n, n / 2147483647
      }
   }
   var sse = function t(e) {
      var n = this;
      IN(this, t), hd(this, "seed", 0), hd(this, "init", function (r) {
         n.seed = r, n.value = MP(r)
      }), hd(this, "value", MP(this.seed)), this.init(e)
   };
   new sse(Math.random());
   var ose = function (e) {
         var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .01,
            r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
            i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / (2 * Math.PI);
         return r / Math.atan(1 / n) * Math.atan(Math.sin(2 * Math.PI * e * i) / n)
      },
      LN = function (e) {
         return 1 / (1 + e + .48 * e * e + .235 * e * e * e)
      };

   function er(t, e, n) {
      var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : .25,
         i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .01,
         s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0,
         o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : LN,
         a = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : .001,
         l = "velocity_" + e;
      if (t.__damp === void 0 && (t.__damp = {}), t.__damp[l] === void 0 && (t.__damp[l] = 0), Math.abs(t[e] - n) <= a) return t[e] = n, !1;
      r = Math.max(1e-4, r);
      var u = 2 / r,
         h = o(u * i),
         d = t[e] - n,
         p = n,
         m = s * r;
      d = Math.min(Math.max(d, -m), m), n = t[e] - d;
      var v = (t.__damp[l] + u * d) * i;
      t.__damp[l] = (t.__damp[l] - u * v) * h;
      var _ = n + (d + v) * h;
      return p - t[e] > 0 == _ > p && (_ = p, t.__damp[l] = (_ - p) / i), t[e] = _, !0
   }

   function tf(t, e, n, r, i, s, o, a) {
      return er(t, e, t[e] + tse(t[e], n), r, i, s, o, a)
   }
   var Bh = new Se,
      EP, wP;

   function ase(t, e, n, r, i, s, o) {
      return typeof e == "number" ? Bh.setScalar(e) : Array.isArray(e) ? Bh.set(e[0], e[1]) : Bh.copy(e), EP = er(t, "x", Bh.x, n, r, i, s, o), wP = er(t, "y", Bh.y, n, r, i, s, o), EP || wP
   }
   var nc = new U,
      bP, CP, TP;

   function mS(t, e, n, r, i, s, o) {
      return typeof e == "number" ? nc.setScalar(e) : Array.isArray(e) ? nc.set(e[0], e[1], e[2]) : nc.copy(e), bP = er(t, "x", nc.x, n, r, i, s, o), CP = er(t, "y", nc.y, n, r, i, s, o), TP = er(t, "z", nc.z, n, r, i, s, o), bP || CP || TP
   }
   var vl = new $t,
      RP, PP, BP, IP;

   function lse(t, e, n, r, i, s, o) {
      return typeof e == "number" ? vl.setScalar(e) : Array.isArray(e) ? vl.set(e[0], e[1], e[2], e[3]) : vl.copy(e), RP = er(t, "x", vl.x, n, r, i, s, o), PP = er(t, "y", vl.y, n, r, i, s, o), BP = er(t, "z", vl.z, n, r, i, s, o), IP = er(t, "w", vl.w, n, r, i, s, o), RP || PP || BP || IP
   }
   var Ih = new Xa,
      LP, DP, FP;

   function use(t, e, n, r, i, s, o) {
      return Array.isArray(e) ? Ih.set(e[0], e[1], e[2], e[3]) : Ih.copy(e), LP = tf(t, "x", Ih.x, n, r, i, s, o), DP = tf(t, "y", Ih.y, n, r, i, s, o), FP = tf(t, "z", Ih.z, n, r, i, s, o), LP || DP || FP
   }
   var rc = new ke,
      OP, NP, UP;

   function cse(t, e, n, r, i, s, o) {
      return e instanceof ke ? rc.copy(e) : Array.isArray(e) ? rc.setRGB(e[0], e[1], e[2]) : rc.set(e), OP = er(t, "r", rc.r, n, r, i, s, o), NP = er(t, "g", rc.g, n, r, i, s, o), UP = er(t, "b", rc.b, n, r, i, s, o), OP || NP || UP
   }
   var as = new tr,
      mo = new $t,
      kP = new $t,
      Lh = new $t,
      HP, GP, zP, VP;

   function DN(t, e, n, r, i, s, o) {
      var a = t;
      Array.isArray(e) ? as.set(e[0], e[1], e[2], e[3]) : as.copy(e);
      var l = t.dot(as) > 0 ? 1 : -1;
      return as.x *= l, as.y *= l, as.z *= l, as.w *= l, HP = er(t, "x", as.x, n, r, i, s, o), GP = er(t, "y", as.y, n, r, i, s, o), zP = er(t, "z", as.z, n, r, i, s, o), VP = er(t, "w", as.w, n, r, i, s, o), mo.set(t.x, t.y, t.z, t.w).normalize(), kP.set(a.__damp.velocity_x, a.__damp.velocity_y, a.__damp.velocity_z, a.__damp.velocity_w), Lh.copy(mo).multiplyScalar(kP.dot(mo) / mo.dot(mo)), a.__damp.velocity_x -= Lh.x, a.__damp.velocity_y -= Lh.y, a.__damp.velocity_z -= Lh.z, a.__damp.velocity_w -= Lh.w, t.set(mo.x, mo.y, mo.z, mo.w), HP || GP || zP || VP
   }
   var Dh = new fO,
      WP, jP, $P;

   function fse(t, e, n, r, i, s, o) {
      return Array.isArray(e) ? Dh.set(e[0], e[1], e[2]) : Dh.copy(e), WP = er(t, "radius", Dh.radius, n, r, i, s, o), jP = tf(t, "phi", Dh.phi, n, r, i, s, o), $P = tf(t, "theta", Dh.theta, n, r, i, s, o), WP || jP || $P
   }
   var Fg = new yt,
      XP = new U,
      JP = new tr,
      KP = new U,
      YP, QP, ZP;

   function hse(t, e, n, r, i, s, o) {
      var a = t;
      return a.__damp === void 0 && (a.__damp = {
         position: new U,
         rotation: new tr,
         scale: new U
      }, t.decompose(a.__damp.position, a.__damp.rotation, a.__damp.scale)), Array.isArray(e) ? Fg.set.apply(Fg, Zie(e)) : Fg.copy(e), Fg.decompose(XP, JP, KP), YP = mS(a.__damp.position, XP, n, r, i, s, o), QP = DN(a.__damp.rotation, JP, n, r, i, s, o), ZP = mS(a.__damp.scale, KP, n, r, i, s, o), t.compose(a.__damp.position, a.__damp.rotation, a.__damp.scale), YP || QP || ZP
   }
   var gS = Object.freeze({
      __proto__: null,
      rsqw: ose,
      exp: LN,
      damp: er,
      dampAngle: tf,
      damp2: ase,
      damp3: mS,
      damp4: lse,
      dampE: use,
      dampC: cse,
      dampQ: DN,
      dampS: fse,
      dampM: hse
   });
   const dse = Symbol(),
      rw = Symbol(),
      Fh = "a",
      f0 = "w";
   let pse = (t, e) => new Proxy(t, e);
   const vS = Object.getPrototypeOf,
      yS = new WeakMap,
      FN = t => t && (yS.has(t) ? yS.get(t) : vS(t) === Object.prototype || vS(t) === Array.prototype),
      qP = t => typeof t == "object" && t !== null,
      mse = t => {
         if (Array.isArray(t)) return Array.from(t);
         const e = Object.getOwnPropertyDescriptors(t);
         return Object.values(e).forEach(n => {
            n.configurable = !0
         }), Object.create(vS(t), e)
      },
      ON = t => t[rw] || t,
      NN = (t, e, n, r) => {
         if (!FN(t)) return t;
         let i = r && r.get(t);
         if (!i) {
            const l = ON(t);
            i = (u => Object.values(Object.getOwnPropertyDescriptors(u)).some(h => !h.configurable && !h.writable))(l) ? [l, mse(l)] : [l], r == null || r.set(t, i)
         }
         const [s, o] = i;
         let a = n && n.get(s);
         return a && a[1].f === !!o || (a = ((l, u) => {
            const h = {
               f: u
            };
            let d = !1;
            const p = (v, _) => {
                  if (!d) {
                     let x = h[Fh].get(l);
                     if (x || (x = {}, h[Fh].set(l, x)), v === f0) x[f0] = !0;
                     else {
                        let g = x[v];
                        g || (g = new Set, x[v] = g), g.add(_)
                     }
                  }
               },
               m = {
                  get: (v, _) => _ === rw ? l : (p("k", _), NN(Reflect.get(v, _), h[Fh], h.c, h.t)),
                  has: (v, _) => _ === dse ? (d = !0, h[Fh].delete(l), !0) : (p("h", _), Reflect.has(v, _)),
                  getOwnPropertyDescriptor: (v, _) => (p("o", _), Reflect.getOwnPropertyDescriptor(v, _)),
                  ownKeys: v => (p(f0), Reflect.ownKeys(v))
               };
            return u && (m.set = m.deleteProperty = () => !1), [m, h]
         })(s, !!o), a[1].p = pse(o || s, a[0]), n && n.set(s, a)), a[1][Fh] = e, a[1].c = n, a[1].t = r, a[1].p
      },
      UN = (t, e, n, r) => {
         if (Object.is(t, e)) return !1;
         if (!qP(t) || !qP(e)) return !0;
         const i = n.get(ON(t));
         if (!i) return !0;
         if (r) {
            const o = r.get(t);
            if (o && o.n === e) return o.g;
            r.set(t, {
               n: e,
               g: !1
            })
         }
         let s = null;
         try {
            for (const o of i.h || [])
               if (s = Reflect.has(t, o) !== Reflect.has(e, o), s) return s;
            if (i[f0] === !0) {
               if (s = ((o, a) => {
                     const l = Reflect.ownKeys(o),
                        u = Reflect.ownKeys(a);
                     return l.length !== u.length || l.some((h, d) => h !== u[d])
                  })(t, e), s) return s
            } else
               for (const o of i.o || [])
                  if (s = !!Reflect.getOwnPropertyDescriptor(t, o) != !!Reflect.getOwnPropertyDescriptor(e, o), s) return s;
            for (const o of i.k || [])
               if (s = UN(t[o], e[o], n, r), s) return s;
            return s === null && (s = !0), s
         } finally {
            r && r.set(t, {
               n: e,
               g: s
            })
         }
      },
      gse = t => FN(t) && t[rw] || null,
      eB = (t, e = !0) => {
         yS.set(t, e)
      },
      t1 = t => typeof t == "object" && t !== null,
      ca = new WeakMap,
      Og = new WeakSet,
      vse = (t = Object.is, e = (u, h) => new Proxy(u, h), n = u => t1(u) && !Og.has(u) && (Array.isArray(u) || !(Symbol.iterator in u)) && !(u instanceof WeakMap) && !(u instanceof WeakSet) && !(u instanceof Error) && !(u instanceof Number) && !(u instanceof Date) && !(u instanceof String) && !(u instanceof RegExp) && !(u instanceof ArrayBuffer), r = u => {
         switch (u.status) {
            case "fulfilled":
               return u.value;
            case "rejected":
               throw u.reason;
            default:
               throw u
         }
      }, i = new WeakMap, s = (u, h, d = r) => {
         const p = i.get(u);
         if ((p == null ? void 0 : p[0]) === h) return p[1];
         const m = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u));
         return eB(m, !0), i.set(u, [h, m]), Reflect.ownKeys(u).forEach(v => {
            if (Object.getOwnPropertyDescriptor(m, v)) return;
            const _ = Reflect.get(u, v),
               x = {
                  value: _,
                  enumerable: !0,
                  configurable: !0
               };
            if (Og.has(_)) eB(_, !1);
            else if (_ instanceof Promise) delete x.value, x.get = () => d(_);
            else if (ca.has(_)) {
               const [g, S] = ca.get(_);
               x.value = s(g, S(), d)
            }
            Object.defineProperty(m, v, x)
         }), Object.preventExtensions(m)
      }, o = new WeakMap, a = [1, 1], l = u => {
         if (!t1(u)) throw new Error("object required");
         const h = o.get(u);
         if (h) return h;
         let d = a[0];
         const p = new Set,
            m = (T, I = ++a[0]) => {
               d !== I && (d = I, p.forEach(N => N(T, I)))
            };
         let v = a[1];
         const _ = (T = ++a[1]) => (v !== T && !p.size && (v = T, g.forEach(([I]) => {
               const N = I[1](T);
               N > d && (d = N)
            })), d),
            x = T => (I, N) => {
               const q = [...I];
               q[1] = [T, ...q[1]], m(q, N)
            },
            g = new Map,
            S = (T, I) => {
               if (p.size) {
                  const N = I[3](x(T));
                  g.set(T, [I, N])
               } else g.set(T, [I])
            },
            A = T => {
               var I;
               const N = g.get(T);
               N && (g.delete(T), (I = N[1]) == null || I.call(N))
            },
            E = T => (p.add(T), p.size === 1 && g.forEach(([N, q], K) => {
               const Z = N[3](x(K));
               g.set(K, [N, Z])
            }), () => {
               p.delete(T), p.size === 0 && g.forEach(([N, q], K) => {
                  q && (q(), g.set(K, [N]))
               })
            }),
            C = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u)),
            B = e(C, {
               deleteProperty(T, I) {
                  const N = Reflect.get(T, I);
                  A(I);
                  const q = Reflect.deleteProperty(T, I);
                  return q && m(["delete", [I], N]), q
               },
               set(T, I, N, q) {
                  const K = Reflect.has(T, I),
                     Z = Reflect.get(T, I, q);
                  if (K && (t(Z, N) || o.has(N) && t(Z, o.get(N)))) return !0;
                  A(I), t1(N) && (N = gse(N) || N);
                  let te = N;
                  if (N instanceof Promise) N.then(se => {
                     N.status = "fulfilled", N.value = se, m(["resolve", [I], se])
                  }).catch(se => {
                     N.status = "rejected", N.reason = se, m(["reject", [I], se])
                  });
                  else {
                     !ca.has(N) && n(N) && (te = l(N));
                     const se = !Og.has(te) && ca.get(te);
                     se && S(I, se)
                  }
                  return Reflect.set(T, I, te, q), m(["set", [I], N, Z]), !0
               }
            });
         o.set(u, B);
         const D = [C, _, s, E];
         return ca.set(B, D), Reflect.ownKeys(u).forEach(T => {
            const I = Object.getOwnPropertyDescriptor(u, T);
            "value" in I && (B[T] = u[T], delete I.value, delete I.writable), Object.defineProperty(C, T, I)
         }), B
      }) => [l, ca, Og, t, e, n, r, i, s, o, a],
      [yse] = vse();

   function xse(t = {}) {
      return yse(t)
   }

   function _se(t, e, n) {
      const r = ca.get(t);
      let i;
      const s = [],
         o = r[3];
      let a = !1;
      const u = o(h => {
         if (s.push(h), n) {
            e(s.splice(0));
            return
         }
         i || (i = Promise.resolve().then(() => {
            i = void 0, a && e(s.splice(0))
         }))
      });
      return a = !0, () => {
         a = !1, u()
      }
   }

   function tB(t, e) {
      const n = ca.get(t),
         [r, i, s] = n;
      return s(r, i(), e)
   }
   var kN = {
         exports: {}
      },
      HN = {};
   /**
    * @license React
    * use-sync-external-store-shim.production.min.js
    *
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */
   var _f = $;

   function Ase(t, e) {
      return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
   }
   var Sse = typeof Object.is == "function" ? Object.is : Ase,
      Mse = _f.useState,
      Ese = _f.useEffect,
      wse = _f.useLayoutEffect,
      bse = _f.useDebugValue;

   function Cse(t, e) {
      var n = e(),
         r = Mse({
            inst: {
               value: n,
               getSnapshot: e
            }
         }),
         i = r[0].inst,
         s = r[1];
      return wse(function () {
         i.value = n, i.getSnapshot = e, n1(i) && s({
            inst: i
         })
      }, [t, n, e]), Ese(function () {
         return n1(i) && s({
            inst: i
         }), t(function () {
            n1(i) && s({
               inst: i
            })
         })
      }, [t]), bse(n), n
   }

   function n1(t) {
      var e = t.getSnapshot;
      t = t.value;
      try {
         var n = e();
         return !Sse(t, n)
      } catch {
         return !0
      }
   }

   function Tse(t, e) {
      return e()
   }
   var Rse = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? Tse : Cse;
   HN.useSyncExternalStore = _f.useSyncExternalStore !== void 0 ? _f.useSyncExternalStore : Rse;
   kN.exports = HN;
   var Pse = kN.exports;
   const Bse = qd(Pse),
      {
         use: nB
      } = z,
      {
         useSyncExternalStore: Ise
      } = Bse,
      Lse = new WeakMap;

   function uu(t, e) {
      const n = e == null ? void 0 : e.sync,
         r = $.useRef(),
         i = $.useRef();
      let s = !0;
      const o = Ise($.useCallback(u => {
         const h = _se(t, u, n);
         return u(), h
      }, [t, n]), () => {
         const u = tB(t, nB);
         try {
            if (!s && r.current && i.current && !UN(r.current, u, i.current, new WeakMap)) return r.current
         } catch {}
         return u
      }, () => tB(t, nB));
      s = !1;
      const a = new WeakMap;
      $.useEffect(() => {
         r.current = o, i.current = a
      });
      const l = $.useMemo(() => new WeakMap, []);
      return NN(o, a, l, Lse)
   }
   const kr = xse({
         intro: !0,
         color: "#353934",
         isLogoTexture: !0,
         isFullTexture: !1,
         logoDecal: "./imagens/logo.png",
         fullDecal: imgInput
      }),
      Dse = () => {
         const t = uu(kr),
            {
               nodes: e,
               materials: n
            } = ew("./shirt_baked.glb"),
            r = $0(t.logoDecal),
            i = $0(t.fullDecal);
         ty((o, a) => gS.dampC(n.lambert1.color, t.color, .25, a));
         const s = JSON.stringify(t);
         return ot.jsx("group", {
            children: ot.jsxs("mesh", {
               castShadow: !0,
               geometry: e.T_Shirt_male.geometry,
               material: n.lambert1,
               "material-roughness": 1,
               dispose: null,
               children: [t.isFullTexture && ot.jsx(vP, {
                  position: [0, 0, 0],
                  rotation: [0, 0, 0],
                  scale: 1,
                  map: i
               }), t.isLogoTexture && ot.jsx(vP, {
                  position: [0, .04, .15],
                  rotation: [0, 0, 0],
                  scale: .15,
                  map: r,
                  mapAnisotropy: 16,
                  depthTest: !1,
                  depthWrite: !0
               })]
            })
         }, s)
      },
      Fse = () => {
         const t = $.useRef();
         return ot.jsxs(Gie, {
            ref: t,
            temporal: !0,
            frames: 60,
            alphaTest: .85,
            scale: 10,
            rotation: [Math.PI / 2, 0, 0],
            position: [0, 0, -.14],
            children: [ot.jsx(xP, {
               amount: 4,
               radius: 9,
               intensity: .55,
               ambient: .25,
               position: [5, 5, -10]
            }), ot.jsx(xP, {
               amount: 4,
               radius: 5,
               intensity: .25,
               ambient: .55,
               position: [-5, 5, -9]
            })]
         })
      },
      Ose = ({
         children: t
      }) => {
         const e = $.useRef(),
            n = uu(kr);
         return ty((r, i) => {
            const s = window.innerWidth <= 1260,
               o = window.innerWidth <= 600;
            let a = [-.4, 0, 2];
            n.intro ? (s && (a = [0, 0, 2]), o && (a = [0, .2, 2.5])) : o ? a = [0, 0, 2.5] : a = [0, 0, 2], gS.damp3(r.camera.position, a, .25, i), gS.dampE(e.current.rotation, [r.pointer.y / 7, -r.pointer.x / 2, 0], .2, i)
         }), ot.jsx("group", {
            ref: e,
            children: t
         })
      },
      Nse = () => ot.jsxs(Lj, {
         shadows: !0,
         camera: {
            position: [0, 0, 0],
            fov: 25
         },
         gl: {
            preserveDrawingBuffer: !0
         },
         className: "w-full max-w-full h-full transition-all ease-in",
         children: [ot.jsx("ambientLight", {
            intensity: .5
         }), ot.jsx(Nie, {
            preset: "city",
            background: !0
         }), ot.jsxs(Ose, {
            children: [ot.jsx(Fse, {}), ot.jsx(Pie, {
               children: ot.jsx(Dse, {})
            })]
         })]
      }),
      GN = $.createContext({
         transformPagePoint: t => t,
         isStatic: !1,
         reducedMotion: "never"
      }),
      cy = $.createContext({}),
      fy = $.createContext(null),
      hy = typeof document < "u",
      X0 = hy ? $.useLayoutEffect : $.useEffect,
      zN = $.createContext({
         strict: !1
      });

   function Use(t, e, n, r) {
      const {
         visualElement: i
      } = $.useContext(cy), s = $.useContext(zN), o = $.useContext(fy), a = $.useContext(GN).reducedMotion, l = $.useRef();
      r = r || s.renderer, !l.current && r && (l.current = r(t, {
         visualState: e,
         parent: i,
         props: n,
         presenceContext: o,
         blockInitialAnimation: o ? o.initial === !1 : !1,
         reducedMotionConfig: a
      }));
      const u = l.current;
      return $.useInsertionEffect(() => {
         u && u.update(n, o)
      }), X0(() => {
         u && u.render()
      }), $.useEffect(() => {
         u && u.updateFeatures()
      }), (window.HandoffAppearAnimations ? X0 : $.useEffect)(() => {
         u && u.animationState && u.animationState.animateChanges()
      }), u
   }

   function Hc(t) {
      return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current")
   }

   function kse(t, e, n) {
      return $.useCallback(r => {
         r && t.mount && t.mount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : Hc(n) && (n.current = r))
      }, [e])
   }

   function Jd(t) {
      return typeof t == "string" || Array.isArray(t)
   }

   function dy(t) {
      return typeof t == "object" && typeof t.start == "function"
   }
   const iw = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
      sw = ["initial", ...iw];

   function py(t) {
      return dy(t.animate) || sw.some(e => Jd(t[e]))
   }

   function VN(t) {
      return !!(py(t) || t.variants)
   }

   function Hse(t, e) {
      if (py(t)) {
         const {
            initial: n,
            animate: r
         } = t;
         return {
            initial: n === !1 || Jd(n) ? n : void 0,
            animate: Jd(r) ? r : void 0
         }
      }
      return t.inherit !== !1 ? e : {}
   }

   function Gse(t) {
      const {
         initial: e,
         animate: n
      } = Hse(t, $.useContext(cy));
      return $.useMemo(() => ({
         initial: e,
         animate: n
      }), [rB(e), rB(n)])
   }

   function rB(t) {
      return Array.isArray(t) ? t.join(" ") : t
   }
   const iB = {
         animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
         exit: ["exit"],
         drag: ["drag", "dragControls"],
         focus: ["whileFocus"],
         hover: ["whileHover", "onHoverStart", "onHoverEnd"],
         tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
         pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
         inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
         layout: ["layout", "layoutId"]
      },
      Kd = {};
   for (const t in iB) Kd[t] = {
      isEnabled: e => iB[t].some(n => !!e[n])
   };

   function zse(t) {
      for (const e in t) Kd[e] = {
         ...Kd[e],
         ...t[e]
      }
   }
   const ow = $.createContext({}),
      WN = $.createContext({}),
      Vse = Symbol.for("motionComponentSymbol");

   function Wse({
      preloadedFeatures: t,
      createVisualElement: e,
      useRender: n,
      useVisualState: r,
      Component: i
   }) {
      t && zse(t);

      function s(a, l) {
         let u;
         const h = {
               ...$.useContext(GN),
               ...a,
               layoutId: jse(a)
            },
            {
               isStatic: d
            } = h,
            p = Gse(a),
            m = r(a, d);
         if (!d && hy) {
            p.visualElement = Use(i, m, h, e);
            const v = $.useContext(WN),
               _ = $.useContext(zN).strict;
            p.visualElement && (u = p.visualElement.loadFeatures(h, _, t, v))
         }
         return $.createElement(cy.Provider, {
            value: p
         }, u && p.visualElement ? $.createElement(u, {
            visualElement: p.visualElement,
            ...h
         }) : null, n(i, a, kse(m, p.visualElement, l), m, d, p.visualElement))
      }
      const o = $.forwardRef(s);
      return o[Vse] = i, o
   }

   function jse({
      layoutId: t
   }) {
      const e = $.useContext(ow).id;
      return e && t !== void 0 ? e + "-" + t : t
   }

   function $se(t) {
      function e(r, i = {}) {
         return Wse(t(r, i))
      }
      if (typeof Proxy > "u") return e;
      const n = new Map;
      return new Proxy(e, {
         get: (r, i) => (n.has(i) || n.set(i, e(i)), n.get(i))
      })
   }
   const Xse = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

   function aw(t) {
      return typeof t != "string" || t.includes("-") ? !1 : !!(Xse.indexOf(t) > -1 || /[A-Z]/.test(t))
   }
   const J0 = {};

   function Jse(t) {
      Object.assign(J0, t)
   }
   const Ap = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
      cu = new Set(Ap);

   function jN(t, {
      layout: e,
      layoutId: n
   }) {
      return cu.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!J0[t] || t === "opacity")
   }
   const ni = t => !!(t && t.getVelocity),
      Kse = {
         x: "translateX",
         y: "translateY",
         z: "translateZ",
         transformPerspective: "perspective"
      },
      Yse = Ap.length;

   function Qse(t, {
      enableHardwareAcceleration: e = !0,
      allowTransformNone: n = !0
   }, r, i) {
      let s = "";
      for (let o = 0; o < Yse; o++) {
         const a = Ap[o];
         if (t[a] !== void 0) {
            const l = Kse[a] || a;
            s += `${l}(${t[a]}) `
         }
      }
      return e && !t.z && (s += "translateZ(0)"), s = s.trim(), i ? s = i(t, r ? "" : s) : n && r && (s = "none"), s
   }
   const $N = t => e => typeof e == "string" && e.startsWith(t),
      XN = $N("--"),
      xS = $N("var(--"),
      Zse = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
      qse = (t, e) => e && typeof t == "number" ? e.transform(t) : t,
      ka = (t, e, n) => Math.min(Math.max(n, t), e),
      fu = {
         test: t => typeof t == "number",
         parse: parseFloat,
         transform: t => t
      },
      dd = {
         ...fu,
         transform: t => ka(0, 1, t)
      },
      Ng = {
         ...fu,
         default: 1
      },
      pd = t => Math.round(t * 1e5) / 1e5,
      my = /(-)?([\d]*\.?[\d])+/g,
      JN = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
      eoe = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;

   function Sp(t) {
      return typeof t == "string"
   }
   const Mp = t => ({
         test: e => Sp(e) && e.endsWith(t) && e.split(" ").length === 1,
         parse: parseFloat,
         transform: e => `${e}${t}`
      }),
      sa = Mp("deg"),
      $s = Mp("%"),
      _t = Mp("px"),
      toe = Mp("vh"),
      noe = Mp("vw"),
      sB = {
         ...$s,
         parse: t => $s.parse(t) / 100,
         transform: t => $s.transform(t * 100)
      },
      oB = {
         ...fu,
         transform: Math.round
      },
      KN = {
         borderWidth: _t,
         borderTopWidth: _t,
         borderRightWidth: _t,
         borderBottomWidth: _t,
         borderLeftWidth: _t,
         borderRadius: _t,
         radius: _t,
         borderTopLeftRadius: _t,
         borderTopRightRadius: _t,
         borderBottomRightRadius: _t,
         borderBottomLeftRadius: _t,
         width: _t,
         maxWidth: _t,
         height: _t,
         maxHeight: _t,
         size: _t,
         top: _t,
         right: _t,
         bottom: _t,
         left: _t,
         padding: _t,
         paddingTop: _t,
         paddingRight: _t,
         paddingBottom: _t,
         paddingLeft: _t,
         margin: _t,
         marginTop: _t,
         marginRight: _t,
         marginBottom: _t,
         marginLeft: _t,
         rotate: sa,
         rotateX: sa,
         rotateY: sa,
         rotateZ: sa,
         scale: Ng,
         scaleX: Ng,
         scaleY: Ng,
         scaleZ: Ng,
         skew: sa,
         skewX: sa,
         skewY: sa,
         distance: _t,
         translateX: _t,
         translateY: _t,
         translateZ: _t,
         x: _t,
         y: _t,
         z: _t,
         perspective: _t,
         transformPerspective: _t,
         opacity: dd,
         originX: sB,
         originY: sB,
         originZ: _t,
         zIndex: oB,
         fillOpacity: dd,
         strokeOpacity: dd,
         numOctaves: oB
      };

   function lw(t, e, n, r) {
      const {
         style: i,
         vars: s,
         transform: o,
         transformOrigin: a
      } = t;
      let l = !1,
         u = !1,
         h = !0;
      for (const d in e) {
         const p = e[d];
         if (XN(d)) {
            s[d] = p;
            continue
         }
         const m = KN[d],
            v = qse(p, m);
         if (cu.has(d)) {
            if (l = !0, o[d] = v, !h) continue;
            p !== (m.default || 0) && (h = !1)
         } else d.startsWith("origin") ? (u = !0, a[d] = v) : i[d] = v
      }
      if (e.transform || (l || r ? i.transform = Qse(t.transform, n, h, r) : i.transform && (i.transform = "none")), u) {
         const {
            originX: d = "50%",
            originY: p = "50%",
            originZ: m = 0
         } = a;
         i.transformOrigin = `${d} ${p} ${m}`
      }
   }
   const uw = () => ({
      style: {},
      transform: {},
      transformOrigin: {},
      vars: {}
   });

   function YN(t, e, n) {
      for (const r in e) !ni(e[r]) && !jN(r, n) && (t[r] = e[r])
   }

   function roe({
      transformTemplate: t
   }, e, n) {
      return $.useMemo(() => {
         const r = uw();
         return lw(r, e, {
            enableHardwareAcceleration: !n
         }, t), Object.assign({}, r.vars, r.style)
      }, [e])
   }

   function ioe(t, e, n) {
      const r = t.style || {},
         i = {};
      return YN(i, r, t), Object.assign(i, roe(t, e, n)), t.transformValues ? t.transformValues(i) : i
   }

   function soe(t, e, n) {
      const r = {},
         i = ioe(t, e, n);
      return t.drag && t.dragListener !== !1 && (r.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = t.drag === !0 ? "none" : `pan-${t.drag==="x"?"y":"x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (r.tabIndex = 0), r.style = i, r
   }
   const ooe = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);

   function K0(t) {
      return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || ooe.has(t)
   }
   let QN = t => !K0(t);

   function aoe(t) {
      t && (QN = e => e.startsWith("on") ? !K0(e) : t(e))
   }
   try {
      aoe(require("@emotion/is-prop-valid").default)
   } catch {}

   function loe(t, e, n) {
      const r = {};
      for (const i in t) i === "values" && typeof t.values == "object" || (QN(i) || n === !0 && K0(i) || !e && !K0(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]);
      return r
   }

   function aB(t, e, n) {
      return typeof t == "string" ? t : _t.transform(e + n * t)
   }

   function uoe(t, e, n) {
      const r = aB(e, t.x, t.width),
         i = aB(n, t.y, t.height);
      return `${r} ${i}`
   }
   const coe = {
         offset: "stroke-dashoffset",
         array: "stroke-dasharray"
      },
      foe = {
         offset: "strokeDashoffset",
         array: "strokeDasharray"
      };

   function hoe(t, e, n = 1, r = 0, i = !0) {
      t.pathLength = 1;
      const s = i ? coe : foe;
      t[s.offset] = _t.transform(-r);
      const o = _t.transform(e),
         a = _t.transform(n);
      t[s.array] = `${o} ${a}`
   }

   function cw(t, {
      attrX: e,
      attrY: n,
      attrScale: r,
      originX: i,
      originY: s,
      pathLength: o,
      pathSpacing: a = 1,
      pathOffset: l = 0,
      ...u
   }, h, d, p) {
      if (lw(t, u, h, p), d) {
         t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
         return
      }
      t.attrs = t.style, t.style = {};
      const {
         attrs: m,
         style: v,
         dimensions: _
      } = t;
      m.transform && (_ && (v.transform = m.transform), delete m.transform), _ && (i !== void 0 || s !== void 0 || v.transform) && (v.transformOrigin = uoe(_, i !== void 0 ? i : .5, s !== void 0 ? s : .5)), e !== void 0 && (m.x = e), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), o !== void 0 && hoe(m, o, a, l, !1)
   }
   const ZN = () => ({
         ...uw(),
         attrs: {}
      }),
      fw = t => typeof t == "string" && t.toLowerCase() === "svg";

   function doe(t, e, n, r) {
      const i = $.useMemo(() => {
         const s = ZN();
         return cw(s, e, {
            enableHardwareAcceleration: !1
         }, fw(r), t.transformTemplate), {
            ...s.attrs,
            style: {
               ...s.style
            }
         }
      }, [e]);
      if (t.style) {
         const s = {};
         YN(s, t.style, t), i.style = {
            ...s,
            ...i.style
         }
      }
      return i
   }

   function poe(t = !1) {
      return (n, r, i, {
         latestValues: s
      }, o) => {
         const l = (aw(n) ? doe : soe)(r, s, o, n),
            h = {
               ...loe(r, typeof n == "string", t),
               ...l,
               ref: i
            },
            {
               children: d
            } = r,
            p = $.useMemo(() => ni(d) ? d.get() : d, [d]);
         return $.createElement(n, {
            ...h,
            children: p
         })
      }
   }
   const hw = t => t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

   function qN(t, {
      style: e,
      vars: n
   }, r, i) {
      Object.assign(t.style, e, i && i.getProjectionStyles(r));
      for (const s in n) t.style.setProperty(s, n[s])
   }
   const eU = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

   function tU(t, e, n, r) {
      qN(t, e, void 0, r);
      for (const i in e.attrs) t.setAttribute(eU.has(i) ? i : hw(i), e.attrs[i])
   }

   function dw(t, e) {
      const {
         style: n
      } = t, r = {};
      for (const i in n)(ni(n[i]) || e.style && ni(e.style[i]) || jN(i, t)) && (r[i] = n[i]);
      return r
   }

   function nU(t, e) {
      const n = dw(t, e);
      for (const r in t)
         if (ni(t[r]) || ni(e[r])) {
            const i = Ap.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
            n[i] = t[r]
         } return n
   }

   function pw(t, e, n, r = {}, i = {}) {
      return typeof e == "function" && (e = e(n !== void 0 ? n : t.custom, r, i)), typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function" && (e = e(n !== void 0 ? n : t.custom, r, i)), e
   }

   function rU(t) {
      const e = $.useRef(null);
      return e.current === null && (e.current = t()), e.current
   }
   const Y0 = t => Array.isArray(t),
      moe = t => !!(t && typeof t == "object" && t.mix && t.toValue),
      goe = t => Y0(t) ? t[t.length - 1] || 0 : t;

   function h0(t) {
      const e = ni(t) ? t.get() : t;
      return moe(e) ? e.toValue() : e
   }

   function voe({
      scrapeMotionValuesFromProps: t,
      createRenderState: e,
      onMount: n
   }, r, i, s) {
      const o = {
         latestValues: yoe(r, i, s, t),
         renderState: e()
      };
      return n && (o.mount = a => n(r, a, o)), o
   }
   const iU = t => (e, n) => {
      const r = $.useContext(cy),
         i = $.useContext(fy),
         s = () => voe(t, e, r, i);
      return n ? s() : rU(s)
   };

   function yoe(t, e, n, r) {
      const i = {},
         s = r(t, {});
      for (const p in s) i[p] = h0(s[p]);
      let {
         initial: o,
         animate: a
      } = t;
      const l = py(t),
         u = VN(t);
      e && u && !l && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
      let h = n ? n.initial === !1 : !1;
      h = h || o === !1;
      const d = h ? a : o;
      return d && typeof d != "boolean" && !dy(d) && (Array.isArray(d) ? d : [d]).forEach(m => {
         const v = pw(t, m);
         if (!v) return;
         const {
            transitionEnd: _,
            transition: x,
            ...g
         } = v;
         for (const S in g) {
            let A = g[S];
            if (Array.isArray(A)) {
               const E = h ? A.length - 1 : 0;
               A = A[E]
            }
            A !== null && (i[S] = A)
         }
         for (const S in _) i[S] = _[S]
      }), i
   }
   const xoe = {
         useVisualState: iU({
            scrapeMotionValuesFromProps: nU,
            createRenderState: ZN,
            onMount: (t, e, {
               renderState: n,
               latestValues: r
            }) => {
               try {
                  n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
               } catch {
                  n.dimensions = {
                     x: 0,
                     y: 0,
                     width: 0,
                     height: 0
                  }
               }
               cw(n, r, {
                  enableHardwareAcceleration: !1
               }, fw(e.tagName), t.transformTemplate), tU(e, n)
            }
         })
      },
      _oe = {
         useVisualState: iU({
            scrapeMotionValuesFromProps: dw,
            createRenderState: uw
         })
      };

   function Aoe(t, {
      forwardMotionProps: e = !1
   }, n, r) {
      return {
         ...aw(t) ? xoe : _oe,
         preloadedFeatures: n,
         useRender: poe(e),
         createVisualElement: r,
         Component: t
      }
   }

   function wo(t, e, n, r = {
      passive: !0
   }) {
      return t.addEventListener(e, n, r), () => t.removeEventListener(e, n)
   }
   const sU = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;

   function gy(t, e = "page") {
      return {
         point: {
            x: t[e + "X"],
            y: t[e + "Y"]
         }
      }
   }
   const Soe = t => e => sU(e) && t(e, gy(e));

   function To(t, e, n, r) {
      return wo(t, e, Soe(n), r)
   }
   const Moe = (t, e) => n => e(t(n)),
      Pa = (...t) => t.reduce(Moe);

   function oU(t) {
      let e = null;
      return () => {
         const n = () => {
            e = null
         };
         return e === null ? (e = t, n) : !1
      }
   }
   const lB = oU("dragHorizontal"),
      uB = oU("dragVertical");

   function aU(t) {
      let e = !1;
      if (t === "y") e = uB();
      else if (t === "x") e = lB();
      else {
         const n = lB(),
            r = uB();
         n && r ? e = () => {
            n(), r()
         } : (n && n(), r && r())
      }
      return e
   }

   function lU() {
      const t = aU(!0);
      return t ? (t(), !1) : !0
   }
   class Ya {
      constructor(e) {
         this.isMounted = !1, this.node = e
      }
      update() {}
   }
   const Nn = t => t;

   function Eoe(t) {
      let e = [],
         n = [],
         r = 0,
         i = !1,
         s = !1;
      const o = new WeakSet,
         a = {
            schedule: (l, u = !1, h = !1) => {
               const d = h && i,
                  p = d ? e : n;
               return u && o.add(l), p.indexOf(l) === -1 && (p.push(l), d && i && (r = e.length)), l
            },
            cancel: l => {
               const u = n.indexOf(l);
               u !== -1 && n.splice(u, 1), o.delete(l)
            },
            process: l => {
               if (i) {
                  s = !0;
                  return
               }
               if (i = !0, [e, n] = [n, e], n.length = 0, r = e.length, r)
                  for (let u = 0; u < r; u++) {
                     const h = e[u];
                     h(l), o.has(h) && (a.schedule(h), t())
                  }
               i = !1, s && (s = !1, a.process(l))
            }
         };
      return a
   }
   const Ug = ["prepare", "read", "update", "preRender", "render", "postRender"],
      woe = 40;

   function boe(t, e) {
      let n = !1,
         r = !0;
      const i = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
         },
         s = Ug.reduce((d, p) => (d[p] = Eoe(() => n = !0), d), {}),
         o = d => s[d].process(i),
         a = () => {
            const d = performance.now();
            n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(d - i.timestamp, woe), 1), i.timestamp = d, i.isProcessing = !0, Ug.forEach(o), i.isProcessing = !1, n && e && (r = !1, t(a))
         },
         l = () => {
            n = !0, r = !0, i.isProcessing || t(a)
         };
      return {
         schedule: Ug.reduce((d, p) => {
            const m = s[p];
            return d[p] = (v, _ = !1, x = !1) => (n || l(), m.schedule(v, _, x)), d
         }, {}),
         cancel: d => Ug.forEach(p => s[p].cancel(d)),
         state: i,
         steps: s
      }
   }
   const {
      schedule: En,
      cancel: Oo,
      state: wr,
      steps: r1
   } = boe(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Nn, !0);

   function cB(t, e) {
      const n = "pointer" + (e ? "enter" : "leave"),
         r = "onHover" + (e ? "Start" : "End"),
         i = (s, o) => {
            if (s.type === "touch" || lU()) return;
            const a = t.getProps();
            t.animationState && a.whileHover && t.animationState.setActive("whileHover", e), a[r] && En.update(() => a[r](s, o))
         };
      return To(t.current, n, i, {
         passive: !t.getProps()[r]
      })
   }
   class Coe extends Ya {
      mount() {
         this.unmount = Pa(cB(this.node, !0), cB(this.node, !1))
      }
      unmount() {}
   }
   class Toe extends Ya {
      constructor() {
         super(...arguments), this.isActive = !1
      }
      onFocus() {
         let e = !1;
         try {
            e = this.node.current.matches(":focus-visible")
         } catch {
            e = !0
         }!e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
      }
      onBlur() {
         !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
      }
      mount() {
         this.unmount = Pa(wo(this.node.current, "focus", () => this.onFocus()), wo(this.node.current, "blur", () => this.onBlur()))
      }
      unmount() {}
   }
   const uU = (t, e) => e ? t === e ? !0 : uU(t, e.parentElement) : !1;

   function i1(t, e) {
      if (!e) return;
      const n = new PointerEvent("pointer" + t);
      e(n, gy(n))
   }
   class Roe extends Ya {
      constructor() {
         super(...arguments), this.removeStartListeners = Nn, this.removeEndListeners = Nn, this.removeAccessibleListeners = Nn, this.startPointerPress = (e, n) => {
            if (this.removeEndListeners(), this.isPressing) return;
            const r = this.node.getProps(),
               s = To(window, "pointerup", (a, l) => {
                  if (!this.checkPressEnd()) return;
                  const {
                     onTap: u,
                     onTapCancel: h
                  } = this.node.getProps();
                  En.update(() => {
                     uU(this.node.current, a.target) ? u && u(a, l) : h && h(a, l)
                  })
               }, {
                  passive: !(r.onTap || r.onPointerUp)
               }),
               o = To(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
                  passive: !(r.onTapCancel || r.onPointerCancel)
               });
            this.removeEndListeners = Pa(s, o), this.startPress(e, n)
         }, this.startAccessiblePress = () => {
            const e = s => {
                  if (s.key !== "Enter" || this.isPressing) return;
                  const o = a => {
                     a.key !== "Enter" || !this.checkPressEnd() || i1("up", (l, u) => {
                        const {
                           onTap: h
                        } = this.node.getProps();
                        h && En.update(() => h(l, u))
                     })
                  };
                  this.removeEndListeners(), this.removeEndListeners = wo(this.node.current, "keyup", o), i1("down", (a, l) => {
                     this.startPress(a, l)
                  })
               },
               n = wo(this.node.current, "keydown", e),
               r = () => {
                  this.isPressing && i1("cancel", (s, o) => this.cancelPress(s, o))
               },
               i = wo(this.node.current, "blur", r);
            this.removeAccessibleListeners = Pa(n, i)
         }
      }
      startPress(e, n) {
         this.isPressing = !0;
         const {
            onTapStart: r,
            whileTap: i
         } = this.node.getProps();
         i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && En.update(() => r(e, n))
      }
      checkPressEnd() {
         return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !lU()
      }
      cancelPress(e, n) {
         if (!this.checkPressEnd()) return;
         const {
            onTapCancel: r
         } = this.node.getProps();
         r && En.update(() => r(e, n))
      }
      mount() {
         const e = this.node.getProps(),
            n = To(this.node.current, "pointerdown", this.startPointerPress, {
               passive: !(e.onTapStart || e.onPointerStart)
            }),
            r = wo(this.node.current, "focus", this.startAccessiblePress);
         this.removeStartListeners = Pa(n, r)
      }
      unmount() {
         this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
      }
   }
   const _S = new WeakMap,
      s1 = new WeakMap,
      Poe = t => {
         const e = _S.get(t.target);
         e && e(t)
      },
      Boe = t => {
         t.forEach(Poe)
      };

   function Ioe({
      root: t,
      ...e
   }) {
      const n = t || document;
      s1.has(n) || s1.set(n, {});
      const r = s1.get(n),
         i = JSON.stringify(e);
      return r[i] || (r[i] = new IntersectionObserver(Boe, {
         root: t,
         ...e
      })), r[i]
   }

   function Loe(t, e, n) {
      const r = Ioe(e);
      return _S.set(t, n), r.observe(t), () => {
         _S.delete(t), r.unobserve(t)
      }
   }
   const Doe = {
      some: 0,
      all: 1
   };
   class Foe extends Ya {
      constructor() {
         super(...arguments), this.hasEnteredView = !1, this.isInView = !1
      }
      startObserver() {
         this.unmount();
         const {
            viewport: e = {}
         } = this.node.getProps(), {
            root: n,
            margin: r,
            amount: i = "some",
            once: s
         } = e, o = {
            root: n ? n.current : void 0,
            rootMargin: r,
            threshold: typeof i == "number" ? i : Doe[i]
         }, a = l => {
            const {
               isIntersecting: u
            } = l;
            if (this.isInView === u || (this.isInView = u, s && !u && this.hasEnteredView)) return;
            u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u);
            const {
               onViewportEnter: h,
               onViewportLeave: d
            } = this.node.getProps(), p = u ? h : d;
            p && p(l)
         };
         return Loe(this.node.current, o, a)
      }
      mount() {
         this.startObserver()
      }
      update() {
         if (typeof IntersectionObserver > "u") return;
         const {
            props: e,
            prevProps: n
         } = this.node;
         ["amount", "margin", "root"].some(Ooe(e, n)) && this.startObserver()
      }
      unmount() {}
   }

   function Ooe({
      viewport: t = {}
   }, {
      viewport: e = {}
   } = {}) {
      return n => t[n] !== e[n]
   }
   const Noe = {
      inView: {
         Feature: Foe
      },
      tap: {
         Feature: Roe
      },
      focus: {
         Feature: Toe
      },
      hover: {
         Feature: Coe
      }
   };

   function cU(t, e) {
      if (!Array.isArray(e)) return !1;
      const n = e.length;
      if (n !== t.length) return !1;
      for (let r = 0; r < n; r++)
         if (e[r] !== t[r]) return !1;
      return !0
   }

   function Uoe(t) {
      const e = {};
      return t.values.forEach((n, r) => e[r] = n.get()), e
   }

   function koe(t) {
      const e = {};
      return t.values.forEach((n, r) => e[r] = n.getVelocity()), e
   }

   function vy(t, e, n) {
      const r = t.getProps();
      return pw(r, e, n !== void 0 ? n : r.custom, Uoe(t), koe(t))
   }
   const Hoe = "framerAppearId",
      Goe = "data-" + hw(Hoe);
   let zoe = Nn,
      mw = Nn;
   const Ba = t => t * 1e3,
      Ro = t => t / 1e3,
      Voe = {
         current: !1
      },
      fU = t => Array.isArray(t) && typeof t[0] == "number";

   function hU(t) {
      return !!(!t || typeof t == "string" && dU[t] || fU(t) || Array.isArray(t) && t.every(hU))
   }
   const Xh = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`,
      dU = {
         linear: "linear",
         ease: "ease",
         easeIn: "ease-in",
         easeOut: "ease-out",
         easeInOut: "ease-in-out",
         circIn: Xh([0, .65, .55, 1]),
         circOut: Xh([.55, 0, 1, .45]),
         backIn: Xh([.31, .01, .66, -.59]),
         backOut: Xh([.33, 1.53, .69, .99])
      };

   function pU(t) {
      if (t) return fU(t) ? Xh(t) : Array.isArray(t) ? t.map(pU) : dU[t]
   }

   function Woe(t, e, n, {
      delay: r = 0,
      duration: i,
      repeat: s = 0,
      repeatType: o = "loop",
      ease: a,
      times: l
   } = {}) {
      const u = {
         [e]: n
      };
      l && (u.offset = l);
      const h = pU(a);
      return Array.isArray(h) && (u.easing = h), t.animate(u, {
         delay: r,
         duration: i,
         easing: Array.isArray(h) ? "linear" : h,
         fill: "both",
         iterations: s + 1,
         direction: o === "reverse" ? "alternate" : "normal"
      })
   }

   function joe(t, {
      repeat: e,
      repeatType: n = "loop"
   }) {
      const r = e && n !== "loop" && e % 2 === 1 ? 0 : t.length - 1;
      return t[r]
   }
   const mU = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t,
      $oe = 1e-7,
      Xoe = 12;

   function Joe(t, e, n, r, i) {
      let s, o, a = 0;
      do o = e + (n - e) / 2, s = mU(o, r, i) - t, s > 0 ? n = o : e = o; while (Math.abs(s) > $oe && ++a < Xoe);
      return o
   }

   function Ep(t, e, n, r) {
      if (t === e && n === r) return Nn;
      const i = s => Joe(s, 0, 1, t, n);
      return s => s === 0 || s === 1 ? s : mU(i(s), e, r)
   }
   const Koe = Ep(.42, 0, 1, 1),
      Yoe = Ep(0, 0, .58, 1),
      gU = Ep(.42, 0, .58, 1),
      Qoe = t => Array.isArray(t) && typeof t[0] != "number",
      vU = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,
      yU = t => e => 1 - t(1 - e),
      xU = t => 1 - Math.sin(Math.acos(t)),
      gw = yU(xU),
      Zoe = vU(gw),
      _U = Ep(.33, 1.53, .69, .99),
      vw = yU(_U),
      qoe = vU(vw),
      eae = t => (t *= 2) < 1 ? .5 * vw(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))),
      tae = {
         linear: Nn,
         easeIn: Koe,
         easeInOut: gU,
         easeOut: Yoe,
         circIn: xU,
         circInOut: Zoe,
         circOut: gw,
         backIn: vw,
         backInOut: qoe,
         backOut: _U,
         anticipate: eae
      },
      fB = t => {
         if (Array.isArray(t)) {
            mw(t.length === 4);
            const [e, n, r, i] = t;
            return Ep(e, n, r, i)
         } else if (typeof t == "string") return tae[t];
         return t
      },
      yw = (t, e) => n => !!(Sp(n) && eoe.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)),
      AU = (t, e, n) => r => {
         if (!Sp(r)) return r;
         const [i, s, o, a] = r.match(my);
         return {
            [t]: parseFloat(i),
            [e]: parseFloat(s),
            [n]: parseFloat(o),
            alpha: a !== void 0 ? parseFloat(a) : 1
         }
      },
      nae = t => ka(0, 255, t),
      o1 = {
         ...fu,
         transform: t => Math.round(nae(t))
      },
      Nl = {
         test: yw("rgb", "red"),
         parse: AU("red", "green", "blue"),
         transform: ({
            red: t,
            green: e,
            blue: n,
            alpha: r = 1
         }) => "rgba(" + o1.transform(t) + ", " + o1.transform(e) + ", " + o1.transform(n) + ", " + pd(dd.transform(r)) + ")"
      };

   function rae(t) {
      let e = "",
         n = "",
         r = "",
         i = "";
      return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, r += r, i += i), {
         red: parseInt(e, 16),
         green: parseInt(n, 16),
         blue: parseInt(r, 16),
         alpha: i ? parseInt(i, 16) / 255 : 1
      }
   }
   const AS = {
         test: yw("#"),
         parse: rae,
         transform: Nl.transform
      },
      Gc = {
         test: yw("hsl", "hue"),
         parse: AU("hue", "saturation", "lightness"),
         transform: ({
            hue: t,
            saturation: e,
            lightness: n,
            alpha: r = 1
         }) => "hsla(" + Math.round(t) + ", " + $s.transform(pd(e)) + ", " + $s.transform(pd(n)) + ", " + pd(dd.transform(r)) + ")"
      },
      Nr = {
         test: t => Nl.test(t) || AS.test(t) || Gc.test(t),
         parse: t => Nl.test(t) ? Nl.parse(t) : Gc.test(t) ? Gc.parse(t) : AS.parse(t),
         transform: t => Sp(t) ? t : t.hasOwnProperty("red") ? Nl.transform(t) : Gc.transform(t)
      },
      Rn = (t, e, n) => -n * t + n * e + t;

   function a1(t, e, n) {
      return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
   }

   function iae({
      hue: t,
      saturation: e,
      lightness: n,
      alpha: r
   }) {
      t /= 360, e /= 100, n /= 100;
      let i = 0,
         s = 0,
         o = 0;
      if (!e) i = s = o = n;
      else {
         const a = n < .5 ? n * (1 + e) : n + e - n * e,
            l = 2 * n - a;
         i = a1(l, a, t + 1 / 3), s = a1(l, a, t), o = a1(l, a, t - 1 / 3)
      }
      return {
         red: Math.round(i * 255),
         green: Math.round(s * 255),
         blue: Math.round(o * 255),
         alpha: r
      }
   }
   const l1 = (t, e, n) => {
         const r = t * t;
         return Math.sqrt(Math.max(0, n * (e * e - r) + r))
      },
      sae = [AS, Nl, Gc],
      oae = t => sae.find(e => e.test(t));

   function hB(t) {
      const e = oae(t);
      let n = e.parse(t);
      return e === Gc && (n = iae(n)), n
   }
   const SU = (t, e) => {
      const n = hB(t),
         r = hB(e),
         i = {
            ...n
         };
      return s => (i.red = l1(n.red, r.red, s), i.green = l1(n.green, r.green, s), i.blue = l1(n.blue, r.blue, s), i.alpha = Rn(n.alpha, r.alpha, s), Nl.transform(i))
   };

   function aae(t) {
      var e, n;
      return isNaN(t) && Sp(t) && (((e = t.match(my)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(JN)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
   }
   const MU = {
         regex: Zse,
         countKey: "Vars",
         token: "${v}",
         parse: Nn
      },
      EU = {
         regex: JN,
         countKey: "Colors",
         token: "${c}",
         parse: Nr.parse
      },
      wU = {
         regex: my,
         countKey: "Numbers",
         token: "${n}",
         parse: fu.parse
      };

   function u1(t, {
      regex: e,
      countKey: n,
      token: r,
      parse: i
   }) {
      const s = t.tokenised.match(e);
      s && (t["num" + n] = s.length, t.tokenised = t.tokenised.replace(e, r), t.values.push(...s.map(i)))
   }

   function Q0(t) {
      const e = t.toString(),
         n = {
            value: e,
            tokenised: e,
            values: [],
            numVars: 0,
            numColors: 0,
            numNumbers: 0
         };
      return n.value.includes("var(--") && u1(n, MU), u1(n, EU), u1(n, wU), n
   }

   function bU(t) {
      return Q0(t).values
   }

   function CU(t) {
      const {
         values: e,
         numColors: n,
         numVars: r,
         tokenised: i
      } = Q0(t), s = e.length;
      return o => {
         let a = i;
         for (let l = 0; l < s; l++) l < r ? a = a.replace(MU.token, o[l]) : l < r + n ? a = a.replace(EU.token, Nr.transform(o[l])) : a = a.replace(wU.token, pd(o[l]));
         return a
      }
   }
   const lae = t => typeof t == "number" ? 0 : t;

   function uae(t) {
      const e = bU(t);
      return CU(t)(e.map(lae))
   }
   const Ha = {
         test: aae,
         parse: bU,
         createTransformer: CU,
         getAnimatableNone: uae
      },
      TU = (t, e) => n => `${n>0?e:t}`;

   function RU(t, e) {
      return typeof t == "number" ? n => Rn(t, e, n) : Nr.test(t) ? SU(t, e) : t.startsWith("var(") ? TU(t, e) : BU(t, e)
   }
   const PU = (t, e) => {
         const n = [...t],
            r = n.length,
            i = t.map((s, o) => RU(s, e[o]));
         return s => {
            for (let o = 0; o < r; o++) n[o] = i[o](s);
            return n
         }
      },
      cae = (t, e) => {
         const n = {
               ...t,
               ...e
            },
            r = {};
         for (const i in n) t[i] !== void 0 && e[i] !== void 0 && (r[i] = RU(t[i], e[i]));
         return i => {
            for (const s in r) n[s] = r[s](i);
            return n
         }
      },
      BU = (t, e) => {
         const n = Ha.createTransformer(e),
            r = Q0(t),
            i = Q0(e);
         return r.numVars === i.numVars && r.numColors === i.numColors && r.numNumbers >= i.numNumbers ? Pa(PU(r.values, i.values), n) : TU(t, e)
      },
      Yd = (t, e, n) => {
         const r = e - t;
         return r === 0 ? 1 : (n - t) / r
      },
      dB = (t, e) => n => Rn(t, e, n);

   function fae(t) {
      return typeof t == "number" ? dB : typeof t == "string" ? Nr.test(t) ? SU : BU : Array.isArray(t) ? PU : typeof t == "object" ? cae : dB
   }

   function hae(t, e, n) {
      const r = [],
         i = n || fae(t[0]),
         s = t.length - 1;
      for (let o = 0; o < s; o++) {
         let a = i(t[o], t[o + 1]);
         if (e) {
            const l = Array.isArray(e) ? e[o] || Nn : e;
            a = Pa(l, a)
         }
         r.push(a)
      }
      return r
   }

   function IU(t, e, {
      clamp: n = !0,
      ease: r,
      mixer: i
   } = {}) {
      const s = t.length;
      if (mw(s === e.length), s === 1) return () => e[0];
      t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
      const o = hae(e, r, i),
         a = o.length,
         l = u => {
            let h = 0;
            if (a > 1)
               for (; h < t.length - 2 && !(u < t[h + 1]); h++);
            const d = Yd(t[h], t[h + 1], u);
            return o[h](d)
         };
      return n ? u => l(ka(t[0], t[s - 1], u)) : l
   }

   function dae(t, e) {
      const n = t[t.length - 1];
      for (let r = 1; r <= e; r++) {
         const i = Yd(0, e, r);
         t.push(Rn(n, 1, i))
      }
   }

   function pae(t) {
      const e = [0];
      return dae(e, t.length - 1), e
   }

   function mae(t, e) {
      return t.map(n => n * e)
   }

   function gae(t, e) {
      return t.map(() => e || gU).splice(0, t.length - 1)
   }

   function Z0({
      duration: t = 300,
      keyframes: e,
      times: n,
      ease: r = "easeInOut"
   }) {
      const i = Qoe(r) ? r.map(fB) : fB(r),
         s = {
            done: !1,
            value: e[0]
         },
         o = mae(n && n.length === e.length ? n : pae(e), t),
         a = IU(o, e, {
            ease: Array.isArray(i) ? i : gae(e, i)
         });
      return {
         calculatedDuration: t,
         next: l => (s.value = a(l), s.done = l >= t, s)
      }
   }

   function LU(t, e) {
      return e ? t * (1e3 / e) : 0
   }
   const vae = 5;

   function DU(t, e, n) {
      const r = Math.max(e - vae, 0);
      return LU(n - t(r), e - r)
   }
   const c1 = .001,
      yae = .01,
      pB = 10,
      xae = .05,
      _ae = 1;

   function Aae({
      duration: t = 800,
      bounce: e = .25,
      velocity: n = 0,
      mass: r = 1
   }) {
      let i, s;
      zoe(t <= Ba(pB));
      let o = 1 - e;
      o = ka(xae, _ae, o), t = ka(yae, pB, Ro(t)), o < 1 ? (i = u => {
         const h = u * o,
            d = h * t,
            p = h - n,
            m = SS(u, o),
            v = Math.exp(-d);
         return c1 - p / m * v
      }, s = u => {
         const d = u * o * t,
            p = d * n + n,
            m = Math.pow(o, 2) * Math.pow(u, 2) * t,
            v = Math.exp(-d),
            _ = SS(Math.pow(u, 2), o);
         return (-i(u) + c1 > 0 ? -1 : 1) * ((p - m) * v) / _
      }) : (i = u => {
         const h = Math.exp(-u * t),
            d = (u - n) * t + 1;
         return -c1 + h * d
      }, s = u => {
         const h = Math.exp(-u * t),
            d = (n - u) * (t * t);
         return h * d
      });
      const a = 5 / t,
         l = Mae(i, s, a);
      if (t = Ba(t), isNaN(l)) return {
         stiffness: 100,
         damping: 10,
         duration: t
      }; {
         const u = Math.pow(l, 2) * r;
         return {
            stiffness: u,
            damping: o * 2 * Math.sqrt(r * u),
            duration: t
         }
      }
   }
   const Sae = 12;

   function Mae(t, e, n) {
      let r = n;
      for (let i = 1; i < Sae; i++) r = r - t(r) / e(r);
      return r
   }

   function SS(t, e) {
      return t * Math.sqrt(1 - e * e)
   }
   const Eae = ["duration", "bounce"],
      wae = ["stiffness", "damping", "mass"];

   function mB(t, e) {
      return e.some(n => t[n] !== void 0)
   }

   function bae(t) {
      let e = {
         velocity: 0,
         stiffness: 100,
         damping: 10,
         mass: 1,
         isResolvedFromDuration: !1,
         ...t
      };
      if (!mB(t, wae) && mB(t, Eae)) {
         const n = Aae(t);
         e = {
            ...e,
            ...n,
            velocity: 0,
            mass: 1
         }, e.isResolvedFromDuration = !0
      }
      return e
   }

   function FU({
      keyframes: t,
      restDelta: e,
      restSpeed: n,
      ...r
   }) {
      const i = t[0],
         s = t[t.length - 1],
         o = {
            done: !1,
            value: i
         },
         {
            stiffness: a,
            damping: l,
            mass: u,
            velocity: h,
            duration: d,
            isResolvedFromDuration: p
         } = bae(r),
         m = h ? -Ro(h) : 0,
         v = l / (2 * Math.sqrt(a * u)),
         _ = s - i,
         x = Ro(Math.sqrt(a / u)),
         g = Math.abs(_) < 5;
      n || (n = g ? .01 : 2), e || (e = g ? .005 : .5);
      let S;
      if (v < 1) {
         const A = SS(x, v);
         S = E => {
            const C = Math.exp(-v * x * E);
            return s - C * ((m + v * x * _) / A * Math.sin(A * E) + _ * Math.cos(A * E))
         }
      } else if (v === 1) S = A => s - Math.exp(-x * A) * (_ + (m + x * _) * A);
      else {
         const A = x * Math.sqrt(v * v - 1);
         S = E => {
            const C = Math.exp(-v * x * E),
               R = Math.min(A * E, 300);
            return s - C * ((m + v * x * _) * Math.sinh(R) + A * _ * Math.cosh(R)) / A
         }
      }
      return {
         calculatedDuration: p && d || null,
         next: A => {
            const E = S(A);
            if (p) o.done = A >= d;
            else {
               let C = m;
               A !== 0 && (v < 1 ? C = DU(S, A, E) : C = 0);
               const R = Math.abs(C) <= n,
                  B = Math.abs(s - E) <= e;
               o.done = R && B
            }
            return o.value = o.done ? s : E, o
         }
      }
   }

   function gB({
      keyframes: t,
      velocity: e = 0,
      power: n = .8,
      timeConstant: r = 325,
      bounceDamping: i = 10,
      bounceStiffness: s = 500,
      modifyTarget: o,
      min: a,
      max: l,
      restDelta: u = .5,
      restSpeed: h
   }) {
      const d = t[0],
         p = {
            done: !1,
            value: d
         },
         m = D => a !== void 0 && D < a || l !== void 0 && D > l,
         v = D => a === void 0 ? l : l === void 0 || Math.abs(a - D) < Math.abs(l - D) ? a : l;
      let _ = n * e;
      const x = d + _,
         g = o === void 0 ? x : o(x);
      g !== x && (_ = g - d);
      const S = D => -_ * Math.exp(-D / r),
         A = D => g + S(D),
         E = D => {
            const T = S(D),
               I = A(D);
            p.done = Math.abs(T) <= u, p.value = p.done ? g : I
         };
      let C, R;
      const B = D => {
         m(p.value) && (C = D, R = FU({
            keyframes: [p.value, v(p.value)],
            velocity: DU(A, D, p.value),
            damping: i,
            stiffness: s,
            restDelta: u,
            restSpeed: h
         }))
      };
      return B(0), {
         calculatedDuration: null,
         next: D => {
            let T = !1;
            return !R && C === void 0 && (T = !0, E(D), B(D)), C !== void 0 && D > C ? R.next(D - C) : (!T && E(D), p)
         }
      }
   }
   const Cae = t => {
         const e = ({
            timestamp: n
         }) => t(n);
         return {
            start: () => En.update(e, !0),
            stop: () => Oo(e),
            now: () => wr.isProcessing ? wr.timestamp : performance.now()
         }
      },
      vB = 2e4;

   function yB(t) {
      let e = 0;
      const n = 50;
      let r = t.next(e);
      for (; !r.done && e < vB;) e += n, r = t.next(e);
      return e >= vB ? 1 / 0 : e
   }
   const Tae = {
      decay: gB,
      inertia: gB,
      tween: Z0,
      keyframes: Z0,
      spring: FU
   };

   function q0({
      autoplay: t = !0,
      delay: e = 0,
      driver: n = Cae,
      keyframes: r,
      type: i = "keyframes",
      repeat: s = 0,
      repeatDelay: o = 0,
      repeatType: a = "loop",
      onPlay: l,
      onStop: u,
      onComplete: h,
      onUpdate: d,
      ...p
   }) {
      let m = 1,
         v = !1,
         _, x;
      const g = () => {
         x = new Promise(X => {
            _ = X
         })
      };
      g();
      let S;
      const A = Tae[i] || Z0;
      let E;
      A !== Z0 && typeof r[0] != "number" && (E = IU([0, 100], r, {
         clamp: !1
      }), r = [0, 100]);
      const C = A({
         ...p,
         keyframes: r
      });
      let R;
      a === "mirror" && (R = A({
         ...p,
         keyframes: [...r].reverse(),
         velocity: -(p.velocity || 0)
      }));
      let B = "idle",
         D = null,
         T = null,
         I = null;
      C.calculatedDuration === null && s && (C.calculatedDuration = yB(C));
      const {
         calculatedDuration: N
      } = C;
      let q = 1 / 0,
         K = 1 / 0;
      N !== null && (q = N + o, K = q * (s + 1) - o);
      let Z = 0;
      const te = X => {
            if (T === null) return;
            m > 0 && (T = Math.min(T, X)), m < 0 && (T = Math.min(X - K / m, T)), D !== null ? Z = D : Z = Math.round(X - T) * m;
            const Q = Z - e * (m >= 0 ? 1 : -1),
               _e = m >= 0 ? Q < 0 : Q > K;
            Z = Math.max(Q, 0), B === "finished" && D === null && (Z = K);
            let Me = Z,
               we = C;
            if (s) {
               const Pt = Z / q;
               let kt = Math.floor(Pt),
                  $e = Pt % 1;
               !$e && Pt >= 1 && ($e = 1), $e === 1 && kt--, kt = Math.min(kt, s + 1);
               const J = !!(kt % 2);
               J && (a === "reverse" ? ($e = 1 - $e, o && ($e -= o / q)) : a === "mirror" && (we = R));
               let Ce = ka(0, 1, $e);
               Z > K && (Ce = a === "reverse" && J ? 1 : 0), Me = Ce * q
            }
            const Ee = _e ? {
               done: !1,
               value: r[0]
            } : we.next(Me);
            E && (Ee.value = E(Ee.value));
            let {
               done: Ue
            } = Ee;
            !_e && N !== null && (Ue = m >= 0 ? Z >= K : Z <= 0);
            const Qe = D === null && (B === "finished" || B === "running" && Ue);
            return d && d(Ee.value), Qe && G(), Ee
         },
         se = () => {
            S && S.stop(), S = void 0
         },
         oe = () => {
            B = "idle", se(), _(), g(), T = I = null
         },
         G = () => {
            B = "finished", h && h(), se(), _()
         },
         ne = () => {
            if (v) return;
            S || (S = n(te));
            const X = S.now();
            l && l(), D !== null ? T = X - D : (!T || B === "finished") && (T = X), B === "finished" && g(), I = T, D = null, B = "running", S.start()
         };
      t && ne();
      const Y = {
         then(X, Q) {
            return x.then(X, Q)
         },
         get time() {
            return Ro(Z)
         },
         set time(X) {
            X = Ba(X), Z = X, D !== null || !S || m === 0 ? D = X : T = S.now() - X / m
         },
         get duration() {
            const X = C.calculatedDuration === null ? yB(C) : C.calculatedDuration;
            return Ro(X)
         },
         get speed() {
            return m
         },
         set speed(X) {
            X === m || !S || (m = X, Y.time = Ro(Z))
         },
         get state() {
            return B
         },
         play: ne,
         pause: () => {
            B = "paused", D = Z
         },
         stop: () => {
            v = !0, B !== "idle" && (B = "idle", u && u(), oe())
         },
         cancel: () => {
            I !== null && te(I), oe()
         },
         complete: () => {
            B = "finished"
         },
         sample: X => (T = 0, te(X))
      };
      return Y
   }

   function Rae(t) {
      let e;
      return () => (e === void 0 && (e = t()), e)
   }
   const Pae = Rae(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
      Bae = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"]),
      kg = 10,
      Iae = 2e4,
      Lae = (t, e) => e.type === "spring" || t === "backgroundColor" || !hU(e.ease);

   function Dae(t, e, {
      onUpdate: n,
      onComplete: r,
      ...i
   }) {
      if (!(Pae() && Bae.has(e) && !i.repeatDelay && i.repeatType !== "mirror" && i.damping !== 0 && i.type !== "inertia")) return !1;
      let o = !1,
         a, l;
      const u = () => {
         l = new Promise(S => {
            a = S
         })
      };
      u();
      let {
         keyframes: h,
         duration: d = 300,
         ease: p,
         times: m
      } = i;
      if (Lae(e, i)) {
         const S = q0({
            ...i,
            repeat: 0,
            delay: 0
         });
         let A = {
            done: !1,
            value: h[0]
         };
         const E = [];
         let C = 0;
         for (; !A.done && C < Iae;) A = S.sample(C), E.push(A.value), C += kg;
         m = void 0, h = E, d = C - kg, p = "linear"
      }
      const v = Woe(t.owner.current, e, h, {
            ...i,
            duration: d,
            ease: p,
            times: m
         }),
         _ = () => v.cancel(),
         x = () => {
            En.update(_), a(), u()
         };
      return v.onfinish = () => {
         t.set(joe(h, i)), r && r(), x()
      }, {
         then(S, A) {
            return l.then(S, A)
         },
         attachTimeline(S) {
            return v.timeline = S, v.onfinish = null, Nn
         },
         get time() {
            return Ro(v.currentTime || 0)
         },
         set time(S) {
            v.currentTime = Ba(S)
         },
         get speed() {
            return v.playbackRate
         },
         set speed(S) {
            v.playbackRate = S
         },
         get duration() {
            return Ro(d)
         },
         play: () => {
            o || (v.play(), Oo(_))
         },
         pause: () => v.pause(),
         stop: () => {
            if (o = !0, v.playState === "idle") return;
            const {
               currentTime: S
            } = v;
            if (S) {
               const A = q0({
                  ...i,
                  autoplay: !1
               });
               t.setWithVelocity(A.sample(S - kg).value, A.sample(S).value, kg)
            }
            x()
         },
         complete: () => v.finish(),
         cancel: x
      }
   }

   function Fae({
      keyframes: t,
      delay: e,
      onUpdate: n,
      onComplete: r
   }) {
      const i = () => (n && n(t[t.length - 1]), r && r(), {
         time: 0,
         speed: 1,
         duration: 0,
         play: Nn,
         pause: Nn,
         stop: Nn,
         then: s => (s(), Promise.resolve()),
         cancel: Nn,
         complete: Nn
      });
      return e ? q0({
         keyframes: [0, 1],
         duration: 0,
         delay: e,
         onComplete: i
      }) : i()
   }
   const Oae = {
         type: "spring",
         stiffness: 500,
         damping: 25,
         restSpeed: 10
      },
      Nae = t => ({
         type: "spring",
         stiffness: 550,
         damping: t === 0 ? 2 * Math.sqrt(550) : 30,
         restSpeed: 10
      }),
      Uae = {
         type: "keyframes",
         duration: .8
      },
      kae = {
         type: "keyframes",
         ease: [.25, .1, .35, 1],
         duration: .3
      },
      Hae = (t, {
         keyframes: e
      }) => e.length > 2 ? Uae : cu.has(t) ? t.startsWith("scale") ? Nae(e[1]) : Oae : kae,
      MS = (t, e) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (Ha.test(e) || e === "0") && !e.startsWith("url(")),
      Gae = new Set(["brightness", "contrast", "saturate", "opacity"]);

   function zae(t) {
      const [e, n] = t.slice(0, -1).split("(");
      if (e === "drop-shadow") return t;
      const [r] = n.match(my) || [];
      if (!r) return t;
      const i = n.replace(r, "");
      let s = Gae.has(e) ? 1 : 0;
      return r !== n && (s *= 100), e + "(" + s + i + ")"
   }
   const Vae = /([a-z-]*)\(.*?\)/g,
      ES = {
         ...Ha,
         getAnimatableNone: t => {
            const e = t.match(Vae);
            return e ? e.map(zae).join(" ") : t
         }
      },
      Wae = {
         ...KN,
         color: Nr,
         backgroundColor: Nr,
         outlineColor: Nr,
         fill: Nr,
         stroke: Nr,
         borderColor: Nr,
         borderTopColor: Nr,
         borderRightColor: Nr,
         borderBottomColor: Nr,
         borderLeftColor: Nr,
         filter: ES,
         WebkitFilter: ES
      },
      xw = t => Wae[t];

   function OU(t, e) {
      let n = xw(t);
      return n !== ES && (n = Ha), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0
   }
   const NU = t => /^0[^.\s]+$/.test(t);

   function jae(t) {
      if (typeof t == "number") return t === 0;
      if (t !== null) return t === "none" || t === "0" || NU(t)
   }

   function $ae(t, e, n, r) {
      const i = MS(e, n);
      let s;
      Array.isArray(n) ? s = [...n] : s = [null, n];
      const o = r.from !== void 0 ? r.from : t.get();
      let a;
      const l = [];
      for (let u = 0; u < s.length; u++) s[u] === null && (s[u] = u === 0 ? o : s[u - 1]), jae(s[u]) && l.push(u), typeof s[u] == "string" && s[u] !== "none" && s[u] !== "0" && (a = s[u]);
      if (i && l.length && a)
         for (let u = 0; u < l.length; u++) {
            const h = l[u];
            s[h] = OU(e, a)
         }
      return s
   }

   function Xae({
      when: t,
      delay: e,
      delayChildren: n,
      staggerChildren: r,
      staggerDirection: i,
      repeat: s,
      repeatType: o,
      repeatDelay: a,
      from: l,
      elapsed: u,
      ...h
   }) {
      return !!Object.keys(h).length
   }

   function UU(t, e) {
      return t[e] || t.default || t
   }
   const _w = (t, e, n, r = {}) => i => {
      const s = UU(r, t) || {},
         o = s.delay || r.delay || 0;
      let {
         elapsed: a = 0
      } = r;
      a = a - Ba(o);
      const l = $ae(e, t, n, s),
         u = l[0],
         h = l[l.length - 1],
         d = MS(t, u),
         p = MS(t, h);
      let m = {
         keyframes: l,
         velocity: e.getVelocity(),
         ease: "easeOut",
         ...s,
         delay: -a,
         onUpdate: v => {
            e.set(v), s.onUpdate && s.onUpdate(v)
         },
         onComplete: () => {
            i(), s.onComplete && s.onComplete()
         }
      };
      if (Xae(s) || (m = {
            ...m,
            ...Hae(t, m)
         }), m.duration && (m.duration = Ba(m.duration)), m.repeatDelay && (m.repeatDelay = Ba(m.repeatDelay)), !d || !p || Voe.current || s.type === !1) return Fae(m);
      if (e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {
         const v = Dae(e, t, m);
         if (v) return v
      }
      return q0(m)
   };

   function ev(t) {
      return !!(ni(t) && t.add)
   }
   const kU = t => /^\-?\d*\.?\d+$/.test(t);

   function Aw(t, e) {
      t.indexOf(e) === -1 && t.push(e)
   }

   function Sw(t, e) {
      const n = t.indexOf(e);
      n > -1 && t.splice(n, 1)
   }
   class Mw {
      constructor() {
         this.subscriptions = []
      }
      add(e) {
         return Aw(this.subscriptions, e), () => Sw(this.subscriptions, e)
      }
      notify(e, n, r) {
         const i = this.subscriptions.length;
         if (i)
            if (i === 1) this.subscriptions[0](e, n, r);
            else
               for (let s = 0; s < i; s++) {
                  const o = this.subscriptions[s];
                  o && o(e, n, r)
               }
      }
      getSize() {
         return this.subscriptions.length
      }
      clear() {
         this.subscriptions.length = 0
      }
   }
   const Jae = t => !isNaN(parseFloat(t));
   class Kae {
      constructor(e, n = {}) {
         this.version = "10.16.0", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (r, i = !0) => {
            this.prev = this.current, this.current = r;
            const {
               delta: s,
               timestamp: o
            } = wr;
            this.lastUpdated !== o && (this.timeDelta = s, this.lastUpdated = o, En.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), i && this.events.renderRequest && this.events.renderRequest.notify(this.current)
         }, this.scheduleVelocityCheck = () => En.postRender(this.velocityCheck), this.velocityCheck = ({
            timestamp: r
         }) => {
            r !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
         }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = Jae(this.current), this.owner = n.owner
      }
      onChange(e) {
         return this.on("change", e)
      }
      on(e, n) {
         this.events[e] || (this.events[e] = new Mw);
         const r = this.events[e].add(n);
         return e === "change" ? () => {
            r(), En.read(() => {
               this.events.change.getSize() || this.stop()
            })
         } : r
      }
      clearListeners() {
         for (const e in this.events) this.events[e].clear()
      }
      attach(e, n) {
         this.passiveEffect = e, this.stopPassiveEffect = n
      }
      set(e, n = !0) {
         !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify)
      }
      setWithVelocity(e, n, r) {
         this.set(n), this.prev = e, this.timeDelta = r
      }
      jump(e) {
         this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
      }
      get() {
         return this.current
      }
      getPrevious() {
         return this.prev
      }
      getVelocity() {
         return this.canTrackVelocity ? LU(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
      }
      start(e) {
         return this.stop(), new Promise(n => {
            this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify()
         }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
         })
      }
      stop() {
         this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
      }
      isAnimating() {
         return !!this.animation
      }
      clearAnimation() {
         delete this.animation
      }
      destroy() {
         this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
      }
   }

   function Af(t, e) {
      return new Kae(t, e)
   }
   const HU = t => e => e.test(t),
      Yae = {
         test: t => t === "auto",
         parse: t => t
      },
      GU = [fu, _t, $s, sa, noe, toe, Yae],
      Oh = t => GU.find(HU(t)),
      Qae = [...GU, Nr, Ha],
      Zae = t => Qae.find(HU(t));

   function qae(t, e, n) {
      t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Af(n))
   }

   function ele(t, e) {
      const n = vy(t, e);
      let {
         transitionEnd: r = {},
         transition: i = {},
         ...s
      } = n ? t.makeTargetAnimatable(n, !1) : {};
      s = {
         ...s,
         ...r
      };
      for (const o in s) {
         const a = goe(s[o]);
         qae(t, o, a)
      }
   }

   function tle(t, e, n) {
      var r, i;
      const s = Object.keys(e).filter(a => !t.hasValue(a)),
         o = s.length;
      if (o)
         for (let a = 0; a < o; a++) {
            const l = s[a],
               u = e[l];
            let h = null;
            Array.isArray(u) && (h = u[0]), h === null && (h = (i = (r = n[l]) !== null && r !== void 0 ? r : t.readValue(l)) !== null && i !== void 0 ? i : e[l]), h != null && (typeof h == "string" && (kU(h) || NU(h)) ? h = parseFloat(h) : !Zae(h) && Ha.test(u) && (h = OU(l, u)), t.addValue(l, Af(h, {
               owner: t
            })), n[l] === void 0 && (n[l] = h), h !== null && t.setBaseTarget(l, h))
         }
   }

   function nle(t, e) {
      return e ? (e[t] || e.default || e).from : void 0
   }

   function rle(t, e, n) {
      const r = {};
      for (const i in t) {
         const s = nle(i, e);
         if (s !== void 0) r[i] = s;
         else {
            const o = n.getValue(i);
            o && (r[i] = o.get())
         }
      }
      return r
   }

   function ile({
      protectedKeys: t,
      needsAnimating: e
   }, n) {
      const r = t.hasOwnProperty(n) && e[n] !== !0;
      return e[n] = !1, r
   }

   function zU(t, e, {
      delay: n = 0,
      transitionOverride: r,
      type: i
   } = {}) {
      let {
         transition: s = t.getDefaultTransition(),
         transitionEnd: o,
         ...a
      } = t.makeTargetAnimatable(e);
      const l = t.getValue("willChange");
      r && (s = r);
      const u = [],
         h = i && t.animationState && t.animationState.getState()[i];
      for (const d in a) {
         const p = t.getValue(d),
            m = a[d];
         if (!p || m === void 0 || h && ile(h, d)) continue;
         const v = {
            delay: n,
            elapsed: 0,
            ...s
         };
         if (window.HandoffAppearAnimations && !p.hasAnimated) {
            const x = t.getProps()[Goe];
            x && (v.elapsed = window.HandoffAppearAnimations(x, d, p, En))
         }
         p.start(_w(d, p, m, t.shouldReduceMotion && cu.has(d) ? {
            type: !1
         } : v));
         const _ = p.animation;
         ev(l) && (l.add(d), _.then(() => l.remove(d))), u.push(_)
      }
      return o && Promise.all(u).then(() => {
         o && ele(t, o)
      }), u
   }

   function wS(t, e, n = {}) {
      const r = vy(t, e, n.custom);
      let {
         transition: i = t.getDefaultTransition() || {}
      } = r || {};
      n.transitionOverride && (i = n.transitionOverride);
      const s = r ? () => Promise.all(zU(t, r, n)) : () => Promise.resolve(),
         o = t.variantChildren && t.variantChildren.size ? (l = 0) => {
            const {
               delayChildren: u = 0,
               staggerChildren: h,
               staggerDirection: d
            } = i;
            return sle(t, e, u + l, h, d, n)
         } : () => Promise.resolve(),
         {
            when: a
         } = i;
      if (a) {
         const [l, u] = a === "beforeChildren" ? [s, o] : [o, s];
         return l().then(() => u())
      } else return Promise.all([s(), o(n.delay)])
   }

   function sle(t, e, n = 0, r = 0, i = 1, s) {
      const o = [],
         a = (t.variantChildren.size - 1) * r,
         l = i === 1 ? (u = 0) => u * r : (u = 0) => a - u * r;
      return Array.from(t.variantChildren).sort(ole).forEach((u, h) => {
         u.notify("AnimationStart", e), o.push(wS(u, e, {
            ...s,
            delay: n + l(h)
         }).then(() => u.notify("AnimationComplete", e)))
      }), Promise.all(o)
   }

   function ole(t, e) {
      return t.sortNodePosition(e)
   }

   function ale(t, e, n = {}) {
      t.notify("AnimationStart", e);
      let r;
      if (Array.isArray(e)) {
         const i = e.map(s => wS(t, s, n));
         r = Promise.all(i)
      } else if (typeof e == "string") r = wS(t, e, n);
      else {
         const i = typeof e == "function" ? vy(t, e, n.custom) : e;
         r = Promise.all(zU(t, i, n))
      }
      return r.then(() => t.notify("AnimationComplete", e))
   }
   const lle = [...iw].reverse(),
      ule = iw.length;

   function cle(t) {
      return e => Promise.all(e.map(({
         animation: n,
         options: r
      }) => ale(t, n, r)))
   }

   function fle(t) {
      let e = cle(t);
      const n = dle();
      let r = !0;
      const i = (l, u) => {
         const h = vy(t, u);
         if (h) {
            const {
               transition: d,
               transitionEnd: p,
               ...m
            } = h;
            l = {
               ...l,
               ...m,
               ...p
            }
         }
         return l
      };

      function s(l) {
         e = l(t)
      }

      function o(l, u) {
         const h = t.getProps(),
            d = t.getVariantContext(!0) || {},
            p = [],
            m = new Set;
         let v = {},
            _ = 1 / 0;
         for (let g = 0; g < ule; g++) {
            const S = lle[g],
               A = n[S],
               E = h[S] !== void 0 ? h[S] : d[S],
               C = Jd(E),
               R = S === u ? A.isActive : null;
            R === !1 && (_ = g);
            let B = E === d[S] && E !== h[S] && C;
            if (B && r && t.manuallyAnimateOnMount && (B = !1), A.protectedKeys = {
                  ...v
               }, !A.isActive && R === null || !E && !A.prevProp || dy(E) || typeof E == "boolean") continue;
            const D = hle(A.prevProp, E);
            let T = D || S === u && A.isActive && !B && C || g > _ && C;
            const I = Array.isArray(E) ? E : [E];
            let N = I.reduce(i, {});
            R === !1 && (N = {});
            const {
               prevResolvedValues: q = {}
            } = A, K = {
               ...q,
               ...N
            }, Z = te => {
               T = !0, m.delete(te), A.needsAnimating[te] = !0
            };
            for (const te in K) {
               const se = N[te],
                  oe = q[te];
               v.hasOwnProperty(te) || (se !== oe ? Y0(se) && Y0(oe) ? !cU(se, oe) || D ? Z(te) : A.protectedKeys[te] = !0 : se !== void 0 ? Z(te) : m.add(te) : se !== void 0 && m.has(te) ? Z(te) : A.protectedKeys[te] = !0)
            }
            A.prevProp = E, A.prevResolvedValues = N, A.isActive && (v = {
               ...v,
               ...N
            }), r && t.blockInitialAnimation && (T = !1), T && !B && p.push(...I.map(te => ({
               animation: te,
               options: {
                  type: S,
                  ...l
               }
            })))
         }
         if (m.size) {
            const g = {};
            m.forEach(S => {
               const A = t.getBaseTarget(S);
               A !== void 0 && (g[S] = A)
            }), p.push({
               animation: g
            })
         }
         let x = !!p.length;
         return r && h.initial === !1 && !t.manuallyAnimateOnMount && (x = !1), r = !1, x ? e(p) : Promise.resolve()
      }

      function a(l, u, h) {
         var d;
         if (n[l].isActive === u) return Promise.resolve();
         (d = t.variantChildren) === null || d === void 0 || d.forEach(m => {
            var v;
            return (v = m.animationState) === null || v === void 0 ? void 0 : v.setActive(l, u)
         }), n[l].isActive = u;
         const p = o(h, l);
         for (const m in n) n[m].protectedKeys = {};
         return p
      }
      return {
         animateChanges: o,
         setActive: a,
         setAnimateFunction: s,
         getState: () => n
      }
   }

   function hle(t, e) {
      return typeof e == "string" ? e !== t : Array.isArray(e) ? !cU(e, t) : !1
   }

   function yl(t = !1) {
      return {
         isActive: t,
         protectedKeys: {},
         needsAnimating: {},
         prevResolvedValues: {}
      }
   }

   function dle() {
      return {
         animate: yl(!0),
         whileInView: yl(),
         whileHover: yl(),
         whileTap: yl(),
         whileDrag: yl(),
         whileFocus: yl(),
         exit: yl()
      }
   }
   class ple extends Ya {
      constructor(e) {
         super(e), e.animationState || (e.animationState = fle(e))
      }
      updateAnimationControlsSubscription() {
         const {
            animate: e
         } = this.node.getProps();
         this.unmount(), dy(e) && (this.unmount = e.subscribe(this.node))
      }
      mount() {
         this.updateAnimationControlsSubscription()
      }
      update() {
         const {
            animate: e
         } = this.node.getProps(), {
            animate: n
         } = this.node.prevProps || {};
         e !== n && this.updateAnimationControlsSubscription()
      }
      unmount() {}
   }
   let mle = 0;
   class gle extends Ya {
      constructor() {
         super(...arguments), this.id = mle++
      }
      update() {
         if (!this.node.presenceContext) return;
         const {
            isPresent: e,
            onExitComplete: n,
            custom: r
         } = this.node.presenceContext, {
            isPresent: i
         } = this.node.prevPresenceContext || {};
         if (!this.node.animationState || e === i) return;
         const s = this.node.animationState.setActive("exit", !e, {
            custom: r ?? this.node.getProps().custom
         });
         n && !e && s.then(() => n(this.id))
      }
      mount() {
         const {
            register: e
         } = this.node.presenceContext || {};
         e && (this.unmount = e(this.id))
      }
      unmount() {}
   }
   const vle = {
         animation: {
            Feature: ple
         },
         exit: {
            Feature: gle
         }
      },
      xB = (t, e) => Math.abs(t - e);

   function yle(t, e) {
      const n = xB(t.x, e.x),
         r = xB(t.y, e.y);
      return Math.sqrt(n ** 2 + r ** 2)
   }
   class VU {
      constructor(e, n, {
         transformPagePoint: r
      } = {}) {
         if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
               if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
               const u = h1(this.lastMoveEventInfo, this.history),
                  h = this.startEvent !== null,
                  d = yle(u.offset, {
                     x: 0,
                     y: 0
                  }) >= 3;
               if (!h && !d) return;
               const {
                  point: p
               } = u, {
                  timestamp: m
               } = wr;
               this.history.push({
                  ...p,
                  timestamp: m
               });
               const {
                  onStart: v,
                  onMove: _
               } = this.handlers;
               h || (v && v(this.lastMoveEvent, u), this.startEvent = this.lastMoveEvent), _ && _(this.lastMoveEvent, u)
            }, this.handlePointerMove = (u, h) => {
               this.lastMoveEvent = u, this.lastMoveEventInfo = f1(h, this.transformPagePoint), En.update(this.updatePoint, !0)
            }, this.handlePointerUp = (u, h) => {
               if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
               const {
                  onEnd: d,
                  onSessionEnd: p
               } = this.handlers, m = h1(u.type === "pointercancel" ? this.lastMoveEventInfo : f1(h, this.transformPagePoint), this.history);
               this.startEvent && d && d(u, m), p && p(u, m)
            }, !sU(e)) return;
         this.handlers = n, this.transformPagePoint = r;
         const i = gy(e),
            s = f1(i, this.transformPagePoint),
            {
               point: o
            } = s,
            {
               timestamp: a
            } = wr;
         this.history = [{
            ...o,
            timestamp: a
         }];
         const {
            onSessionStart: l
         } = n;
         l && l(e, h1(s, this.history)), this.removeListeners = Pa(To(window, "pointermove", this.handlePointerMove), To(window, "pointerup", this.handlePointerUp), To(window, "pointercancel", this.handlePointerUp))
      }
      updateHandlers(e) {
         this.handlers = e
      }
      end() {
         this.removeListeners && this.removeListeners(), Oo(this.updatePoint)
      }
   }

   function f1(t, e) {
      return e ? {
         point: e(t.point)
      } : t
   }

   function _B(t, e) {
      return {
         x: t.x - e.x,
         y: t.y - e.y
      }
   }

   function h1({
      point: t
   }, e) {
      return {
         point: t,
         delta: _B(t, WU(e)),
         offset: _B(t, xle(e)),
         velocity: _le(e, .1)
      }
   }

   function xle(t) {
      return t[0]
   }

   function WU(t) {
      return t[t.length - 1]
   }

   function _le(t, e) {
      if (t.length < 2) return {
         x: 0,
         y: 0
      };
      let n = t.length - 1,
         r = null;
      const i = WU(t);
      for (; n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > Ba(e)));) n--;
      if (!r) return {
         x: 0,
         y: 0
      };
      const s = Ro(i.timestamp - r.timestamp);
      if (s === 0) return {
         x: 0,
         y: 0
      };
      const o = {
         x: (i.x - r.x) / s,
         y: (i.y - r.y) / s
      };
      return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
   }

   function Mi(t) {
      return t.max - t.min
   }

   function bS(t, e = 0, n = .01) {
      return Math.abs(t - e) <= n
   }

   function AB(t, e, n, r = .5) {
      t.origin = r, t.originPoint = Rn(e.min, e.max, t.origin), t.scale = Mi(n) / Mi(e), (bS(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = Rn(n.min, n.max, t.origin) - t.originPoint, (bS(t.translate) || isNaN(t.translate)) && (t.translate = 0)
   }

   function md(t, e, n, r) {
      AB(t.x, e.x, n.x, r ? r.originX : void 0), AB(t.y, e.y, n.y, r ? r.originY : void 0)
   }

   function SB(t, e, n) {
      t.min = n.min + e.min, t.max = t.min + Mi(e)
   }

   function Ale(t, e, n) {
      SB(t.x, e.x, n.x), SB(t.y, e.y, n.y)
   }

   function MB(t, e, n) {
      t.min = e.min - n.min, t.max = t.min + Mi(e)
   }

   function gd(t, e, n) {
      MB(t.x, e.x, n.x), MB(t.y, e.y, n.y)
   }

   function Sle(t, {
      min: e,
      max: n
   }, r) {
      return e !== void 0 && t < e ? t = r ? Rn(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Rn(n, t, r.max) : Math.min(t, n)), t
   }

   function EB(t, e, n) {
      return {
         min: e !== void 0 ? t.min + e : void 0,
         max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
      }
   }

   function Mle(t, {
      top: e,
      left: n,
      bottom: r,
      right: i
   }) {
      return {
         x: EB(t.x, n, i),
         y: EB(t.y, e, r)
      }
   }

   function wB(t, e) {
      let n = e.min - t.min,
         r = e.max - t.max;
      return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), {
         min: n,
         max: r
      }
   }

   function Ele(t, e) {
      return {
         x: wB(t.x, e.x),
         y: wB(t.y, e.y)
      }
   }

   function wle(t, e) {
      let n = .5;
      const r = Mi(t),
         i = Mi(e);
      return i > r ? n = Yd(e.min, e.max - r, t.min) : r > i && (n = Yd(t.min, t.max - i, e.min)), ka(0, 1, n)
   }

   function ble(t, e) {
      const n = {};
      return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n
   }
   const CS = .35;

   function Cle(t = CS) {
      return t === !1 ? t = 0 : t === !0 && (t = CS), {
         x: bB(t, "left", "right"),
         y: bB(t, "top", "bottom")
      }
   }

   function bB(t, e, n) {
      return {
         min: CB(t, e),
         max: CB(t, n)
      }
   }

   function CB(t, e) {
      return typeof t == "number" ? t : t[e] || 0
   }
   const TB = () => ({
         translate: 0,
         scale: 1,
         origin: 0,
         originPoint: 0
      }),
      zc = () => ({
         x: TB(),
         y: TB()
      }),
      RB = () => ({
         min: 0,
         max: 0
      }),
      jn = () => ({
         x: RB(),
         y: RB()
      });

   function Os(t) {
      return [t("x"), t("y")]
   }

   function jU({
      top: t,
      left: e,
      right: n,
      bottom: r
   }) {
      return {
         x: {
            min: e,
            max: n
         },
         y: {
            min: t,
            max: r
         }
      }
   }

   function Tle({
      x: t,
      y: e
   }) {
      return {
         top: e.min,
         right: t.max,
         bottom: e.max,
         left: t.min
      }
   }

   function Rle(t, e) {
      if (!e) return t;
      const n = e({
            x: t.left,
            y: t.top
         }),
         r = e({
            x: t.right,
            y: t.bottom
         });
      return {
         top: n.y,
         left: n.x,
         bottom: r.y,
         right: r.x
      }
   }

   function d1(t) {
      return t === void 0 || t === 1
   }

   function TS({
      scale: t,
      scaleX: e,
      scaleY: n
   }) {
      return !d1(t) || !d1(e) || !d1(n)
   }

   function Ml(t) {
      return TS(t) || $U(t) || t.z || t.rotate || t.rotateX || t.rotateY
   }

   function $U(t) {
      return PB(t.x) || PB(t.y)
   }

   function PB(t) {
      return t && t !== "0%"
   }

   function tv(t, e, n) {
      const r = t - n,
         i = e * r;
      return n + i
   }

   function BB(t, e, n, r, i) {
      return i !== void 0 && (t = tv(t, i, r)), tv(t, n, r) + e
   }

   function RS(t, e = 0, n = 1, r, i) {
      t.min = BB(t.min, e, n, r, i), t.max = BB(t.max, e, n, r, i)
   }

   function XU(t, {
      x: e,
      y: n
   }) {
      RS(t.x, e.translate, e.scale, e.originPoint), RS(t.y, n.translate, n.scale, n.originPoint)
   }

   function Ple(t, e, n, r = !1) {
      const i = n.length;
      if (!i) return;
      e.x = e.y = 1;
      let s, o;
      for (let a = 0; a < i; a++) {
         s = n[a], o = s.projectionDelta;
         const l = s.instance;
         l && l.style && l.style.display === "contents" || (r && s.options.layoutScroll && s.scroll && s !== s.root && Vc(t, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
         }), o && (e.x *= o.x.scale, e.y *= o.y.scale, XU(t, o)), r && Ml(s.latestValues) && Vc(t, s.latestValues))
      }
      e.x = IB(e.x), e.y = IB(e.y)
   }

   function IB(t) {
      return Number.isInteger(t) || t > 1.0000000000001 || t < .999999999999 ? t : 1
   }

   function fa(t, e) {
      t.min = t.min + e, t.max = t.max + e
   }

   function LB(t, e, [n, r, i]) {
      const s = e[i] !== void 0 ? e[i] : .5,
         o = Rn(t.min, t.max, s);
      RS(t, e[n], e[r], o, e.scale)
   }
   const Ble = ["x", "scaleX", "originX"],
      Ile = ["y", "scaleY", "originY"];

   function Vc(t, e) {
      LB(t.x, e, Ble), LB(t.y, e, Ile)
   }

   function JU(t, e) {
      return jU(Rle(t.getBoundingClientRect(), e))
   }

   function Lle(t, e, n) {
      const r = JU(t, n),
         {
            scroll: i
         } = e;
      return i && (fa(r.x, i.offset.x), fa(r.y, i.offset.y)), r
   }
   const Dle = new WeakMap;
   class Fle {
      constructor(e) {
         this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
         }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = jn(), this.visualElement = e
      }
      start(e, {
         snapToCursor: n = !1
      } = {}) {
         const {
            presenceContext: r
         } = this.visualElement;
         if (r && r.isPresent === !1) return;
         const i = l => {
               this.stopAnimation(), n && this.snapToCursor(gy(l, "page").point)
            },
            s = (l, u) => {
               const {
                  drag: h,
                  dragPropagation: d,
                  onDragStart: p
               } = this.getProps();
               if (h && !d && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = aU(h), !this.openGlobalLock)) return;
               this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Os(v => {
                  let _ = this.getAxisMotionValue(v).get() || 0;
                  if ($s.test(_)) {
                     const {
                        projection: x
                     } = this.visualElement;
                     if (x && x.layout) {
                        const g = x.layout.layoutBox[v];
                        g && (_ = Mi(g) * (parseFloat(_) / 100))
                     }
                  }
                  this.originPoint[v] = _
               }), p && En.update(() => p(l, u), !1, !0);
               const {
                  animationState: m
               } = this.visualElement;
               m && m.setActive("whileDrag", !0)
            },
            o = (l, u) => {
               const {
                  dragPropagation: h,
                  dragDirectionLock: d,
                  onDirectionLock: p,
                  onDrag: m
               } = this.getProps();
               if (!h && !this.openGlobalLock) return;
               const {
                  offset: v
               } = u;
               if (d && this.currentDirection === null) {
                  this.currentDirection = Ole(v), this.currentDirection !== null && p && p(this.currentDirection);
                  return
               }
               this.updateAxis("x", u.point, v), this.updateAxis("y", u.point, v), this.visualElement.render(), m && m(l, u)
            },
            a = (l, u) => this.stop(l, u);
         this.panSession = new VU(e, {
            onSessionStart: i,
            onStart: s,
            onMove: o,
            onSessionEnd: a
         }, {
            transformPagePoint: this.visualElement.getTransformPagePoint()
         })
      }
      stop(e, n) {
         const r = this.isDragging;
         if (this.cancel(), !r) return;
         const {
            velocity: i
         } = n;
         this.startAnimation(i);
         const {
            onDragEnd: s
         } = this.getProps();
         s && En.update(() => s(e, n))
      }
      cancel() {
         this.isDragging = !1;
         const {
            projection: e,
            animationState: n
         } = this.visualElement;
         e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
         const {
            dragPropagation: r
         } = this.getProps();
         !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1)
      }
      updateAxis(e, n, r) {
         const {
            drag: i
         } = this.getProps();
         if (!r || !Hg(e, i, this.currentDirection)) return;
         const s = this.getAxisMotionValue(e);
         let o = this.originPoint[e] + r[e];
         this.constraints && this.constraints[e] && (o = Sle(o, this.constraints[e], this.elastic[e])), s.set(o)
      }
      resolveConstraints() {
         const {
            dragConstraints: e,
            dragElastic: n
         } = this.getProps(), {
            layout: r
         } = this.visualElement.projection || {}, i = this.constraints;
         e && Hc(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && r ? this.constraints = Mle(r.layoutBox, e) : this.constraints = !1, this.elastic = Cle(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && Os(s => {
            this.getAxisMotionValue(s) && (this.constraints[s] = ble(r.layoutBox[s], this.constraints[s]))
         })
      }
      resolveRefConstraints() {
         const {
            dragConstraints: e,
            onMeasureDragConstraints: n
         } = this.getProps();
         if (!e || !Hc(e)) return !1;
         const r = e.current,
            {
               projection: i
            } = this.visualElement;
         if (!i || !i.layout) return !1;
         const s = Lle(r, i.root, this.visualElement.getTransformPagePoint());
         let o = Ele(i.layout.layoutBox, s);
         if (n) {
            const a = n(Tle(o));
            this.hasMutatedConstraints = !!a, a && (o = jU(a))
         }
         return o
      }
      startAnimation(e) {
         const {
            drag: n,
            dragMomentum: r,
            dragElastic: i,
            dragTransition: s,
            dragSnapToOrigin: o,
            onDragTransitionEnd: a
         } = this.getProps(), l = this.constraints || {}, u = Os(h => {
            if (!Hg(h, n, this.currentDirection)) return;
            let d = l && l[h] || {};
            o && (d = {
               min: 0,
               max: 0
            });
            const p = i ? 200 : 1e6,
               m = i ? 40 : 1e7,
               v = {
                  type: "inertia",
                  velocity: r ? e[h] : 0,
                  bounceStiffness: p,
                  bounceDamping: m,
                  timeConstant: 750,
                  restDelta: 1,
                  restSpeed: 10,
                  ...s,
                  ...d
               };
            return this.startAxisValueAnimation(h, v)
         });
         return Promise.all(u).then(a)
      }
      startAxisValueAnimation(e, n) {
         const r = this.getAxisMotionValue(e);
         return r.start(_w(e, r, 0, n))
      }
      stopAnimation() {
         Os(e => this.getAxisMotionValue(e).stop())
      }
      getAxisMotionValue(e) {
         const n = "_drag" + e.toUpperCase(),
            r = this.visualElement.getProps(),
            i = r[n];
         return i || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0)
      }
      snapToCursor(e) {
         Os(n => {
            const {
               drag: r
            } = this.getProps();
            if (!Hg(n, r, this.currentDirection)) return;
            const {
               projection: i
            } = this.visualElement, s = this.getAxisMotionValue(n);
            if (i && i.layout) {
               const {
                  min: o,
                  max: a
               } = i.layout.layoutBox[n];
               s.set(e[n] - Rn(o, a, .5))
            }
         })
      }
      scalePositionWithinConstraints() {
         if (!this.visualElement.current) return;
         const {
            drag: e,
            dragConstraints: n
         } = this.getProps(), {
            projection: r
         } = this.visualElement;
         if (!Hc(n) || !r || !this.constraints) return;
         this.stopAnimation();
         const i = {
            x: 0,
            y: 0
         };
         Os(o => {
            const a = this.getAxisMotionValue(o);
            if (a) {
               const l = a.get();
               i[o] = wle({
                  min: l,
                  max: l
               }, this.constraints[o])
            }
         });
         const {
            transformTemplate: s
         } = this.visualElement.getProps();
         this.visualElement.current.style.transform = s ? s({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Os(o => {
            if (!Hg(o, e, null)) return;
            const a = this.getAxisMotionValue(o),
               {
                  min: l,
                  max: u
               } = this.constraints[o];
            a.set(Rn(l, u, i[o]))
         })
      }
      addListeners() {
         if (!this.visualElement.current) return;
         Dle.set(this.visualElement, this);
         const e = this.visualElement.current,
            n = To(e, "pointerdown", l => {
               const {
                  drag: u,
                  dragListener: h = !0
               } = this.getProps();
               u && h && this.start(l)
            }),
            r = () => {
               const {
                  dragConstraints: l
               } = this.getProps();
               Hc(l) && (this.constraints = this.resolveRefConstraints())
            },
            {
               projection: i
            } = this.visualElement,
            s = i.addEventListener("measure", r);
         i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), r();
         const o = wo(window, "resize", () => this.scalePositionWithinConstraints()),
            a = i.addEventListener("didUpdate", ({
               delta: l,
               hasLayoutChanged: u
            }) => {
               this.isDragging && u && (Os(h => {
                  const d = this.getAxisMotionValue(h);
                  d && (this.originPoint[h] += l[h].translate, d.set(d.get() + l[h].translate))
               }), this.visualElement.render())
            });
         return () => {
            o(), n(), s(), a && a()
         }
      }
      getProps() {
         const e = this.visualElement.getProps(),
            {
               drag: n = !1,
               dragDirectionLock: r = !1,
               dragPropagation: i = !1,
               dragConstraints: s = !1,
               dragElastic: o = CS,
               dragMomentum: a = !0
            } = e;
         return {
            ...e,
            drag: n,
            dragDirectionLock: r,
            dragPropagation: i,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
         }
      }
   }

   function Hg(t, e, n) {
      return (e === !0 || e === t) && (n === null || n === t)
   }

   function Ole(t, e = 10) {
      let n = null;
      return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n
   }
   class Nle extends Ya {
      constructor(e) {
         super(e), this.removeGroupControls = Nn, this.removeListeners = Nn, this.controls = new Fle(e)
      }
      mount() {
         const {
            dragControls: e
         } = this.node.getProps();
         e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Nn
      }
      unmount() {
         this.removeGroupControls(), this.removeListeners()
      }
   }
   const DB = t => (e, n) => {
      t && En.update(() => t(e, n))
   };
   class Ule extends Ya {
      constructor() {
         super(...arguments), this.removePointerDownListener = Nn
      }
      onPointerDown(e) {
         this.session = new VU(e, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint()
         })
      }
      createPanHandlers() {
         const {
            onPanSessionStart: e,
            onPanStart: n,
            onPan: r,
            onPanEnd: i
         } = this.node.getProps();
         return {
            onSessionStart: DB(e),
            onStart: DB(n),
            onMove: r,
            onEnd: (s, o) => {
               delete this.session, i && En.update(() => i(s, o))
            }
         }
      }
      mount() {
         this.removePointerDownListener = To(this.node.current, "pointerdown", e => this.onPointerDown(e))
      }
      update() {
         this.session && this.session.updateHandlers(this.createPanHandlers())
      }
      unmount() {
         this.removePointerDownListener(), this.session && this.session.end()
      }
   }

   function kle() {
      const t = $.useContext(fy);
      if (t === null) return [!0, null];
      const {
         isPresent: e,
         onExitComplete: n,
         register: r
      } = t, i = $.useId();
      return $.useEffect(() => r(i), []), !e && n ? [!1, () => n && n(i)] : [!0]
   }
   const d0 = {
      hasAnimatedSinceResize: !0,
      hasEverUpdated: !1
   };

   function FB(t, e) {
      return e.max === e.min ? 0 : t / (e.max - e.min) * 100
   }
   const Nh = {
         correct: (t, e) => {
            if (!e.target) return t;
            if (typeof t == "string")
               if (_t.test(t)) t = parseFloat(t);
               else return t;
            const n = FB(t, e.target.x),
               r = FB(t, e.target.y);
            return `${n}% ${r}%`
         }
      },
      Hle = {
         correct: (t, {
            treeScale: e,
            projectionDelta: n
         }) => {
            const r = t,
               i = Ha.parse(t);
            if (i.length > 5) return r;
            const s = Ha.createTransformer(t),
               o = typeof i[0] != "number" ? 1 : 0,
               a = n.x.scale * e.x,
               l = n.y.scale * e.y;
            i[0 + o] /= a, i[1 + o] /= l;
            const u = Rn(a, l, .5);
            return typeof i[2 + o] == "number" && (i[2 + o] /= u), typeof i[3 + o] == "number" && (i[3 + o] /= u), s(i)
         }
      };
   class Gle extends z.Component {
      componentDidMount() {
         const {
            visualElement: e,
            layoutGroup: n,
            switchLayoutGroup: r,
            layoutId: i
         } = this.props, {
            projection: s
         } = e;
         Jse(zle), s && (n.group && n.group.add(s), r && r.register && i && r.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
            this.safeToRemove()
         }), s.setOptions({
            ...s.options,
            onExitComplete: () => this.safeToRemove()
         })), d0.hasEverUpdated = !0
      }
      getSnapshotBeforeUpdate(e) {
         const {
            layoutDependency: n,
            visualElement: r,
            drag: i,
            isPresent: s
         } = this.props, o = r.projection;
         return o && (o.isPresent = s, i || e.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || En.postRender(() => {
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
         }))), null
      }
      componentDidUpdate() {
         const {
            projection: e
         } = this.props.visualElement;
         e && (e.root.didUpdate(), queueMicrotask(() => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
         }))
      }
      componentWillUnmount() {
         const {
            visualElement: e,
            layoutGroup: n,
            switchLayoutGroup: r
         } = this.props, {
            projection: i
         } = e;
         i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i))
      }
      safeToRemove() {
         const {
            safeToRemove: e
         } = this.props;
         e && e()
      }
      render() {
         return null
      }
   }

   function KU(t) {
      const [e, n] = kle(), r = $.useContext(ow);
      return z.createElement(Gle, {
         ...t,
         layoutGroup: r,
         switchLayoutGroup: $.useContext(WN),
         isPresent: e,
         safeToRemove: n
      })
   }
   const zle = {
         borderRadius: {
            ...Nh,
            applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
         },
         borderTopLeftRadius: Nh,
         borderTopRightRadius: Nh,
         borderBottomLeftRadius: Nh,
         borderBottomRightRadius: Nh,
         boxShadow: Hle
      },
      YU = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
      Vle = YU.length,
      OB = t => typeof t == "string" ? parseFloat(t) : t,
      NB = t => typeof t == "number" || _t.test(t);

   function Wle(t, e, n, r, i, s) {
      i ? (t.opacity = Rn(0, n.opacity !== void 0 ? n.opacity : 1, jle(r)), t.opacityExit = Rn(e.opacity !== void 0 ? e.opacity : 1, 0, $le(r))) : s && (t.opacity = Rn(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
      for (let o = 0; o < Vle; o++) {
         const a = `border${YU[o]}Radius`;
         let l = UB(e, a),
            u = UB(n, a);
         if (l === void 0 && u === void 0) continue;
         l || (l = 0), u || (u = 0), l === 0 || u === 0 || NB(l) === NB(u) ? (t[a] = Math.max(Rn(OB(l), OB(u), r), 0), ($s.test(u) || $s.test(l)) && (t[a] += "%")) : t[a] = u
      }(e.rotate || n.rotate) && (t.rotate = Rn(e.rotate || 0, n.rotate || 0, r))
   }

   function UB(t, e) {
      return t[e] !== void 0 ? t[e] : t.borderRadius
   }
   const jle = QU(0, .5, gw),
      $le = QU(.5, .95, Nn);

   function QU(t, e, n) {
      return r => r < t ? 0 : r > e ? 1 : n(Yd(t, e, r))
   }

   function kB(t, e) {
      t.min = e.min, t.max = e.max
   }

   function Ui(t, e) {
      kB(t.x, e.x), kB(t.y, e.y)
   }

   function HB(t, e, n, r, i) {
      return t -= e, t = tv(t, 1 / n, r), i !== void 0 && (t = tv(t, 1 / i, r)), t
   }

   function Xle(t, e = 0, n = 1, r = .5, i, s = t, o = t) {
      if ($s.test(e) && (e = parseFloat(e), e = Rn(o.min, o.max, e / 100) - o.min), typeof e != "number") return;
      let a = Rn(s.min, s.max, r);
      t === s && (a -= e), t.min = HB(t.min, e, n, a, i), t.max = HB(t.max, e, n, a, i)
   }

   function GB(t, e, [n, r, i], s, o) {
      Xle(t, e[n], e[r], e[i], e.scale, s, o)
   }
   const Jle = ["x", "scaleX", "originX"],
      Kle = ["y", "scaleY", "originY"];

   function zB(t, e, n, r) {
      GB(t.x, e, Jle, n ? n.x : void 0, r ? r.x : void 0), GB(t.y, e, Kle, n ? n.y : void 0, r ? r.y : void 0)
   }

   function VB(t) {
      return t.translate === 0 && t.scale === 1
   }

   function ZU(t) {
      return VB(t.x) && VB(t.y)
   }

   function Yle(t, e) {
      return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max
   }

   function qU(t, e) {
      return Math.round(t.x.min) === Math.round(e.x.min) && Math.round(t.x.max) === Math.round(e.x.max) && Math.round(t.y.min) === Math.round(e.y.min) && Math.round(t.y.max) === Math.round(e.y.max)
   }

   function WB(t) {
      return Mi(t.x) / Mi(t.y)
   }
   class Qle {
      constructor() {
         this.members = []
      }
      add(e) {
         Aw(this.members, e), e.scheduleRender()
      }
      remove(e) {
         if (Sw(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
         }
      }
      relegate(e) {
         const n = this.members.findIndex(i => e === i);
         if (n === 0) return !1;
         let r;
         for (let i = n; i >= 0; i--) {
            const s = this.members[i];
            if (s.isPresent !== !1) {
               r = s;
               break
            }
         }
         return r ? (this.promote(r), !0) : !1
      }
      promote(e, n) {
         const r = this.lead;
         if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) {
            r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {
               crossfade: i
            } = e.options;
            i === !1 && r.hide()
         }
      }
      exitAnimationComplete() {
         this.members.forEach(e => {
            const {
               options: n,
               resumingFrom: r
            } = e;
            n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete()
         })
      }
      scheduleRender() {
         this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
         })
      }
      removeLeadSnapshot() {
         this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
      }
   }

   function jB(t, e, n) {
      let r = "";
      const i = t.x.translate / e.x,
         s = t.y.translate / e.y;
      if ((i || s) && (r = `translate3d(${i}px, ${s}px, 0) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1/e.x}, ${1/e.y}) `), n) {
         const {
            rotate: l,
            rotateX: u,
            rotateY: h
         } = n;
         l && (r += `rotate(${l}deg) `), u && (r += `rotateX(${u}deg) `), h && (r += `rotateY(${h}deg) `)
      }
      const o = t.x.scale * e.x,
         a = t.y.scale * e.y;
      return (o !== 1 || a !== 1) && (r += `scale(${o}, ${a})`), r || "none"
   }
   const Zle = (t, e) => t.depth - e.depth;
   class qle {
      constructor() {
         this.children = [], this.isDirty = !1
      }
      add(e) {
         Aw(this.children, e), this.isDirty = !0
      }
      remove(e) {
         Sw(this.children, e), this.isDirty = !0
      }
      forEach(e) {
         this.isDirty && this.children.sort(Zle), this.isDirty = !1, this.children.forEach(e)
      }
   }

   function eue(t, e) {
      const n = performance.now(),
         r = ({
            timestamp: i
         }) => {
            const s = i - n;
            s >= e && (Oo(r), t(s - e))
         };
      return En.read(r, !0), () => Oo(r)
   }

   function tue(t) {
      window.MotionDebug && window.MotionDebug.record(t)
   }

   function nue(t) {
      return t instanceof SVGElement && t.tagName !== "svg"
   }

   function rue(t, e, n) {
      const r = ni(t) ? t : Af(t);
      return r.start(_w("", r, e, n)), r.animation
   }
   const $B = ["", "X", "Y", "Z"],
      XB = 1e3;
   let iue = 0;
   const El = {
      type: "projectionFrame",
      totalNodes: 0,
      resolvedTargetDeltas: 0,
      recalculatedProjection: 0
   };

   function ek({
      attachResizeListener: t,
      defaultParent: e,
      measureScroll: n,
      checkIsScrollRoot: r,
      resetTransform: i
   }) {
      return class {
         constructor(o = {}, a = e == null ? void 0 : e()) {
            this.id = iue++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = {
               x: 1,
               y: 1
            }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.checkUpdateFailed = () => {
               this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
            }, this.updateProjection = () => {
               El.totalNodes = El.resolvedTargetDeltas = El.recalculatedProjection = 0, this.nodes.forEach(aue), this.nodes.forEach(hue), this.nodes.forEach(due), this.nodes.forEach(lue), tue(El)
            }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new qle)
         }
         addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Mw), this.eventHandlers.get(o).add(a)
         }
         notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
         }
         hasListeners(o) {
            return this.eventHandlers.has(o)
         }
         mount(o, a = this.root.hasTreeAnimated) {
            if (this.instance) return;
            this.isSVG = nue(o), this.instance = o;
            const {
               layoutId: l,
               layout: u,
               visualElement: h
            } = this.options;
            if (h && !h.current && h.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (u || l) && (this.isLayoutDirty = !0), t) {
               let d;
               const p = () => this.root.updateBlockedByResize = !1;
               t(o, () => {
                  this.root.updateBlockedByResize = !0, d && d(), d = eue(p, 250), d0.hasAnimatedSinceResize && (d0.hasAnimatedSinceResize = !1, this.nodes.forEach(KB))
               })
            }
            l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && h && (l || u) && this.addEventListener("didUpdate", ({
               delta: d,
               hasLayoutChanged: p,
               hasRelativeTargetChanged: m,
               layout: v
            }) => {
               if (this.isTreeAnimationBlocked()) {
                  this.target = void 0, this.relativeTarget = void 0;
                  return
               }
               const _ = this.options.transition || h.getDefaultTransition() || yue,
                  {
                     onLayoutAnimationStart: x,
                     onLayoutAnimationComplete: g
                  } = h.getProps(),
                  S = !this.targetLayout || !qU(this.targetLayout, v) || m,
                  A = !p && m;
               if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || A || p && (S || !this.currentAnimation)) {
                  this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, A);
                  const E = {
                     ...UU(_, "layout"),
                     onPlay: x,
                     onComplete: g
                  };
                  (h.shouldReduceMotion || this.options.layoutRoot) && (E.delay = 0, E.type = !1), this.startAnimation(E)
               } else p || KB(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
               this.targetLayout = v
            })
         }
         unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Oo(this.updateProjection)
         }
         blockUpdate() {
            this.updateManuallyBlocked = !0
         }
         unblockUpdate() {
            this.updateManuallyBlocked = !1
         }
         isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
         }
         isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
         }
         startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(pue), this.animationId++)
         }
         getTransformTemplate() {
            const {
               visualElement: o
            } = this.options;
            return o && o.getProps().transformTemplate
         }
         willUpdate(o = !0) {
            if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
               this.options.onExitComplete && this.options.onExitComplete();
               return
            }
            if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
            this.isLayoutDirty = !0;
            for (let h = 0; h < this.path.length; h++) {
               const d = this.path[h];
               d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1)
            }
            const {
               layoutId: a,
               layout: l
            } = this.options;
            if (a === void 0 && !l) return;
            const u = this.getTransformTemplate();
            this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate")
         }
         update() {
            if (this.updateScheduled = !1, this.isUpdateBlocked()) {
               this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(JB);
               return
            }
            this.isUpdating || this.nodes.forEach(cue), this.isUpdating = !1, this.nodes.forEach(fue), this.nodes.forEach(sue), this.nodes.forEach(oue), this.clearAllSnapshots();
            const a = performance.now();
            wr.delta = ka(0, 1e3 / 60, a - wr.timestamp), wr.timestamp = a, wr.isProcessing = !0, r1.update.process(wr), r1.preRender.process(wr), r1.render.process(wr), wr.isProcessing = !1
         }
         didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()))
         }
         clearAllSnapshots() {
            this.nodes.forEach(uue), this.sharedNodes.forEach(mue)
         }
         scheduleUpdateProjection() {
            En.preRender(this.updateProjection, !1, !0)
         }
         scheduleCheckAfterUnmount() {
            En.postRender(() => {
               this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            })
         }
         updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
         }
         updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
            if (this.resumeFrom && !this.resumeFrom.instance)
               for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1), this.layoutCorrected = jn(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            const {
               visualElement: a
            } = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
         }
         updateScroll(o = "measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && (this.scroll = {
               animationId: this.root.animationId,
               phase: o,
               isRoot: r(this.instance),
               offset: n(this.instance)
            })
         }
         resetTransform() {
            if (!i) return;
            const o = this.isLayoutDirty || this.shouldResetTransform,
               a = this.projectionDelta && !ZU(this.projectionDelta),
               l = this.getTransformTemplate(),
               u = l ? l(this.latestValues, "") : void 0,
               h = u !== this.prevTransformTemplateValue;
            o && (a || Ml(this.latestValues) || h) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender())
         }
         measure(o = !0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)), xue(l), {
               animationId: this.root.animationId,
               measuredBox: a,
               layoutBox: l,
               latestValues: {},
               source: this.id
            }
         }
         measurePageBox() {
            const {
               visualElement: o
            } = this.options;
            if (!o) return jn();
            const a = o.measureViewportBox(),
               {
                  scroll: l
               } = this.root;
            return l && (fa(a.x, l.offset.x), fa(a.y, l.offset.y)), a
         }
         removeElementScroll(o) {
            const a = jn();
            Ui(a, o);
            for (let l = 0; l < this.path.length; l++) {
               const u = this.path[l],
                  {
                     scroll: h,
                     options: d
                  } = u;
               if (u !== this.root && h && d.layoutScroll) {
                  if (h.isRoot) {
                     Ui(a, o);
                     const {
                        scroll: p
                     } = this.root;
                     p && (fa(a.x, -p.offset.x), fa(a.y, -p.offset.y))
                  }
                  fa(a.x, h.offset.x), fa(a.y, h.offset.y)
               }
            }
            return a
         }
         applyTransform(o, a = !1) {
            const l = jn();
            Ui(l, o);
            for (let u = 0; u < this.path.length; u++) {
               const h = this.path[u];
               !a && h.options.layoutScroll && h.scroll && h !== h.root && Vc(l, {
                  x: -h.scroll.offset.x,
                  y: -h.scroll.offset.y
               }), Ml(h.latestValues) && Vc(l, h.latestValues)
            }
            return Ml(this.latestValues) && Vc(l, this.latestValues), l
         }
         removeTransform(o) {
            const a = jn();
            Ui(a, o);
            for (let l = 0; l < this.path.length; l++) {
               const u = this.path[l];
               if (!u.instance || !Ml(u.latestValues)) continue;
               TS(u.latestValues) && u.updateSnapshot();
               const h = jn(),
                  d = u.measurePageBox();
               Ui(h, d), zB(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, h)
            }
            return Ml(this.latestValues) && zB(a, this.latestValues), a
         }
         setTargetDelta(o) {
            this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
         }
         setOptions(o) {
            this.options = {
               ...this.options,
               ...o,
               crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
         }
         clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
         }
         forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== wr.timestamp && this.relativeParent.resolveTargetDelta(!0)
         }
         resolveTargetDelta(o = !1) {
            var a;
            const l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            const u = !!this.resumingFrom || this !== l;
            if (!(o || u && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget)) return;
            const {
               layout: d,
               layoutId: p
            } = this.options;
            if (!(!this.layout || !(d || p))) {
               if (this.resolvedRelativeTargetAt = wr.timestamp, !this.targetDelta && !this.relativeTarget) {
                  const m = this.getClosestProjectingParent();
                  m && m.layout && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = jn(), this.relativeTargetOrigin = jn(), gd(this.relativeTargetOrigin, this.layout.layoutBox, m.layout.layoutBox), Ui(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
               }
               if (!(!this.relativeTarget && !this.targetDelta)) {
                  if (this.target || (this.target = jn(), this.targetWithTransforms = jn()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Ale(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Ui(this.target, this.layout.layoutBox), XU(this.target, this.targetDelta)) : Ui(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                     this.attemptToResolveRelativeTarget = !1;
                     const m = this.getClosestProjectingParent();
                     m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = jn(), this.relativeTargetOrigin = jn(), gd(this.relativeTargetOrigin, this.target, m.target), Ui(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                  }
                  El.resolvedTargetDeltas++
               }
            }
         }
         getClosestProjectingParent() {
            if (!(!this.parent || TS(this.parent.latestValues) || $U(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
         }
         isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
         }
         calcProjection() {
            var o;
            const a = this.getLead(),
               l = !!this.resumingFrom || this !== a;
            let u = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (u = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), this.resolvedRelativeTargetAt === wr.timestamp && (u = !1), u) return;
            const {
               layout: h,
               layoutId: d
            } = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || d)) return;
            Ui(this.layoutCorrected, this.layout.layoutBox);
            const p = this.treeScale.x,
               m = this.treeScale.y;
            Ple(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox);
            const {
               target: v
            } = a;
            if (!v) {
               this.projectionTransform && (this.projectionDelta = zc(), this.projectionTransform = "none", this.scheduleRender());
               return
            }
            this.projectionDelta || (this.projectionDelta = zc(), this.projectionDeltaWithTransform = zc());
            const _ = this.projectionTransform;
            md(this.projectionDelta, this.layoutCorrected, v, this.latestValues), this.projectionTransform = jB(this.projectionDelta, this.treeScale), (this.projectionTransform !== _ || this.treeScale.x !== p || this.treeScale.y !== m) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", v)), El.recalculatedProjection++
         }
         hide() {
            this.isVisible = !1
         }
         show() {
            this.isVisible = !0
         }
         scheduleRender(o = !0) {
            if (this.options.scheduleRender && this.options.scheduleRender(), o) {
               const a = this.getStack();
               a && a.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
         }
         setAnimationOrigin(o, a = !1) {
            const l = this.snapshot,
               u = l ? l.latestValues : {},
               h = {
                  ...this.latestValues
               },
               d = zc();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
            const p = jn(),
               m = l ? l.source : void 0,
               v = this.layout ? this.layout.source : void 0,
               _ = m !== v,
               x = this.getStack(),
               g = !x || x.members.length <= 1,
               S = !!(_ && !g && this.options.crossfade === !0 && !this.path.some(vue));
            this.animationProgress = 0;
            let A;
            this.mixTargetDelta = E => {
               const C = E / 1e3;
               YB(d.x, o.x, C), YB(d.y, o.y, C), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (gd(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox), gue(this.relativeTarget, this.relativeTargetOrigin, p, C), A && Yle(this.relativeTarget, A) && (this.isProjectionDirty = !1), A || (A = jn()), Ui(A, this.relativeTarget)), _ && (this.animationValues = h, Wle(h, u, this.latestValues, C, S, g)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
         }
         startAnimation(o) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Oo(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = En.update(() => {
               d0.hasAnimatedSinceResize = !0, this.currentAnimation = rue(0, XB, {
                  ...o,
                  onUpdate: a => {
                     this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a)
                  },
                  onComplete: () => {
                     o.onComplete && o.onComplete(), this.completeAnimation()
                  }
               }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
            })
         }
         completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
         }
         finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(XB), this.currentAnimation.stop()), this.completeAnimation()
         }
         applyTransformsToTarget() {
            const o = this.getLead();
            let {
               targetWithTransforms: a,
               target: l,
               layout: u,
               latestValues: h
            } = o;
            if (!(!a || !l || !u)) {
               if (this !== o && this.layout && u && tk(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
                  l = this.target || jn();
                  const d = Mi(this.layout.layoutBox.x);
                  l.x.min = o.target.x.min, l.x.max = l.x.min + d;
                  const p = Mi(this.layout.layoutBox.y);
                  l.y.min = o.target.y.min, l.y.max = l.y.min + p
               }
               Ui(a, l), Vc(a, h), md(this.projectionDeltaWithTransform, this.layoutCorrected, a, h)
            }
         }
         registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new Qle), this.sharedNodes.get(o).add(a);
            const u = a.options.initialPromotionConfig;
            a.promote({
               transition: u ? u.transition : void 0,
               preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0
            })
         }
         isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
         }
         getLead() {
            var o;
            const {
               layoutId: a
            } = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
         }
         getPrevLead() {
            var o;
            const {
               layoutId: a
            } = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
         }
         getStack() {
            const {
               layoutId: o
            } = this.options;
            if (o) return this.root.sharedNodes.get(o)
         }
         promote({
            needsReset: o,
            transition: a,
            preserveFollowOpacity: l
         } = {}) {
            const u = this.getStack();
            u && u.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({
               transition: a
            })
         }
         relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
         }
         resetRotation() {
            const {
               visualElement: o
            } = this.options;
            if (!o) return;
            let a = !1;
            const {
               latestValues: l
            } = o;
            if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a) return;
            const u = {};
            for (let h = 0; h < $B.length; h++) {
               const d = "rotate" + $B[h];
               l[d] && (u[d] = l[d], o.setStaticValue(d, 0))
            }
            o.render();
            for (const h in u) o.setStaticValue(h, u[h]);
            o.scheduleRender()
         }
         getProjectionStyles(o = {}) {
            var a, l;
            const u = {};
            if (!this.instance || this.isSVG) return u;
            if (this.isVisible) u.visibility = "";
            else return {
               visibility: "hidden"
            };
            const h = this.getTransformTemplate();
            if (this.needsReset) return this.needsReset = !1, u.opacity = "", u.pointerEvents = h0(o.pointerEvents) || "", u.transform = h ? h(this.latestValues, "") : "none", u;
            const d = this.getLead();
            if (!this.projectionDelta || !this.layout || !d.target) {
               const _ = {};
               return this.options.layoutId && (_.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, _.pointerEvents = h0(o.pointerEvents) || ""), this.hasProjected && !Ml(this.latestValues) && (_.transform = h ? h({}, "") : "none", this.hasProjected = !1), _
            }
            const p = d.animationValues || d.latestValues;
            this.applyTransformsToTarget(), u.transform = jB(this.projectionDeltaWithTransform, this.treeScale, p), h && (u.transform = h(p, u.transform));
            const {
               x: m,
               y: v
            } = this.projectionDelta;
            u.transformOrigin = `${m.origin*100}% ${v.origin*100}% 0`, d.animationValues ? u.opacity = d === this ? (l = (a = p.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : u.opacity = d === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0;
            for (const _ in J0) {
               if (p[_] === void 0) continue;
               const {
                  correct: x,
                  applyTo: g
               } = J0[_], S = u.transform === "none" ? p[_] : x(p[_], d);
               if (g) {
                  const A = g.length;
                  for (let E = 0; E < A; E++) u[g[E]] = S
               } else u[_] = S
            }
            return this.options.layoutId && (u.pointerEvents = d === this ? h0(o.pointerEvents) || "" : "none"), u
         }
         clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
         }
         resetTree() {
            this.root.nodes.forEach(o => {
               var a;
               return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }), this.root.nodes.forEach(JB), this.root.sharedNodes.clear()
         }
      }
   }

   function sue(t) {
      t.updateLayout()
   }

   function oue(t) {
      var e;
      const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
      if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
         const {
            layoutBox: r,
            measuredBox: i
         } = t.layout, {
            animationType: s
         } = t.options, o = n.source !== t.layout.source;
         s === "size" ? Os(d => {
            const p = o ? n.measuredBox[d] : n.layoutBox[d],
               m = Mi(p);
            p.min = r[d].min, p.max = p.min + m
         }) : tk(s, n.layoutBox, r) && Os(d => {
            const p = o ? n.measuredBox[d] : n.layoutBox[d],
               m = Mi(r[d]);
            p.max = p.min + m, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[d].max = t.relativeTarget[d].min + m)
         });
         const a = zc();
         md(a, r, n.layoutBox);
         const l = zc();
         o ? md(l, t.applyTransform(i, !0), n.measuredBox) : md(l, r, n.layoutBox);
         const u = !ZU(a);
         let h = !1;
         if (!t.resumeFrom) {
            const d = t.getClosestProjectingParent();
            if (d && !d.resumeFrom) {
               const {
                  snapshot: p,
                  layout: m
               } = d;
               if (p && m) {
                  const v = jn();
                  gd(v, n.layoutBox, p.layoutBox);
                  const _ = jn();
                  gd(_, r, m.layoutBox), qU(v, _) || (h = !0), d.options.layoutRoot && (t.relativeTarget = _, t.relativeTargetOrigin = v, t.relativeParent = d)
               }
            }
         }
         t.notifyListeners("didUpdate", {
            layout: r,
            snapshot: n,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: u,
            hasRelativeTargetChanged: h
         })
      } else if (t.isLead()) {
         const {
            onExitComplete: r
         } = t.options;
         r && r()
      }
      t.options.transition = void 0
   }

   function aue(t) {
      El.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
   }

   function lue(t) {
      t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
   }

   function uue(t) {
      t.clearSnapshot()
   }

   function JB(t) {
      t.clearMeasurements()
   }

   function cue(t) {
      t.isLayoutDirty = !1
   }

   function fue(t) {
      const {
         visualElement: e
      } = t.options;
      e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform()
   }

   function KB(t) {
      t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0
   }

   function hue(t) {
      t.resolveTargetDelta()
   }

   function due(t) {
      t.calcProjection()
   }

   function pue(t) {
      t.resetRotation()
   }

   function mue(t) {
      t.removeLeadSnapshot()
   }

   function YB(t, e, n) {
      t.translate = Rn(e.translate, 0, n), t.scale = Rn(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint
   }

   function QB(t, e, n, r) {
      t.min = Rn(e.min, n.min, r), t.max = Rn(e.max, n.max, r)
   }

   function gue(t, e, n, r) {
      QB(t.x, e.x, n.x, r), QB(t.y, e.y, n.y, r)
   }

   function vue(t) {
      return t.animationValues && t.animationValues.opacityExit !== void 0
   }
   const yue = {
         duration: .45,
         ease: [.4, 0, .1, 1]
      },
      ZB = t => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(t),
      qB = ZB("applewebkit/") && !ZB("chrome/") ? Math.round : Nn;

   function eI(t) {
      t.min = qB(t.min), t.max = qB(t.max)
   }

   function xue(t) {
      eI(t.x), eI(t.y)
   }

   function tk(t, e, n) {
      return t === "position" || t === "preserve-aspect" && !bS(WB(e), WB(n), .2)
   }
   const _ue = ek({
         attachResizeListener: (t, e) => wo(t, "resize", e),
         measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
         }),
         checkIsScrollRoot: () => !0
      }),
      p1 = {
         current: void 0
      },
      nk = ek({
         measureScroll: t => ({
            x: t.scrollLeft,
            y: t.scrollTop
         }),
         defaultParent: () => {
            if (!p1.current) {
               const t = new _ue({});
               t.mount(window), t.setOptions({
                  layoutScroll: !0
               }), p1.current = t
            }
            return p1.current
         },
         resetTransform: (t, e) => {
            t.style.transform = e !== void 0 ? e : "none"
         },
         checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed"
      }),
      Aue = {
         pan: {
            Feature: Ule
         },
         drag: {
            Feature: Nle,
            ProjectionNode: nk,
            MeasureLayout: KU
         }
      },
      Sue = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

   function Mue(t) {
      const e = Sue.exec(t);
      if (!e) return [, ];
      const [, n, r] = e;
      return [n, r]
   }

   function PS(t, e, n = 1) {
      const [r, i] = Mue(t);
      if (!r) return;
      const s = window.getComputedStyle(e).getPropertyValue(r);
      if (s) {
         const o = s.trim();
         return kU(o) ? parseFloat(o) : o
      } else return xS(i) ? PS(i, e, n + 1) : i
   }

   function Eue(t, {
      ...e
   }, n) {
      const r = t.current;
      if (!(r instanceof Element)) return {
         target: e,
         transitionEnd: n
      };
      n && (n = {
         ...n
      }), t.values.forEach(i => {
         const s = i.get();
         if (!xS(s)) return;
         const o = PS(s, r);
         o && i.set(o)
      });
      for (const i in e) {
         const s = e[i];
         if (!xS(s)) continue;
         const o = PS(s, r);
         o && (e[i] = o, n || (n = {}), n[i] === void 0 && (n[i] = s))
      }
      return {
         target: e,
         transitionEnd: n
      }
   }
   const wue = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
      rk = t => wue.has(t),
      bue = t => Object.keys(t).some(rk),
      tI = t => t === fu || t === _t,
      nI = (t, e) => parseFloat(t.split(", ")[e]),
      rI = (t, e) => (n, {
         transform: r
      }) => {
         if (r === "none" || !r) return 0;
         const i = r.match(/^matrix3d\((.+)\)$/);
         if (i) return nI(i[1], e); {
            const s = r.match(/^matrix\((.+)\)$/);
            return s ? nI(s[1], t) : 0
         }
      },
      Cue = new Set(["x", "y", "z"]),
      Tue = Ap.filter(t => !Cue.has(t));

   function Rue(t) {
      const e = [];
      return Tue.forEach(n => {
         const r = t.getValue(n);
         r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0))
      }), e.length && t.render(), e
   }
   const Sf = {
      width: ({
         x: t
      }, {
         paddingLeft: e = "0",
         paddingRight: n = "0"
      }) => t.max - t.min - parseFloat(e) - parseFloat(n),
      height: ({
         y: t
      }, {
         paddingTop: e = "0",
         paddingBottom: n = "0"
      }) => t.max - t.min - parseFloat(e) - parseFloat(n),
      top: (t, {
         top: e
      }) => parseFloat(e),
      left: (t, {
         left: e
      }) => parseFloat(e),
      bottom: ({
         y: t
      }, {
         top: e
      }) => parseFloat(e) + (t.max - t.min),
      right: ({
         x: t
      }, {
         left: e
      }) => parseFloat(e) + (t.max - t.min),
      x: rI(4, 13),
      y: rI(5, 14)
   };
   Sf.translateX = Sf.x;
   Sf.translateY = Sf.y;
   const Pue = (t, e, n) => {
         const r = e.measureViewportBox(),
            i = e.current,
            s = getComputedStyle(i),
            {
               display: o
            } = s,
            a = {};
         o === "none" && e.setStaticValue("display", t.display || "block"), n.forEach(u => {
            a[u] = Sf[u](r, s)
         }), e.render();
         const l = e.measureViewportBox();
         return n.forEach(u => {
            const h = e.getValue(u);
            h && h.jump(a[u]), t[u] = Sf[u](l, s)
         }), t
      },
      Bue = (t, e, n = {}, r = {}) => {
         e = {
            ...e
         }, r = {
            ...r
         };
         const i = Object.keys(e).filter(rk);
         let s = [],
            o = !1;
         const a = [];
         if (i.forEach(l => {
               const u = t.getValue(l);
               if (!t.hasValue(l)) return;
               let h = n[l],
                  d = Oh(h);
               const p = e[l];
               let m;
               if (Y0(p)) {
                  const v = p.length,
                     _ = p[0] === null ? 1 : 0;
                  h = p[_], d = Oh(h);
                  for (let x = _; x < v && p[x] !== null; x++) m ? mw(Oh(p[x]) === m) : m = Oh(p[x])
               } else m = Oh(p);
               if (d !== m)
                  if (tI(d) && tI(m)) {
                     const v = u.get();
                     typeof v == "string" && u.set(parseFloat(v)), typeof p == "string" ? e[l] = parseFloat(p) : Array.isArray(p) && m === _t && (e[l] = p.map(parseFloat))
                  } else d != null && d.transform && (m != null && m.transform) && (h === 0 || p === 0) ? h === 0 ? u.set(m.transform(h)) : e[l] = d.transform(p) : (o || (s = Rue(t), o = !0), a.push(l), r[l] = r[l] !== void 0 ? r[l] : e[l], u.jump(p))
            }), a.length) {
            const l = a.indexOf("height") >= 0 ? window.pageYOffset : null,
               u = Pue(e, t, a);
            return s.length && s.forEach(([h, d]) => {
               t.getValue(h).set(d)
            }), t.render(), hy && l !== null && window.scrollTo({
               top: l
            }), {
               target: u,
               transitionEnd: r
            }
         } else return {
            target: e,
            transitionEnd: r
         }
      };

   function Iue(t, e, n, r) {
      return bue(e) ? Bue(t, e, n, r) : {
         target: e,
         transitionEnd: r
      }
   }
   const Lue = (t, e, n, r) => {
         const i = Eue(t, e, r);
         return e = i.target, r = i.transitionEnd, Iue(t, e, n, r)
      },
      BS = {
         current: null
      },
      ik = {
         current: !1
      };

   function Due() {
      if (ik.current = !0, !!hy)
         if (window.matchMedia) {
            const t = window.matchMedia("(prefers-reduced-motion)"),
               e = () => BS.current = t.matches;
            t.addListener(e), e()
         } else BS.current = !1
   }

   function Fue(t, e, n) {
      const {
         willChange: r
      } = e;
      for (const i in e) {
         const s = e[i],
            o = n[i];
         if (ni(s)) t.addValue(i, s), ev(r) && r.add(i);
         else if (ni(o)) t.addValue(i, Af(s, {
            owner: t
         })), ev(r) && r.remove(i);
         else if (o !== s)
            if (t.hasValue(i)) {
               const a = t.getValue(i);
               !a.hasAnimated && a.set(s)
            } else {
               const a = t.getStaticValue(i);
               t.addValue(i, Af(a !== void 0 ? a : s, {
                  owner: t
               }))
            }
      }
      for (const i in n) e[i] === void 0 && t.removeValue(i);
      return e
   }
   const iI = new WeakMap,
      sk = Object.keys(Kd),
      Oue = sk.length,
      sI = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"],
      Nue = sw.length;
   class Uue {
      constructor({
         parent: e,
         props: n,
         presenceContext: r,
         reducedMotionConfig: i,
         visualState: s
      }, o = {}) {
         this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
         }, this.scheduleRender = () => En.render(this.render, !1, !0);
         const {
            latestValues: a,
            renderState: l
         } = s;
         this.latestValues = a, this.baseTarget = {
            ...a
         }, this.initialValues = n.initial ? {
            ...a
         } : {}, this.renderState = l, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = o, this.isControllingVariants = py(n), this.isVariantNode = VN(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current);
         const {
            willChange: u,
            ...h
         } = this.scrapeMotionValuesFromProps(n, {});
         for (const d in h) {
            const p = h[d];
            a[d] !== void 0 && ni(p) && (p.set(a[d], !1), ev(u) && u.add(d))
         }
      }
      scrapeMotionValuesFromProps(e, n) {
         return {}
      }
      mount(e) {
         this.current = e, iI.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), ik.current || Due(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : BS.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
      }
      unmount() {
         iI.delete(this.current), this.projection && this.projection.unmount(), Oo(this.notifyUpdate), Oo(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
         for (const e in this.events) this.events[e].clear();
         for (const e in this.features) this.features[e].unmount();
         this.current = null
      }
      bindToMotionValue(e, n) {
         const r = cu.has(e),
            i = n.on("change", o => {
               this.latestValues[e] = o, this.props.onUpdate && En.update(this.notifyUpdate, !1, !0), r && this.projection && (this.projection.isTransformDirty = !0)
            }),
            s = n.on("renderRequest", this.scheduleRender);
         this.valueSubscriptions.set(e, () => {
            i(), s()
         })
      }
      sortNodePosition(e) {
         return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
      }
      loadFeatures({
         children: e,
         ...n
      }, r, i, s) {
         let o, a;
         for (let l = 0; l < Oue; l++) {
            const u = sk[l],
               {
                  isEnabled: h,
                  Feature: d,
                  ProjectionNode: p,
                  MeasureLayout: m
               } = Kd[u];
            p && (o = p), h(n) && (!this.features[u] && d && (this.features[u] = new d(this)), m && (a = m))
         }
         if (!this.projection && o) {
            this.projection = new o(this.latestValues, this.parent && this.parent.projection);
            const {
               layoutId: l,
               layout: u,
               drag: h,
               dragConstraints: d,
               layoutScroll: p,
               layoutRoot: m
            } = n;
            this.projection.setOptions({
               layoutId: l,
               layout: u,
               alwaysMeasureLayout: !!h || d && Hc(d),
               visualElement: this,
               scheduleRender: () => this.scheduleRender(),
               animationType: typeof u == "string" ? u : "both",
               initialPromotionConfig: s,
               layoutScroll: p,
               layoutRoot: m
            })
         }
         return a
      }
      updateFeatures() {
         for (const e in this.features) {
            const n = this.features[e];
            n.isMounted ? n.update() : (n.mount(), n.isMounted = !0)
         }
      }
      triggerBuild() {
         this.build(this.renderState, this.latestValues, this.options, this.props)
      }
      measureViewportBox() {
         return this.current ? this.measureInstanceViewportBox(this.current, this.props) : jn()
      }
      getStaticValue(e) {
         return this.latestValues[e]
      }
      setStaticValue(e, n) {
         this.latestValues[e] = n
      }
      makeTargetAnimatable(e, n = !0) {
         return this.makeTargetAnimatableFromInstance(e, this.props, n)
      }
      update(e, n) {
         (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
         for (let r = 0; r < sI.length; r++) {
            const i = sI[r];
            this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
            const s = e["on" + i];
            s && (this.propEventSubscriptions[i] = this.on(i, s))
         }
         this.prevMotionValues = Fue(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
      }
      getProps() {
         return this.props
      }
      getVariant(e) {
         return this.props.variants ? this.props.variants[e] : void 0
      }
      getDefaultTransition() {
         return this.props.transition
      }
      getTransformPagePoint() {
         return this.props.transformPagePoint
      }
      getClosestVariantNode() {
         return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
      }
      getVariantContext(e = !1) {
         if (e) return this.parent ? this.parent.getVariantContext() : void 0;
         if (!this.isControllingVariants) {
            const r = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (r.initial = this.props.initial), r
         }
         const n = {};
         for (let r = 0; r < Nue; r++) {
            const i = sw[r],
               s = this.props[i];
            (Jd(s) || s === !1) && (n[i] = s)
         }
         return n
      }
      addVariantChild(e) {
         const n = this.getClosestVariantNode();
         if (n) return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e)
      }
      addValue(e, n) {
         n !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, n)), this.values.set(e, n), this.latestValues[e] = n.get()
      }
      removeValue(e) {
         this.values.delete(e);
         const n = this.valueSubscriptions.get(e);
         n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState)
      }
      hasValue(e) {
         return this.values.has(e)
      }
      getValue(e, n) {
         if (this.props.values && this.props.values[e]) return this.props.values[e];
         let r = this.values.get(e);
         return r === void 0 && n !== void 0 && (r = Af(n, {
            owner: this
         }), this.addValue(e, r)), r
      }
      readValue(e) {
         var n;
         return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options)
      }
      setBaseTarget(e, n) {
         this.baseTarget[e] = n
      }
      getBaseTarget(e) {
         var n;
         const {
            initial: r
         } = this.props, i = typeof r == "string" || typeof r == "object" ? (n = pw(this.props, r)) === null || n === void 0 ? void 0 : n[e] : void 0;
         if (r && i !== void 0) return i;
         const s = this.getBaseTargetFromProps(this.props, e);
         return s !== void 0 && !ni(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e]
      }
      on(e, n) {
         return this.events[e] || (this.events[e] = new Mw), this.events[e].add(n)
      }
      notify(e, ...n) {
         this.events[e] && this.events[e].notify(...n)
      }
   }
   class ok extends Uue {
      sortInstanceNodePosition(e, n) {
         return e.compareDocumentPosition(n) & 2 ? 1 : -1
      }
      getBaseTargetFromProps(e, n) {
         return e.style ? e.style[n] : void 0
      }
      removeValueFromRenderState(e, {
         vars: n,
         style: r
      }) {
         delete n[e], delete r[e]
      }
      makeTargetAnimatableFromInstance({
         transition: e,
         transitionEnd: n,
         ...r
      }, {
         transformValues: i
      }, s) {
         let o = rle(r, e || {}, this);
         if (i && (n && (n = i(n)), r && (r = i(r)), o && (o = i(o))), s) {
            tle(this, r, o);
            const a = Lue(this, r, o, n);
            n = a.transitionEnd, r = a.target
         }
         return {
            transition: e,
            transitionEnd: n,
            ...r
         }
      }
   }

   function kue(t) {
      return window.getComputedStyle(t)
   }
   class Hue extends ok {
      readValueFromInstance(e, n) {
         if (cu.has(n)) {
            const r = xw(n);
            return r && r.default || 0
         } else {
            const r = kue(e),
               i = (XN(n) ? r.getPropertyValue(n) : r[n]) || 0;
            return typeof i == "string" ? i.trim() : i
         }
      }
      measureInstanceViewportBox(e, {
         transformPagePoint: n
      }) {
         return JU(e, n)
      }
      build(e, n, r, i) {
         lw(e, n, r, i.transformTemplate)
      }
      scrapeMotionValuesFromProps(e, n) {
         return dw(e, n)
      }
      handleChildMotionValue() {
         this.childSubscription && (this.childSubscription(), delete this.childSubscription);
         const {
            children: e
         } = this.props;
         ni(e) && (this.childSubscription = e.on("change", n => {
            this.current && (this.current.textContent = `${n}`)
         }))
      }
      renderInstance(e, n, r, i) {
         qN(e, n, r, i)
      }
   }
   class Gue extends ok {
      constructor() {
         super(...arguments), this.isSVGTag = !1
      }
      getBaseTargetFromProps(e, n) {
         return e[n]
      }
      readValueFromInstance(e, n) {
         if (cu.has(n)) {
            const r = xw(n);
            return r && r.default || 0
         }
         return n = eU.has(n) ? n : hw(n), e.getAttribute(n)
      }
      measureInstanceViewportBox() {
         return jn()
      }
      scrapeMotionValuesFromProps(e, n) {
         return nU(e, n)
      }
      build(e, n, r, i) {
         cw(e, n, r, this.isSVGTag, i.transformTemplate)
      }
      renderInstance(e, n, r, i) {
         tU(e, n, r, i)
      }
      mount(e) {
         this.isSVGTag = fw(e.tagName), super.mount(e)
      }
   }
   const zue = (t, e) => aw(t) ? new Gue(e, {
         enableHardwareAcceleration: !1
      }) : new Hue(e, {
         enableHardwareAcceleration: !0
      }),
      Vue = {
         layout: {
            ProjectionNode: nk,
            MeasureLayout: KU
         }
      },
      Wue = {
         ...vle,
         ...Noe,
         ...Aue,
         ...Vue
      },
      pa = $se((t, e) => Aoe(t, e, Wue, zue));

   function ak() {
      const t = $.useRef(!1);
      return X0(() => (t.current = !0, () => {
         t.current = !1
      }), []), t
   }

   function jue() {
      const t = ak(),
         [e, n] = $.useState(0),
         r = $.useCallback(() => {
            t.current && n(e + 1)
         }, [e]);
      return [$.useCallback(() => En.postRender(r), [r]), e]
   }
   class $ue extends $.Component {
      getSnapshotBeforeUpdate(e) {
         const n = this.props.childRef.current;
         if (n && e.isPresent && !this.props.isPresent) {
            const r = this.props.sizeRef.current;
            r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft
         }
         return null
      }
      componentDidUpdate() {}
      render() {
         return this.props.children
      }
   }

   function Xue({
      children: t,
      isPresent: e
   }) {
      const n = $.useId(),
         r = $.useRef(null),
         i = $.useRef({
            width: 0,
            height: 0,
            top: 0,
            left: 0
         });
      return $.useInsertionEffect(() => {
         const {
            width: s,
            height: o,
            top: a,
            left: l
         } = i.current;
         if (e || !r.current || !s || !o) return;
         r.current.dataset.motionPopId = n;
         const u = document.createElement("style");
         return document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${o}px !important;
            top: ${a}px !important;
            left: ${l}px !important;
          }
        `), () => {
            document.head.removeChild(u)
         }
      }, [e]), $.createElement($ue, {
         isPresent: e,
         childRef: r,
         sizeRef: i
      }, $.cloneElement(t, {
         ref: r
      }))
   }
   const m1 = ({
      children: t,
      initial: e,
      isPresent: n,
      onExitComplete: r,
      custom: i,
      presenceAffectsLayout: s,
      mode: o
   }) => {
      const a = rU(Jue),
         l = $.useId(),
         u = $.useMemo(() => ({
            id: l,
            initial: e,
            isPresent: n,
            custom: i,
            onExitComplete: h => {
               a.set(h, !0);
               for (const d of a.values())
                  if (!d) return;
               r && r()
            },
            register: h => (a.set(h, !1), () => a.delete(h))
         }), s ? void 0 : [n]);
      return $.useMemo(() => {
         a.forEach((h, d) => a.set(d, !1))
      }, [n]), $.useEffect(() => {
         !n && !a.size && r && r()
      }, [n]), o === "popLayout" && (t = $.createElement(Xue, {
         isPresent: n
      }, t)), $.createElement(fy.Provider, {
         value: u
      }, t)
   };

   function Jue() {
      return new Map
   }

   function Kue(t) {
      return $.useEffect(() => () => t(), [])
   }
   const oc = t => t.key || "";

   function Yue(t, e) {
      t.forEach(n => {
         const r = oc(n);
         e.set(r, n)
      })
   }

   function Que(t) {
      const e = [];
      return $.Children.forEach(t, n => {
         $.isValidElement(n) && e.push(n)
      }), e
   }
   const lk = ({
         children: t,
         custom: e,
         initial: n = !0,
         onExitComplete: r,
         exitBeforeEnter: i,
         presenceAffectsLayout: s = !0,
         mode: o = "sync"
      }) => {
         const a = $.useContext(ow).forceRender || jue()[0],
            l = ak(),
            u = Que(t);
         let h = u;
         const d = $.useRef(new Map).current,
            p = $.useRef(h),
            m = $.useRef(new Map).current,
            v = $.useRef(!0);
         if (X0(() => {
               v.current = !1, Yue(u, m), p.current = h
            }), Kue(() => {
               v.current = !0, m.clear(), d.clear()
            }), v.current) return $.createElement($.Fragment, null, h.map(S => $.createElement(m1, {
            key: oc(S),
            isPresent: !0,
            initial: n ? void 0 : !1,
            presenceAffectsLayout: s,
            mode: o
         }, S)));
         h = [...h];
         const _ = p.current.map(oc),
            x = u.map(oc),
            g = _.length;
         for (let S = 0; S < g; S++) {
            const A = _[S];
            x.indexOf(A) === -1 && !d.has(A) && d.set(A, void 0)
         }
         return o === "wait" && d.size && (h = []), d.forEach((S, A) => {
            if (x.indexOf(A) !== -1) return;
            const E = m.get(A);
            if (!E) return;
            const C = _.indexOf(A);
            let R = S;
            if (!R) {
               const B = () => {
                  m.delete(A), d.delete(A);
                  const D = p.current.findIndex(T => T.key === A);
                  if (p.current.splice(D, 1), !d.size) {
                     if (p.current = u, l.current === !1) return;
                     a(), r && r()
                  }
               };
               R = $.createElement(m1, {
                  key: oc(E),
                  isPresent: !1,
                  onExitComplete: B,
                  custom: e,
                  presenceAffectsLayout: s,
                  mode: o
               }, E), d.set(A, R)
            }
            h.splice(C, 0, R)
         }), h = h.map(S => {
            const A = S.key;
            return d.has(A) ? S : $.createElement(m1, {
               key: oc(S),
               isPresent: !0,
               presenceAffectsLayout: s,
               mode: o
            }, S)
         }), $.createElement($.Fragment, null, d.size ? h : h.map(S => $.cloneElement(S)))
      },
      Zue = "./imagens/file-ac07d4a6.png",
      que = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAM5klEQVR4nO3dW1Qadx4H8Jzunm72nD503/rWPX1r39q8bx82D3vOKphm3V7SbgKKGGO8zABimmRAUam9YiRt0nTTy7bp2mpuaqK24SLOIAzGGsQYZTUGvCE6CkJU8L9nUCIaRS4zQMh8z/k+Jg98zv//H378kT17mDBhwoQJEyZMmDBhwoRJxAGHL+4lOHX7CU6d3AZBcptAsH8EQfZG/j8wiTsE55OXCI4ij+AoGghO3QLBrQNk7TAcrMcOQR12GC4bh+F9AEGeYV52CuM+XP8CkXMmm+DWnSM4CnsQYGtDQDbVBsMOOww3jMNw3kRx8Z8ZnCgzVVD/XHAbIjh1+E4AkYJsA2S1wfA5GwRl3xeL/8QAbQlAkN8TuYp9BFdRRnAVHXMcxXKkCLGAbMHx2WAYD54/944f/8NTCbTwnvLlOY6iZI6jaCY4ClcsAAQFINsAuewQ1GwXCErGRcUv73ka0s7HeHheq4oKBIJikNA6TxSpQG3u8T3pjtGWj6228fWeSe65B6kLAtn9tXmL4APeatqiBDHa8/WArJavQlMVxIUUoKCWBwJNR5StGMGO5nzTm2og4wKoD8hJhHWQdEPZCYPsL/nowCxX4UsVEBsE+ZdkfMsmjHRCCYcRrJnXqE0VkKmyYu22GOmAEgnGWjGHk6ucTzaIDYJcvhreVFiQJxUlcoy16vNuqpMNMneyUL0rxpOIEi3G+ipZGud+OZIskHEYuu+X5z6MGORJQYkNY63qfG13skDckgJDVBhPAko8GMFac/5jTDTIhKDUFBNGKqNQgREoH7XOcuoSN1yEoJVlWf5QXCCphkIZxnp/y72iThSIQ1wU+UH+JKBQjdEeWCX6OQfnrJN+EGjWJ89zUgaSbBRaMPLXivE7NHSDEKcKNZRiJBNFAfe88k2JQXWTr/fQAdKer/fZuV8N0gcCDYMPeD5aQGpzPeCHbBVoZb2SMJB6oalUKTQBpRCfuFRk0NGxUm7laW/TBeKpOBrfk9VO/fJdA2jJfABuZALQmlmSMBClwNSyBrLWswKT+cqx7jtUowzlXMKoBpkogzDKIeqPDIBmVm8AItjWjOaEYDQg5meVAtwVCkK2XoivXoBwXctR/RRVIB356Ngs94yXMhAIWlqu5o9SBvEJ1wl+OqgBNzJ8mzDWVogbtP6N/s/olcKe17dibC7u/rrEqG7jdz+kAsXEa1ZRBTIT+FiWknNiGXz3pga0ZMw/BhHaZtZf6AcR4JXhQYLbGD7603EDGjcKH3NPcz+fjBfEBsPT/hreQtwY594zgZbM4bAQG9tWBe0g9QITFglIsF/AeM/VY9334kHR8X/tjBdk/nSBLi4IxZERcJVtiAhiY9tCacX4tPj280qBaSUakEAFppULkFHbmq+fiQWkLR9bHeVeNMcMIoAsoDbXHxPERzlzoOGgGtzIWIoKI9AMH2j+O32X8c4I8ANRY4Qe/ALT7PdFBs1Nvn4lWpRf+bo7c1zFarQgNhhe9VYe7YvhnPCDr9/SgdZMR/QQIW3JyKINpF5gUsYDEuznQpO1sdBgjBbFwmvQRQsyKSqOfqv64r3boDVzMC6IjW2rnkYQ/B4VIMGeh3DD9QL9/SgO+Akn94w7UhAbBC2u1PDtEUN8mmMHl7N0lEBsdJAeDNj0IpUYG+9fTMv/LsU1N/L1C5Gg4LybqkhBnCeOR/aY+1GuG1zKVoPWTC/FGOtlU3/r/owQz6UDJKSTPxQZtO18zB/+gNd7J7nnx3YFgUrXbh/uNgj86hAKWjLs9EA82rZyKAepF+A/0gwCyJ4V4Jamwu6+cCgavhrbDcQtKQg/Iqk/bAHXM/tohdh42rpEKQaCgGeUAnw6ESDK9THMeRhHm49223ZCGc35dtPwMRRjXAj99tjtw41xxyRoPKAFNzL8icEI1EHpN7nOCPHXEoWhDIURmBbJMcx2Y/5f+F2DobceQw5y/5Is//Hbhx/ylgLjjtYMVwIhQrYt1quUgSgFJlEyQJTBCvDx7cb8fbwm7VYQh7hEs8NYfCwpEBvblpAykHoh3pFUEOH6+QIbe68VdN/deAzWzzq4Z2c3QCDCJ+fNbIw7DlvBtSw8uRDBFZLRTgnGRUS1Vyk0eZKNodxYLf71Mf80iaLPawtcigh8LHty/dLCx9zZHcfiSQPJ9IKG7D/GDXJW0LM/6QjC7WBMxHfFRvXNfL3bzv1qyA7DVn9t7iL45m0taM10Jh1g+1Xy17hB6gW4POkvvjAcjHH0SqGm3VN35DpoYQ0l/UUP2wx53CDlVQZ5ebURpGrFcnyk+CdtMzF2tAVYsoZAPxukblnxg4hrDPtTEqLaQPAvDKkPaN0uBKv5X/sgMgoIkRuMcbXgDtuZ/Bd/28a/ZSGIam95ldGTQhB+6LM+3cFfXNPsTi8o7LqulmIy0NQvBVNTYjWYFwEwC8+Cobc0wMzypQDCWs1sLxij4FAnU15l7Eg2RHm1EQhrTb1vNTvvkhBkD2pnZiSYjAiCXOtHFgAhmgqgkHUUWcHdN/AUAaHmsXcdRJTcVYGP534/pmNrPatBDLKirgtaEiMIQvbug/e1j0CCtfMNoJ81llwUFnVvDE/I8NeStD0tHjs/qGarFz2hEGTf1lrvSrBK31aQy2apf4UQWh5DmRMsgdHDGtDPciUJ5FVKh4viasN0wjCqDKvwJ71odtu8bStEsKfQD3uDGKEgZHXWU32AEK0+hkLWWToJ7v1TC8wsfwK3KwcAFP+ZqPIq44+JwCj7ALccujrdtxME2dwuFA3F2ApC1uUsw7YFCXaq0ALuHuhLEAi143cyZTV4Lq3bU41xMufbES1L4/GHwzjQueCVoFUPdgO5MXjaDuaFi2FRyFVk56HAnGWnGYX6D6jerzS9SNM5sVSktGjeuOVaCAcRbFHXz6qtGNuBkLVPnVCFBXkEI1gE1kPqwKMpHSADNHyES0ZcbbxHJYbg49uGf7TNjUUCwe70guzO6QkJWumOFOSKRbroI0T2iFAC719K7WAwW0ftdsWi55IDmfIqo5KSVSHHrf9qnDBGCsFerxg7q9sOYycQsuax93URgwQ7cfQ26GcPUoRC3zWgspruA3GeE7P8i8OaLO3iSrQYh3SDdyRo5Wq0II1mZHV5TvRb1CiE0A9sXHK1OOIEoe+iHILcfl5cbVyJ/pwwrpQqzNoDt1zOaCHYnV6QpfWsIliteSeMcCBkNUOnLYEXOFqUwPsXmADD76hBP2sphu3KB/povEpKRlxtwKLBENb29LzZ4hyKBYK93vyuW53hMHYDIUs4xJ0xgWyMYUbAwEFDlCD0XrZeB6mMcHsaPdJgR+OBYAdWB+GWoNWT8YK0DCDTYF60EBcK2cmjJmBhD0eGwqL/6wjlVYbXw2JUGdzkuCNLu/gwXgx2pxeUdv2w7WNutCBk749H+Bi86zYmWg6MYcys+V1A6P/CDoKYnxVXG1y7jcWpaHanfUyKybxUgVyxSJf8hGiEEpTAYzLsDDPmd4N7CfhKG5nyKkNLKEZZrcn8zrWZO1RBsNd7Aq3TR4IRKQjZ26Onwo9UYunM8QFgeaN38/nBTsyXPtdAjKVrqwKf2G4sTkUP6/p6IsWIBoSsd1aMU47yaMyftTbmt7AT97Xo8g97Xik4P6jabixOTRd9ElQ+SBfIrWFkGBAiHy0ohNADrO+qgDmBfziADEvr5dGxMtidXnBM16qJBiNaELIzDrGGHhDRKiBEhQnFoBPlYCcxJ+mSOekGaRmQzIJ5kTNtMOhCEXR9Hbi0QDcI2WH7CXVaYVCN8qbuvlWCVi4nCqTJIl1ZmRUNpRUGlSgnsc+MsWDEDNIvBZj1VE/aYVCBwtF1d8eKEQ8IWY+zrDvtMOJDcS1JuqpHkgXSNnj6PiBED9MOI1aUQt3VmA5yKUUgZCcn1289phtGtCgHOx0OCSqbTzbINYvEBQjhZFpiRINShn356PahNIkgZAcenNCmLUYkKId01gEpKvOnCshls9S/PCfqT1uM3VBOox9tun0oTTIIWZ319OO3HtMJYyeUPFTXRRWGlEIQsgszZWhaY2xFydK6PAhWbUtVkJt3kXEwL3KnNUYoSknXfyP6WFaaJBCytslyVdpjBHMSk78sRWUlErSyWYrJXCkE4moyS5obLdKSpjsnn44fltyahoaG31XoK/ZJMFmZFJN1JHS4aJb4Gs0SvKlfKv+5H9nfek/xdP70arggKuQ5BK3cL0Ur5RJUhtMAYm3sl5xr6pdmN/fVMD9OHDVQN/KCFJVlS9DKcxKscscHgZ0AGs1SR1O/tOGyuSLv8gDC/Hw35SvIUPNShV6WJ8VkDRKscuExELPE02SWdjSaJWWXByr2IVR/c4nJzkFUyN7g9hY8By6OIHvD/BMmTJgwYcKECRMmTJgwYbJnc/4PKLMFE0aceqoAAAAASUVORK5CYII=",
      ece = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAADVklEQVR4nO2YzU8TURTFjyIuDCYGTZSNEoxGcUDMEAENFpEAlbp04cL/wL0Ja0DAxAUuDLbBRDsl8mEChkBh6BfixujCuNCFCyNKQhQToxKIcMy002YoBVoHQqd9v+Qk7bR9c+957973OoBAIBAIBAKBQLDtsA97qaCDCr5SAWNy4wsVtGufI5OhlqQx8bVqRybD+JmPlxuzyGS48eyHhUyGwgCIFUBRAhA9gKIJQuwCFNsgxDmA4iAEcRJkVh2F/XbSW0UOHs7SJhhwMKbnp7LcgIAj4UpAVhngrcpyA3yNmWcAR6sL6Kt/TX/T8pqE1xhQv+m/Q/1J0TsqKIIV4OTl+5smHtVYRXIGREzohRWgWtuVMNlXt8i5F+TyIvmpL3Jt4FDyBigYghWgWnGY/saZVclrCXOFMf4ukMMnUkn+N90og1Wg1yYxcPVHzAAtYSMfulJZ+iv04AasBr3VtQw0LYQNmBlebYC2Ijy7kzWhDVaF47abkd3gGjk7vtqEjz3JzP4Y+5ADK0O1pjlSCnEmaGUxcHAjA97zEQ4gE6B65XHMBK0cojuBr4F8mpco+Z98gmJkCuy7nkO1fjLh9qjWkJ4cY/LLdMOBTIN+Wx59DW8TmjBUZDTgNtIJ17npY045qDrLQ7+ccnCiW546auqYPGn/vO6fIjcGSOz63/E7zzw73ip5plok5U+LpITulAyYPz475aDqKg/RoHEz43GksoSTDXOrDJiwackH2I19ZsbWkm+VFEalmQCzOMuDi0YDtPdmx+SoXMCJSw+o1r2hWvuSo+eb2Y1cs+O2SMpSnAFLZsdE3OyHhTTFmHxUpgd1CQNCYgW4RAmE0kLdso93SwfZKnnW1Pp62pYe4NohRZJPLvEtNCC444lH1VbSm6IBHvMGPJSD3626AjpL++dNG9BTNn3BJYe+7XTyqfUADztK++fvnR25aNoAgUAgECRmD4D9APIBFAAoBHASgARABlAFoFpXDYBaXQ267ED40ZdDfx29Hv1ejeH3VfqYkn6PQv2e+XoMWizbSi6AI0D4QaUWTJ0h+HRRnR5bsR6r6ecLUaS42bKK7HrsppGy3QBjCZwGUJnGJVCpx7ilJYB1SKUJ2hI0wUZD8Nrr+Cao/Wbbm+A/yjelC5SMJbwAAAAASUVORK5CYII=",
      tce = "./imagens/1.png",
      nce = "./imagens/2.png",
      rce = () => {
         const e = document.querySelector("canvas").toDataURL(),
            n = document.createElement("a");
         n.href = e, n.download = "canvas.png", document.body.appendChild(n), n.click(), document.body.removeChild(n)
      },
      ice = t => new Promise((e, n) => {
         const r = new FileReader;
         r.onload = () => e(r.result), r.readAsDataURL(t)
      }),
      sce = t => {
         const e = t.replace("#", ""),
            n = parseInt(e.substring(0, 2), 16),
            r = parseInt(e.substring(2, 4), 16),
            i = parseInt(e.substring(4, 6), 16);
         return (n * 299 + r * 587 + i * 114) / 1e3 > 128 ? "black" : "white"
      },
      oce = [{
         name: "colorpicker",
         icon: que
      }, {
         name: "filepicker",
         icon: Zue
      }],
      ace = [{
         name: "logoShirt",
         icon: tce
      }, {
         name: "stylishShirt",
         icon: nce
      }],
      lce = {
         logo: {
            stateProperty: "logoDecal",
            filterTab: "logoShirt"
         },
         full: {
            stateProperty: "fullDecal",
            filterTab: "stylishShirt"
         }
      },
      Po = {
         type: "spring",
         duration: .8
      },
      nv = t => ({
         initial: {
            x: t === "left" ? -100 : t === "right" ? 100 : 0,
            y: t === "up" ? 100 : t === "down" ? -100 : 0,
            opacity: 0,
            transition: {
               ...Po,
               delay: .5
            }
         },
         animate: {
            x: 0,
            y: 0,
            opacity: 1,
            transition: {
               ...Po,
               delay: 0
            }
         },
         exit: {
            x: t === "left" ? -100 : t === "right" ? 100 : 0,
            y: t === "up" ? 100 : t === "down" ? -100 : 0,
            transition: {
               ...Po,
               delay: 0
            }
         }
      }),
      uce = {
         initial: {
            opacity: 0,
            transition: {
               ...Po,
               delay: .5
            }
         },
         animate: {
            opacity: 1,
            transition: {
               ...Po,
               delay: 0
            }
         },
         exit: {
            opacity: 0,
            transition: {
               ...Po,
               delay: 0
            }
         }
      },
      cce = {
         initial: {
            x: 100,
            opacity: 0
         },
         animate: {
            x: 0,
            opacity: 1
         },
         transition: {
            type: "spring",
            damping: 5,
            stiffness: 40,
            restDelta: .001,
            duration: .3
         }
      },
      fce = {
         initial: {
            y: 100,
            opacity: 0
         },
         animate: {
            y: 0,
            opacity: 1
         },
         transition: {
            type: "spring",
            damping: 7,
            stiffness: 30,
            restDelta: .001,
            duration: .6,
            delay: .2,
            delayChildren: .2
         }
      },
      hce = {
         initial: {
            x: -100,
            opacity: 0,
            transition: {
               ...Po,
               delay: .5
            }
         },
         animate: {
            x: 0,
            opacity: 1,
            transition: {
               ...Po,
               delay: 0
            }
         },
         exit: {
            x: -100,
            opacity: 0,
            transition: {
               ...Po,
               delay: 0
            }
         }
      },
      rv = ({
         type: t,
         title: e,
         customStyles: n,
         handleClick: r
      }) => {
         const i = uu(kr),
            s = o => {
               if (o === "filled") return {
                  backgroundColor: i.color,
                  color: sce(i.color)
               };
               if (o === "outline") return {
                  borderWidth: "1px",
                  borderColor: i.color,
                  color: i.color
               }
            };
         return ot.jsx("button", {
            className: `px-2 py-1.5 flex-1 rounded-md ${n}`,
            style: s(t),
            onClick: r,
            children: e
         })
      };
   var $i = {},
      wp = {},
      dce = vN,
      pce = ote;

   function mce(t, e) {
      return t && dce(t, pce(e))
   }
   var Ew = mce,
      gce = au,
      vce = ZE,
      yce = Ho,
      xce = "[object Object]",
      _ce = Function.prototype,
      Ace = Object.prototype,
      uk = _ce.toString,
      Sce = Ace.hasOwnProperty,
      Mce = uk.call(Object);

   function Ece(t) {
      if (!yce(t) || gce(t) != xce) return !1;
      var e = vce(t);
      if (e === null) return !0;
      var n = Sce.call(e, "constructor") && e.constructor;
      return typeof n == "function" && n instanceof n && uk.call(n) == Mce
   }
   var wce = Ece;
   Object.defineProperty(wp, "__esModule", {
      value: !0
   });
   wp.flattenNames = void 0;
   var bce = Eie,
      Cce = yy(bce),
      Tce = Ew,
      Rce = yy(Tce),
      Pce = wce,
      Bce = yy(Pce),
      Ice = tte,
      Lce = yy(Ice);

   function yy(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }
   var Dce = wp.flattenNames = function t() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
         n = [];
      return (0, Lce.default)(e, function (r) {
         Array.isArray(r) ? t(r).map(function (i) {
            return n.push(i)
         }) : (0, Bce.default)(r) ? (0, Rce.default)(r, function (i, s) {
            i === !0 && n.push(s), n.push(s + "-" + i)
         }) : (0, Cce.default)(r) && n.push(r)
      }), n
   };
   wp.default = Dce;
   var bp = {},
      Fce = yie,
      Oce = 1,
      Nce = 4;

   function Uce(t) {
      return Fce(t, Oce | Nce)
   }
   var kce = Uce;
   Object.defineProperty(bp, "__esModule", {
      value: !0
   });
   bp.mergeClasses = void 0;
   var Hce = Ew,
      Gce = ck(Hce),
      zce = kce,
      Vce = ck(zce),
      Wce = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      };

   function ck(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }
   var jce = bp.mergeClasses = function (e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
         r = e.default && (0, Vce.default)(e.default) || {};
      return n.map(function (i) {
         var s = e[i];
         return s && (0, Gce.default)(s, function (o, a) {
            r[a] || (r[a] = {}), r[a] = Wce({}, r[a], s[a])
         }), i
      }), r
   };
   bp.default = jce;
   var Cp = {};
   Object.defineProperty(Cp, "__esModule", {
      value: !0
   });
   Cp.autoprefix = void 0;
   var $ce = Ew,
      oI = Jce($ce),
      Xce = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      };

   function Jce(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }
   var Kce = {
         borderRadius: function (e) {
            return {
               msBorderRadius: e,
               MozBorderRadius: e,
               OBorderRadius: e,
               WebkitBorderRadius: e,
               borderRadius: e
            }
         },
         boxShadow: function (e) {
            return {
               msBoxShadow: e,
               MozBoxShadow: e,
               OBoxShadow: e,
               WebkitBoxShadow: e,
               boxShadow: e
            }
         },
         userSelect: function (e) {
            return {
               WebkitTouchCallout: e,
               KhtmlUserSelect: e,
               MozUserSelect: e,
               msUserSelect: e,
               WebkitUserSelect: e,
               userSelect: e
            }
         },
         flex: function (e) {
            return {
               WebkitBoxFlex: e,
               MozBoxFlex: e,
               WebkitFlex: e,
               msFlex: e,
               flex: e
            }
         },
         flexBasis: function (e) {
            return {
               WebkitFlexBasis: e,
               flexBasis: e
            }
         },
         justifyContent: function (e) {
            return {
               WebkitJustifyContent: e,
               justifyContent: e
            }
         },
         transition: function (e) {
            return {
               msTransition: e,
               MozTransition: e,
               OTransition: e,
               WebkitTransition: e,
               transition: e
            }
         },
         transform: function (e) {
            return {
               msTransform: e,
               MozTransform: e,
               OTransform: e,
               WebkitTransform: e,
               transform: e
            }
         },
         absolute: function (e) {
            var n = e && e.split(" ");
            return {
               position: "absolute",
               top: n && n[0],
               right: n && n[1],
               bottom: n && n[2],
               left: n && n[3]
            }
         },
         extend: function (e, n) {
            var r = n[e];
            return r || {
               extend: e
            }
         }
      },
      Yce = Cp.autoprefix = function (e) {
         var n = {};
         return (0, oI.default)(e, function (r, i) {
            var s = {};
            (0, oI.default)(r, function (o, a) {
               var l = Kce[a];
               l ? s = Xce({}, s, l(o)) : s[a] = o
            }), n[i] = s
         }), n
      };
   Cp.default = Yce;
   var Tp = {};
   Object.defineProperty(Tp, "__esModule", {
      value: !0
   });
   Tp.hover = void 0;
   var Qce = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      Zce = $,
      g1 = qce(Zce);

   function qce(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }

   function efe(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function aI(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function tfe(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var nfe = Tp.hover = function (e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function (r) {
         tfe(i, r);

         function i() {
            var s, o, a, l;
            efe(this, i);
            for (var u = arguments.length, h = Array(u), d = 0; d < u; d++) h[d] = arguments[d];
            return l = (o = (a = aI(this, (s = i.__proto__ || Object.getPrototypeOf(i)).call.apply(s, [this].concat(h))), a), a.state = {
               hover: !1
            }, a.handleMouseOver = function () {
               return a.setState({
                  hover: !0
               })
            }, a.handleMouseOut = function () {
               return a.setState({
                  hover: !1
               })
            }, a.render = function () {
               return g1.default.createElement(n, {
                  onMouseOver: a.handleMouseOver,
                  onMouseOut: a.handleMouseOut
               }, g1.default.createElement(e, Qce({}, a.props, a.state)))
            }, o), aI(a, l)
         }
         return i
      }(g1.default.Component)
   };
   Tp.default = nfe;
   var Rp = {};
   Object.defineProperty(Rp, "__esModule", {
      value: !0
   });
   Rp.active = void 0;
   var rfe = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      ife = $,
      v1 = sfe(ife);

   function sfe(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }

   function ofe(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function lI(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function afe(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var lfe = Rp.active = function (e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function (r) {
         afe(i, r);

         function i() {
            var s, o, a, l;
            ofe(this, i);
            for (var u = arguments.length, h = Array(u), d = 0; d < u; d++) h[d] = arguments[d];
            return l = (o = (a = lI(this, (s = i.__proto__ || Object.getPrototypeOf(i)).call.apply(s, [this].concat(h))), a), a.state = {
               active: !1
            }, a.handleMouseDown = function () {
               return a.setState({
                  active: !0
               })
            }, a.handleMouseUp = function () {
               return a.setState({
                  active: !1
               })
            }, a.render = function () {
               return v1.default.createElement(n, {
                  onMouseDown: a.handleMouseDown,
                  onMouseUp: a.handleMouseUp
               }, v1.default.createElement(e, rfe({}, a.props, a.state)))
            }, o), lI(a, l)
         }
         return i
      }(v1.default.Component)
   };
   Rp.default = lfe;
   var ww = {};
   Object.defineProperty(ww, "__esModule", {
      value: !0
   });
   var ufe = function (e, n) {
      var r = {},
         i = function (o) {
            var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
            r[o] = a
         };
      return e === 0 && i("first-child"), e === n - 1 && i("last-child"), (e === 0 || e % 2 === 0) && i("even"), Math.abs(e % 2) === 1 && i("odd"), i("nth-child", e), r
   };
   ww.default = ufe;
   Object.defineProperty($i, "__esModule", {
      value: !0
   });
   $i.ReactCSS = $i.loop = $i.handleActive = bw = $i.handleHover = $i.hover = void 0;
   var cfe = wp,
      ffe = Uf(cfe),
      hfe = bp,
      dfe = Uf(hfe),
      pfe = Cp,
      mfe = Uf(pfe),
      gfe = Tp,
      fk = Uf(gfe),
      vfe = Rp,
      yfe = Uf(vfe),
      xfe = ww,
      _fe = Uf(xfe);

   function Uf(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }
   $i.hover = fk.default;
   var bw = $i.handleHover = fk.default;
   $i.handleActive = yfe.default;
   $i.loop = _fe.default;
   var Afe = $i.ReactCSS = function (e) {
         for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
         var s = (0, ffe.default)(r),
            o = (0, dfe.default)(e, s);
         return (0, mfe.default)(o)
      },
      St = $i.default = Afe,
      Sfe = function (e, n, r, i, s) {
         var o = s.clientWidth,
            a = s.clientHeight,
            l = typeof e.pageX == "number" ? e.pageX : e.touches[0].pageX,
            u = typeof e.pageY == "number" ? e.pageY : e.touches[0].pageY,
            h = l - (s.getBoundingClientRect().left + window.pageXOffset),
            d = u - (s.getBoundingClientRect().top + window.pageYOffset);
         if (r === "vertical") {
            var p = void 0;
            if (d < 0 ? p = 0 : d > a ? p = 1 : p = Math.round(d * 100 / a) / 100, n.a !== p) return {
               h: n.h,
               s: n.s,
               l: n.l,
               a: p,
               source: "rgb"
            }
         } else {
            var m = void 0;
            if (h < 0 ? m = 0 : h > o ? m = 1 : m = Math.round(h * 100 / o) / 100, i !== m) return {
               h: n.h,
               s: n.s,
               l: n.l,
               a: m,
               source: "rgb"
            }
         }
         return null
      },
      y1 = {},
      Mfe = function (e, n, r, i) {
         if (typeof document > "u" && !i) return null;
         var s = i ? new i : document.createElement("canvas");
         s.width = r * 2, s.height = r * 2;
         var o = s.getContext("2d");
         return o ? (o.fillStyle = e, o.fillRect(0, 0, s.width, s.height), o.fillStyle = n, o.fillRect(0, 0, r, r), o.translate(r, r), o.fillRect(0, 0, r, r), s.toDataURL()) : null
      },
      Efe = function (e, n, r, i) {
         var s = e + "-" + n + "-" + r + (i ? "-server" : "");
         if (y1[s]) return y1[s];
         var o = Mfe(e, n, r, i);
         return y1[s] = o, o
      },
      uI = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      kf = function (e) {
         var n = e.white,
            r = e.grey,
            i = e.size,
            s = e.renderers,
            o = e.borderRadius,
            a = e.boxShadow,
            l = e.children,
            u = St({
               default: {
                  grid: {
                     borderRadius: o,
                     boxShadow: a,
                     absolute: "0px 0px 0px 0px",
                     background: "url(" + Efe(n, r, i, s.canvas) + ") center left"
                  }
               }
            });
         return $.isValidElement(l) ? z.cloneElement(l, uI({}, l.props, {
            style: uI({}, l.props.style, u.grid)
         })) : z.createElement("div", {
            style: u.grid
         })
      };
   kf.defaultProps = {
      size: 8,
      white: "transparent",
      grey: "rgba(0,0,0,.08)",
      renderers: {}
   };
   var wfe = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      bfe = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function Cfe(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function cI(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function Tfe(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var Cw = function (t) {
         Tfe(e, t);

         function e() {
            var n, r, i, s;
            Cfe(this, e);
            for (var o = arguments.length, a = Array(o), l = 0; l < o; l++) a[l] = arguments[l];
            return s = (r = (i = cI(this, (n = e.__proto__ || Object.getPrototypeOf(e)).call.apply(n, [this].concat(a))), i), i.handleChange = function (u) {
               var h = Sfe(u, i.props.hsl, i.props.direction, i.props.a, i.container);
               h && typeof i.props.onChange == "function" && i.props.onChange(h, u)
            }, i.handleMouseDown = function (u) {
               i.handleChange(u), window.addEventListener("mousemove", i.handleChange), window.addEventListener("mouseup", i.handleMouseUp)
            }, i.handleMouseUp = function () {
               i.unbindEventListeners()
            }, i.unbindEventListeners = function () {
               window.removeEventListener("mousemove", i.handleChange), window.removeEventListener("mouseup", i.handleMouseUp)
            }, r), cI(i, s)
         }
         return bfe(e, [{
            key: "componentWillUnmount",
            value: function () {
               this.unbindEventListeners()
            }
         }, {
            key: "render",
            value: function () {
               var r = this,
                  i = this.props.rgb,
                  s = St({
                     default: {
                        alpha: {
                           absolute: "0px 0px 0px 0px",
                           borderRadius: this.props.radius
                        },
                        checkboard: {
                           absolute: "0px 0px 0px 0px",
                           overflow: "hidden",
                           borderRadius: this.props.radius
                        },
                        gradient: {
                           absolute: "0px 0px 0px 0px",
                           background: "linear-gradient(to right, rgba(" + i.r + "," + i.g + "," + i.b + `, 0) 0%,
           rgba(` + i.r + "," + i.g + "," + i.b + ", 1) 100%)",
                           boxShadow: this.props.shadow,
                           borderRadius: this.props.radius
                        },
                        container: {
                           position: "relative",
                           height: "100%",
                           margin: "0 3px"
                        },
                        pointer: {
                           position: "absolute",
                           left: i.a * 100 + "%"
                        },
                        slider: {
                           width: "4px",
                           borderRadius: "1px",
                           height: "8px",
                           boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                           background: "#fff",
                           marginTop: "1px",
                           transform: "translateX(-2px)"
                        }
                     },
                     vertical: {
                        gradient: {
                           background: "linear-gradient(to bottom, rgba(" + i.r + "," + i.g + "," + i.b + `, 0) 0%,
           rgba(` + i.r + "," + i.g + "," + i.b + ", 1) 100%)"
                        },
                        pointer: {
                           left: 0,
                           top: i.a * 100 + "%"
                        }
                     },
                     overwrite: wfe({}, this.props.style)
                  }, {
                     vertical: this.props.direction === "vertical",
                     overwrite: !0
                  });
               return z.createElement("div", {
                  style: s.alpha
               }, z.createElement("div", {
                  style: s.checkboard
               }, z.createElement(kf, {
                  renderers: this.props.renderers
               })), z.createElement("div", {
                  style: s.gradient
               }), z.createElement("div", {
                  style: s.container,
                  ref: function (a) {
                     return r.container = a
                  },
                  onMouseDown: this.handleMouseDown,
                  onTouchMove: this.handleChange,
                  onTouchStart: this.handleChange
               }, z.createElement("div", {
                  style: s.pointer
               }, this.props.pointer ? z.createElement(this.props.pointer, this.props) : z.createElement("div", {
                  style: s.slider
               }))))
            }
         }]), e
      }($.PureComponent || $.Component),
      Rfe = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function Pfe(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
         value: n,
         enumerable: !0,
         configurable: !0,
         writable: !0
      }) : t[e] = n, t
   }

   function Bfe(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function Ife(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function Lfe(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var Dfe = 1,
      hk = 38,
      Ffe = 40,
      Ofe = [hk, Ffe],
      Nfe = function (e) {
         return Ofe.indexOf(e) > -1
      },
      Ufe = function (e) {
         return Number(String(e).replace(/%/g, ""))
      },
      kfe = 1,
      zt = function (t) {
         Lfe(e, t);

         function e(n) {
            Bfe(this, e);
            var r = Ife(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
            return r.handleBlur = function () {
               r.state.blurValue && r.setState({
                  value: r.state.blurValue,
                  blurValue: null
               })
            }, r.handleChange = function (i) {
               r.setUpdatedValue(i.target.value, i)
            }, r.handleKeyDown = function (i) {
               var s = Ufe(i.target.value);
               if (!isNaN(s) && Nfe(i.keyCode)) {
                  var o = r.getArrowOffset(),
                     a = i.keyCode === hk ? s + o : s - o;
                  r.setUpdatedValue(a, i)
               }
            }, r.handleDrag = function (i) {
               if (r.props.dragLabel) {
                  var s = Math.round(r.props.value + i.movementX);
                  s >= 0 && s <= r.props.dragMax && r.props.onChange && r.props.onChange(r.getValueObjectWithLabel(s), i)
               }
            }, r.handleMouseDown = function (i) {
               r.props.dragLabel && (i.preventDefault(), r.handleDrag(i), window.addEventListener("mousemove", r.handleDrag), window.addEventListener("mouseup", r.handleMouseUp))
            }, r.handleMouseUp = function () {
               r.unbindEventListeners()
            }, r.unbindEventListeners = function () {
               window.removeEventListener("mousemove", r.handleDrag), window.removeEventListener("mouseup", r.handleMouseUp)
            }, r.state = {
               value: String(n.value).toUpperCase(),
               blurValue: String(n.value).toUpperCase()
            }, r.inputId = "rc-editable-input-" + kfe++, r
         }
         return Rfe(e, [{
            key: "componentDidUpdate",
            value: function (r, i) {
               this.props.value !== this.state.value && (r.value !== this.props.value || i.value !== this.state.value) && (this.input === document.activeElement ? this.setState({
                  blurValue: String(this.props.value).toUpperCase()
               }) : this.setState({
                  value: String(this.props.value).toUpperCase(),
                  blurValue: !this.state.blurValue && String(this.props.value).toUpperCase()
               }))
            }
         }, {
            key: "componentWillUnmount",
            value: function () {
               this.unbindEventListeners()
            }
         }, {
            key: "getValueObjectWithLabel",
            value: function (r) {
               return Pfe({}, this.props.label, r)
            }
         }, {
            key: "getArrowOffset",
            value: function () {
               return this.props.arrowOffset || Dfe
            }
         }, {
            key: "setUpdatedValue",
            value: function (r, i) {
               var s = this.props.label ? this.getValueObjectWithLabel(r) : r;
               this.props.onChange && this.props.onChange(s, i), this.setState({
                  value: r
               })
            }
         }, {
            key: "render",
            value: function () {
               var r = this,
                  i = St({
                     default: {
                        wrap: {
                           position: "relative"
                        }
                     },
                     "user-override": {
                        wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
                        input: this.props.style && this.props.style.input ? this.props.style.input : {},
                        label: this.props.style && this.props.style.label ? this.props.style.label : {}
                     },
                     "dragLabel-true": {
                        label: {
                           cursor: "ew-resize"
                        }
                     }
                  }, {
                     "user-override": !0
                  }, this.props);
               return z.createElement("div", {
                  style: i.wrap
               }, z.createElement("input", {
                  id: this.inputId,
                  style: i.input,
                  ref: function (o) {
                     return r.input = o
                  },
                  value: this.state.value,
                  onKeyDown: this.handleKeyDown,
                  onChange: this.handleChange,
                  onBlur: this.handleBlur,
                  placeholder: this.props.placeholder,
                  spellCheck: "false"
               }), this.props.label && !this.props.hideLabel ? z.createElement("label", {
                  htmlFor: this.inputId,
                  style: i.label,
                  onMouseDown: this.handleMouseDown
               }, this.props.label) : null)
            }
         }]), e
      }($.PureComponent || $.Component),
      Hfe = function (e, n, r, i) {
         var s = i.clientWidth,
            o = i.clientHeight,
            a = typeof e.pageX == "number" ? e.pageX : e.touches[0].pageX,
            l = typeof e.pageY == "number" ? e.pageY : e.touches[0].pageY,
            u = a - (i.getBoundingClientRect().left + window.pageXOffset),
            h = l - (i.getBoundingClientRect().top + window.pageYOffset);
         if (n === "vertical") {
            var d = void 0;
            if (h < 0) d = 359;
            else if (h > o) d = 0;
            else {
               var p = -(h * 100 / o) + 100;
               d = 360 * p / 100
            }
            if (r.h !== d) return {
               h: d,
               s: r.s,
               l: r.l,
               a: r.a,
               source: "hsl"
            }
         } else {
            var m = void 0;
            if (u < 0) m = 0;
            else if (u > s) m = 359;
            else {
               var v = u * 100 / s;
               m = 360 * v / 100
            }
            if (r.h !== m) return {
               h: m,
               s: r.s,
               l: r.l,
               a: r.a,
               source: "hsl"
            }
         }
         return null
      },
      Gfe = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function zfe(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function fI(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function Vfe(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var Hf = function (t) {
      Vfe(e, t);

      function e() {
         var n, r, i, s;
         zfe(this, e);
         for (var o = arguments.length, a = Array(o), l = 0; l < o; l++) a[l] = arguments[l];
         return s = (r = (i = fI(this, (n = e.__proto__ || Object.getPrototypeOf(e)).call.apply(n, [this].concat(a))), i), i.handleChange = function (u) {
            var h = Hfe(u, i.props.direction, i.props.hsl, i.container);
            h && typeof i.props.onChange == "function" && i.props.onChange(h, u)
         }, i.handleMouseDown = function (u) {
            i.handleChange(u), window.addEventListener("mousemove", i.handleChange), window.addEventListener("mouseup", i.handleMouseUp)
         }, i.handleMouseUp = function () {
            i.unbindEventListeners()
         }, r), fI(i, s)
      }
      return Gfe(e, [{
         key: "componentWillUnmount",
         value: function () {
            this.unbindEventListeners()
         }
      }, {
         key: "unbindEventListeners",
         value: function () {
            window.removeEventListener("mousemove", this.handleChange), window.removeEventListener("mouseup", this.handleMouseUp)
         }
      }, {
         key: "render",
         value: function () {
            var r = this,
               i = this.props.direction,
               s = i === void 0 ? "horizontal" : i,
               o = St({
                  default: {
                     hue: {
                        absolute: "0px 0px 0px 0px",
                        borderRadius: this.props.radius,
                        boxShadow: this.props.shadow
                     },
                     container: {
                        padding: "0 2px",
                        position: "relative",
                        height: "100%",
                        borderRadius: this.props.radius
                     },
                     pointer: {
                        position: "absolute",
                        left: this.props.hsl.h * 100 / 360 + "%"
                     },
                     slider: {
                        marginTop: "1px",
                        width: "4px",
                        borderRadius: "1px",
                        height: "8px",
                        boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                        background: "#fff",
                        transform: "translateX(-2px)"
                     }
                  },
                  vertical: {
                     pointer: {
                        left: "0px",
                        top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
                     }
                  }
               }, {
                  vertical: s === "vertical"
               });
            return z.createElement("div", {
               style: o.hue
            }, z.createElement("div", {
               className: "hue-" + s,
               style: o.container,
               ref: function (l) {
                  return r.container = l
               },
               onMouseDown: this.handleMouseDown,
               onTouchMove: this.handleChange,
               onTouchStart: this.handleChange
            }, z.createElement("style", null, `
            .hue-horizontal {
              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0
                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
              background: -webkit-linear-gradient(to right, #f00 0%, #ff0
                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
            }

            .hue-vertical {
              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,
                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,
                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
            }
          `), z.createElement("div", {
               style: o.pointer
            }, this.props.pointer ? z.createElement(this.props.pointer, this.props) : z.createElement("div", {
               style: o.slider
            }))))
         }
      }]), e
   }($.PureComponent || $.Component);

   function Wfe() {
      this.__data__ = [], this.size = 0
   }

   function Pp(t, e) {
      return t === e || t !== t && e !== e
   }

   function xy(t, e) {
      for (var n = t.length; n--;)
         if (Pp(t[n][0], e)) return n;
      return -1
   }
   var jfe = Array.prototype,
      $fe = jfe.splice;

   function Xfe(t) {
      var e = this.__data__,
         n = xy(e, t);
      if (n < 0) return !1;
      var r = e.length - 1;
      return n == r ? e.pop() : $fe.call(e, n, 1), --this.size, !0
   }

   function Jfe(t) {
      var e = this.__data__,
         n = xy(e, t);
      return n < 0 ? void 0 : e[n][1]
   }

   function Kfe(t) {
      return xy(this.__data__, t) > -1
   }

   function Yfe(t, e) {
      var n = this.__data__,
         r = xy(n, t);
      return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
   }

   function Go(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.clear(); ++e < n;) {
         var r = t[e];
         this.set(r[0], r[1])
      }
   }
   Go.prototype.clear = Wfe;
   Go.prototype.delete = Xfe;
   Go.prototype.get = Jfe;
   Go.prototype.has = Kfe;
   Go.prototype.set = Yfe;

   function Qfe() {
      this.__data__ = new Go, this.size = 0
   }

   function Zfe(t) {
      var e = this.__data__,
         n = e.delete(t);
      return this.size = e.size, n
   }

   function qfe(t) {
      return this.__data__.get(t)
   }

   function ehe(t) {
      return this.__data__.has(t)
   }
   var the = typeof global == "object" && global && global.Object === Object && global;
   const dk = the;
   var nhe = typeof self == "object" && self && self.Object === Object && self,
      rhe = dk || nhe || Function("return this")();
   const Ms = rhe;
   var ihe = Ms.Symbol;
   const Ga = ihe;
   var pk = Object.prototype,
      she = pk.hasOwnProperty,
      ohe = pk.toString,
      Uh = Ga ? Ga.toStringTag : void 0;

   function ahe(t) {
      var e = she.call(t, Uh),
         n = t[Uh];
      try {
         t[Uh] = void 0;
         var r = !0
      } catch {}
      var i = ohe.call(t);
      return r && (e ? t[Uh] = n : delete t[Uh]), i
   }
   var lhe = Object.prototype,
      uhe = lhe.toString;

   function che(t) {
      return uhe.call(t)
   }
   var fhe = "[object Null]",
      hhe = "[object Undefined]",
      hI = Ga ? Ga.toStringTag : void 0;

   function hu(t) {
      return t == null ? t === void 0 ? hhe : fhe : hI && hI in Object(t) ? ahe(t) : che(t)
   }

   function Zi(t) {
      var e = typeof t;
      return t != null && (e == "object" || e == "function")
   }
   var dhe = "[object AsyncFunction]",
      phe = "[object Function]",
      mhe = "[object GeneratorFunction]",
      ghe = "[object Proxy]";

   function Tw(t) {
      if (!Zi(t)) return !1;
      var e = hu(t);
      return e == phe || e == mhe || e == dhe || e == ghe
   }
   var vhe = Ms["__core-js_shared__"];
   const x1 = vhe;
   var dI = function () {
      var t = /[^.]+$/.exec(x1 && x1.keys && x1.keys.IE_PROTO || "");
      return t ? "Symbol(src)_1." + t : ""
   }();

   function yhe(t) {
      return !!dI && dI in t
   }
   var xhe = Function.prototype,
      _he = xhe.toString;

   function du(t) {
      if (t != null) {
         try {
            return _he.call(t)
         } catch {}
         try {
            return t + ""
         } catch {}
      }
      return ""
   }
   var Ahe = /[\\^$.*+?()[\]{}|]/g,
      She = /^\[object .+?Constructor\]$/,
      Mhe = Function.prototype,
      Ehe = Object.prototype,
      whe = Mhe.toString,
      bhe = Ehe.hasOwnProperty,
      Che = RegExp("^" + whe.call(bhe).replace(Ahe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

   function The(t) {
      if (!Zi(t) || yhe(t)) return !1;
      var e = Tw(t) ? Che : She;
      return e.test(du(t))
   }

   function Rhe(t, e) {
      return t == null ? void 0 : t[e]
   }

   function pu(t, e) {
      var n = Rhe(t, e);
      return The(n) ? n : void 0
   }
   var Phe = pu(Ms, "Map");
   const Qd = Phe;
   var Bhe = pu(Object, "create");
   const Zd = Bhe;

   function Ihe() {
      this.__data__ = Zd ? Zd(null) : {}, this.size = 0
   }

   function Lhe(t) {
      var e = this.has(t) && delete this.__data__[t];
      return this.size -= e ? 1 : 0, e
   }
   var Dhe = "__lodash_hash_undefined__",
      Fhe = Object.prototype,
      Ohe = Fhe.hasOwnProperty;

   function Nhe(t) {
      var e = this.__data__;
      if (Zd) {
         var n = e[t];
         return n === Dhe ? void 0 : n
      }
      return Ohe.call(e, t) ? e[t] : void 0
   }
   var Uhe = Object.prototype,
      khe = Uhe.hasOwnProperty;

   function Hhe(t) {
      var e = this.__data__;
      return Zd ? e[t] !== void 0 : khe.call(e, t)
   }
   var Ghe = "__lodash_hash_undefined__";

   function zhe(t, e) {
      var n = this.__data__;
      return this.size += this.has(t) ? 0 : 1, n[t] = Zd && e === void 0 ? Ghe : e, this
   }

   function ql(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.clear(); ++e < n;) {
         var r = t[e];
         this.set(r[0], r[1])
      }
   }
   ql.prototype.clear = Ihe;
   ql.prototype.delete = Lhe;
   ql.prototype.get = Nhe;
   ql.prototype.has = Hhe;
   ql.prototype.set = zhe;

   function Vhe() {
      this.size = 0, this.__data__ = {
         hash: new ql,
         map: new(Qd || Go),
         string: new ql
      }
   }

   function Whe(t) {
      var e = typeof t;
      return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
   }

   function _y(t, e) {
      var n = t.__data__;
      return Whe(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
   }

   function jhe(t) {
      var e = _y(this, t).delete(t);
      return this.size -= e ? 1 : 0, e
   }

   function $he(t) {
      return _y(this, t).get(t)
   }

   function Xhe(t) {
      return _y(this, t).has(t)
   }

   function Jhe(t, e) {
      var n = _y(this, t),
         r = n.size;
      return n.set(t, e), this.size += n.size == r ? 0 : 1, this
   }

   function zo(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.clear(); ++e < n;) {
         var r = t[e];
         this.set(r[0], r[1])
      }
   }
   zo.prototype.clear = Vhe;
   zo.prototype.delete = jhe;
   zo.prototype.get = $he;
   zo.prototype.has = Xhe;
   zo.prototype.set = Jhe;
   var Khe = 200;

   function Yhe(t, e) {
      var n = this.__data__;
      if (n instanceof Go) {
         var r = n.__data__;
         if (!Qd || r.length < Khe - 1) return r.push([t, e]), this.size = ++n.size, this;
         n = this.__data__ = new zo(r)
      }
      return n.set(t, e), this.size = n.size, this
   }

   function Xs(t) {
      var e = this.__data__ = new Go(t);
      this.size = e.size
   }
   Xs.prototype.clear = Qfe;
   Xs.prototype.delete = Zfe;
   Xs.prototype.get = qfe;
   Xs.prototype.has = ehe;
   Xs.prototype.set = Yhe;
   var Qhe = function () {
      try {
         var t = pu(Object, "defineProperty");
         return t({}, "", {}), t
      } catch {}
   }();
   const iv = Qhe;

   function Rw(t, e, n) {
      e == "__proto__" && iv ? iv(t, e, {
         configurable: !0,
         enumerable: !0,
         value: n,
         writable: !0
      }) : t[e] = n
   }

   function IS(t, e, n) {
      (n !== void 0 && !Pp(t[e], n) || n === void 0 && !(e in t)) && Rw(t, e, n)
   }

   function Zhe(t) {
      return function (e, n, r) {
         for (var i = -1, s = Object(e), o = r(e), a = o.length; a--;) {
            var l = o[t ? a : ++i];
            if (n(s[l], l, s) === !1) break
         }
         return e
      }
   }
   var qhe = Zhe();
   const mk = qhe;
   var gk = typeof gi == "object" && gi && !gi.nodeType && gi,
      pI = gk && typeof vi == "object" && vi && !vi.nodeType && vi,
      ede = pI && pI.exports === gk,
      mI = ede ? Ms.Buffer : void 0,
      gI = mI ? mI.allocUnsafe : void 0;

   function tde(t, e) {
      if (e) return t.slice();
      var n = t.length,
         r = gI ? gI(n) : new t.constructor(n);
      return t.copy(r), r
   }
   var nde = Ms.Uint8Array;
   const sv = nde;

   function rde(t) {
      var e = new t.constructor(t.byteLength);
      return new sv(e).set(new sv(t)), e
   }

   function ide(t, e) {
      var n = e ? rde(t.buffer) : t.buffer;
      return new t.constructor(n, t.byteOffset, t.length)
   }

   function sde(t, e) {
      var n = -1,
         r = t.length;
      for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
      return e
   }
   var vI = Object.create,
      ode = function () {
         function t() {}
         return function (e) {
            if (!Zi(e)) return {};
            if (vI) return vI(e);
            t.prototype = e;
            var n = new t;
            return t.prototype = void 0, n
         }
      }();
   const ade = ode;

   function vk(t, e) {
      return function (n) {
         return t(e(n))
      }
   }
   var lde = vk(Object.getPrototypeOf, Object);
   const yk = lde;
   var ude = Object.prototype;

   function Pw(t) {
      var e = t && t.constructor,
         n = typeof e == "function" && e.prototype || ude;
      return t === n
   }

   function cde(t) {
      return typeof t.constructor == "function" && !Pw(t) ? ade(yk(t)) : {}
   }

   function za(t) {
      return t != null && typeof t == "object"
   }
   var fde = "[object Arguments]";

   function yI(t) {
      return za(t) && hu(t) == fde
   }
   var xk = Object.prototype,
      hde = xk.hasOwnProperty,
      dde = xk.propertyIsEnumerable,
      pde = yI(function () {
         return arguments
      }()) ? yI : function (t) {
         return za(t) && hde.call(t, "callee") && !dde.call(t, "callee")
      };
   const ov = pde;
   var mde = Array.isArray;
   const Ei = mde;
   var gde = 9007199254740991;

   function Bw(t) {
      return typeof t == "number" && t > -1 && t % 1 == 0 && t <= gde
   }

   function Gf(t) {
      return t != null && Bw(t.length) && !Tw(t)
   }

   function vde(t) {
      return za(t) && Gf(t)
   }

   function yde() {
      return !1
   }
   var _k = typeof gi == "object" && gi && !gi.nodeType && gi,
      xI = _k && typeof vi == "object" && vi && !vi.nodeType && vi,
      xde = xI && xI.exports === _k,
      _I = xde ? Ms.Buffer : void 0,
      _de = _I ? _I.isBuffer : void 0,
      Ade = _de || yde;
   const av = Ade;
   var Sde = "[object Object]",
      Mde = Function.prototype,
      Ede = Object.prototype,
      Ak = Mde.toString,
      wde = Ede.hasOwnProperty,
      bde = Ak.call(Object);

   function Cde(t) {
      if (!za(t) || hu(t) != Sde) return !1;
      var e = yk(t);
      if (e === null) return !0;
      var n = wde.call(e, "constructor") && e.constructor;
      return typeof n == "function" && n instanceof n && Ak.call(n) == bde
   }
   var Tde = "[object Arguments]",
      Rde = "[object Array]",
      Pde = "[object Boolean]",
      Bde = "[object Date]",
      Ide = "[object Error]",
      Lde = "[object Function]",
      Dde = "[object Map]",
      Fde = "[object Number]",
      Ode = "[object Object]",
      Nde = "[object RegExp]",
      Ude = "[object Set]",
      kde = "[object String]",
      Hde = "[object WeakMap]",
      Gde = "[object ArrayBuffer]",
      zde = "[object DataView]",
      Vde = "[object Float32Array]",
      Wde = "[object Float64Array]",
      jde = "[object Int8Array]",
      $de = "[object Int16Array]",
      Xde = "[object Int32Array]",
      Jde = "[object Uint8Array]",
      Kde = "[object Uint8ClampedArray]",
      Yde = "[object Uint16Array]",
      Qde = "[object Uint32Array]",
      pn = {};
   pn[Vde] = pn[Wde] = pn[jde] = pn[$de] = pn[Xde] = pn[Jde] = pn[Kde] = pn[Yde] = pn[Qde] = !0;
   pn[Tde] = pn[Rde] = pn[Gde] = pn[Pde] = pn[zde] = pn[Bde] = pn[Ide] = pn[Lde] = pn[Dde] = pn[Fde] = pn[Ode] = pn[Nde] = pn[Ude] = pn[kde] = pn[Hde] = !1;

   function Zde(t) {
      return za(t) && Bw(t.length) && !!pn[hu(t)]
   }

   function qde(t) {
      return function (e) {
         return t(e)
      }
   }
   var Sk = typeof gi == "object" && gi && !gi.nodeType && gi,
      vd = Sk && typeof vi == "object" && vi && !vi.nodeType && vi,
      epe = vd && vd.exports === Sk,
      _1 = epe && dk.process,
      tpe = function () {
         try {
            var t = vd && vd.require && vd.require("util").types;
            return t || _1 && _1.binding && _1.binding("util")
         } catch {}
      }();
   const AI = tpe;
   var SI = AI && AI.isTypedArray,
      npe = SI ? qde(SI) : Zde;
   const Iw = npe;

   function LS(t, e) {
      if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__") return t[e]
   }
   var rpe = Object.prototype,
      ipe = rpe.hasOwnProperty;

   function spe(t, e, n) {
      var r = t[e];
      (!(ipe.call(t, e) && Pp(r, n)) || n === void 0 && !(e in t)) && Rw(t, e, n)
   }

   function ope(t, e, n, r) {
      var i = !n;
      n || (n = {});
      for (var s = -1, o = e.length; ++s < o;) {
         var a = e[s],
            l = r ? r(n[a], t[a], a, n, t) : void 0;
         l === void 0 && (l = t[a]), i ? Rw(n, a, l) : spe(n, a, l)
      }
      return n
   }

   function ape(t, e) {
      for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
      return r
   }
   var lpe = 9007199254740991,
      upe = /^(?:0|[1-9]\d*)$/;

   function Lw(t, e) {
      var n = typeof t;
      return e = e ?? lpe, !!e && (n == "number" || n != "symbol" && upe.test(t)) && t > -1 && t % 1 == 0 && t < e
   }
   var cpe = Object.prototype,
      fpe = cpe.hasOwnProperty;

   function Mk(t, e) {
      var n = Ei(t),
         r = !n && ov(t),
         i = !n && !r && av(t),
         s = !n && !r && !i && Iw(t),
         o = n || r || i || s,
         a = o ? ape(t.length, String) : [],
         l = a.length;
      for (var u in t)(e || fpe.call(t, u)) && !(o && (u == "length" || i && (u == "offset" || u == "parent") || s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || Lw(u, l))) && a.push(u);
      return a
   }

   function hpe(t) {
      var e = [];
      if (t != null)
         for (var n in Object(t)) e.push(n);
      return e
   }
   var dpe = Object.prototype,
      ppe = dpe.hasOwnProperty;

   function mpe(t) {
      if (!Zi(t)) return hpe(t);
      var e = Pw(t),
         n = [];
      for (var r in t) r == "constructor" && (e || !ppe.call(t, r)) || n.push(r);
      return n
   }

   function Ek(t) {
      return Gf(t) ? Mk(t, !0) : mpe(t)
   }

   function gpe(t) {
      return ope(t, Ek(t))
   }

   function vpe(t, e, n, r, i, s, o) {
      var a = LS(t, n),
         l = LS(e, n),
         u = o.get(l);
      if (u) {
         IS(t, n, u);
         return
      }
      var h = s ? s(a, l, n + "", t, e, o) : void 0,
         d = h === void 0;
      if (d) {
         var p = Ei(l),
            m = !p && av(l),
            v = !p && !m && Iw(l);
         h = l, p || m || v ? Ei(a) ? h = a : vde(a) ? h = sde(a) : m ? (d = !1, h = tde(l, !0)) : v ? (d = !1, h = ide(l, !0)) : h = [] : Cde(l) || ov(l) ? (h = a, ov(a) ? h = gpe(a) : (!Zi(a) || Tw(a)) && (h = cde(l))) : d = !1
      }
      d && (o.set(l, h), i(h, l, r, s, o), o.delete(l)), IS(t, n, h)
   }

   function wk(t, e, n, r, i) {
      t !== e && mk(e, function (s, o) {
         if (i || (i = new Xs), Zi(s)) vpe(t, e, o, n, wk, r, i);
         else {
            var a = r ? r(LS(t, o), s, o + "", t, e, i) : void 0;
            a === void 0 && (a = s), IS(t, o, a)
         }
      }, Ek)
   }

   function Ay(t) {
      return t
   }

   function ype(t, e, n) {
      switch (n.length) {
         case 0:
            return t.call(e);
         case 1:
            return t.call(e, n[0]);
         case 2:
            return t.call(e, n[0], n[1]);
         case 3:
            return t.call(e, n[0], n[1], n[2])
      }
      return t.apply(e, n)
   }
   var MI = Math.max;

   function xpe(t, e, n) {
      return e = MI(e === void 0 ? t.length - 1 : e, 0),
         function () {
            for (var r = arguments, i = -1, s = MI(r.length - e, 0), o = Array(s); ++i < s;) o[i] = r[e + i];
            i = -1;
            for (var a = Array(e + 1); ++i < e;) a[i] = r[i];
            return a[e] = n(o), ype(t, this, a)
         }
   }

   function _pe(t) {
      return function () {
         return t
      }
   }
   var Ape = iv ? function (t, e) {
      return iv(t, "toString", {
         configurable: !0,
         enumerable: !1,
         value: _pe(e),
         writable: !0
      })
   } : Ay;
   const Spe = Ape;
   var Mpe = 800,
      Epe = 16,
      wpe = Date.now;

   function bpe(t) {
      var e = 0,
         n = 0;
      return function () {
         var r = wpe(),
            i = Epe - (r - n);
         if (n = r, i > 0) {
            if (++e >= Mpe) return arguments[0]
         } else e = 0;
         return t.apply(void 0, arguments)
      }
   }
   var Cpe = bpe(Spe);
   const Tpe = Cpe;

   function Rpe(t, e) {
      return Tpe(xpe(t, e, Ay), t + "")
   }

   function Ppe(t, e, n) {
      if (!Zi(n)) return !1;
      var r = typeof e;
      return (r == "number" ? Gf(n) && Lw(e, n.length) : r == "string" && e in n) ? Pp(n[e], t) : !1
   }

   function Bpe(t) {
      return Rpe(function (e, n) {
         var r = -1,
            i = n.length,
            s = i > 1 ? n[i - 1] : void 0,
            o = i > 2 ? n[2] : void 0;
         for (s = t.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && Ppe(n[0], n[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i;) {
            var a = n[r];
            a && t(e, a, r, s)
         }
         return e
      })
   }
   var Ipe = Bpe(function (t, e, n) {
      wk(t, e, n)
   });
   const ri = Ipe;
   var Bp = function (e) {
      var n = e.zDepth,
         r = e.radius,
         i = e.background,
         s = e.children,
         o = e.styles,
         a = o === void 0 ? {} : o,
         l = St(ri({
            default: {
               wrap: {
                  position: "relative",
                  display: "inline-block"
               },
               content: {
                  position: "relative"
               },
               bg: {
                  absolute: "0px 0px 0px 0px",
                  boxShadow: "0 " + n + "px " + n * 4 + "px rgba(0,0,0,.24)",
                  borderRadius: r,
                  background: i
               }
            },
            "zDepth-0": {
               bg: {
                  boxShadow: "none"
               }
            },
            "zDepth-1": {
               bg: {
                  boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
               }
            },
            "zDepth-2": {
               bg: {
                  boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
               }
            },
            "zDepth-3": {
               bg: {
                  boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
               }
            },
            "zDepth-4": {
               bg: {
                  boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
               }
            },
            "zDepth-5": {
               bg: {
                  boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
               }
            },
            square: {
               bg: {
                  borderRadius: "0"
               }
            },
            circle: {
               bg: {
                  borderRadius: "50%"
               }
            }
         }, a), {
            "zDepth-1": n === 1
         });
      return z.createElement("div", {
         style: l.wrap
      }, z.createElement("div", {
         style: l.bg
      }), z.createElement("div", {
         style: l.content
      }, s))
   };
   Bp.propTypes = {
      background: Ne.string,
      zDepth: Ne.oneOf([0, 1, 2, 3, 4, 5]),
      radius: Ne.number,
      styles: Ne.object
   };
   Bp.defaultProps = {
      background: "#fff",
      zDepth: 1,
      radius: 2,
      styles: {}
   };
   var Lpe = function () {
      return Ms.Date.now()
   };
   const A1 = Lpe;
   var Dpe = /\s/;

   function Fpe(t) {
      for (var e = t.length; e-- && Dpe.test(t.charAt(e)););
      return e
   }
   var Ope = /^\s+/;

   function Npe(t) {
      return t && t.slice(0, Fpe(t) + 1).replace(Ope, "")
   }
   var Upe = "[object Symbol]";

   function Sy(t) {
      return typeof t == "symbol" || za(t) && hu(t) == Upe
   }
   var EI = 0 / 0,
      kpe = /^[-+]0x[0-9a-f]+$/i,
      Hpe = /^0b[01]+$/i,
      Gpe = /^0o[0-7]+$/i,
      zpe = parseInt;

   function wI(t) {
      if (typeof t == "number") return t;
      if (Sy(t)) return EI;
      if (Zi(t)) {
         var e = typeof t.valueOf == "function" ? t.valueOf() : t;
         t = Zi(e) ? e + "" : e
      }
      if (typeof t != "string") return t === 0 ? t : +t;
      t = Npe(t);
      var n = Hpe.test(t);
      return n || Gpe.test(t) ? zpe(t.slice(2), n ? 2 : 8) : kpe.test(t) ? EI : +t
   }
   var Vpe = "Expected a function",
      Wpe = Math.max,
      jpe = Math.min;

   function bk(t, e, n) {
      var r, i, s, o, a, l, u = 0,
         h = !1,
         d = !1,
         p = !0;
      if (typeof t != "function") throw new TypeError(Vpe);
      e = wI(e) || 0, Zi(n) && (h = !!n.leading, d = "maxWait" in n, s = d ? Wpe(wI(n.maxWait) || 0, e) : s, p = "trailing" in n ? !!n.trailing : p);

      function m(R) {
         var B = r,
            D = i;
         return r = i = void 0, u = R, o = t.apply(D, B), o
      }

      function v(R) {
         return u = R, a = setTimeout(g, e), h ? m(R) : o
      }

      function _(R) {
         var B = R - l,
            D = R - u,
            T = e - B;
         return d ? jpe(T, s - D) : T
      }

      function x(R) {
         var B = R - l,
            D = R - u;
         return l === void 0 || B >= e || B < 0 || d && D >= s
      }

      function g() {
         var R = A1();
         if (x(R)) return S(R);
         a = setTimeout(g, _(R))
      }

      function S(R) {
         return a = void 0, p && r ? m(R) : (r = i = void 0, o)
      }

      function A() {
         a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0
      }

      function E() {
         return a === void 0 ? o : S(A1())
      }

      function C() {
         var R = A1(),
            B = x(R);
         if (r = arguments, i = this, l = R, B) {
            if (a === void 0) return v(l);
            if (d) return clearTimeout(a), a = setTimeout(g, e), m(l)
         }
         return a === void 0 && (a = setTimeout(g, e)), o
      }
      return C.cancel = A, C.flush = E, C
   }
   var $pe = "Expected a function";

   function Xpe(t, e, n) {
      var r = !0,
         i = !0;
      if (typeof t != "function") throw new TypeError($pe);
      return Zi(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), bk(t, e, {
         leading: r,
         maxWait: e,
         trailing: i
      })
   }
   var Jpe = function (e, n, r) {
         var i = r.getBoundingClientRect(),
            s = i.width,
            o = i.height,
            a = typeof e.pageX == "number" ? e.pageX : e.touches[0].pageX,
            l = typeof e.pageY == "number" ? e.pageY : e.touches[0].pageY,
            u = a - (r.getBoundingClientRect().left + window.pageXOffset),
            h = l - (r.getBoundingClientRect().top + window.pageYOffset);
         u < 0 ? u = 0 : u > s && (u = s), h < 0 ? h = 0 : h > o && (h = o);
         var d = u / s,
            p = 1 - h / o;
         return {
            h: n.h,
            s: d,
            v: p,
            a: n.a,
            source: "hsv"
         }
      },
      Kpe = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function Ype(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function Qpe(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function Zpe(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var My = function (t) {
      Zpe(e, t);

      function e(n) {
         Ype(this, e);
         var r = Qpe(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n));
         return r.handleChange = function (i) {
            typeof r.props.onChange == "function" && r.throttle(r.props.onChange, Jpe(i, r.props.hsl, r.container), i)
         }, r.handleMouseDown = function (i) {
            r.handleChange(i);
            var s = r.getContainerRenderWindow();
            s.addEventListener("mousemove", r.handleChange), s.addEventListener("mouseup", r.handleMouseUp)
         }, r.handleMouseUp = function () {
            r.unbindEventListeners()
         }, r.throttle = Xpe(function (i, s, o) {
            i(s, o)
         }, 50), r
      }
      return Kpe(e, [{
         key: "componentWillUnmount",
         value: function () {
            this.throttle.cancel(), this.unbindEventListeners()
         }
      }, {
         key: "getContainerRenderWindow",
         value: function () {
            for (var r = this.container, i = window; !i.document.contains(r) && i.parent !== i;) i = i.parent;
            return i
         }
      }, {
         key: "unbindEventListeners",
         value: function () {
            var r = this.getContainerRenderWindow();
            r.removeEventListener("mousemove", this.handleChange), r.removeEventListener("mouseup", this.handleMouseUp)
         }
      }, {
         key: "render",
         value: function () {
            var r = this,
               i = this.props.style || {},
               s = i.color,
               o = i.white,
               a = i.black,
               l = i.pointer,
               u = i.circle,
               h = St({
                  default: {
                     color: {
                        absolute: "0px 0px 0px 0px",
                        background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
                        borderRadius: this.props.radius
                     },
                     white: {
                        absolute: "0px 0px 0px 0px",
                        borderRadius: this.props.radius
                     },
                     black: {
                        absolute: "0px 0px 0px 0px",
                        boxShadow: this.props.shadow,
                        borderRadius: this.props.radius
                     },
                     pointer: {
                        position: "absolute",
                        top: -(this.props.hsv.v * 100) + 100 + "%",
                        left: this.props.hsv.s * 100 + "%",
                        cursor: "default"
                     },
                     circle: {
                        width: "4px",
                        height: "4px",
                        boxShadow: `0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),
            0 0 1px 2px rgba(0,0,0,.4)`,
                        borderRadius: "50%",
                        cursor: "hand",
                        transform: "translate(-2px, -2px)"
                     }
                  },
                  custom: {
                     color: s,
                     white: o,
                     black: a,
                     pointer: l,
                     circle: u
                  }
               }, {
                  custom: !!this.props.style
               });
            return z.createElement("div", {
               style: h.color,
               ref: function (p) {
                  return r.container = p
               },
               onMouseDown: this.handleMouseDown,
               onTouchMove: this.handleChange,
               onTouchStart: this.handleChange
            }, z.createElement("style", null, `
          .saturation-white {
            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));
            background: linear-gradient(to right, #fff, rgba(255,255,255,0));
          }
          .saturation-black {
            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));
            background: linear-gradient(to top, #000, rgba(0,0,0,0));
          }
        `), z.createElement("div", {
               style: h.white,
               className: "saturation-white"
            }, z.createElement("div", {
               style: h.black,
               className: "saturation-black"
            }), z.createElement("div", {
               style: h.pointer
            }, this.props.pointer ? z.createElement(this.props.pointer, this.props) : z.createElement("div", {
               style: h.circle
            }))))
         }
      }]), e
   }($.PureComponent || $.Component);

   function qpe(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1;);
      return t
   }
   var eme = vk(Object.keys, Object);
   const tme = eme;
   var nme = Object.prototype,
      rme = nme.hasOwnProperty;

   function ime(t) {
      if (!Pw(t)) return tme(t);
      var e = [];
      for (var n in Object(t)) rme.call(t, n) && n != "constructor" && e.push(n);
      return e
   }

   function Dw(t) {
      return Gf(t) ? Mk(t) : ime(t)
   }

   function sme(t, e) {
      return t && mk(t, e, Dw)
   }

   function ome(t, e) {
      return function (n, r) {
         if (n == null) return n;
         if (!Gf(n)) return t(n, r);
         for (var i = n.length, s = e ? i : -1, o = Object(n);
            (e ? s-- : ++s < i) && r(o[s], s, o) !== !1;);
         return n
      }
   }
   var ame = ome(sme);
   const Ck = ame;

   function lme(t) {
      return typeof t == "function" ? t : Ay
   }

   function ume(t, e) {
      var n = Ei(t) ? qpe : Ck;
      return n(t, lme(e))
   }

   function lv(t) {
      "@babel/helpers - typeof";
      return lv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
         return typeof e
      } : function (e) {
         return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
      }, lv(t)
   }
   var cme = /^\s+/,
      fme = /\s+$/;

   function at(t, e) {
      if (t = t || "", e = e || {}, t instanceof at) return t;
      if (!(this instanceof at)) return new at(t, e);
      var n = hme(t);
      this._originalInput = t, this._r = n.r, this._g = n.g, this._b = n.b, this._a = n.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || n.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = n.ok
   }
   at.prototype = {
      isDark: function () {
         return this.getBrightness() < 128
      },
      isLight: function () {
         return !this.isDark()
      },
      isValid: function () {
         return this._ok
      },
      getOriginalInput: function () {
         return this._originalInput
      },
      getFormat: function () {
         return this._format
      },
      getAlpha: function () {
         return this._a
      },
      getBrightness: function () {
         var e = this.toRgb();
         return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3
      },
      getLuminance: function () {
         var e = this.toRgb(),
            n, r, i, s, o, a;
         return n = e.r / 255, r = e.g / 255, i = e.b / 255, n <= .03928 ? s = n / 12.92 : s = Math.pow((n + .055) / 1.055, 2.4), r <= .03928 ? o = r / 12.92 : o = Math.pow((r + .055) / 1.055, 2.4), i <= .03928 ? a = i / 12.92 : a = Math.pow((i + .055) / 1.055, 2.4), .2126 * s + .7152 * o + .0722 * a
      },
      setAlpha: function (e) {
         return this._a = Tk(e), this._roundA = Math.round(100 * this._a) / 100, this
      },
      toHsv: function () {
         var e = CI(this._r, this._g, this._b);
         return {
            h: e.h * 360,
            s: e.s,
            v: e.v,
            a: this._a
         }
      },
      toHsvString: function () {
         var e = CI(this._r, this._g, this._b),
            n = Math.round(e.h * 360),
            r = Math.round(e.s * 100),
            i = Math.round(e.v * 100);
         return this._a == 1 ? "hsv(" + n + ", " + r + "%, " + i + "%)" : "hsva(" + n + ", " + r + "%, " + i + "%, " + this._roundA + ")"
      },
      toHsl: function () {
         var e = bI(this._r, this._g, this._b);
         return {
            h: e.h * 360,
            s: e.s,
            l: e.l,
            a: this._a
         }
      },
      toHslString: function () {
         var e = bI(this._r, this._g, this._b),
            n = Math.round(e.h * 360),
            r = Math.round(e.s * 100),
            i = Math.round(e.l * 100);
         return this._a == 1 ? "hsl(" + n + ", " + r + "%, " + i + "%)" : "hsla(" + n + ", " + r + "%, " + i + "%, " + this._roundA + ")"
      },
      toHex: function (e) {
         return TI(this._r, this._g, this._b, e)
      },
      toHexString: function (e) {
         return "#" + this.toHex(e)
      },
      toHex8: function (e) {
         return gme(this._r, this._g, this._b, this._a, e)
      },
      toHex8String: function (e) {
         return "#" + this.toHex8(e)
      },
      toRgb: function () {
         return {
            r: Math.round(this._r),
            g: Math.round(this._g),
            b: Math.round(this._b),
            a: this._a
         }
      },
      toRgbString: function () {
         return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")"
      },
      toPercentageRgb: function () {
         return {
            r: Math.round(Sn(this._r, 255) * 100) + "%",
            g: Math.round(Sn(this._g, 255) * 100) + "%",
            b: Math.round(Sn(this._b, 255) * 100) + "%",
            a: this._a
         }
      },
      toPercentageRgbString: function () {
         return this._a == 1 ? "rgb(" + Math.round(Sn(this._r, 255) * 100) + "%, " + Math.round(Sn(this._g, 255) * 100) + "%, " + Math.round(Sn(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(Sn(this._r, 255) * 100) + "%, " + Math.round(Sn(this._g, 255) * 100) + "%, " + Math.round(Sn(this._b, 255) * 100) + "%, " + this._roundA + ")"
      },
      toName: function () {
         return this._a === 0 ? "transparent" : this._a < 1 ? !1 : Tme[TI(this._r, this._g, this._b, !0)] || !1
      },
      toFilter: function (e) {
         var n = "#" + RI(this._r, this._g, this._b, this._a),
            r = n,
            i = this._gradientType ? "GradientType = 1, " : "";
         if (e) {
            var s = at(e);
            r = "#" + RI(s._r, s._g, s._b, s._a)
         }
         return "progid:DXImageTransform.Microsoft.gradient(" + i + "startColorstr=" + n + ",endColorstr=" + r + ")"
      },
      toString: function (e) {
         var n = !!e;
         e = e || this._format;
         var r = !1,
            i = this._a < 1 && this._a >= 0,
            s = !n && i && (e === "hex" || e === "hex6" || e === "hex3" || e === "hex4" || e === "hex8" || e === "name");
         return s ? e === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), r || this.toHexString())
      },
      clone: function () {
         return at(this.toString())
      },
      _applyModification: function (e, n) {
         var r = e.apply(null, [this].concat([].slice.call(n)));
         return this._r = r._r, this._g = r._g, this._b = r._b, this.setAlpha(r._a), this
      },
      lighten: function () {
         return this._applyModification(_me, arguments)
      },
      brighten: function () {
         return this._applyModification(Ame, arguments)
      },
      darken: function () {
         return this._applyModification(Sme, arguments)
      },
      desaturate: function () {
         return this._applyModification(vme, arguments)
      },
      saturate: function () {
         return this._applyModification(yme, arguments)
      },
      greyscale: function () {
         return this._applyModification(xme, arguments)
      },
      spin: function () {
         return this._applyModification(Mme, arguments)
      },
      _applyCombination: function (e, n) {
         return e.apply(null, [this].concat([].slice.call(n)))
      },
      analogous: function () {
         return this._applyCombination(bme, arguments)
      },
      complement: function () {
         return this._applyCombination(Eme, arguments)
      },
      monochromatic: function () {
         return this._applyCombination(Cme, arguments)
      },
      splitcomplement: function () {
         return this._applyCombination(wme, arguments)
      },
      triad: function () {
         return this._applyCombination(PI, [3])
      },
      tetrad: function () {
         return this._applyCombination(PI, [4])
      }
   };
   at.fromRatio = function (t, e) {
      if (lv(t) == "object") {
         var n = {};
         for (var r in t) t.hasOwnProperty(r) && (r === "a" ? n[r] = t[r] : n[r] = Jh(t[r]));
         t = n
      }
      return at(t, e)
   };

   function hme(t) {
      var e = {
            r: 0,
            g: 0,
            b: 0
         },
         n = 1,
         r = null,
         i = null,
         s = null,
         o = !1,
         a = !1;
      return typeof t == "string" && (t = Ime(t)), lv(t) == "object" && (go(t.r) && go(t.g) && go(t.b) ? (e = dme(t.r, t.g, t.b), o = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : go(t.h) && go(t.s) && go(t.v) ? (r = Jh(t.s), i = Jh(t.v), e = mme(t.h, r, i), o = !0, a = "hsv") : go(t.h) && go(t.s) && go(t.l) && (r = Jh(t.s), s = Jh(t.l), e = pme(t.h, r, s), o = !0, a = "hsl"), t.hasOwnProperty("a") && (n = t.a)), n = Tk(n), {
         ok: o,
         format: t.format || a,
         r: Math.min(255, Math.max(e.r, 0)),
         g: Math.min(255, Math.max(e.g, 0)),
         b: Math.min(255, Math.max(e.b, 0)),
         a: n
      }
   }

   function dme(t, e, n) {
      return {
         r: Sn(t, 255) * 255,
         g: Sn(e, 255) * 255,
         b: Sn(n, 255) * 255
      }
   }

   function bI(t, e, n) {
      t = Sn(t, 255), e = Sn(e, 255), n = Sn(n, 255);
      var r = Math.max(t, e, n),
         i = Math.min(t, e, n),
         s, o, a = (r + i) / 2;
      if (r == i) s = o = 0;
      else {
         var l = r - i;
         switch (o = a > .5 ? l / (2 - r - i) : l / (r + i), r) {
            case t:
               s = (e - n) / l + (e < n ? 6 : 0);
               break;
            case e:
               s = (n - t) / l + 2;
               break;
            case n:
               s = (t - e) / l + 4;
               break
         }
         s /= 6
      }
      return {
         h: s,
         s: o,
         l: a
      }
   }

   function pme(t, e, n) {
      var r, i, s;
      t = Sn(t, 360), e = Sn(e, 100), n = Sn(n, 100);

      function o(u, h, d) {
         return d < 0 && (d += 1), d > 1 && (d -= 1), d < 1 / 6 ? u + (h - u) * 6 * d : d < 1 / 2 ? h : d < 2 / 3 ? u + (h - u) * (2 / 3 - d) * 6 : u
      }
      if (e === 0) r = i = s = n;
      else {
         var a = n < .5 ? n * (1 + e) : n + e - n * e,
            l = 2 * n - a;
         r = o(l, a, t + 1 / 3), i = o(l, a, t), s = o(l, a, t - 1 / 3)
      }
      return {
         r: r * 255,
         g: i * 255,
         b: s * 255
      }
   }

   function CI(t, e, n) {
      t = Sn(t, 255), e = Sn(e, 255), n = Sn(n, 255);
      var r = Math.max(t, e, n),
         i = Math.min(t, e, n),
         s, o, a = r,
         l = r - i;
      if (o = r === 0 ? 0 : l / r, r == i) s = 0;
      else {
         switch (r) {
            case t:
               s = (e - n) / l + (e < n ? 6 : 0);
               break;
            case e:
               s = (n - t) / l + 2;
               break;
            case n:
               s = (t - e) / l + 4;
               break
         }
         s /= 6
      }
      return {
         h: s,
         s: o,
         v: a
      }
   }

   function mme(t, e, n) {
      t = Sn(t, 360) * 6, e = Sn(e, 100), n = Sn(n, 100);
      var r = Math.floor(t),
         i = t - r,
         s = n * (1 - e),
         o = n * (1 - i * e),
         a = n * (1 - (1 - i) * e),
         l = r % 6,
         u = [n, o, s, s, a, n][l],
         h = [a, n, n, o, s, s][l],
         d = [s, s, a, n, n, o][l];
      return {
         r: u * 255,
         g: h * 255,
         b: d * 255
      }
   }

   function TI(t, e, n, r) {
      var i = [ps(Math.round(t).toString(16)), ps(Math.round(e).toString(16)), ps(Math.round(n).toString(16))];
      return r && i[0].charAt(0) == i[0].charAt(1) && i[1].charAt(0) == i[1].charAt(1) && i[2].charAt(0) == i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
   }

   function gme(t, e, n, r, i) {
      var s = [ps(Math.round(t).toString(16)), ps(Math.round(e).toString(16)), ps(Math.round(n).toString(16)), ps(Rk(r))];
      return i && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) && s[3].charAt(0) == s[3].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("")
   }

   function RI(t, e, n, r) {
      var i = [ps(Rk(r)), ps(Math.round(t).toString(16)), ps(Math.round(e).toString(16)), ps(Math.round(n).toString(16))];
      return i.join("")
   }
   at.equals = function (t, e) {
      return !t || !e ? !1 : at(t).toRgbString() == at(e).toRgbString()
   };
   at.random = function () {
      return at.fromRatio({
         r: Math.random(),
         g: Math.random(),
         b: Math.random()
      })
   };

   function vme(t, e) {
      e = e === 0 ? 0 : e || 10;
      var n = at(t).toHsl();
      return n.s -= e / 100, n.s = Ey(n.s), at(n)
   }

   function yme(t, e) {
      e = e === 0 ? 0 : e || 10;
      var n = at(t).toHsl();
      return n.s += e / 100, n.s = Ey(n.s), at(n)
   }

   function xme(t) {
      return at(t).desaturate(100)
   }

   function _me(t, e) {
      e = e === 0 ? 0 : e || 10;
      var n = at(t).toHsl();
      return n.l += e / 100, n.l = Ey(n.l), at(n)
   }

   function Ame(t, e) {
      e = e === 0 ? 0 : e || 10;
      var n = at(t).toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), at(n)
   }

   function Sme(t, e) {
      e = e === 0 ? 0 : e || 10;
      var n = at(t).toHsl();
      return n.l -= e / 100, n.l = Ey(n.l), at(n)
   }

   function Mme(t, e) {
      var n = at(t).toHsl(),
         r = (n.h + e) % 360;
      return n.h = r < 0 ? 360 + r : r, at(n)
   }

   function Eme(t) {
      var e = at(t).toHsl();
      return e.h = (e.h + 180) % 360, at(e)
   }

   function PI(t, e) {
      if (isNaN(e) || e <= 0) throw new Error("Argument to polyad must be a positive number");
      for (var n = at(t).toHsl(), r = [at(t)], i = 360 / e, s = 1; s < e; s++) r.push(at({
         h: (n.h + s * i) % 360,
         s: n.s,
         l: n.l
      }));
      return r
   }

   function wme(t) {
      var e = at(t).toHsl(),
         n = e.h;
      return [at(t), at({
         h: (n + 72) % 360,
         s: e.s,
         l: e.l
      }), at({
         h: (n + 216) % 360,
         s: e.s,
         l: e.l
      })]
   }

   function bme(t, e, n) {
      e = e || 6, n = n || 30;
      var r = at(t).toHsl(),
         i = 360 / n,
         s = [at(t)];
      for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e;) r.h = (r.h + i) % 360, s.push(at(r));
      return s
   }

   function Cme(t, e) {
      e = e || 6;
      for (var n = at(t).toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / e; e--;) o.push(at({
         h: r,
         s: i,
         v: s
      })), s = (s + a) % 1;
      return o
   }
   at.mix = function (t, e, n) {
      n = n === 0 ? 0 : n || 50;
      var r = at(t).toRgb(),
         i = at(e).toRgb(),
         s = n / 100,
         o = {
            r: (i.r - r.r) * s + r.r,
            g: (i.g - r.g) * s + r.g,
            b: (i.b - r.b) * s + r.b,
            a: (i.a - r.a) * s + r.a
         };
      return at(o)
   };
   at.readability = function (t, e) {
      var n = at(t),
         r = at(e);
      return (Math.max(n.getLuminance(), r.getLuminance()) + .05) / (Math.min(n.getLuminance(), r.getLuminance()) + .05)
   };
   at.isReadable = function (t, e, n) {
      var r = at.readability(t, e),
         i, s;
      switch (s = !1, i = Lme(n), i.level + i.size) {
         case "AAsmall":
         case "AAAlarge":
            s = r >= 4.5;
            break;
         case "AAlarge":
            s = r >= 3;
            break;
         case "AAAsmall":
            s = r >= 7;
            break
      }
      return s
   };
   at.mostReadable = function (t, e, n) {
      var r = null,
         i = 0,
         s, o, a, l;
      n = n || {}, o = n.includeFallbackColors, a = n.level, l = n.size;
      for (var u = 0; u < e.length; u++) s = at.readability(t, e[u]), s > i && (i = s, r = at(e[u]));
      return at.isReadable(t, r, {
         level: a,
         size: l
      }) || !o ? r : (n.includeFallbackColors = !1, at.mostReadable(t, ["#fff", "#000"], n))
   };
   var DS = at.names = {
         aliceblue: "f0f8ff",
         antiquewhite: "faebd7",
         aqua: "0ff",
         aquamarine: "7fffd4",
         azure: "f0ffff",
         beige: "f5f5dc",
         bisque: "ffe4c4",
         black: "000",
         blanchedalmond: "ffebcd",
         blue: "00f",
         blueviolet: "8a2be2",
         brown: "a52a2a",
         burlywood: "deb887",
         burntsienna: "ea7e5d",
         cadetblue: "5f9ea0",
         chartreuse: "7fff00",
         chocolate: "d2691e",
         coral: "ff7f50",
         cornflowerblue: "6495ed",
         cornsilk: "fff8dc",
         crimson: "dc143c",
         cyan: "0ff",
         darkblue: "00008b",
         darkcyan: "008b8b",
         darkgoldenrod: "b8860b",
         darkgray: "a9a9a9",
         darkgreen: "006400",
         darkgrey: "a9a9a9",
         darkkhaki: "bdb76b",
         darkmagenta: "8b008b",
         darkolivegreen: "556b2f",
         darkorange: "ff8c00",
         darkorchid: "9932cc",
         darkred: "8b0000",
         darksalmon: "e9967a",
         darkseagreen: "8fbc8f",
         darkslateblue: "483d8b",
         darkslategray: "2f4f4f",
         darkslategrey: "2f4f4f",
         darkturquoise: "00ced1",
         darkviolet: "9400d3",
         deeppink: "ff1493",
         deepskyblue: "00bfff",
         dimgray: "696969",
         dimgrey: "696969",
         dodgerblue: "1e90ff",
         firebrick: "b22222",
         floralwhite: "fffaf0",
         forestgreen: "228b22",
         fuchsia: "f0f",
         gainsboro: "dcdcdc",
         ghostwhite: "f8f8ff",
         gold: "ffd700",
         goldenrod: "daa520",
         gray: "808080",
         green: "008000",
         greenyellow: "adff2f",
         grey: "808080",
         honeydew: "f0fff0",
         hotpink: "ff69b4",
         indianred: "cd5c5c",
         indigo: "4b0082",
         ivory: "fffff0",
         khaki: "f0e68c",
         lavender: "e6e6fa",
         lavenderblush: "fff0f5",
         lawngreen: "7cfc00",
         lemonchiffon: "fffacd",
         lightblue: "add8e6",
         lightcoral: "f08080",
         lightcyan: "e0ffff",
         lightgoldenrodyellow: "fafad2",
         lightgray: "d3d3d3",
         lightgreen: "90ee90",
         lightgrey: "d3d3d3",
         lightpink: "ffb6c1",
         lightsalmon: "ffa07a",
         lightseagreen: "20b2aa",
         lightskyblue: "87cefa",
         lightslategray: "789",
         lightslategrey: "789",
         lightsteelblue: "b0c4de",
         lightyellow: "ffffe0",
         lime: "0f0",
         limegreen: "32cd32",
         linen: "faf0e6",
         magenta: "f0f",
         maroon: "800000",
         mediumaquamarine: "66cdaa",
         mediumblue: "0000cd",
         mediumorchid: "ba55d3",
         mediumpurple: "9370db",
         mediumseagreen: "3cb371",
         mediumslateblue: "7b68ee",
         mediumspringgreen: "00fa9a",
         mediumturquoise: "48d1cc",
         mediumvioletred: "c71585",
         midnightblue: "191970",
         mintcream: "f5fffa",
         mistyrose: "ffe4e1",
         moccasin: "ffe4b5",
         navajowhite: "ffdead",
         navy: "000080",
         oldlace: "fdf5e6",
         olive: "808000",
         olivedrab: "6b8e23",
         orange: "ffa500",
         orangered: "ff4500",
         orchid: "da70d6",
         palegoldenrod: "eee8aa",
         palegreen: "98fb98",
         paleturquoise: "afeeee",
         palevioletred: "db7093",
         papayawhip: "ffefd5",
         peachpuff: "ffdab9",
         peru: "cd853f",
         pink: "ffc0cb",
         plum: "dda0dd",
         powderblue: "b0e0e6",
         purple: "800080",
         rebeccapurple: "663399",
         red: "f00",
         rosybrown: "bc8f8f",
         royalblue: "4169e1",
         saddlebrown: "8b4513",
         salmon: "fa8072",
         sandybrown: "f4a460",
         seagreen: "2e8b57",
         seashell: "fff5ee",
         sienna: "a0522d",
         silver: "c0c0c0",
         skyblue: "87ceeb",
         slateblue: "6a5acd",
         slategray: "708090",
         slategrey: "708090",
         snow: "fffafa",
         springgreen: "00ff7f",
         steelblue: "4682b4",
         tan: "d2b48c",
         teal: "008080",
         thistle: "d8bfd8",
         tomato: "ff6347",
         turquoise: "40e0d0",
         violet: "ee82ee",
         wheat: "f5deb3",
         white: "fff",
         whitesmoke: "f5f5f5",
         yellow: "ff0",
         yellowgreen: "9acd32"
      },
      Tme = at.hexNames = Rme(DS);

   function Rme(t) {
      var e = {};
      for (var n in t) t.hasOwnProperty(n) && (e[t[n]] = n);
      return e
   }

   function Tk(t) {
      return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t
   }

   function Sn(t, e) {
      Pme(t) && (t = "100%");
      var n = Bme(t);
      return t = Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(t * e, 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : t % e / parseFloat(e)
   }

   function Ey(t) {
      return Math.min(1, Math.max(0, t))
   }

   function hi(t) {
      return parseInt(t, 16)
   }

   function Pme(t) {
      return typeof t == "string" && t.indexOf(".") != -1 && parseFloat(t) === 1
   }

   function Bme(t) {
      return typeof t == "string" && t.indexOf("%") != -1
   }

   function ps(t) {
      return t.length == 1 ? "0" + t : "" + t
   }

   function Jh(t) {
      return t <= 1 && (t = t * 100 + "%"), t
   }

   function Rk(t) {
      return Math.round(parseFloat(t) * 255).toString(16)
   }

   function BI(t) {
      return hi(t) / 255
   }
   var ls = function () {
      var t = "[-\\+]?\\d+%?",
         e = "[-\\+]?\\d*\\.\\d+%?",
         n = "(?:" + e + ")|(?:" + t + ")",
         r = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?",
         i = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?";
      return {
         CSS_UNIT: new RegExp(n),
         rgb: new RegExp("rgb" + r),
         rgba: new RegExp("rgba" + i),
         hsl: new RegExp("hsl" + r),
         hsla: new RegExp("hsla" + i),
         hsv: new RegExp("hsv" + r),
         hsva: new RegExp("hsva" + i),
         hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
         hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
         hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
         hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      }
   }();

   function go(t) {
      return !!ls.CSS_UNIT.exec(t)
   }

   function Ime(t) {
      t = t.replace(cme, "").replace(fme, "").toLowerCase();
      var e = !1;
      if (DS[t]) t = DS[t], e = !0;
      else if (t == "transparent") return {
         r: 0,
         g: 0,
         b: 0,
         a: 0,
         format: "name"
      };
      var n;
      return (n = ls.rgb.exec(t)) ? {
         r: n[1],
         g: n[2],
         b: n[3]
      } : (n = ls.rgba.exec(t)) ? {
         r: n[1],
         g: n[2],
         b: n[3],
         a: n[4]
      } : (n = ls.hsl.exec(t)) ? {
         h: n[1],
         s: n[2],
         l: n[3]
      } : (n = ls.hsla.exec(t)) ? {
         h: n[1],
         s: n[2],
         l: n[3],
         a: n[4]
      } : (n = ls.hsv.exec(t)) ? {
         h: n[1],
         s: n[2],
         v: n[3]
      } : (n = ls.hsva.exec(t)) ? {
         h: n[1],
         s: n[2],
         v: n[3],
         a: n[4]
      } : (n = ls.hex8.exec(t)) ? {
         r: hi(n[1]),
         g: hi(n[2]),
         b: hi(n[3]),
         a: BI(n[4]),
         format: e ? "name" : "hex8"
      } : (n = ls.hex6.exec(t)) ? {
         r: hi(n[1]),
         g: hi(n[2]),
         b: hi(n[3]),
         format: e ? "name" : "hex"
      } : (n = ls.hex4.exec(t)) ? {
         r: hi(n[1] + "" + n[1]),
         g: hi(n[2] + "" + n[2]),
         b: hi(n[3] + "" + n[3]),
         a: BI(n[4] + "" + n[4]),
         format: e ? "name" : "hex8"
      } : (n = ls.hex3.exec(t)) ? {
         r: hi(n[1] + "" + n[1]),
         g: hi(n[2] + "" + n[2]),
         b: hi(n[3] + "" + n[3]),
         format: e ? "name" : "hex"
      } : !1
   }

   function Lme(t) {
      var e, n;
      return t = t || {
         level: "AA",
         size: "small"
      }, e = (t.level || "AA").toUpperCase(), n = (t.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), n !== "small" && n !== "large" && (n = "small"), {
         level: e,
         size: n
      }
   }
   var II = function (e) {
         var n = ["r", "g", "b", "a", "h", "s", "l", "v"],
            r = 0,
            i = 0;
         return ume(n, function (s) {
            if (e[s] && (r += 1, isNaN(e[s]) || (i += 1), s === "s" || s === "l")) {
               var o = /^\d+%$/;
               o.test(e[s]) && (i += 1)
            }
         }), r === i ? e : !1
      },
      Kh = function (e, n) {
         var r = e.hex ? at(e.hex) : at(e),
            i = r.toHsl(),
            s = r.toHsv(),
            o = r.toRgb(),
            a = r.toHex();
         i.s === 0 && (i.h = n || 0, s.h = n || 0);
         var l = a === "000000" && o.a === 0;
         return {
            hsl: i,
            hex: l ? "transparent" : "#" + a,
            rgb: o,
            hsv: s,
            oldHue: e.h || n || i.h,
            source: e.source
         }
      },
      Qa = function (e) {
         if (e === "transparent") return !0;
         var n = String(e).charAt(0) === "#" ? 1 : 0;
         return e.length !== 4 + n && e.length < 7 + n && at(e).isValid()
      },
      Fw = function (e) {
         if (!e) return "#fff";
         var n = Kh(e);
         if (n.hex === "transparent") return "rgba(0,0,0,0.4)";
         var r = (n.rgb.r * 299 + n.rgb.g * 587 + n.rgb.b * 114) / 1e3;
         return r >= 128 ? "#000" : "#fff"
      },
      S1 = function (e, n) {
         var r = e.replace("Â°", "");
         return at(n + " (" + r + ")")._ok
      },
      kh = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      Dme = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function Fme(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function Ome(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function Nme(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var ii = function (e) {
         var n = function (r) {
            Nme(i, r);

            function i(s) {
               Fme(this, i);
               var o = Ome(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this));
               return o.handleChange = function (a, l) {
                  var u = II(a);
                  if (u) {
                     var h = Kh(a, a.h || o.state.oldHue);
                     o.setState(h), o.props.onChangeComplete && o.debounce(o.props.onChangeComplete, h, l), o.props.onChange && o.props.onChange(h, l)
                  }
               }, o.handleSwatchHover = function (a, l) {
                  var u = II(a);
                  if (u) {
                     var h = Kh(a, a.h || o.state.oldHue);
                     o.props.onSwatchHover && o.props.onSwatchHover(h, l)
                  }
               }, o.state = kh({}, Kh(s.color, 0)), o.debounce = bk(function (a, l, u) {
                  a(l, u)
               }, 100), o
            }
            return Dme(i, [{
               key: "render",
               value: function () {
                  var o = {};
                  return this.props.onSwatchHover && (o.onSwatchHover = this.handleSwatchHover), z.createElement(e, kh({}, this.props, this.state, {
                     onChange: this.handleChange
                  }, o))
               }
            }], [{
               key: "getDerivedStateFromProps",
               value: function (o, a) {
                  return kh({}, Kh(o.color, a.oldHue))
               }
            }]), i
         }($.PureComponent || $.Component);
         return n.propTypes = kh({}, e.propTypes), n.defaultProps = kh({}, e.defaultProps, {
            color: {
               h: 250,
               s: .5,
               l: .2,
               a: 1
            }
         }), n
      },
      Ume = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      kme = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function Hme(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function LI(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function Gme(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var zme = function (e) {
         var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
         return function (r) {
            Gme(i, r);

            function i() {
               var s, o, a, l;
               Hme(this, i);
               for (var u = arguments.length, h = Array(u), d = 0; d < u; d++) h[d] = arguments[d];
               return l = (o = (a = LI(this, (s = i.__proto__ || Object.getPrototypeOf(i)).call.apply(s, [this].concat(h))), a), a.state = {
                  focus: !1
               }, a.handleFocus = function () {
                  return a.setState({
                     focus: !0
                  })
               }, a.handleBlur = function () {
                  return a.setState({
                     focus: !1
                  })
               }, o), LI(a, l)
            }
            return kme(i, [{
               key: "render",
               value: function () {
                  return z.createElement(n, {
                     onFocus: this.handleFocus,
                     onBlur: this.handleBlur
                  }, z.createElement(e, Ume({}, this.props, this.state)))
               }
            }]), i
         }(z.Component)
      },
      DI = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      Vme = 13,
      Wme = function (e) {
         var n = e.color,
            r = e.style,
            i = e.onClick,
            s = i === void 0 ? function () {} : i,
            o = e.onHover,
            a = e.title,
            l = a === void 0 ? n : a,
            u = e.children,
            h = e.focus,
            d = e.focusStyle,
            p = d === void 0 ? {} : d,
            m = n === "transparent",
            v = St({
               default: {
                  swatch: DI({
                     background: n,
                     height: "100%",
                     width: "100%",
                     cursor: "pointer",
                     position: "relative",
                     outline: "none"
                  }, r, h ? p : {})
               }
            }),
            _ = function (E) {
               return s(n, E)
            },
            x = function (E) {
               return E.keyCode === Vme && s(n, E)
            },
            g = function (E) {
               return o(n, E)
            },
            S = {};
         return o && (S.onMouseOver = g), z.createElement("div", DI({
            style: v.swatch,
            onClick: _,
            title: l,
            tabIndex: 0,
            onKeyDown: x
         }, S), u, m && z.createElement(kf, {
            borderRadius: v.swatch.borderRadius,
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
         }))
      };
   const mu = zme(Wme);
   var jme = function (e) {
         var n = e.direction,
            r = St({
               default: {
                  picker: {
                     width: "18px",
                     height: "18px",
                     borderRadius: "50%",
                     transform: "translate(-9px, -1px)",
                     backgroundColor: "rgb(248, 248, 248)",
                     boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
                  }
               },
               vertical: {
                  picker: {
                     transform: "translate(-3px, -9px)"
                  }
               }
            }, {
               vertical: n === "vertical"
            });
         return z.createElement("div", {
            style: r.picker
         })
      },
      $me = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      Pk = function (e) {
         var n = e.rgb,
            r = e.hsl,
            i = e.width,
            s = e.height,
            o = e.onChange,
            a = e.direction,
            l = e.style,
            u = e.renderers,
            h = e.pointer,
            d = e.className,
            p = d === void 0 ? "" : d,
            m = St({
               default: {
                  picker: {
                     position: "relative",
                     width: i,
                     height: s
                  },
                  alpha: {
                     radius: "2px",
                     style: l
                  }
               }
            });
         return z.createElement("div", {
            style: m.picker,
            className: "alpha-picker " + p
         }, z.createElement(Cw, $me({}, m.alpha, {
            rgb: n,
            hsl: r,
            pointer: h,
            renderers: u,
            onChange: o,
            direction: a
         })))
      };
   Pk.defaultProps = {
      width: "316px",
      height: "16px",
      direction: "horizontal",
      pointer: jme
   };
   ii(Pk);

   function Bk(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r;) i[n] = e(t[n], n, t);
      return i
   }
   var Xme = "__lodash_hash_undefined__";

   function Jme(t) {
      return this.__data__.set(t, Xme), this
   }

   function Kme(t) {
      return this.__data__.has(t)
   }

   function uv(t) {
      var e = -1,
         n = t == null ? 0 : t.length;
      for (this.__data__ = new zo; ++e < n;) this.add(t[e])
   }
   uv.prototype.add = uv.prototype.push = Jme;
   uv.prototype.has = Kme;

   function Yme(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length; ++n < r;)
         if (e(t[n], n, t)) return !0;
      return !1
   }

   function Qme(t, e) {
      return t.has(e)
   }
   var Zme = 1,
      qme = 2;

   function Ik(t, e, n, r, i, s) {
      var o = n & Zme,
         a = t.length,
         l = e.length;
      if (a != l && !(o && l > a)) return !1;
      var u = s.get(t),
         h = s.get(e);
      if (u && h) return u == e && h == t;
      var d = -1,
         p = !0,
         m = n & qme ? new uv : void 0;
      for (s.set(t, e), s.set(e, t); ++d < a;) {
         var v = t[d],
            _ = e[d];
         if (r) var x = o ? r(_, v, d, e, t, s) : r(v, _, d, t, e, s);
         if (x !== void 0) {
            if (x) continue;
            p = !1;
            break
         }
         if (m) {
            if (!Yme(e, function (g, S) {
                  if (!Qme(m, S) && (v === g || i(v, g, n, r, s))) return m.push(S)
               })) {
               p = !1;
               break
            }
         } else if (!(v === _ || i(v, _, n, r, s))) {
            p = !1;
            break
         }
      }
      return s.delete(t), s.delete(e), p
   }

   function ege(t) {
      var e = -1,
         n = Array(t.size);
      return t.forEach(function (r, i) {
         n[++e] = [i, r]
      }), n
   }

   function tge(t) {
      var e = -1,
         n = Array(t.size);
      return t.forEach(function (r) {
         n[++e] = r
      }), n
   }
   var nge = 1,
      rge = 2,
      ige = "[object Boolean]",
      sge = "[object Date]",
      oge = "[object Error]",
      age = "[object Map]",
      lge = "[object Number]",
      uge = "[object RegExp]",
      cge = "[object Set]",
      fge = "[object String]",
      hge = "[object Symbol]",
      dge = "[object ArrayBuffer]",
      pge = "[object DataView]",
      FI = Ga ? Ga.prototype : void 0,
      M1 = FI ? FI.valueOf : void 0;

   function mge(t, e, n, r, i, s, o) {
      switch (n) {
         case pge:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
            t = t.buffer, e = e.buffer;
         case dge:
            return !(t.byteLength != e.byteLength || !s(new sv(t), new sv(e)));
         case ige:
         case sge:
         case lge:
            return Pp(+t, +e);
         case oge:
            return t.name == e.name && t.message == e.message;
         case uge:
         case fge:
            return t == e + "";
         case age:
            var a = ege;
         case cge:
            var l = r & nge;
            if (a || (a = tge), t.size != e.size && !l) return !1;
            var u = o.get(t);
            if (u) return u == e;
            r |= rge, o.set(t, e);
            var h = Ik(a(t), a(e), r, i, s, o);
            return o.delete(t), h;
         case hge:
            if (M1) return M1.call(t) == M1.call(e)
      }
      return !1
   }

   function gge(t, e) {
      for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
      return t
   }

   function vge(t, e, n) {
      var r = e(t);
      return Ei(t) ? r : gge(r, n(t))
   }

   function yge(t, e) {
      for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r;) {
         var o = t[n];
         e(o, n, t) && (s[i++] = o)
      }
      return s
   }

   function xge() {
      return []
   }
   var _ge = Object.prototype,
      Age = _ge.propertyIsEnumerable,
      OI = Object.getOwnPropertySymbols,
      Sge = OI ? function (t) {
         return t == null ? [] : (t = Object(t), yge(OI(t), function (e) {
            return Age.call(t, e)
         }))
      } : xge;
   const Mge = Sge;

   function NI(t) {
      return vge(t, Dw, Mge)
   }
   var Ege = 1,
      wge = Object.prototype,
      bge = wge.hasOwnProperty;

   function Cge(t, e, n, r, i, s) {
      var o = n & Ege,
         a = NI(t),
         l = a.length,
         u = NI(e),
         h = u.length;
      if (l != h && !o) return !1;
      for (var d = l; d--;) {
         var p = a[d];
         if (!(o ? p in e : bge.call(e, p))) return !1
      }
      var m = s.get(t),
         v = s.get(e);
      if (m && v) return m == e && v == t;
      var _ = !0;
      s.set(t, e), s.set(e, t);
      for (var x = o; ++d < l;) {
         p = a[d];
         var g = t[p],
            S = e[p];
         if (r) var A = o ? r(S, g, p, e, t, s) : r(g, S, p, t, e, s);
         if (!(A === void 0 ? g === S || i(g, S, n, r, s) : A)) {
            _ = !1;
            break
         }
         x || (x = p == "constructor")
      }
      if (_ && !x) {
         var E = t.constructor,
            C = e.constructor;
         E != C && "constructor" in t && "constructor" in e && !(typeof E == "function" && E instanceof E && typeof C == "function" && C instanceof C) && (_ = !1)
      }
      return s.delete(t), s.delete(e), _
   }
   var Tge = pu(Ms, "DataView");
   const FS = Tge;
   var Rge = pu(Ms, "Promise");
   const OS = Rge;
   var Pge = pu(Ms, "Set");
   const NS = Pge;
   var Bge = pu(Ms, "WeakMap");
   const US = Bge;
   var UI = "[object Map]",
      Ige = "[object Object]",
      kI = "[object Promise]",
      HI = "[object Set]",
      GI = "[object WeakMap]",
      zI = "[object DataView]",
      Lge = du(FS),
      Dge = du(Qd),
      Fge = du(OS),
      Oge = du(NS),
      Nge = du(US),
      wl = hu;
   (FS && wl(new FS(new ArrayBuffer(1))) != zI || Qd && wl(new Qd) != UI || OS && wl(OS.resolve()) != kI || NS && wl(new NS) != HI || US && wl(new US) != GI) && (wl = function (t) {
      var e = hu(t),
         n = e == Ige ? t.constructor : void 0,
         r = n ? du(n) : "";
      if (r) switch (r) {
         case Lge:
            return zI;
         case Dge:
            return UI;
         case Fge:
            return kI;
         case Oge:
            return HI;
         case Nge:
            return GI
      }
      return e
   });
   const VI = wl;
   var Uge = 1,
      WI = "[object Arguments]",
      jI = "[object Array]",
      Gg = "[object Object]",
      kge = Object.prototype,
      $I = kge.hasOwnProperty;

   function Hge(t, e, n, r, i, s) {
      var o = Ei(t),
         a = Ei(e),
         l = o ? jI : VI(t),
         u = a ? jI : VI(e);
      l = l == WI ? Gg : l, u = u == WI ? Gg : u;
      var h = l == Gg,
         d = u == Gg,
         p = l == u;
      if (p && av(t)) {
         if (!av(e)) return !1;
         o = !0, h = !1
      }
      if (p && !h) return s || (s = new Xs), o || Iw(t) ? Ik(t, e, n, r, i, s) : mge(t, e, l, n, r, i, s);
      if (!(n & Uge)) {
         var m = h && $I.call(t, "__wrapped__"),
            v = d && $I.call(e, "__wrapped__");
         if (m || v) {
            var _ = m ? t.value() : t,
               x = v ? e.value() : e;
            return s || (s = new Xs), i(_, x, n, r, s)
         }
      }
      return p ? (s || (s = new Xs), Cge(t, e, n, r, i, s)) : !1
   }

   function Ow(t, e, n, r, i) {
      return t === e ? !0 : t == null || e == null || !za(t) && !za(e) ? t !== t && e !== e : Hge(t, e, n, r, Ow, i)
   }
   var Gge = 1,
      zge = 2;

   function Vge(t, e, n, r) {
      var i = n.length,
         s = i,
         o = !r;
      if (t == null) return !s;
      for (t = Object(t); i--;) {
         var a = n[i];
         if (o && a[2] ? a[1] !== t[a[0]] : !(a[0] in t)) return !1
      }
      for (; ++i < s;) {
         a = n[i];
         var l = a[0],
            u = t[l],
            h = a[1];
         if (o && a[2]) {
            if (u === void 0 && !(l in t)) return !1
         } else {
            var d = new Xs;
            if (r) var p = r(u, h, l, t, e, d);
            if (!(p === void 0 ? Ow(h, u, Gge | zge, r, d) : p)) return !1
         }
      }
      return !0
   }

   function Lk(t) {
      return t === t && !Zi(t)
   }

   function Wge(t) {
      for (var e = Dw(t), n = e.length; n--;) {
         var r = e[n],
            i = t[r];
         e[n] = [r, i, Lk(i)]
      }
      return e
   }

   function Dk(t, e) {
      return function (n) {
         return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n))
      }
   }

   function jge(t) {
      var e = Wge(t);
      return e.length == 1 && e[0][2] ? Dk(e[0][0], e[0][1]) : function (n) {
         return n === t || Vge(n, t, e)
      }
   }
   var $ge = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      Xge = /^\w*$/;

   function Nw(t, e) {
      if (Ei(t)) return !1;
      var n = typeof t;
      return n == "number" || n == "symbol" || n == "boolean" || t == null || Sy(t) ? !0 : Xge.test(t) || !$ge.test(t) || e != null && t in Object(e)
   }
   var Jge = "Expected a function";

   function Uw(t, e) {
      if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(Jge);
      var n = function () {
         var r = arguments,
            i = e ? e.apply(this, r) : r[0],
            s = n.cache;
         if (s.has(i)) return s.get(i);
         var o = t.apply(this, r);
         return n.cache = s.set(i, o) || s, o
      };
      return n.cache = new(Uw.Cache || zo), n
   }
   Uw.Cache = zo;
   var Kge = 500;

   function Yge(t) {
      var e = Uw(t, function (r) {
            return n.size === Kge && n.clear(), r
         }),
         n = e.cache;
      return e
   }
   var Qge = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      Zge = /\\(\\)?/g,
      qge = Yge(function (t) {
         var e = [];
         return t.charCodeAt(0) === 46 && e.push(""), t.replace(Qge, function (n, r, i, s) {
            e.push(i ? s.replace(Zge, "$1") : r || n)
         }), e
      });
   const e0e = qge;
   var t0e = 1 / 0,
      XI = Ga ? Ga.prototype : void 0,
      JI = XI ? XI.toString : void 0;

   function Fk(t) {
      if (typeof t == "string") return t;
      if (Ei(t)) return Bk(t, Fk) + "";
      if (Sy(t)) return JI ? JI.call(t) : "";
      var e = t + "";
      return e == "0" && 1 / t == -t0e ? "-0" : e
   }

   function n0e(t) {
      return t == null ? "" : Fk(t)
   }

   function Ok(t, e) {
      return Ei(t) ? t : Nw(t, e) ? [t] : e0e(n0e(t))
   }
   var r0e = 1 / 0;

   function wy(t) {
      if (typeof t == "string" || Sy(t)) return t;
      var e = t + "";
      return e == "0" && 1 / t == -r0e ? "-0" : e
   }

   function Nk(t, e) {
      e = Ok(e, t);
      for (var n = 0, r = e.length; t != null && n < r;) t = t[wy(e[n++])];
      return n && n == r ? t : void 0
   }

   function i0e(t, e, n) {
      var r = t == null ? void 0 : Nk(t, e);
      return r === void 0 ? n : r
   }

   function s0e(t, e) {
      return t != null && e in Object(t)
   }

   function o0e(t, e, n) {
      e = Ok(e, t);
      for (var r = -1, i = e.length, s = !1; ++r < i;) {
         var o = wy(e[r]);
         if (!(s = t != null && n(t, o))) break;
         t = t[o]
      }
      return s || ++r != i ? s : (i = t == null ? 0 : t.length, !!i && Bw(i) && Lw(o, i) && (Ei(t) || ov(t)))
   }

   function a0e(t, e) {
      return t != null && o0e(t, e, s0e)
   }
   var l0e = 1,
      u0e = 2;

   function c0e(t, e) {
      return Nw(t) && Lk(e) ? Dk(wy(t), e) : function (n) {
         var r = i0e(n, t);
         return r === void 0 && r === e ? a0e(n, t) : Ow(e, r, l0e | u0e)
      }
   }

   function f0e(t) {
      return function (e) {
         return e == null ? void 0 : e[t]
      }
   }

   function h0e(t) {
      return function (e) {
         return Nk(e, t)
      }
   }

   function d0e(t) {
      return Nw(t) ? f0e(wy(t)) : h0e(t)
   }

   function p0e(t) {
      return typeof t == "function" ? t : t == null ? Ay : typeof t == "object" ? Ei(t) ? c0e(t[0], t[1]) : jge(t) : d0e(t)
   }

   function m0e(t, e) {
      var n = -1,
         r = Gf(t) ? Array(t.length) : [];
      return Ck(t, function (i, s, o) {
         r[++n] = e(i, s, o)
      }), r
   }

   function gu(t, e) {
      var n = Ei(t) ? Bk : m0e;
      return n(t, p0e(e))
   }
   var g0e = function (e) {
         var n = e.colors,
            r = e.onClick,
            i = e.onSwatchHover,
            s = St({
               default: {
                  swatches: {
                     marginRight: "-10px"
                  },
                  swatch: {
                     width: "22px",
                     height: "22px",
                     float: "left",
                     marginRight: "10px",
                     marginBottom: "10px",
                     borderRadius: "4px"
                  },
                  clear: {
                     clear: "both"
                  }
               }
            });
         return z.createElement("div", {
            style: s.swatches
         }, gu(n, function (o) {
            return z.createElement(mu, {
               key: o,
               color: o,
               style: s.swatch,
               onClick: r,
               onHover: i,
               focusStyle: {
                  boxShadow: "0 0 4px " + o
               }
            })
         }), z.createElement("div", {
            style: s.clear
         }))
      },
      kw = function (e) {
         var n = e.onChange,
            r = e.onSwatchHover,
            i = e.hex,
            s = e.colors,
            o = e.width,
            a = e.triangle,
            l = e.styles,
            u = l === void 0 ? {} : l,
            h = e.className,
            d = h === void 0 ? "" : h,
            p = i === "transparent",
            m = function (x, g) {
               Qa(x) && n({
                  hex: x,
                  source: "hex"
               }, g)
            },
            v = St(ri({
               default: {
                  card: {
                     width: o,
                     background: "#fff",
                     boxShadow: "0 1px rgba(0,0,0,.1)",
                     borderRadius: "6px",
                     position: "relative"
                  },
                  head: {
                     height: "110px",
                     background: i,
                     borderRadius: "6px 6px 0 0",
                     display: "flex",
                     alignItems: "center",
                     justifyContent: "center",
                     position: "relative"
                  },
                  body: {
                     padding: "10px"
                  },
                  label: {
                     fontSize: "18px",
                     color: Fw(i),
                     position: "relative"
                  },
                  triangle: {
                     width: "0px",
                     height: "0px",
                     borderStyle: "solid",
                     borderWidth: "0 10px 10px 10px",
                     borderColor: "transparent transparent " + i + " transparent",
                     position: "absolute",
                     top: "-10px",
                     left: "50%",
                     marginLeft: "-10px"
                  },
                  input: {
                     width: "100%",
                     fontSize: "12px",
                     color: "#666",
                     border: "0px",
                     outline: "none",
                     height: "22px",
                     boxShadow: "inset 0 0 0 1px #ddd",
                     borderRadius: "4px",
                     padding: "0 7px",
                     boxSizing: "border-box"
                  }
               },
               "hide-triangle": {
                  triangle: {
                     display: "none"
                  }
               }
            }, u), {
               "hide-triangle": a === "hide"
            });
         return z.createElement("div", {
            style: v.card,
            className: "block-picker " + d
         }, z.createElement("div", {
            style: v.triangle
         }), z.createElement("div", {
            style: v.head
         }, p && z.createElement(kf, {
            borderRadius: "6px 6px 0 0"
         }), z.createElement("div", {
            style: v.label
         }, i)), z.createElement("div", {
            style: v.body
         }, z.createElement(g0e, {
            colors: s,
            onClick: m,
            onSwatchHover: r
         }), z.createElement(zt, {
            style: {
               input: v.input
            },
            value: i,
            onChange: m
         })))
      };
   kw.propTypes = {
      width: Ne.oneOfType([Ne.string, Ne.number]),
      colors: Ne.arrayOf(Ne.string),
      triangle: Ne.oneOf(["top", "hide"]),
      styles: Ne.object
   };
   kw.defaultProps = {
      width: 170,
      colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
      triangle: "top",
      styles: {}
   };
   ii(kw);
   var ac = {
         50: "#ffebee",
         100: "#ffcdd2",
         200: "#ef9a9a",
         300: "#e57373",
         400: "#ef5350",
         500: "#f44336",
         600: "#e53935",
         700: "#d32f2f",
         800: "#c62828",
         900: "#b71c1c",
         a100: "#ff8a80",
         a200: "#ff5252",
         a400: "#ff1744",
         a700: "#d50000"
      },
      lc = {
         50: "#fce4ec",
         100: "#f8bbd0",
         200: "#f48fb1",
         300: "#f06292",
         400: "#ec407a",
         500: "#e91e63",
         600: "#d81b60",
         700: "#c2185b",
         800: "#ad1457",
         900: "#880e4f",
         a100: "#ff80ab",
         a200: "#ff4081",
         a400: "#f50057",
         a700: "#c51162"
      },
      uc = {
         50: "#f3e5f5",
         100: "#e1bee7",
         200: "#ce93d8",
         300: "#ba68c8",
         400: "#ab47bc",
         500: "#9c27b0",
         600: "#8e24aa",
         700: "#7b1fa2",
         800: "#6a1b9a",
         900: "#4a148c",
         a100: "#ea80fc",
         a200: "#e040fb",
         a400: "#d500f9",
         a700: "#aa00ff"
      },
      cc = {
         50: "#ede7f6",
         100: "#d1c4e9",
         200: "#b39ddb",
         300: "#9575cd",
         400: "#7e57c2",
         500: "#673ab7",
         600: "#5e35b1",
         700: "#512da8",
         800: "#4527a0",
         900: "#311b92",
         a100: "#b388ff",
         a200: "#7c4dff",
         a400: "#651fff",
         a700: "#6200ea"
      },
      fc = {
         50: "#e8eaf6",
         100: "#c5cae9",
         200: "#9fa8da",
         300: "#7986cb",
         400: "#5c6bc0",
         500: "#3f51b5",
         600: "#3949ab",
         700: "#303f9f",
         800: "#283593",
         900: "#1a237e",
         a100: "#8c9eff",
         a200: "#536dfe",
         a400: "#3d5afe",
         a700: "#304ffe"
      },
      hc = {
         50: "#e3f2fd",
         100: "#bbdefb",
         200: "#90caf9",
         300: "#64b5f6",
         400: "#42a5f5",
         500: "#2196f3",
         600: "#1e88e5",
         700: "#1976d2",
         800: "#1565c0",
         900: "#0d47a1",
         a100: "#82b1ff",
         a200: "#448aff",
         a400: "#2979ff",
         a700: "#2962ff"
      },
      dc = {
         50: "#e1f5fe",
         100: "#b3e5fc",
         200: "#81d4fa",
         300: "#4fc3f7",
         400: "#29b6f6",
         500: "#03a9f4",
         600: "#039be5",
         700: "#0288d1",
         800: "#0277bd",
         900: "#01579b",
         a100: "#80d8ff",
         a200: "#40c4ff",
         a400: "#00b0ff",
         a700: "#0091ea"
      },
      pc = {
         50: "#e0f7fa",
         100: "#b2ebf2",
         200: "#80deea",
         300: "#4dd0e1",
         400: "#26c6da",
         500: "#00bcd4",
         600: "#00acc1",
         700: "#0097a7",
         800: "#00838f",
         900: "#006064",
         a100: "#84ffff",
         a200: "#18ffff",
         a400: "#00e5ff",
         a700: "#00b8d4"
      },
      mc = {
         50: "#e0f2f1",
         100: "#b2dfdb",
         200: "#80cbc4",
         300: "#4db6ac",
         400: "#26a69a",
         500: "#009688",
         600: "#00897b",
         700: "#00796b",
         800: "#00695c",
         900: "#004d40",
         a100: "#a7ffeb",
         a200: "#64ffda",
         a400: "#1de9b6",
         a700: "#00bfa5"
      },
      Yh = {
         50: "#e8f5e9",
         100: "#c8e6c9",
         200: "#a5d6a7",
         300: "#81c784",
         400: "#66bb6a",
         500: "#4caf50",
         600: "#43a047",
         700: "#388e3c",
         800: "#2e7d32",
         900: "#1b5e20",
         a100: "#b9f6ca",
         a200: "#69f0ae",
         a400: "#00e676",
         a700: "#00c853"
      },
      gc = {
         50: "#f1f8e9",
         100: "#dcedc8",
         200: "#c5e1a5",
         300: "#aed581",
         400: "#9ccc65",
         500: "#8bc34a",
         600: "#7cb342",
         700: "#689f38",
         800: "#558b2f",
         900: "#33691e",
         a100: "#ccff90",
         a200: "#b2ff59",
         a400: "#76ff03",
         a700: "#64dd17"
      },
      vc = {
         50: "#f9fbe7",
         100: "#f0f4c3",
         200: "#e6ee9c",
         300: "#dce775",
         400: "#d4e157",
         500: "#cddc39",
         600: "#c0ca33",
         700: "#afb42b",
         800: "#9e9d24",
         900: "#827717",
         a100: "#f4ff81",
         a200: "#eeff41",
         a400: "#c6ff00",
         a700: "#aeea00"
      },
      yc = {
         50: "#fffde7",
         100: "#fff9c4",
         200: "#fff59d",
         300: "#fff176",
         400: "#ffee58",
         500: "#ffeb3b",
         600: "#fdd835",
         700: "#fbc02d",
         800: "#f9a825",
         900: "#f57f17",
         a100: "#ffff8d",
         a200: "#ffff00",
         a400: "#ffea00",
         a700: "#ffd600"
      },
      xc = {
         50: "#fff8e1",
         100: "#ffecb3",
         200: "#ffe082",
         300: "#ffd54f",
         400: "#ffca28",
         500: "#ffc107",
         600: "#ffb300",
         700: "#ffa000",
         800: "#ff8f00",
         900: "#ff6f00",
         a100: "#ffe57f",
         a200: "#ffd740",
         a400: "#ffc400",
         a700: "#ffab00"
      },
      _c = {
         50: "#fff3e0",
         100: "#ffe0b2",
         200: "#ffcc80",
         300: "#ffb74d",
         400: "#ffa726",
         500: "#ff9800",
         600: "#fb8c00",
         700: "#f57c00",
         800: "#ef6c00",
         900: "#e65100",
         a100: "#ffd180",
         a200: "#ffab40",
         a400: "#ff9100",
         a700: "#ff6d00"
      },
      Ac = {
         50: "#fbe9e7",
         100: "#ffccbc",
         200: "#ffab91",
         300: "#ff8a65",
         400: "#ff7043",
         500: "#ff5722",
         600: "#f4511e",
         700: "#e64a19",
         800: "#d84315",
         900: "#bf360c",
         a100: "#ff9e80",
         a200: "#ff6e40",
         a400: "#ff3d00",
         a700: "#dd2c00"
      },
      Sc = {
         50: "#efebe9",
         100: "#d7ccc8",
         200: "#bcaaa4",
         300: "#a1887f",
         400: "#8d6e63",
         500: "#795548",
         600: "#6d4c41",
         700: "#5d4037",
         800: "#4e342e",
         900: "#3e2723"
      },
      Mc = {
         50: "#eceff1",
         100: "#cfd8dc",
         200: "#b0bec5",
         300: "#90a4ae",
         400: "#78909c",
         500: "#607d8b",
         600: "#546e7a",
         700: "#455a64",
         800: "#37474f",
         900: "#263238"
      },
      Uk = function (e) {
         var n = e.color,
            r = e.onClick,
            i = e.onSwatchHover,
            s = e.hover,
            o = e.active,
            a = e.circleSize,
            l = e.circleSpacing,
            u = St({
               default: {
                  swatch: {
                     width: a,
                     height: a,
                     marginRight: l,
                     marginBottom: l,
                     transform: "scale(1)",
                     transition: "100ms transform ease"
                  },
                  Swatch: {
                     borderRadius: "50%",
                     background: "transparent",
                     boxShadow: "inset 0 0 0 " + (a / 2 + 1) + "px " + n,
                     transition: "100ms box-shadow ease"
                  }
               },
               hover: {
                  swatch: {
                     transform: "scale(1.2)"
                  }
               },
               active: {
                  Swatch: {
                     boxShadow: "inset 0 0 0 3px " + n
                  }
               }
            }, {
               hover: s,
               active: o
            });
         return z.createElement("div", {
            style: u.swatch
         }, z.createElement(mu, {
            style: u.Swatch,
            color: n,
            onClick: r,
            onHover: i,
            focusStyle: {
               boxShadow: u.Swatch.boxShadow + ", 0 0 5px " + n
            }
         }))
      };
   Uk.defaultProps = {
      circleSize: 28,
      circleSpacing: 14
   };
   const v0e = bw(Uk);
   var Hw = function (e) {
      var n = e.width,
         r = e.onChange,
         i = e.onSwatchHover,
         s = e.colors,
         o = e.hex,
         a = e.circleSize,
         l = e.styles,
         u = l === void 0 ? {} : l,
         h = e.circleSpacing,
         d = e.className,
         p = d === void 0 ? "" : d,
         m = St(ri({
            default: {
               card: {
                  width: n,
                  display: "flex",
                  flexWrap: "wrap",
                  marginRight: -h,
                  marginBottom: -h
               }
            }
         }, u)),
         v = function (x, g) {
            return r({
               hex: x,
               source: "hex"
            }, g)
         };
      return z.createElement("div", {
         style: m.card,
         className: "circle-picker " + p
      }, gu(s, function (_) {
         return z.createElement(v0e, {
            key: _,
            color: _,
            onClick: v,
            onSwatchHover: i,
            active: o === _.toLowerCase(),
            circleSize: a,
            circleSpacing: h
         })
      }))
   };
   Hw.propTypes = {
      width: Ne.oneOfType([Ne.string, Ne.number]),
      circleSize: Ne.number,
      circleSpacing: Ne.number,
      styles: Ne.object
   };
   Hw.defaultProps = {
      width: 252,
      circleSize: 28,
      circleSpacing: 14,
      colors: [ac[500], lc[500], uc[500], cc[500], fc[500], hc[500], dc[500], pc[500], mc[500], Yh[500], gc[500], vc[500], yc[500], xc[500], _c[500], Ac[500], Sc[500], Mc[500]],
      styles: {}
   };
   ii(Hw);

   function KI(t) {
      return t === void 0
   }
   var kk = {};
   Object.defineProperty(kk, "__esModule", {
      value: !0
   });
   var YI = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      y0e = $,
      QI = x0e(y0e);

   function x0e(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }

   function _0e(t, e) {
      var n = {};
      for (var r in t) e.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      return n
   }
   var zg = 24,
      A0e = kk.default = function (t) {
         var e = t.fill,
            n = e === void 0 ? "currentColor" : e,
            r = t.width,
            i = r === void 0 ? zg : r,
            s = t.height,
            o = s === void 0 ? zg : s,
            a = t.style,
            l = a === void 0 ? {} : a,
            u = _0e(t, ["fill", "width", "height", "style"]);
         return QI.default.createElement("svg", YI({
            viewBox: "0 0 " + zg + " " + zg,
            style: YI({
               fill: n,
               width: i,
               height: o
            }, l)
         }, u), QI.default.createElement("path", {
            d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"
         }))
      },
      S0e = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function M0e(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function E0e(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function w0e(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var Hk = function (t) {
      w0e(e, t);

      function e(n) {
         M0e(this, e);
         var r = E0e(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
         return r.toggleViews = function () {
            r.state.view === "hex" ? r.setState({
               view: "rgb"
            }) : r.state.view === "rgb" ? r.setState({
               view: "hsl"
            }) : r.state.view === "hsl" && (r.props.hsl.a === 1 ? r.setState({
               view: "hex"
            }) : r.setState({
               view: "rgb"
            }))
         }, r.handleChange = function (i, s) {
            i.hex ? Qa(i.hex) && r.props.onChange({
               hex: i.hex,
               source: "hex"
            }, s) : i.r || i.g || i.b ? r.props.onChange({
               r: i.r || r.props.rgb.r,
               g: i.g || r.props.rgb.g,
               b: i.b || r.props.rgb.b,
               source: "rgb"
            }, s) : i.a ? (i.a < 0 ? i.a = 0 : i.a > 1 && (i.a = 1), r.props.onChange({
               h: r.props.hsl.h,
               s: r.props.hsl.s,
               l: r.props.hsl.l,
               a: Math.round(i.a * 100) / 100,
               source: "rgb"
            }, s)) : (i.h || i.s || i.l) && (typeof i.s == "string" && i.s.includes("%") && (i.s = i.s.replace("%", "")), typeof i.l == "string" && i.l.includes("%") && (i.l = i.l.replace("%", "")), i.s == 1 ? i.s = .01 : i.l == 1 && (i.l = .01), r.props.onChange({
               h: i.h || r.props.hsl.h,
               s: Number(KI(i.s) ? r.props.hsl.s : i.s),
               l: Number(KI(i.l) ? r.props.hsl.l : i.l),
               source: "hsl"
            }, s))
         }, r.showHighlight = function (i) {
            i.currentTarget.style.background = "#eee"
         }, r.hideHighlight = function (i) {
            i.currentTarget.style.background = "transparent"
         }, n.hsl.a !== 1 && n.view === "hex" ? r.state = {
            view: "rgb"
         } : r.state = {
            view: n.view
         }, r
      }
      return S0e(e, [{
         key: "render",
         value: function () {
            var r = this,
               i = St({
                  default: {
                     wrap: {
                        paddingTop: "16px",
                        display: "flex"
                     },
                     fields: {
                        flex: "1",
                        display: "flex",
                        marginLeft: "-6px"
                     },
                     field: {
                        paddingLeft: "6px",
                        width: "100%"
                     },
                     alpha: {
                        paddingLeft: "6px",
                        width: "100%"
                     },
                     toggle: {
                        width: "32px",
                        textAlign: "right",
                        position: "relative"
                     },
                     icon: {
                        marginRight: "-4px",
                        marginTop: "12px",
                        cursor: "pointer",
                        position: "relative"
                     },
                     iconHighlight: {
                        position: "absolute",
                        width: "24px",
                        height: "28px",
                        background: "#eee",
                        borderRadius: "4px",
                        top: "10px",
                        left: "12px",
                        display: "none"
                     },
                     input: {
                        fontSize: "11px",
                        color: "#333",
                        width: "100%",
                        borderRadius: "2px",
                        border: "none",
                        boxShadow: "inset 0 0 0 1px #dadada",
                        height: "21px",
                        textAlign: "center"
                     },
                     label: {
                        textTransform: "uppercase",
                        fontSize: "11px",
                        lineHeight: "11px",
                        color: "#969696",
                        textAlign: "center",
                        display: "block",
                        marginTop: "12px"
                     },
                     svg: {
                        fill: "#333",
                        width: "24px",
                        height: "24px",
                        border: "1px transparent solid",
                        borderRadius: "5px"
                     }
                  },
                  disableAlpha: {
                     alpha: {
                        display: "none"
                     }
                  }
               }, this.props, this.state),
               s = void 0;
            return this.state.view === "hex" ? s = z.createElement("div", {
               style: i.fields,
               className: "flexbox-fix"
            }, z.createElement("div", {
               style: i.field
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "hex",
               value: this.props.hex,
               onChange: this.handleChange
            }))) : this.state.view === "rgb" ? s = z.createElement("div", {
               style: i.fields,
               className: "flexbox-fix"
            }, z.createElement("div", {
               style: i.field
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "r",
               value: this.props.rgb.r,
               onChange: this.handleChange
            })), z.createElement("div", {
               style: i.field
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "g",
               value: this.props.rgb.g,
               onChange: this.handleChange
            })), z.createElement("div", {
               style: i.field
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "b",
               value: this.props.rgb.b,
               onChange: this.handleChange
            })), z.createElement("div", {
               style: i.alpha
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "a",
               value: this.props.rgb.a,
               arrowOffset: .01,
               onChange: this.handleChange
            }))) : this.state.view === "hsl" && (s = z.createElement("div", {
               style: i.fields,
               className: "flexbox-fix"
            }, z.createElement("div", {
               style: i.field
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "h",
               value: Math.round(this.props.hsl.h),
               onChange: this.handleChange
            })), z.createElement("div", {
               style: i.field
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "s",
               value: Math.round(this.props.hsl.s * 100) + "%",
               onChange: this.handleChange
            })), z.createElement("div", {
               style: i.field
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "l",
               value: Math.round(this.props.hsl.l * 100) + "%",
               onChange: this.handleChange
            })), z.createElement("div", {
               style: i.alpha
            }, z.createElement(zt, {
               style: {
                  input: i.input,
                  label: i.label
               },
               label: "a",
               value: this.props.hsl.a,
               arrowOffset: .01,
               onChange: this.handleChange
            })))), z.createElement("div", {
               style: i.wrap,
               className: "flexbox-fix"
            }, s, z.createElement("div", {
               style: i.toggle
            }, z.createElement("div", {
               style: i.icon,
               onClick: this.toggleViews,
               ref: function (a) {
                  return r.icon = a
               }
            }, z.createElement(A0e, {
               style: i.svg,
               onMouseOver: this.showHighlight,
               onMouseEnter: this.showHighlight,
               onMouseOut: this.hideHighlight
            }))))
         }
      }], [{
         key: "getDerivedStateFromProps",
         value: function (r, i) {
            return r.hsl.a !== 1 && i.view === "hex" ? {
               view: "rgb"
            } : null
         }
      }]), e
   }(z.Component);
   Hk.defaultProps = {
      view: "hex"
   };
   var ZI = function () {
         var e = St({
            default: {
               picker: {
                  width: "12px",
                  height: "12px",
                  borderRadius: "6px",
                  transform: "translate(-6px, -1px)",
                  backgroundColor: "rgb(248, 248, 248)",
                  boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
               }
            }
         });
         return z.createElement("div", {
            style: e.picker
         })
      },
      b0e = function () {
         var e = St({
            default: {
               picker: {
                  width: "12px",
                  height: "12px",
                  borderRadius: "6px",
                  boxShadow: "inset 0 0 0 1px #fff",
                  transform: "translate(-6px, -6px)"
               }
            }
         });
         return z.createElement("div", {
            style: e.picker
         })
      },
      Gw = function (e) {
         var n = e.width,
            r = e.onChange,
            i = e.disableAlpha,
            s = e.rgb,
            o = e.hsl,
            a = e.hsv,
            l = e.hex,
            u = e.renderers,
            h = e.styles,
            d = h === void 0 ? {} : h,
            p = e.className,
            m = p === void 0 ? "" : p,
            v = e.defaultView,
            _ = St(ri({
               default: {
                  picker: {
                     width: n,
                     background: "#fff",
                     borderRadius: "2px",
                     boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
                     boxSizing: "initial",
                     fontFamily: "Menlo"
                  },
                  saturation: {
                     width: "100%",
                     paddingBottom: "55%",
                     position: "relative",
                     borderRadius: "2px 2px 0 0",
                     overflow: "hidden"
                  },
                  Saturation: {
                     radius: "2px 2px 0 0"
                  },
                  body: {
                     padding: "16px 16px 12px"
                  },
                  controls: {
                     display: "flex"
                  },
                  color: {
                     width: "32px"
                  },
                  swatch: {
                     marginTop: "6px",
                     width: "16px",
                     height: "16px",
                     borderRadius: "8px",
                     position: "relative",
                     overflow: "hidden"
                  },
                  active: {
                     absolute: "0px 0px 0px 0px",
                     borderRadius: "8px",
                     boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
                     background: "rgba(" + s.r + ", " + s.g + ", " + s.b + ", " + s.a + ")",
                     zIndex: "2"
                  },
                  toggles: {
                     flex: "1"
                  },
                  hue: {
                     height: "10px",
                     position: "relative",
                     marginBottom: "8px"
                  },
                  Hue: {
                     radius: "2px"
                  },
                  alpha: {
                     height: "10px",
                     position: "relative"
                  },
                  Alpha: {
                     radius: "2px"
                  }
               },
               disableAlpha: {
                  color: {
                     width: "22px"
                  },
                  alpha: {
                     display: "none"
                  },
                  hue: {
                     marginBottom: "0px"
                  },
                  swatch: {
                     width: "10px",
                     height: "10px",
                     marginTop: "0px"
                  }
               }
            }, d), {
               disableAlpha: i
            });
         return z.createElement("div", {
            style: _.picker,
            className: "chrome-picker " + m
         }, z.createElement("div", {
            style: _.saturation
         }, z.createElement(My, {
            style: _.Saturation,
            hsl: o,
            hsv: a,
            pointer: b0e,
            onChange: r
         })), z.createElement("div", {
            style: _.body
         }, z.createElement("div", {
            style: _.controls,
            className: "flexbox-fix"
         }, z.createElement("div", {
            style: _.color
         }, z.createElement("div", {
            style: _.swatch
         }, z.createElement("div", {
            style: _.active
         }), z.createElement(kf, {
            renderers: u
         }))), z.createElement("div", {
            style: _.toggles
         }, z.createElement("div", {
            style: _.hue
         }, z.createElement(Hf, {
            style: _.Hue,
            hsl: o,
            pointer: ZI,
            onChange: r
         })), z.createElement("div", {
            style: _.alpha
         }, z.createElement(Cw, {
            style: _.Alpha,
            rgb: s,
            hsl: o,
            pointer: ZI,
            renderers: u,
            onChange: r
         })))), z.createElement(Hk, {
            rgb: s,
            hsl: o,
            hex: l,
            view: v,
            onChange: r,
            disableAlpha: i
         })))
      };
   Gw.propTypes = {
      width: Ne.oneOfType([Ne.string, Ne.number]),
      disableAlpha: Ne.bool,
      styles: Ne.object,
      defaultView: Ne.oneOf(["hex", "rgb", "hsl"])
   };
   Gw.defaultProps = {
      width: 225,
      disableAlpha: !1,
      styles: {}
   };
   ii(Gw);
   var C0e = function (e) {
         var n = e.color,
            r = e.onClick,
            i = r === void 0 ? function () {} : r,
            s = e.onSwatchHover,
            o = e.active,
            a = St({
               default: {
                  color: {
                     background: n,
                     width: "15px",
                     height: "15px",
                     float: "left",
                     marginRight: "5px",
                     marginBottom: "5px",
                     position: "relative",
                     cursor: "pointer"
                  },
                  dot: {
                     absolute: "5px 5px 5px 5px",
                     background: Fw(n),
                     borderRadius: "50%",
                     opacity: "0"
                  }
               },
               active: {
                  dot: {
                     opacity: "1"
                  }
               },
               "color-#FFFFFF": {
                  color: {
                     boxShadow: "inset 0 0 0 1px #ddd"
                  },
                  dot: {
                     background: "#000"
                  }
               },
               transparent: {
                  dot: {
                     background: "#000"
                  }
               }
            }, {
               active: o,
               "color-#FFFFFF": n === "#FFFFFF",
               transparent: n === "transparent"
            });
         return z.createElement(mu, {
            style: a.color,
            color: n,
            onClick: i,
            onHover: s,
            focusStyle: {
               boxShadow: "0 0 4px " + n
            }
         }, z.createElement("div", {
            style: a.dot
         }))
      },
      T0e = function (e) {
         var n = e.hex,
            r = e.rgb,
            i = e.onChange,
            s = St({
               default: {
                  fields: {
                     display: "flex",
                     paddingBottom: "6px",
                     paddingRight: "5px",
                     position: "relative"
                  },
                  active: {
                     position: "absolute",
                     top: "6px",
                     left: "5px",
                     height: "9px",
                     width: "9px",
                     background: n
                  },
                  HEXwrap: {
                     flex: "6",
                     position: "relative"
                  },
                  HEXinput: {
                     width: "80%",
                     padding: "0px",
                     paddingLeft: "20%",
                     border: "none",
                     outline: "none",
                     background: "none",
                     fontSize: "12px",
                     color: "#333",
                     height: "16px"
                  },
                  HEXlabel: {
                     display: "none"
                  },
                  RGBwrap: {
                     flex: "3",
                     position: "relative"
                  },
                  RGBinput: {
                     width: "70%",
                     padding: "0px",
                     paddingLeft: "30%",
                     border: "none",
                     outline: "none",
                     background: "none",
                     fontSize: "12px",
                     color: "#333",
                     height: "16px"
                  },
                  RGBlabel: {
                     position: "absolute",
                     top: "3px",
                     left: "0px",
                     lineHeight: "16px",
                     textTransform: "uppercase",
                     fontSize: "12px",
                     color: "#999"
                  }
               }
            }),
            o = function (l, u) {
               l.r || l.g || l.b ? i({
                  r: l.r || r.r,
                  g: l.g || r.g,
                  b: l.b || r.b,
                  source: "rgb"
               }, u) : i({
                  hex: l.hex,
                  source: "hex"
               }, u)
            };
         return z.createElement("div", {
            style: s.fields,
            className: "flexbox-fix"
         }, z.createElement("div", {
            style: s.active
         }), z.createElement(zt, {
            style: {
               wrap: s.HEXwrap,
               input: s.HEXinput,
               label: s.HEXlabel
            },
            label: "hex",
            value: n,
            onChange: o
         }), z.createElement(zt, {
            style: {
               wrap: s.RGBwrap,
               input: s.RGBinput,
               label: s.RGBlabel
            },
            label: "r",
            value: r.r,
            onChange: o
         }), z.createElement(zt, {
            style: {
               wrap: s.RGBwrap,
               input: s.RGBinput,
               label: s.RGBlabel
            },
            label: "g",
            value: r.g,
            onChange: o
         }), z.createElement(zt, {
            style: {
               wrap: s.RGBwrap,
               input: s.RGBinput,
               label: s.RGBlabel
            },
            label: "b",
            value: r.b,
            onChange: o
         }))
      },
      zw = function (e) {
         var n = e.onChange,
            r = e.onSwatchHover,
            i = e.colors,
            s = e.hex,
            o = e.rgb,
            a = e.styles,
            l = a === void 0 ? {} : a,
            u = e.className,
            h = u === void 0 ? "" : u,
            d = St(ri({
               default: {
                  Compact: {
                     background: "#f6f6f6",
                     radius: "4px"
                  },
                  compact: {
                     paddingTop: "5px",
                     paddingLeft: "5px",
                     boxSizing: "initial",
                     width: "240px"
                  },
                  clear: {
                     clear: "both"
                  }
               }
            }, l)),
            p = function (v, _) {
               v.hex ? Qa(v.hex) && n({
                  hex: v.hex,
                  source: "hex"
               }, _) : n(v, _)
            };
         return z.createElement(Bp, {
            style: d.Compact,
            styles: l
         }, z.createElement("div", {
            style: d.compact,
            className: "compact-picker " + h
         }, z.createElement("div", null, gu(i, function (m) {
            return z.createElement(C0e, {
               key: m,
               color: m,
               active: m.toLowerCase() === s,
               onClick: p,
               onSwatchHover: r
            })
         }), z.createElement("div", {
            style: d.clear
         })), z.createElement(T0e, {
            hex: s,
            rgb: o,
            onChange: p
         })))
      };
   zw.propTypes = {
      colors: Ne.arrayOf(Ne.string),
      styles: Ne.object
   };
   zw.defaultProps = {
      colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
      styles: {}
   };
   ii(zw);
   var R0e = function (e) {
      var n = e.hover,
         r = e.color,
         i = e.onClick,
         s = e.onSwatchHover,
         o = {
            position: "relative",
            zIndex: "2",
            outline: "2px solid #fff",
            boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
         },
         a = St({
            default: {
               swatch: {
                  width: "25px",
                  height: "25px",
                  fontSize: "0"
               }
            },
            hover: {
               swatch: o
            }
         }, {
            hover: n
         });
      return z.createElement("div", {
         style: a.swatch
      }, z.createElement(mu, {
         color: r,
         onClick: i,
         onHover: s,
         focusStyle: o
      }))
   };
   const P0e = bw(R0e);
   var Vw = function (e) {
      var n = e.width,
         r = e.colors,
         i = e.onChange,
         s = e.onSwatchHover,
         o = e.triangle,
         a = e.styles,
         l = a === void 0 ? {} : a,
         u = e.className,
         h = u === void 0 ? "" : u,
         d = St(ri({
            default: {
               card: {
                  width: n,
                  background: "#fff",
                  border: "1px solid rgba(0,0,0,0.2)",
                  boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
                  borderRadius: "4px",
                  position: "relative",
                  padding: "5px",
                  display: "flex",
                  flexWrap: "wrap"
               },
               triangle: {
                  position: "absolute",
                  border: "7px solid transparent",
                  borderBottomColor: "#fff"
               },
               triangleShadow: {
                  position: "absolute",
                  border: "8px solid transparent",
                  borderBottomColor: "rgba(0,0,0,0.15)"
               }
            },
            "hide-triangle": {
               triangle: {
                  display: "none"
               },
               triangleShadow: {
                  display: "none"
               }
            },
            "top-left-triangle": {
               triangle: {
                  top: "-14px",
                  left: "10px"
               },
               triangleShadow: {
                  top: "-16px",
                  left: "9px"
               }
            },
            "top-right-triangle": {
               triangle: {
                  top: "-14px",
                  right: "10px"
               },
               triangleShadow: {
                  top: "-16px",
                  right: "9px"
               }
            },
            "bottom-left-triangle": {
               triangle: {
                  top: "35px",
                  left: "10px",
                  transform: "rotate(180deg)"
               },
               triangleShadow: {
                  top: "37px",
                  left: "9px",
                  transform: "rotate(180deg)"
               }
            },
            "bottom-right-triangle": {
               triangle: {
                  top: "35px",
                  right: "10px",
                  transform: "rotate(180deg)"
               },
               triangleShadow: {
                  top: "37px",
                  right: "9px",
                  transform: "rotate(180deg)"
               }
            }
         }, l), {
            "hide-triangle": o === "hide",
            "top-left-triangle": o === "top-left",
            "top-right-triangle": o === "top-right",
            "bottom-left-triangle": o === "bottom-left",
            "bottom-right-triangle": o === "bottom-right"
         }),
         p = function (v, _) {
            return i({
               hex: v,
               source: "hex"
            }, _)
         };
      return z.createElement("div", {
         style: d.card,
         className: "github-picker " + h
      }, z.createElement("div", {
         style: d.triangleShadow
      }), z.createElement("div", {
         style: d.triangle
      }), gu(r, function (m) {
         return z.createElement(P0e, {
            color: m,
            key: m,
            onClick: p,
            onSwatchHover: s
         })
      }))
   };
   Vw.propTypes = {
      width: Ne.oneOfType([Ne.string, Ne.number]),
      colors: Ne.arrayOf(Ne.string),
      triangle: Ne.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
      styles: Ne.object
   };
   Vw.defaultProps = {
      width: 200,
      colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
      triangle: "top-left",
      styles: {}
   };
   ii(Vw);
   var B0e = function (e) {
         var n = e.direction,
            r = St({
               default: {
                  picker: {
                     width: "18px",
                     height: "18px",
                     borderRadius: "50%",
                     transform: "translate(-9px, -1px)",
                     backgroundColor: "rgb(248, 248, 248)",
                     boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
                  }
               },
               vertical: {
                  picker: {
                     transform: "translate(-3px, -9px)"
                  }
               }
            }, {
               vertical: n === "vertical"
            });
         return z.createElement("div", {
            style: r.picker
         })
      },
      I0e = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      Ww = function (e) {
         var n = e.width,
            r = e.height,
            i = e.onChange,
            s = e.hsl,
            o = e.direction,
            a = e.pointer,
            l = e.styles,
            u = l === void 0 ? {} : l,
            h = e.className,
            d = h === void 0 ? "" : h,
            p = St(ri({
               default: {
                  picker: {
                     position: "relative",
                     width: n,
                     height: r
                  },
                  hue: {
                     radius: "2px"
                  }
               }
            }, u)),
            m = function (_) {
               return i({
                  a: 1,
                  h: _.h,
                  l: .5,
                  s: 1
               })
            };
         return z.createElement("div", {
            style: p.picker,
            className: "hue-picker " + d
         }, z.createElement(Hf, I0e({}, p.hue, {
            hsl: s,
            pointer: a,
            onChange: m,
            direction: o
         })))
      };
   Ww.propTypes = {
      styles: Ne.object
   };
   Ww.defaultProps = {
      width: "316px",
      height: "16px",
      direction: "horizontal",
      pointer: B0e,
      styles: {}
   };
   ii(Ww);
   var L0e = function (e) {
      var n = e.onChange,
         r = e.hex,
         i = e.rgb,
         s = e.styles,
         o = s === void 0 ? {} : s,
         a = e.className,
         l = a === void 0 ? "" : a,
         u = St(ri({
            default: {
               material: {
                  width: "98px",
                  height: "98px",
                  padding: "16px",
                  fontFamily: "Roboto"
               },
               HEXwrap: {
                  position: "relative"
               },
               HEXinput: {
                  width: "100%",
                  marginTop: "12px",
                  fontSize: "15px",
                  color: "#333",
                  padding: "0px",
                  border: "0px",
                  borderBottom: "2px solid " + r,
                  outline: "none",
                  height: "30px"
               },
               HEXlabel: {
                  position: "absolute",
                  top: "0px",
                  left: "0px",
                  fontSize: "11px",
                  color: "#999999",
                  textTransform: "capitalize"
               },
               Hex: {
                  style: {}
               },
               RGBwrap: {
                  position: "relative"
               },
               RGBinput: {
                  width: "100%",
                  marginTop: "12px",
                  fontSize: "15px",
                  color: "#333",
                  padding: "0px",
                  border: "0px",
                  borderBottom: "1px solid #eee",
                  outline: "none",
                  height: "30px"
               },
               RGBlabel: {
                  position: "absolute",
                  top: "0px",
                  left: "0px",
                  fontSize: "11px",
                  color: "#999999",
                  textTransform: "capitalize"
               },
               split: {
                  display: "flex",
                  marginRight: "-10px",
                  paddingTop: "11px"
               },
               third: {
                  flex: "1",
                  paddingRight: "10px"
               }
            }
         }, o)),
         h = function (p, m) {
            p.hex ? Qa(p.hex) && n({
               hex: p.hex,
               source: "hex"
            }, m) : (p.r || p.g || p.b) && n({
               r: p.r || i.r,
               g: p.g || i.g,
               b: p.b || i.b,
               source: "rgb"
            }, m)
         };
      return z.createElement(Bp, {
         styles: o
      }, z.createElement("div", {
         style: u.material,
         className: "material-picker " + l
      }, z.createElement(zt, {
         style: {
            wrap: u.HEXwrap,
            input: u.HEXinput,
            label: u.HEXlabel
         },
         label: "hex",
         value: r,
         onChange: h
      }), z.createElement("div", {
         style: u.split,
         className: "flexbox-fix"
      }, z.createElement("div", {
         style: u.third
      }, z.createElement(zt, {
         style: {
            wrap: u.RGBwrap,
            input: u.RGBinput,
            label: u.RGBlabel
         },
         label: "r",
         value: i.r,
         onChange: h
      })), z.createElement("div", {
         style: u.third
      }, z.createElement(zt, {
         style: {
            wrap: u.RGBwrap,
            input: u.RGBinput,
            label: u.RGBlabel
         },
         label: "g",
         value: i.g,
         onChange: h
      })), z.createElement("div", {
         style: u.third
      }, z.createElement(zt, {
         style: {
            wrap: u.RGBwrap,
            input: u.RGBinput,
            label: u.RGBlabel
         },
         label: "b",
         value: i.b,
         onChange: h
      })))))
   };
   ii(L0e);
   var D0e = function (e) {
         var n = e.onChange,
            r = e.rgb,
            i = e.hsv,
            s = e.hex,
            o = St({
               default: {
                  fields: {
                     paddingTop: "5px",
                     paddingBottom: "9px",
                     width: "80px",
                     position: "relative"
                  },
                  divider: {
                     height: "5px"
                  },
                  RGBwrap: {
                     position: "relative"
                  },
                  RGBinput: {
                     marginLeft: "40%",
                     width: "40%",
                     height: "18px",
                     border: "1px solid #888888",
                     boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
                     marginBottom: "5px",
                     fontSize: "13px",
                     paddingLeft: "3px",
                     marginRight: "10px"
                  },
                  RGBlabel: {
                     left: "0px",
                     top: "0px",
                     width: "34px",
                     textTransform: "uppercase",
                     fontSize: "13px",
                     height: "18px",
                     lineHeight: "22px",
                     position: "absolute"
                  },
                  HEXwrap: {
                     position: "relative"
                  },
                  HEXinput: {
                     marginLeft: "20%",
                     width: "80%",
                     height: "18px",
                     border: "1px solid #888888",
                     boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
                     marginBottom: "6px",
                     fontSize: "13px",
                     paddingLeft: "3px"
                  },
                  HEXlabel: {
                     position: "absolute",
                     top: "0px",
                     left: "0px",
                     width: "14px",
                     textTransform: "uppercase",
                     fontSize: "13px",
                     height: "18px",
                     lineHeight: "22px"
                  },
                  fieldSymbols: {
                     position: "absolute",
                     top: "5px",
                     right: "-7px",
                     fontSize: "13px"
                  },
                  symbol: {
                     height: "20px",
                     lineHeight: "22px",
                     paddingBottom: "7px"
                  }
               }
            }),
            a = function (u, h) {
               u["#"] ? Qa(u["#"]) && n({
                  hex: u["#"],
                  source: "hex"
               }, h) : u.r || u.g || u.b ? n({
                  r: u.r || r.r,
                  g: u.g || r.g,
                  b: u.b || r.b,
                  source: "rgb"
               }, h) : (u.h || u.s || u.v) && n({
                  h: u.h || i.h,
                  s: u.s || i.s,
                  v: u.v || i.v,
                  source: "hsv"
               }, h)
            };
         return z.createElement("div", {
            style: o.fields
         }, z.createElement(zt, {
            style: {
               wrap: o.RGBwrap,
               input: o.RGBinput,
               label: o.RGBlabel
            },
            label: "h",
            value: Math.round(i.h),
            onChange: a
         }), z.createElement(zt, {
            style: {
               wrap: o.RGBwrap,
               input: o.RGBinput,
               label: o.RGBlabel
            },
            label: "s",
            value: Math.round(i.s * 100),
            onChange: a
         }), z.createElement(zt, {
            style: {
               wrap: o.RGBwrap,
               input: o.RGBinput,
               label: o.RGBlabel
            },
            label: "v",
            value: Math.round(i.v * 100),
            onChange: a
         }), z.createElement("div", {
            style: o.divider
         }), z.createElement(zt, {
            style: {
               wrap: o.RGBwrap,
               input: o.RGBinput,
               label: o.RGBlabel
            },
            label: "r",
            value: r.r,
            onChange: a
         }), z.createElement(zt, {
            style: {
               wrap: o.RGBwrap,
               input: o.RGBinput,
               label: o.RGBlabel
            },
            label: "g",
            value: r.g,
            onChange: a
         }), z.createElement(zt, {
            style: {
               wrap: o.RGBwrap,
               input: o.RGBinput,
               label: o.RGBlabel
            },
            label: "b",
            value: r.b,
            onChange: a
         }), z.createElement("div", {
            style: o.divider
         }), z.createElement(zt, {
            style: {
               wrap: o.HEXwrap,
               input: o.HEXinput,
               label: o.HEXlabel
            },
            label: "#",
            value: s.replace("#", ""),
            onChange: a
         }), z.createElement("div", {
            style: o.fieldSymbols
         }, z.createElement("div", {
            style: o.symbol
         }, "Â°"), z.createElement("div", {
            style: o.symbol
         }, "%"), z.createElement("div", {
            style: o.symbol
         }, "%")))
      },
      F0e = function (e) {
         var n = e.hsl,
            r = St({
               default: {
                  picker: {
                     width: "12px",
                     height: "12px",
                     borderRadius: "6px",
                     boxShadow: "inset 0 0 0 1px #fff",
                     transform: "translate(-6px, -6px)"
                  }
               },
               "black-outline": {
                  picker: {
                     boxShadow: "inset 0 0 0 1px #000"
                  }
               }
            }, {
               "black-outline": n.l > .5
            });
         return z.createElement("div", {
            style: r.picker
         })
      },
      O0e = function () {
         var e = St({
            default: {
               triangle: {
                  width: 0,
                  height: 0,
                  borderStyle: "solid",
                  borderWidth: "4px 0 4px 6px",
                  borderColor: "transparent transparent transparent #fff",
                  position: "absolute",
                  top: "1px",
                  left: "1px"
               },
               triangleBorder: {
                  width: 0,
                  height: 0,
                  borderStyle: "solid",
                  borderWidth: "5px 0 5px 8px",
                  borderColor: "transparent transparent transparent #555"
               },
               left: {
                  Extend: "triangleBorder",
                  transform: "translate(-13px, -4px)"
               },
               leftInside: {
                  Extend: "triangle",
                  transform: "translate(-8px, -5px)"
               },
               right: {
                  Extend: "triangleBorder",
                  transform: "translate(20px, -14px) rotate(180deg)"
               },
               rightInside: {
                  Extend: "triangle",
                  transform: "translate(-8px, -5px)"
               }
            }
         });
         return z.createElement("div", {
            style: e.pointer
         }, z.createElement("div", {
            style: e.left
         }, z.createElement("div", {
            style: e.leftInside
         })), z.createElement("div", {
            style: e.right
         }, z.createElement("div", {
            style: e.rightInside
         })))
      },
      qI = function (e) {
         var n = e.onClick,
            r = e.label,
            i = e.children,
            s = e.active,
            o = St({
               default: {
                  button: {
                     backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
                     border: "1px solid #878787",
                     borderRadius: "2px",
                     height: "20px",
                     boxShadow: "0 1px 0 0 #EAEAEA",
                     fontSize: "14px",
                     color: "#000",
                     lineHeight: "20px",
                     textAlign: "center",
                     marginBottom: "10px",
                     cursor: "pointer"
                  }
               },
               active: {
                  button: {
                     boxShadow: "0 0 0 1px #878787"
                  }
               }
            }, {
               active: s
            });
         return z.createElement("div", {
            style: o.button,
            onClick: n
         }, r || i)
      },
      N0e = function (e) {
         var n = e.rgb,
            r = e.currentColor,
            i = St({
               default: {
                  swatches: {
                     border: "1px solid #B3B3B3",
                     borderBottom: "1px solid #F0F0F0",
                     marginBottom: "2px",
                     marginTop: "1px"
                  },
                  new: {
                     height: "34px",
                     background: "rgb(" + n.r + "," + n.g + ", " + n.b + ")",
                     boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
                  },
                  current: {
                     height: "34px",
                     background: r,
                     boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
                  },
                  label: {
                     fontSize: "14px",
                     color: "#000",
                     textAlign: "center"
                  }
               }
            });
         return z.createElement("div", null, z.createElement("div", {
            style: i.label
         }, "new"), z.createElement("div", {
            style: i.swatches
         }, z.createElement("div", {
            style: i.new
         }), z.createElement("div", {
            style: i.current
         })), z.createElement("div", {
            style: i.label
         }, "current"))
      },
      U0e = function () {
         function t(e, n) {
            for (var r = 0; r < n.length; r++) {
               var i = n[r];
               i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
         }
         return function (e, n, r) {
            return n && t(e.prototype, n), r && t(e, r), e
         }
      }();

   function k0e(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
   }

   function H0e(t, e) {
      if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t
   }

   function G0e(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
         constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
         }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
   }
   var jw = function (t) {
      G0e(e, t);

      function e(n) {
         k0e(this, e);
         var r = H0e(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
         return r.state = {
            currentColor: n.hex
         }, r
      }
      return U0e(e, [{
         key: "render",
         value: function () {
            var r = this.props,
               i = r.styles,
               s = i === void 0 ? {} : i,
               o = r.className,
               a = o === void 0 ? "" : o,
               l = St(ri({
                  default: {
                     picker: {
                        background: "#DCDCDC",
                        borderRadius: "4px",
                        boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
                        boxSizing: "initial",
                        width: "513px"
                     },
                     head: {
                        backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
                        borderBottom: "1px solid #B1B1B1",
                        boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
                        height: "23px",
                        lineHeight: "24px",
                        borderRadius: "4px 4px 0 0",
                        fontSize: "13px",
                        color: "#4D4D4D",
                        textAlign: "center"
                     },
                     body: {
                        padding: "15px 15px 0",
                        display: "flex"
                     },
                     saturation: {
                        width: "256px",
                        height: "256px",
                        position: "relative",
                        border: "2px solid #B3B3B3",
                        borderBottom: "2px solid #F0F0F0",
                        overflow: "hidden"
                     },
                     hue: {
                        position: "relative",
                        height: "256px",
                        width: "19px",
                        marginLeft: "10px",
                        border: "2px solid #B3B3B3",
                        borderBottom: "2px solid #F0F0F0"
                     },
                     controls: {
                        width: "180px",
                        marginLeft: "10px"
                     },
                     top: {
                        display: "flex"
                     },
                     previews: {
                        width: "60px"
                     },
                     actions: {
                        flex: "1",
                        marginLeft: "20px"
                     }
                  }
               }, s));
            return z.createElement("div", {
               style: l.picker,
               className: "photoshop-picker " + a
            }, z.createElement("div", {
               style: l.head
            }, this.props.header), z.createElement("div", {
               style: l.body,
               className: "flexbox-fix"
            }, z.createElement("div", {
               style: l.saturation
            }, z.createElement(My, {
               hsl: this.props.hsl,
               hsv: this.props.hsv,
               pointer: F0e,
               onChange: this.props.onChange
            })), z.createElement("div", {
               style: l.hue
            }, z.createElement(Hf, {
               direction: "vertical",
               hsl: this.props.hsl,
               pointer: O0e,
               onChange: this.props.onChange
            })), z.createElement("div", {
               style: l.controls
            }, z.createElement("div", {
               style: l.top,
               className: "flexbox-fix"
            }, z.createElement("div", {
               style: l.previews
            }, z.createElement(N0e, {
               rgb: this.props.rgb,
               currentColor: this.state.currentColor
            })), z.createElement("div", {
               style: l.actions
            }, z.createElement(qI, {
               label: "OK",
               onClick: this.props.onAccept,
               active: !0
            }), z.createElement(qI, {
               label: "Cancel",
               onClick: this.props.onCancel
            }), z.createElement(D0e, {
               onChange: this.props.onChange,
               rgb: this.props.rgb,
               hsv: this.props.hsv,
               hex: this.props.hex
            }))))))
         }
      }]), e
   }(z.Component);
   jw.propTypes = {
      header: Ne.string,
      styles: Ne.object
   };
   jw.defaultProps = {
      header: "Color Picker",
      styles: {}
   };
   ii(jw);
   var z0e = function (e) {
         var n = e.onChange,
            r = e.rgb,
            i = e.hsl,
            s = e.hex,
            o = e.disableAlpha,
            a = St({
               default: {
                  fields: {
                     display: "flex",
                     paddingTop: "4px"
                  },
                  single: {
                     flex: "1",
                     paddingLeft: "6px"
                  },
                  alpha: {
                     flex: "1",
                     paddingLeft: "6px"
                  },
                  double: {
                     flex: "2"
                  },
                  input: {
                     width: "80%",
                     padding: "4px 10% 3px",
                     border: "none",
                     boxShadow: "inset 0 0 0 1px #ccc",
                     fontSize: "11px"
                  },
                  label: {
                     display: "block",
                     textAlign: "center",
                     fontSize: "11px",
                     color: "#222",
                     paddingTop: "3px",
                     paddingBottom: "4px",
                     textTransform: "capitalize"
                  }
               },
               disableAlpha: {
                  alpha: {
                     display: "none"
                  }
               }
            }, {
               disableAlpha: o
            }),
            l = function (h, d) {
               h.hex ? Qa(h.hex) && n({
                  hex: h.hex,
                  source: "hex"
               }, d) : h.r || h.g || h.b ? n({
                  r: h.r || r.r,
                  g: h.g || r.g,
                  b: h.b || r.b,
                  a: r.a,
                  source: "rgb"
               }, d) : h.a && (h.a < 0 ? h.a = 0 : h.a > 100 && (h.a = 100), h.a /= 100, n({
                  h: i.h,
                  s: i.s,
                  l: i.l,
                  a: h.a,
                  source: "rgb"
               }, d))
            };
         return z.createElement("div", {
            style: a.fields,
            className: "flexbox-fix"
         }, z.createElement("div", {
            style: a.double
         }, z.createElement(zt, {
            style: {
               input: a.input,
               label: a.label
            },
            label: "hex",
            value: s.replace("#", ""),
            onChange: l
         })), z.createElement("div", {
            style: a.single
         }, z.createElement(zt, {
            style: {
               input: a.input,
               label: a.label
            },
            label: "r",
            value: r.r,
            onChange: l,
            dragLabel: "true",
            dragMax: "255"
         })), z.createElement("div", {
            style: a.single
         }, z.createElement(zt, {
            style: {
               input: a.input,
               label: a.label
            },
            label: "g",
            value: r.g,
            onChange: l,
            dragLabel: "true",
            dragMax: "255"
         })), z.createElement("div", {
            style: a.single
         }, z.createElement(zt, {
            style: {
               input: a.input,
               label: a.label
            },
            label: "b",
            value: r.b,
            onChange: l,
            dragLabel: "true",
            dragMax: "255"
         })), z.createElement("div", {
            style: a.alpha
         }, z.createElement(zt, {
            style: {
               input: a.input,
               label: a.label
            },
            label: "a",
            value: Math.round(r.a * 100),
            onChange: l,
            dragLabel: "true",
            dragMax: "100"
         })))
      },
      V0e = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      Gk = function (e) {
         var n = e.colors,
            r = e.onClick,
            i = r === void 0 ? function () {} : r,
            s = e.onSwatchHover,
            o = St({
               default: {
                  colors: {
                     margin: "0 -10px",
                     padding: "10px 0 0 10px",
                     borderTop: "1px solid #eee",
                     display: "flex",
                     flexWrap: "wrap",
                     position: "relative"
                  },
                  swatchWrap: {
                     width: "16px",
                     height: "16px",
                     margin: "0 10px 10px 0"
                  },
                  swatch: {
                     borderRadius: "3px",
                     boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
                  }
               },
               "no-presets": {
                  colors: {
                     display: "none"
                  }
               }
            }, {
               "no-presets": !n || !n.length
            }),
            a = function (u, h) {
               i({
                  hex: u,
                  source: "hex"
               }, h)
            };
         return z.createElement("div", {
            style: o.colors,
            className: "flexbox-fix"
         }, n.map(function (l) {
            var u = typeof l == "string" ? {
                  color: l
               } : l,
               h = "" + u.color + (u.title || "");
            return z.createElement("div", {
               key: h,
               style: o.swatchWrap
            }, z.createElement(mu, V0e({}, u, {
               style: o.swatch,
               onClick: a,
               onHover: s,
               focusStyle: {
                  boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + u.color
               }
            })))
         }))
      };
   Gk.propTypes = {
      colors: Ne.arrayOf(Ne.oneOfType([Ne.string, Ne.shape({
         color: Ne.string,
         title: Ne.string
      })])).isRequired
   };
   var W0e = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      $w = function (e) {
         var n = e.width,
            r = e.rgb,
            i = e.hex,
            s = e.hsv,
            o = e.hsl,
            a = e.onChange,
            l = e.onSwatchHover,
            u = e.disableAlpha,
            h = e.presetColors,
            d = e.renderers,
            p = e.styles,
            m = p === void 0 ? {} : p,
            v = e.className,
            _ = v === void 0 ? "" : v,
            x = St(ri({
               default: W0e({
                  picker: {
                     width: n,
                     padding: "10px 10px 0",
                     boxSizing: "initial",
                     background: "#fff",
                     borderRadius: "4px",
                     boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
                  },
                  saturation: {
                     width: "100%",
                     paddingBottom: "75%",
                     position: "relative",
                     overflow: "hidden"
                  },
                  Saturation: {
                     radius: "3px",
                     shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
                  },
                  controls: {
                     display: "flex"
                  },
                  sliders: {
                     padding: "4px 0",
                     flex: "1"
                  },
                  color: {
                     width: "24px",
                     height: "24px",
                     position: "relative",
                     marginTop: "4px",
                     marginLeft: "4px",
                     borderRadius: "3px"
                  },
                  activeColor: {
                     absolute: "0px 0px 0px 0px",
                     borderRadius: "2px",
                     background: "rgba(" + r.r + "," + r.g + "," + r.b + "," + r.a + ")",
                     boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
                  },
                  hue: {
                     position: "relative",
                     height: "10px",
                     overflow: "hidden"
                  },
                  Hue: {
                     radius: "2px",
                     shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
                  },
                  alpha: {
                     position: "relative",
                     height: "10px",
                     marginTop: "4px",
                     overflow: "hidden"
                  },
                  Alpha: {
                     radius: "2px",
                     shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
                  }
               }, m),
               disableAlpha: {
                  color: {
                     height: "10px"
                  },
                  hue: {
                     height: "10px"
                  },
                  alpha: {
                     display: "none"
                  }
               }
            }, m), {
               disableAlpha: u
            });
         return z.createElement("div", {
            style: x.picker,
            className: "sketch-picker " + _
         }, z.createElement("div", {
            style: x.saturation
         }, z.createElement(My, {
            style: x.Saturation,
            hsl: o,
            hsv: s,
            onChange: a
         })), z.createElement("div", {
            style: x.controls,
            className: "flexbox-fix"
         }, z.createElement("div", {
            style: x.sliders
         }, z.createElement("div", {
            style: x.hue
         }, z.createElement(Hf, {
            style: x.Hue,
            hsl: o,
            onChange: a
         })), z.createElement("div", {
            style: x.alpha
         }, z.createElement(Cw, {
            style: x.Alpha,
            rgb: r,
            hsl: o,
            renderers: d,
            onChange: a
         }))), z.createElement("div", {
            style: x.color
         }, z.createElement(kf, null), z.createElement("div", {
            style: x.activeColor
         }))), z.createElement(z0e, {
            rgb: r,
            hsl: o,
            hex: i,
            onChange: a,
            disableAlpha: u
         }), z.createElement(Gk, {
            colors: h,
            onClick: a,
            onSwatchHover: l
         }))
      };
   $w.propTypes = {
      disableAlpha: Ne.bool,
      width: Ne.oneOfType([Ne.string, Ne.number]),
      styles: Ne.object
   };
   $w.defaultProps = {
      disableAlpha: !1,
      width: 200,
      styles: {},
      presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
   };
   const j0e = ii($w);
   var Hh = function (e) {
         var n = e.hsl,
            r = e.offset,
            i = e.onClick,
            s = i === void 0 ? function () {} : i,
            o = e.active,
            a = e.first,
            l = e.last,
            u = St({
               default: {
                  swatch: {
                     height: "12px",
                     background: "hsl(" + n.h + ", 50%, " + r * 100 + "%)",
                     cursor: "pointer"
                  }
               },
               first: {
                  swatch: {
                     borderRadius: "2px 0 0 2px"
                  }
               },
               last: {
                  swatch: {
                     borderRadius: "0 2px 2px 0"
                  }
               },
               active: {
                  swatch: {
                     transform: "scaleY(1.8)",
                     borderRadius: "3.6px/2px"
                  }
               }
            }, {
               active: o,
               first: a,
               last: l
            }),
            h = function (p) {
               return s({
                  h: n.h,
                  s: .5,
                  l: r,
                  source: "hsl"
               }, p)
            };
         return z.createElement("div", {
            style: u.swatch,
            onClick: h
         })
      },
      $0e = function (e) {
         var n = e.onClick,
            r = e.hsl,
            i = St({
               default: {
                  swatches: {
                     marginTop: "20px"
                  },
                  swatch: {
                     boxSizing: "border-box",
                     width: "20%",
                     paddingRight: "1px",
                     float: "left"
                  },
                  clear: {
                     clear: "both"
                  }
               }
            }),
            s = .1;
         return z.createElement("div", {
            style: i.swatches
         }, z.createElement("div", {
            style: i.swatch
         }, z.createElement(Hh, {
            hsl: r,
            offset: ".80",
            active: Math.abs(r.l - .8) < s && Math.abs(r.s - .5) < s,
            onClick: n,
            first: !0
         })), z.createElement("div", {
            style: i.swatch
         }, z.createElement(Hh, {
            hsl: r,
            offset: ".65",
            active: Math.abs(r.l - .65) < s && Math.abs(r.s - .5) < s,
            onClick: n
         })), z.createElement("div", {
            style: i.swatch
         }, z.createElement(Hh, {
            hsl: r,
            offset: ".50",
            active: Math.abs(r.l - .5) < s && Math.abs(r.s - .5) < s,
            onClick: n
         })), z.createElement("div", {
            style: i.swatch
         }, z.createElement(Hh, {
            hsl: r,
            offset: ".35",
            active: Math.abs(r.l - .35) < s && Math.abs(r.s - .5) < s,
            onClick: n
         })), z.createElement("div", {
            style: i.swatch
         }, z.createElement(Hh, {
            hsl: r,
            offset: ".20",
            active: Math.abs(r.l - .2) < s && Math.abs(r.s - .5) < s,
            onClick: n,
            last: !0
         })), z.createElement("div", {
            style: i.clear
         }))
      },
      X0e = function () {
         var e = St({
            default: {
               picker: {
                  width: "14px",
                  height: "14px",
                  borderRadius: "6px",
                  transform: "translate(-7px, -1px)",
                  backgroundColor: "rgb(248, 248, 248)",
                  boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
               }
            }
         });
         return z.createElement("div", {
            style: e.picker
         })
      },
      Xw = function (e) {
         var n = e.hsl,
            r = e.onChange,
            i = e.pointer,
            s = e.styles,
            o = s === void 0 ? {} : s,
            a = e.className,
            l = a === void 0 ? "" : a,
            u = St(ri({
               default: {
                  hue: {
                     height: "12px",
                     position: "relative"
                  },
                  Hue: {
                     radius: "2px"
                  }
               }
            }, o));
         return z.createElement("div", {
            style: u.wrap || {},
            className: "slider-picker " + l
         }, z.createElement("div", {
            style: u.hue
         }, z.createElement(Hf, {
            style: u.Hue,
            hsl: n,
            pointer: i,
            onChange: r
         })), z.createElement("div", {
            style: u.swatches
         }, z.createElement($0e, {
            hsl: n,
            onClick: r
         })))
      };
   Xw.propTypes = {
      styles: Ne.object
   };
   Xw.defaultProps = {
      pointer: X0e,
      styles: {}
   };
   ii(Xw);
   var zk = {};
   Object.defineProperty(zk, "__esModule", {
      value: !0
   });
   var eL = Object.assign || function (t) {
         for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
         }
         return t
      },
      J0e = $,
      tL = K0e(J0e);

   function K0e(t) {
      return t && t.__esModule ? t : {
         default: t
      }
   }

   function Y0e(t, e) {
      var n = {};
      for (var r in t) e.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      return n
   }
   var Vg = 24,
      Q0e = zk.default = function (t) {
         var e = t.fill,
            n = e === void 0 ? "currentColor" : e,
            r = t.width,
            i = r === void 0 ? Vg : r,
            s = t.height,
            o = s === void 0 ? Vg : s,
            a = t.style,
            l = a === void 0 ? {} : a,
            u = Y0e(t, ["fill", "width", "height", "style"]);
         return tL.default.createElement("svg", eL({
            viewBox: "0 0 " + Vg + " " + Vg,
            style: eL({
               fill: n,
               width: i,
               height: o
            }, l)
         }, u), tL.default.createElement("path", {
            d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"
         }))
      },
      Z0e = function (e) {
         var n = e.color,
            r = e.onClick,
            i = r === void 0 ? function () {} : r,
            s = e.onSwatchHover,
            o = e.first,
            a = e.last,
            l = e.active,
            u = St({
               default: {
                  color: {
                     width: "40px",
                     height: "24px",
                     cursor: "pointer",
                     background: n,
                     marginBottom: "1px"
                  },
                  check: {
                     color: Fw(n),
                     marginLeft: "8px",
                     display: "none"
                  }
               },
               first: {
                  color: {
                     overflow: "hidden",
                     borderRadius: "2px 2px 0 0"
                  }
               },
               last: {
                  color: {
                     overflow: "hidden",
                     borderRadius: "0 0 2px 2px"
                  }
               },
               active: {
                  check: {
                     display: "block"
                  }
               },
               "color-#FFFFFF": {
                  color: {
                     boxShadow: "inset 0 0 0 1px #ddd"
                  },
                  check: {
                     color: "#333"
                  }
               },
               transparent: {
                  check: {
                     color: "#333"
                  }
               }
            }, {
               first: o,
               last: a,
               active: l,
               "color-#FFFFFF": n === "#FFFFFF",
               transparent: n === "transparent"
            });
         return z.createElement(mu, {
            color: n,
            style: u.color,
            onClick: i,
            onHover: s,
            focusStyle: {
               boxShadow: "0 0 4px " + n
            }
         }, z.createElement("div", {
            style: u.check
         }, z.createElement(Q0e, null)))
      },
      q0e = function (e) {
         var n = e.onClick,
            r = e.onSwatchHover,
            i = e.group,
            s = e.active,
            o = St({
               default: {
                  group: {
                     paddingBottom: "10px",
                     width: "40px",
                     float: "left",
                     marginRight: "10px"
                  }
               }
            });
         return z.createElement("div", {
            style: o.group
         }, gu(i, function (a, l) {
            return z.createElement(Z0e, {
               key: a,
               color: a,
               active: a.toLowerCase() === s,
               first: l === 0,
               last: l === i.length - 1,
               onClick: n,
               onSwatchHover: r
            })
         }))
      },
      Jw = function (e) {
         var n = e.width,
            r = e.height,
            i = e.onChange,
            s = e.onSwatchHover,
            o = e.colors,
            a = e.hex,
            l = e.styles,
            u = l === void 0 ? {} : l,
            h = e.className,
            d = h === void 0 ? "" : h,
            p = St(ri({
               default: {
                  picker: {
                     width: n,
                     height: r
                  },
                  overflow: {
                     height: r,
                     overflowY: "scroll"
                  },
                  body: {
                     padding: "16px 0 6px 16px"
                  },
                  clear: {
                     clear: "both"
                  }
               }
            }, u)),
            m = function (_, x) {
               return i({
                  hex: _,
                  source: "hex"
               }, x)
            };
         return z.createElement("div", {
            style: p.picker,
            className: "swatches-picker " + d
         }, z.createElement(Bp, null, z.createElement("div", {
            style: p.overflow
         }, z.createElement("div", {
            style: p.body
         }, gu(o, function (v) {
            return z.createElement(q0e, {
               key: v.toString(),
               group: v,
               active: a,
               onClick: m,
               onSwatchHover: s
            })
         }), z.createElement("div", {
            style: p.clear
         })))))
      };
   Jw.propTypes = {
      width: Ne.oneOfType([Ne.string, Ne.number]),
      height: Ne.oneOfType([Ne.string, Ne.number]),
      colors: Ne.arrayOf(Ne.arrayOf(Ne.string)),
      styles: Ne.object
   };
   Jw.defaultProps = {
      width: 320,
      height: 240,
      colors: [
         [ac[900], ac[700], ac[500], ac[300], ac[100]],
         [lc[900], lc[700], lc[500], lc[300], lc[100]],
         [uc[900], uc[700], uc[500], uc[300], uc[100]],
         [cc[900], cc[700], cc[500], cc[300], cc[100]],
         [fc[900], fc[700], fc[500], fc[300], fc[100]],
         [hc[900], hc[700], hc[500], hc[300], hc[100]],
         [dc[900], dc[700], dc[500], dc[300], dc[100]],
         [pc[900], pc[700], pc[500], pc[300], pc[100]],
         [mc[900], mc[700], mc[500], mc[300], mc[100]],
         ["#194D33", Yh[700], Yh[500], Yh[300], Yh[100]],
         [gc[900], gc[700], gc[500], gc[300], gc[100]],
         [vc[900], vc[700], vc[500], vc[300], vc[100]],
         [yc[900], yc[700], yc[500], yc[300], yc[100]],
         [xc[900], xc[700], xc[500], xc[300], xc[100]],
         [_c[900], _c[700], _c[500], _c[300], _c[100]],
         [Ac[900], Ac[700], Ac[500], Ac[300], Ac[100]],
         [Sc[900], Sc[700], Sc[500], Sc[300], Sc[100]],
         [Mc[900], Mc[700], Mc[500], Mc[300], Mc[100]],
         ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]
      ],
      styles: {}
   };
   ii(Jw);
   var Kw = function (e) {
      var n = e.onChange,
         r = e.onSwatchHover,
         i = e.hex,
         s = e.colors,
         o = e.width,
         a = e.triangle,
         l = e.styles,
         u = l === void 0 ? {} : l,
         h = e.className,
         d = h === void 0 ? "" : h,
         p = St(ri({
            default: {
               card: {
                  width: o,
                  background: "#fff",
                  border: "0 solid rgba(0,0,0,0.25)",
                  boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
                  borderRadius: "4px",
                  position: "relative"
               },
               body: {
                  padding: "15px 9px 9px 15px"
               },
               label: {
                  fontSize: "18px",
                  color: "#fff"
               },
               triangle: {
                  width: "0px",
                  height: "0px",
                  borderStyle: "solid",
                  borderWidth: "0 9px 10px 9px",
                  borderColor: "transparent transparent #fff transparent",
                  position: "absolute"
               },
               triangleShadow: {
                  width: "0px",
                  height: "0px",
                  borderStyle: "solid",
                  borderWidth: "0 9px 10px 9px",
                  borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
                  position: "absolute"
               },
               hash: {
                  background: "#F0F0F0",
                  height: "30px",
                  width: "30px",
                  borderRadius: "4px 0 0 4px",
                  float: "left",
                  color: "#98A1A4",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center"
               },
               input: {
                  width: "100px",
                  fontSize: "14px",
                  color: "#666",
                  border: "0px",
                  outline: "none",
                  height: "28px",
                  boxShadow: "inset 0 0 0 1px #F0F0F0",
                  boxSizing: "content-box",
                  borderRadius: "0 4px 4px 0",
                  float: "left",
                  paddingLeft: "8px"
               },
               swatch: {
                  width: "30px",
                  height: "30px",
                  float: "left",
                  borderRadius: "4px",
                  margin: "0 6px 6px 0"
               },
               clear: {
                  clear: "both"
               }
            },
            "hide-triangle": {
               triangle: {
                  display: "none"
               },
               triangleShadow: {
                  display: "none"
               }
            },
            "top-left-triangle": {
               triangle: {
                  top: "-10px",
                  left: "12px"
               },
               triangleShadow: {
                  top: "-11px",
                  left: "12px"
               }
            },
            "top-right-triangle": {
               triangle: {
                  top: "-10px",
                  right: "12px"
               },
               triangleShadow: {
                  top: "-11px",
                  right: "12px"
               }
            }
         }, u), {
            "hide-triangle": a === "hide",
            "top-left-triangle": a === "top-left",
            "top-right-triangle": a === "top-right"
         }),
         m = function (_, x) {
            Qa(_) && n({
               hex: _,
               source: "hex"
            }, x)
         };
      return z.createElement("div", {
         style: p.card,
         className: "twitter-picker " + d
      }, z.createElement("div", {
         style: p.triangleShadow
      }), z.createElement("div", {
         style: p.triangle
      }), z.createElement("div", {
         style: p.body
      }, gu(s, function (v, _) {
         return z.createElement(mu, {
            key: _,
            color: v,
            hex: v,
            style: p.swatch,
            onClick: m,
            onHover: r,
            focusStyle: {
               boxShadow: "0 0 4px " + v
            }
         })
      }), z.createElement("div", {
         style: p.hash
      }, "#"), z.createElement(zt, {
         label: null,
         style: {
            input: p.input
         },
         value: i.replace("#", ""),
         onChange: m
      }), z.createElement("div", {
         style: p.clear
      })))
   };
   Kw.propTypes = {
      width: Ne.oneOfType([Ne.string, Ne.number]),
      triangle: Ne.oneOf(["hide", "top-left", "top-right"]),
      colors: Ne.arrayOf(Ne.string),
      styles: Ne.object
   };
   Kw.defaultProps = {
      width: 276,
      colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
      triangle: "top-left",
      styles: {}
   };
   ii(Kw);
   var Yw = function (e) {
      var n = St({
         default: {
            picker: {
               width: "20px",
               height: "20px",
               borderRadius: "22px",
               border: "2px #fff solid",
               transform: "translate(-12px, -13px)",
               background: "hsl(" + Math.round(e.hsl.h) + ", " + Math.round(e.hsl.s * 100) + "%, " + Math.round(e.hsl.l * 100) + "%)"
            }
         }
      });
      return z.createElement("div", {
         style: n.picker
      })
   };
   Yw.propTypes = {
      hsl: Ne.shape({
         h: Ne.number,
         s: Ne.number,
         l: Ne.number,
         a: Ne.number
      })
   };
   Yw.defaultProps = {
      hsl: {
         a: 1,
         h: 249.94,
         l: .2,
         s: .5
      }
   };
   var Qw = function (e) {
      var n = St({
         default: {
            picker: {
               width: "20px",
               height: "20px",
               borderRadius: "22px",
               transform: "translate(-10px, -7px)",
               background: "hsl(" + Math.round(e.hsl.h) + ", 100%, 50%)",
               border: "2px white solid"
            }
         }
      });
      return z.createElement("div", {
         style: n.picker
      })
   };
   Qw.propTypes = {
      hsl: Ne.shape({
         h: Ne.number,
         s: Ne.number,
         l: Ne.number,
         a: Ne.number
      })
   };
   Qw.defaultProps = {
      hsl: {
         a: 1,
         h: 249.94,
         l: .2,
         s: .5
      }
   };
   var eve = function (e) {
         var n = e.onChange,
            r = e.rgb,
            i = e.hsl,
            s = e.hex,
            o = e.hsv,
            a = function (m, v) {
               if (m.hex) Qa(m.hex) && n({
                  hex: m.hex,
                  source: "hex"
               }, v);
               else if (m.rgb) {
                  var _ = m.rgb.split(",");
                  S1(m.rgb, "rgb") && n({
                     r: _[0],
                     g: _[1],
                     b: _[2],
                     a: 1,
                     source: "rgb"
                  }, v)
               } else if (m.hsv) {
                  var x = m.hsv.split(",");
                  S1(m.hsv, "hsv") && (x[2] = x[2].replace("%", ""), x[1] = x[1].replace("%", ""), x[0] = x[0].replace("Â°", ""), x[1] == 1 ? x[1] = .01 : x[2] == 1 && (x[2] = .01), n({
                     h: Number(x[0]),
                     s: Number(x[1]),
                     v: Number(x[2]),
                     source: "hsv"
                  }, v))
               } else if (m.hsl) {
                  var g = m.hsl.split(",");
                  S1(m.hsl, "hsl") && (g[2] = g[2].replace("%", ""), g[1] = g[1].replace("%", ""), g[0] = g[0].replace("Â°", ""), d[1] == 1 ? d[1] = .01 : d[2] == 1 && (d[2] = .01), n({
                     h: Number(g[0]),
                     s: Number(g[1]),
                     v: Number(g[2]),
                     source: "hsl"
                  }, v))
               }
            },
            l = St({
               default: {
                  wrap: {
                     display: "flex",
                     height: "100px",
                     marginTop: "4px"
                  },
                  fields: {
                     width: "100%"
                  },
                  column: {
                     paddingTop: "10px",
                     display: "flex",
                     justifyContent: "space-between"
                  },
                  double: {
                     padding: "0px 4.4px",
                     boxSizing: "border-box"
                  },
                  input: {
                     width: "100%",
                     height: "38px",
                     boxSizing: "border-box",
                     padding: "4px 10% 3px",
                     textAlign: "center",
                     border: "1px solid #dadce0",
                     fontSize: "11px",
                     textTransform: "lowercase",
                     borderRadius: "5px",
                     outline: "none",
                     fontFamily: "Roboto,Arial,sans-serif"
                  },
                  input2: {
                     height: "38px",
                     width: "100%",
                     border: "1px solid #dadce0",
                     boxSizing: "border-box",
                     fontSize: "11px",
                     textTransform: "lowercase",
                     borderRadius: "5px",
                     outline: "none",
                     paddingLeft: "10px",
                     fontFamily: "Roboto,Arial,sans-serif"
                  },
                  label: {
                     textAlign: "center",
                     fontSize: "12px",
                     background: "#fff",
                     position: "absolute",
                     textTransform: "uppercase",
                     color: "#3c4043",
                     width: "35px",
                     top: "-6px",
                     left: "0",
                     right: "0",
                     marginLeft: "auto",
                     marginRight: "auto",
                     fontFamily: "Roboto,Arial,sans-serif"
                  },
                  label2: {
                     left: "10px",
                     textAlign: "center",
                     fontSize: "12px",
                     background: "#fff",
                     position: "absolute",
                     textTransform: "uppercase",
                     color: "#3c4043",
                     width: "32px",
                     top: "-6px",
                     fontFamily: "Roboto,Arial,sans-serif"
                  },
                  single: {
                     flexGrow: "1",
                     margin: "0px 4.4px"
                  }
               }
            }),
            u = r.r + ", " + r.g + ", " + r.b,
            h = Math.round(i.h) + "Â°, " + Math.round(i.s * 100) + "%, " + Math.round(i.l * 100) + "%",
            d = Math.round(o.h) + "Â°, " + Math.round(o.s * 100) + "%, " + Math.round(o.v * 100) + "%";
         return z.createElement("div", {
            style: l.wrap,
            className: "flexbox-fix"
         }, z.createElement("div", {
            style: l.fields
         }, z.createElement("div", {
            style: l.double
         }, z.createElement(zt, {
            style: {
               input: l.input,
               label: l.label
            },
            label: "hex",
            value: s,
            onChange: a
         })), z.createElement("div", {
            style: l.column
         }, z.createElement("div", {
            style: l.single
         }, z.createElement(zt, {
            style: {
               input: l.input2,
               label: l.label2
            },
            label: "rgb",
            value: u,
            onChange: a
         })), z.createElement("div", {
            style: l.single
         }, z.createElement(zt, {
            style: {
               input: l.input2,
               label: l.label2
            },
            label: "hsv",
            value: d,
            onChange: a
         })), z.createElement("div", {
            style: l.single
         }, z.createElement(zt, {
            style: {
               input: l.input2,
               label: l.label2
            },
            label: "hsl",
            value: h,
            onChange: a
         })))))
      },
      Zw = function (e) {
         var n = e.width,
            r = e.onChange,
            i = e.rgb,
            s = e.hsl,
            o = e.hsv,
            a = e.hex,
            l = e.header,
            u = e.styles,
            h = u === void 0 ? {} : u,
            d = e.className,
            p = d === void 0 ? "" : d,
            m = St(ri({
               default: {
                  picker: {
                     width: n,
                     background: "#fff",
                     border: "1px solid #dfe1e5",
                     boxSizing: "initial",
                     display: "flex",
                     flexWrap: "wrap",
                     borderRadius: "8px 8px 0px 0px"
                  },
                  head: {
                     height: "57px",
                     width: "100%",
                     paddingTop: "16px",
                     paddingBottom: "16px",
                     paddingLeft: "16px",
                     fontSize: "20px",
                     boxSizing: "border-box",
                     fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
                  },
                  saturation: {
                     width: "70%",
                     padding: "0px",
                     position: "relative",
                     overflow: "hidden"
                  },
                  swatch: {
                     width: "30%",
                     height: "228px",
                     padding: "0px",
                     background: "rgba(" + i.r + ", " + i.g + ", " + i.b + ", 1)",
                     position: "relative",
                     overflow: "hidden"
                  },
                  body: {
                     margin: "auto",
                     width: "95%"
                  },
                  controls: {
                     display: "flex",
                     boxSizing: "border-box",
                     height: "52px",
                     paddingTop: "22px"
                  },
                  color: {
                     width: "32px"
                  },
                  hue: {
                     height: "8px",
                     position: "relative",
                     margin: "0px 16px 0px 16px",
                     width: "100%"
                  },
                  Hue: {
                     radius: "2px"
                  }
               }
            }, h));
         return z.createElement("div", {
            style: m.picker,
            className: "google-picker " + p
         }, z.createElement("div", {
            style: m.head
         }, l), z.createElement("div", {
            style: m.swatch
         }), z.createElement("div", {
            style: m.saturation
         }, z.createElement(My, {
            hsl: s,
            hsv: o,
            pointer: Yw,
            onChange: r
         })), z.createElement("div", {
            style: m.body
         }, z.createElement("div", {
            style: m.controls,
            className: "flexbox-fix"
         }, z.createElement("div", {
            style: m.hue
         }, z.createElement(Hf, {
            style: m.Hue,
            hsl: s,
            radius: "4px",
            pointer: Qw,
            onChange: r
         }))), z.createElement(eve, {
            rgb: i,
            hsl: s,
            hex: a,
            hsv: o,
            onChange: r
         })))
      };
   Zw.propTypes = {
      width: Ne.oneOfType([Ne.string, Ne.number]),
      styles: Ne.object,
      header: Ne.string
   };
   Zw.defaultProps = {
      width: 652,
      styles: {},
      header: "Color picker"
   };
   ii(Zw);
   const tve = () => {
         const t = uu(kr);
         return ot.jsx("div", {
            className: "absolute left-full ml-3",
            children: ot.jsx(j0e, {
               color: t.color,
               disableAlpha: !0,
               presetColors: ["#000000", "#353934", "#ccc", "#80C670", "#5F3", "#EFBD4E", "#00008b", "#5123DA", "#726DE8", "#7098DA", "#2CCCE4", "#ff8a65", "#C19277", "#8B0000", "#512314", "#5F123D"],
               onChange: e => kr.color = e.hex
            })
         })
      },
      Vk = ({
         file: t,
         setFile: e,
         readFile: n
      }) => ot.jsxs("div", {
         className: "filepicker-container",
         children: [ot.jsxs("div", {
            className: "flex-1 flex flex-col",
            children: [ot.jsx("input", {
               id: "file-upload",
               type: "file",
               accept: "image/*",
               onChange: r => e(r.target.files[0])
            }), ot.jsx("label", {
               htmlFor: "file-upload",
               className: "filepicker-label",
               children: "Upload File"
            }), ot.jsx("p", {
               className: "mt-2 text-gray-500 text-xs truncate",
               children: t === "" ? "No file selected" : t.name
            })]
         }), ot.jsxs("div", {
            className: "mt-4 flex flex-wrap gap-3",
            children: [ot.jsx(rv, {
               type: "outline",
               title: "Logo",
               handleClick: () => n("logo"),
               customStyles: "text-xs"
            }), ot.jsx(rv, {
               type: "filled",
               title: "Full",
               handleClick: () => n("full"),
               customStyles: "text-xs"
            })]
         })]
      });
   Vk.propTypes = {
      file: Ne.object,
      setFile: Ne.func.isRequired,
      readFile: Ne.func.isRequired
   };
   const nL = ({
         tab: t,
         isFilterTab: e,
         isActiveTab: n,
         handleClick: r
      }) => {
         const i = uu(kr),
            s = e && n ? {
               backgroundColor: i.color,
               opacity: .5
            } : {
               backgroundColor: "transparent",
               opacity: 1
            };
         return ot.jsx("div", {
            className: `tab-btn ${e?"rounded-full glassmorphism":"rounded-4"}`,
            onClick: r,
            style: s,
            children: ot.jsx("img", {
               src: t.icon,
               alt: t.name,
               className: `${e?"w-2/3 h-2/3":"w-11/12 h-11/12 object-contain"}`
            })
         }, t.name)
      },
      nve = () => {
         const t = uu(kr),
            [e, n] = $.useState(""),
            [r, i] = $.useState(""),
            [s, o] = $.useState({
               logoShirt: !0,
               stylishShirt: !1,
               stylishShirtb: !2
            }),
            a = () => {
               switch (r) {
                  case "colorpicker":
                     return ot.jsx(tve, {});
                  case "filepicker":
                     return ot.jsx(Vk, {
                        file: e,
                        setFile: n,
                        readFile: h
                     });
                  default:
                     return null
               }
            },
            l = (d, p) => {
               const m = lce[d];
               kr[m.stateProperty] = p, s[m.filterTab] || u(m.filterTab)
            },
            u = d => {
               switch (d) {
                  case "logoShirt":
                     kr.isLogoTexture = !s[d];
                     break;
                  case "stylishShirt":
                     kr.isFullTexture = !s[d];
                     break;
                  default:
                     kr.isLogoTexture = !0, kr.isFullTexture = !1;
                     break
               }
               o(p => ({
                  ...p,
                  [d]: !p[d]
               }))
            },
            h = d => {
               ice(e).then(p => {
                  l(d, p), i("")
               })
            };
         return ot.jsx(lk, {
            children: !t.intro && ot.jsxs(ot.Fragment, {
               children: [ot.jsx(pa.div, {
                  className: "absolute top-0 left-0 z-10",
                  ...nv("left"),
                  children: ot.jsx("div", {
                     className: "flex items-center min-h-screen",
                     children: ot.jsxs("div", {
                        className: "editortabs-container tabs",
                        children: [oce.map(d => ot.jsx(nL, {
                           tab: d,
                           handleClick: () => i(d.name)
                        }, d.name)), a()]
                     })
                  })
               }, "custom"), ot.jsx(pa.div, {
                  className: "absolute z-10 top-5 right-5",
                  ...uce,
                  children: ot.jsx(rv, {
                     type: "filled",
                     title: "Go Back",
                     handleClick: () => kr.intro = !0,
                     customStyles: "w-fit px-4 py-2.5 font-bold text-sm"
                  })
               }), ot.jsxs(pa.div, {
                  className: "filtertabs-container",
                  ...nv("up"),
                  children: [ace.map(d => ot.jsx(nL, {
                     tab: d,
                     isFilterTab: !0,
                     isActiveTab: s[d.name],
                     handleClick: () => u(d.name)
                  }, d.name)), ot.jsx("button", {
                     className: "download-btn",
                     onClick: rce,
                     children: ot.jsx("img", {
                        src: ece,
                        alt: "Download Image",
                        className: "w-3/5 h-3/5 object-contain"
                     })
                  })]
               })]
            })
         })
      },
      rve = () => {
         const t = uu(kr);
         return ot.jsx(lk, {
            children: t.intro && ot.jsxs(pa.section, {
               className: "home",
               ...nv("left"),
               children: [ot.jsx(pa.header, {
                  ...nv("down"),
                  children: ot.jsx("img", {
                     src: "./simulador/logo.png",
                     alt: "logo",
                     className: "w-16 h-16 object-contain"
                  })
               }), ot.jsxs(pa.div, {
                  className: "home-content",
                  ...hce,
                  children: [ot.jsx(pa.div, {
                     ...cce,
                     children: ot.jsxs("h1", {
                        className: "head-text",
                        children: [modelo," Vamos lÃ¡"]
                     })
                  }), ot.jsxs(pa.div, {
                     ...fce,
                     className: "flex flex-col gap-5",
                     children: [ot.jsxs("p", {}), ot.jsx(rv, {
                        type: "filled",
                        title: "Customizar",
                        handleClick: () => kr.intro = !1,
                        customStyles: "w-fit px-4 py-2.5 font-bold text-sm"
                     })]
                  })]
               })]
            })
         })
      };

   function ive() {
      return ot.jsxs("main", {
         className: "app transition-all ease-in",
         children: [ot.jsx(rve, {}), ot.jsx(Nse, {}), ot.jsx(nve, {})]
      })
   }

   E1.createRoot(document.getElementById("root")).render(ot.jsx(z.StrictMode, {
      children: ot.jsx(ive, {})
   }))
});
export default sve();
